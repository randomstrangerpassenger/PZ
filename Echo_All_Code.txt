
===== FILE START: C:\Users\MW\Downloads\coding\Echo\.gradle =====


===== FILE END: C:\Users\MW\Downloads\coding\Echo\.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\.vscode\settings.json =====

{
    "java.configuration.updateBuildConfiguration": "interactive"
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\.vscode\settings.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\build.gradle =====

plugins {
    id 'java'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'com.echo'
version = '0.2.1'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven' }
}

dependencies {
    // Pulse dependency (compile-only, provided at runtime)
    compileOnly files('libs/Pulse.jar')
    
    // Project Zomboid stubs (compile-only)
    compileOnly files('libs/pz-stubs.jar')
    
    // Gson for JSON serialization
    implementation 'com.google.code.gson:gson:2.10.1'
    
    // Test dependencies
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

test {
    useJUnitPlatform()
}

shadowJar {
    archiveBaseName.set('Echo')
    archiveClassifier.set('')
    archiveVersion.set(version)
    
    // Relocate Gson to avoid conflicts
    relocate 'com.google.gson', 'com.echo.shaded.gson'
    
    manifest {
        attributes(
            'Echo-Version': version,
            'Pulse-Mod': 'true',
            'Mod-Id': 'echo',
            'Mod-Name': 'Echo Profiler',
            'Mod-Version': version,
            'Mod-Authors': 'Echo Team',
            'Mod-Description': 'Performance profiling tool for Project Zomboid'
        )
    }
}

tasks.named('jar') {
    enabled = false
}

tasks.named('build') {
    dependsOn shadowJar
}

// Create libs directory task
tasks.register('createLibsDir') {
    doLast {
        mkdir 'libs'
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\build.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\build\test-results\test\TEST-com.echo.aggregate.SpikeLogTest.xml =====

<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="com.echo.aggregate.SpikeLogTest" tests="8" skipped="0" failures="0" errors="0" timestamp="2025-12-07T16:50:03" hostname="DESKTOP-M9CHBTO" time="0.04">
  <properties/>
  <testcase name="Recent spikes retrieval" classname="com.echo.aggregate.SpikeLogTest" time="0.022"/>
  <testcase name="Reset clears all data" classname="com.echo.aggregate.SpikeLogTest" time="0.002"/>
  <testcase name="toMap generates valid output" classname="com.echo.aggregate.SpikeLogTest" time="0.003"/>
  <testcase name="Spikes below threshold not logged" classname="com.echo.aggregate.SpikeLogTest" time="0.001"/>
  <testcase name="Spikes above threshold logged" classname="com.echo.aggregate.SpikeLogTest" time="0.0"/>
  <testcase name="Threshold can be changed at runtime" classname="com.echo.aggregate.SpikeLogTest" time="0.006"/>
  <testcase name="Initial state" classname="com.echo.aggregate.SpikeLogTest" time="0.001"/>
  <testcase name="Worst spike tracking" classname="com.echo.aggregate.SpikeLogTest" time="0.001"/>
  <system-out><![CDATA[[Echo] Spike threshold set to: 5.0 ms
]]></system-out>
  <system-err><![CDATA[]]></system-err>
</testsuite>

===== FILE END: C:\Users\MW\Downloads\coding\Echo\build\test-results\test\TEST-com.echo.aggregate.SpikeLogTest.xml =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\build\test-results\test\TEST-com.echo.aggregate.TimingDataTest.xml =====

<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="com.echo.aggregate.TimingDataTest" tests="8" skipped="0" failures="0" errors="0" timestamp="2025-12-07T16:50:03" hostname="DESKTOP-M9CHBTO" time="0.012">
  <properties/>
  <testcase name="Max value tracking" classname="com.echo.aggregate.TimingDataTest" time="0.001"/>
  <testcase name="Reset clears all data" classname="com.echo.aggregate.TimingDataTest" time="0.002"/>
  <testcase name="Top N by total time" classname="com.echo.aggregate.TimingDataTest" time="0.002"/>
  <testcase name="Multiple samples average correctly" classname="com.echo.aggregate.TimingDataTest" time="0.0"/>
  <testcase name="Labeled sub-timing data" classname="com.echo.aggregate.TimingDataTest" time="0.0"/>
  <testcase name="Initial state" classname="com.echo.aggregate.TimingDataTest" time="0.001"/>
  <testcase name="Add sample updates statistics" classname="com.echo.aggregate.TimingDataTest" time="0.001"/>
  <testcase name="Min value tracking" classname="com.echo.aggregate.TimingDataTest" time="0.0"/>
  <system-out><![CDATA[]]></system-out>
  <system-err><![CDATA[]]></system-err>
</testsuite>

===== FILE END: C:\Users\MW\Downloads\coding\Echo\build\test-results\test\TEST-com.echo.aggregate.TimingDataTest.xml =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\build\test-results\test\TEST-com.echo.measure.EchoProfilerTest.xml =====

<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="com.echo.measure.EchoProfilerTest" tests="8" skipped="0" failures="0" errors="0" timestamp="2025-12-07T16:50:03" hostname="DESKTOP-M9CHBTO" time="0.16">
  <properties/>
  <testcase name="Reset clears all data" classname="com.echo.measure.EchoProfilerTest" time="0.012"/>
  <testcase name="Profiler singleton instance" classname="com.echo.measure.EchoProfilerTest" time="0.001"/>
  <testcase name="Push/Pop records timing data" classname="com.echo.measure.EchoProfilerTest" time="0.019"/>
  <testcase name="Scope API with try-with-resources" classname="com.echo.measure.EchoProfilerTest" time="0.008"/>
  <testcase name="Enable/Disable profiler" classname="com.echo.measure.EchoProfilerTest" time="0.001"/>
  <testcase name="Labeled profiling" classname="com.echo.measure.EchoProfilerTest" time="0.003"/>
  <testcase name="Session duration tracking" classname="com.echo.measure.EchoProfilerTest" time="0.11"/>
  <testcase name="Raw API for zero-allocation" classname="com.echo.measure.EchoProfilerTest" time="0.001"/>
  <system-out><![CDATA[[Echo] All timing data RESET
[Echo] All timing data RESET
[Echo] Profiler ENABLED (stats reset)
[Echo] All timing data RESET
[Echo] Profiler DISABLED
[Echo] All timing data RESET
[Echo] All timing data RESET
[Echo] Profiler ENABLED (stats reset)
[Echo] Profiler DISABLED
[Echo] All timing data RESET
[Echo] All timing data RESET
[Echo] Profiler ENABLED (stats reset)
[Echo] Profiler DISABLED
[Echo] All timing data RESET
[Echo] All timing data RESET
[Echo] Profiler ENABLED (stats reset)
[Echo] Profiler DISABLED
[Echo] All timing data RESET
[Echo] All timing data RESET
[Echo] Profiler ENABLED (stats reset)
[Echo] Profiler DISABLED
[Echo] All timing data RESET
[Echo] Profiler ENABLED (stats reset)
[Echo] Profiler DISABLED
[Echo] All timing data RESET
[Echo] All timing data RESET
[Echo] Profiler ENABLED (stats reset)
[Echo] Profiler DISABLED
[Echo] All timing data RESET
[Echo] All timing data RESET
[Echo] Profiler ENABLED (stats reset)
[Echo] Profiler DISABLED
[Echo] All timing data RESET
[Echo] All timing data RESET
[Echo] Profiler ENABLED (stats reset)
[Echo] Profiler DISABLED
]]></system-out>
  <system-err><![CDATA[]]></system-err>
</testsuite>

===== FILE END: C:\Users\MW\Downloads\coding\Echo\build\test-results\test\TEST-com.echo.measure.EchoProfilerTest.xml =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\settings.gradle =====

rootProject.name = 'Echo'

===== FILE END: C:\Users\MW\Downloads\coding\Echo\settings.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\aggregate\SpikeLog.java =====

package com.echo.aggregate;

import com.echo.measure.ProfilingPoint;

import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.atomic.AtomicLong;

import com.echo.EchoConstants;

/**
 * ìŠ¤íŒŒì´í¬ ë¡œê·¸
 * 
 * ì„±ëŠ¥ ìŠ¤íŒŒì´í¬ ì´ë²¤íŠ¸ë¥¼ ê¸°ë¡í•˜ê³  ë¶„ì„í•©ë‹ˆë‹¤.
 * Phase 4: ìŠ¤íƒ ìº¡ì²˜ ê¸°ëŠ¥ ì¶”ê°€
 */
public class SpikeLog {

    private static final int MAX_ENTRIES = EchoConstants.SPIKE_LOG_MAX_ENTRIES;
    private static final int MAX_STACK_DEPTH = EchoConstants.SPIKE_MAX_STACK_DEPTH;

    private final Deque<SpikeEntry> entries = new ConcurrentLinkedDeque<>();
    private volatile double thresholdMs;

    // Phase 4: ìŠ¤íƒ ìº¡ì²˜ ì˜µì…˜
    private volatile boolean stackCaptureEnabled = false;
    private static final StackWalker STACK_WALKER = StackWalker.getInstance(
            StackWalker.Option.RETAIN_CLASS_REFERENCE);

    // í†µê³„ (ìŠ¤ë ˆë“œ ì•ˆì „)
    private final AtomicLong totalSpikes = new AtomicLong(0);
    private final AtomicLong worstSpikeMicros = new AtomicLong(0);
    private volatile String worstSpikeLabel = "";

    public SpikeLog() {
        this(EchoConstants.DEFAULT_SPIKE_THRESHOLD_MS); // ê¸°ë³¸ 2í”„ë ˆì„ (30fps ê¸°ì¤€)
    }

    public SpikeLog(double thresholdMs) {
        this.thresholdMs = thresholdMs;
    }

    /**
     * ìŠ¤íƒ ìº¡ì²˜ í™œì„±í™”/ë¹„í™œì„±í™”
     * ì£¼ì˜: ì„±ëŠ¥ ë¹„ìš©ì´ í¬ë¯€ë¡œ ë””ë²„ê¹… ì‹œì—ë§Œ ì‚¬ìš©
     */
    public void setStackCaptureEnabled(boolean enabled) {
        this.stackCaptureEnabled = enabled;
        System.out.println("[Echo] Spike stack capture: " + (enabled ? "ENABLED" : "DISABLED"));
    }

    public boolean isStackCaptureEnabled() {
        return stackCaptureEnabled;
    }

    /**
     * ìŠ¤íŒŒì´í¬ ê¸°ë¡
     */
    public void logSpike(long durationMicros, ProfilingPoint point, String label) {
        logSpike(durationMicros, point, label, null);
    }

    /**
     * ìŠ¤íŒŒì´í¬ ê¸°ë¡ (ìŠ¤íƒ ê²½ë¡œ í¬í•¨)
     */
    public void logSpike(long durationMicros, ProfilingPoint point, String label, String stackPath) {
        double durationMs = durationMicros / 1000.0;
        if (durationMs < thresholdMs)
            return;

        // Phase 4: ìŠ¤íƒ ìº¡ì²˜ (ì˜µì…˜)
        String capturedStack = stackPath;
        if (stackCaptureEnabled && capturedStack == null) {
            capturedStack = captureStackTrace();
        }

        SpikeEntry entry = new SpikeEntry(
                Instant.now(),
                durationMicros,
                point,
                label,
                capturedStack);

        entries.addLast(entry);
        totalSpikes.incrementAndGet();

        // ìµœì•… ìŠ¤íŒŒì´í¬ ê°±ì‹  (CAS íŒ¨í„´)
        long current;
        do {
            current = worstSpikeMicros.get();
            if (durationMicros <= current)
                break;
        } while (!worstSpikeMicros.compareAndSet(current, durationMicros));

        if (durationMicros > current) {
            worstSpikeLabel = (label != null ? label : point.name());
        }

        // ìµœëŒ€ ì—”íŠ¸ë¦¬ ìˆ˜ ìœ ì§€
        while (entries.size() > MAX_ENTRIES) {
            entries.pollFirst();
        }
    }

    /**
     * ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ìº¡ì²˜ (Phase 4)
     * ë¹„ìš©ì´ í¬ë¯€ë¡œ ì˜µì…˜ìœ¼ë¡œë§Œ ì‚¬ìš©
     */
    private String captureStackTrace() {
        StringBuilder sb = new StringBuilder();
        STACK_WALKER.walk(frames -> {
            frames.limit(MAX_STACK_DEPTH)
                    .skip(3) // logSpike í˜¸ì¶œ ìŠ¤íƒ ìŠ¤í‚µ
                    .forEach(frame -> {
                        sb.append(frame.getClassName())
                                .append(".")
                                .append(frame.getMethodName())
                                .append(":")
                                .append(frame.getLineNumber())
                                .append("\n");
                    });
            return null;
        });
        return sb.toString().trim();
    }

    /**
     * ê°„í¸ ìŠ¤íŒŒì´í¬ ë¡œê¹… (Tickìš©)
     */
    public void logTickSpike(long durationMicros) {
        logSpike(durationMicros, ProfilingPoint.TICK, null);
    }

    /**
     * ìµœê·¼ ìŠ¤íŒŒì´í¬ ëª©ë¡ ì¡°íšŒ
     */
    public List<SpikeEntry> getRecentSpikes(int count) {
        List<SpikeEntry> result = new ArrayList<>();
        Iterator<SpikeEntry> iter = entries.descendingIterator();
        while (iter.hasNext() && result.size() < count) {
            result.add(iter.next());
        }
        return result;
    }

    /**
     * ëª¨ë“  ìŠ¤íŒŒì´í¬ ì¡°íšŒ
     */
    public List<SpikeEntry> getAllSpikes() {
        return new ArrayList<>(entries);
    }

    /**
     * ì´ ìŠ¤íŒŒì´í¬ ìˆ˜
     */
    public long getTotalSpikes() {
        return totalSpikes.get();
    }

    /**
     * ìµœì•… ìŠ¤íŒŒì´í¬ ì‹œê°„ (ë°€ë¦¬ì´ˆ)
     */
    public double getWorstSpikeMs() {
        return worstSpikeMicros.get() / 1000.0;
    }

    /**
     * ìµœì•… ìŠ¤íŒŒì´í¬ ë¼ë²¨
     */
    public String getWorstSpikeLabel() {
        return worstSpikeLabel;
    }

    /**
     * ì„ê³„ê°’ (ë°€ë¦¬ì´ˆ)
     */
    public double getThresholdMs() {
        return thresholdMs;
    }

    /**
     * ì„ê³„ê°’ ì„¤ì •
     * 
     * @param thresholdMs ìƒˆ ì„ê³„ê°’ (ë°€ë¦¬ì´ˆ)
     */
    public void setThresholdMs(double thresholdMs) {
        this.thresholdMs = thresholdMs;
        System.out.println("[Echo] Spike threshold set to: " + thresholdMs + " ms");
    }

    /**
     * í¬ì¸íŠ¸ë³„ ìŠ¤íŒŒì´í¬ ì¹´ìš´íŠ¸
     */
    public Map<ProfilingPoint, Long> getSpikesByPoint() {
        Map<ProfilingPoint, Long> result = new EnumMap<>(ProfilingPoint.class);
        for (SpikeEntry entry : entries) {
            result.merge(entry.point, 1L, Long::sum);
        }
        return result;
    }

    /**
     * JSON ì¶œë ¥ìš© Map
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("threshold_ms", thresholdMs);
        map.put("total_spikes", totalSpikes);
        map.put("worst_spike_ms", Math.round(getWorstSpikeMs() * 100) / 100.0);
        map.put("worst_spike_source", worstSpikeLabel);

        List<Map<String, Object>> recent = new ArrayList<>();
        for (SpikeEntry entry : getRecentSpikes(10)) {
            recent.add(entry.toMap());
        }
        map.put("recent_spikes", recent);

        return map;
    }

    /**
     * ì´ˆê¸°í™”
     */
    public void reset() {
        entries.clear();
        totalSpikes.set(0);
        worstSpikeMicros.set(0);
        worstSpikeLabel = "";
    }

    // ============================================================
    // ìŠ¤íŒŒì´í¬ ì—”íŠ¸ë¦¬
    // ============================================================

    public static class SpikeEntry {
        private final Instant timestamp;
        private final long durationMicros;
        private final ProfilingPoint point;
        private final String label;
        private final String stackPath;

        public SpikeEntry(Instant timestamp, long durationMicros,
                ProfilingPoint point, String label) {
            this(timestamp, durationMicros, point, label, null);
        }

        public SpikeEntry(Instant timestamp, long durationMicros,
                ProfilingPoint point, String label, String stackPath) {
            this.timestamp = timestamp;
            this.durationMicros = durationMicros;
            this.point = point;
            this.label = label;
            this.stackPath = stackPath;
        }

        public Instant getTimestamp() {
            return timestamp;
        }

        public long getDurationMicros() {
            return durationMicros;
        }

        public double getDurationMs() {
            return durationMicros / 1000.0;
        }

        public ProfilingPoint getPoint() {
            return point;
        }

        public String getLabel() {
            return label;
        }

        public String getStackPath() {
            return stackPath;
        }

        public Map<String, Object> toMap() {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("timestamp", DateTimeFormatter.ISO_INSTANT.format(timestamp));
            map.put("duration_ms", Math.round(getDurationMs() * 100) / 100.0);
            map.put("point", point.name());
            map.put("label", label != null ? label : point.getDisplayName());
            if (stackPath != null) {
                map.put("stack_path", stackPath);
            }
            return map;
        }

        @Override
        public String toString() {
            return String.format("[%s] %.2fms - %s (%s)",
                    DateTimeFormatter.ISO_LOCAL_TIME.format(
                            timestamp.atZone(java.time.ZoneId.systemDefault())),
                    getDurationMs(),
                    point.getDisplayName(),
                    label != null ? label : "");
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\aggregate\SpikeLog.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\aggregate\TickHistogram.java =====

package com.echo.aggregate;

import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.atomic.LongAdder;

import com.echo.EchoConstants;

/**
 * í‹± íˆìŠ¤í† ê·¸ë¨
 * 
 * í‹± ì‹œê°„ ë¶„í¬ë¥¼ ë²„í‚·ë³„ë¡œ ì§‘ê³„í•©ë‹ˆë‹¤.
 * ì„±ëŠ¥ ë¶„ì„ ë° ì‹œê°í™”ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
 */
public class TickHistogram {

    // ê¸°ë³¸ ë²„í‚· ê²½ê³„ (ë°€ë¦¬ì´ˆ)
    private static final double[] DEFAULT_BUCKETS = EchoConstants.DEFAULT_HISTOGRAM_BUCKETS;

    private final double[] buckets;
    private final LongAdder[] counts;
    private final LongAdder totalSamples = new LongAdder();

    // í†µê³„
    private final LongAdder sumMicros = new LongAdder();

    // ì •í™•í•œ ë°±ë¶„ìœ„ìˆ˜ ê³„ì‚°ì„ ìœ„í•œ ìµœê·¼ ìƒ˜í”Œ ì¶”ì 
    private final long[] recentSamples = new long[EchoConstants.HISTOGRAM_SAMPLE_BUFFER];
    private int sampleIndex = 0;
    private final Object sampleLock = new Object();

    public TickHistogram() {
        this(DEFAULT_BUCKETS);
    }

    public TickHistogram(double[] bucketsMs) {
        this.buckets = Arrays.copyOf(bucketsMs, bucketsMs.length);
        this.counts = new LongAdder[buckets.length];
        for (int i = 0; i < counts.length; i++) {
            counts[i] = new LongAdder();
        }
    }

    /**
     * ìƒ˜í”Œ ì¶”ê°€
     * 
     * @param durationMicros ì†Œìš” ì‹œê°„ (ë§ˆì´í¬ë¡œì´ˆ)
     */
    public void addSample(long durationMicros) {
        double durationMs = durationMicros / 1000.0;

        // í•´ë‹¹í•˜ëŠ” ë²„í‚· ì°¾ê¸°
        int bucketIndex = findBucket(durationMs);
        counts[bucketIndex].increment();
        totalSamples.increment();
        sumMicros.add(durationMicros);

        // ìµœê·¼ ìƒ˜í”Œ ì €ì¥ (ì •í™•í•œ ë°±ë¶„ìœ„ìˆ˜ìš©)
        synchronized (sampleLock) {
            recentSamples[sampleIndex] = durationMicros;
            sampleIndex = (sampleIndex + 1) % recentSamples.length;
        }
    }

    private int findBucket(double durationMs) {
        for (int i = buckets.length - 1; i >= 0; i--) {
            if (durationMs >= buckets[i]) {
                return i;
            }
        }
        return 0;
    }

    /**
     * ë²„í‚·ë³„ ì¹´ìš´íŠ¸ ì¡°íšŒ
     */
    public long[] getCounts() {
        long[] result = new long[counts.length];
        for (int i = 0; i < counts.length; i++) {
            result[i] = counts[i].sum();
        }
        return result;
    }

    /**
     * ë²„í‚· ê²½ê³„ê°’ ì¡°íšŒ
     */
    public double[] getBuckets() {
        return Arrays.copyOf(buckets, buckets.length);
    }

    /**
     * ì´ ìƒ˜í”Œ ìˆ˜
     */
    public long getTotalSamples() {
        return totalSamples.sum();
    }

    /**
     * ë°±ë¶„ìœ„ìˆ˜ ê³„ì‚° (ê°œì„ ëœ ë²„ì „)
     * 
     * @param percentile 0-100 ì‚¬ì´ ê°’
     */
    public double getPercentile(double percentile) {
        long total = totalSamples.sum();
        if (total == 0)
            return 0;

        // ìµœê·¼ ìƒ˜í”Œ ê¸°ë°˜ ì •í™•í•œ ê³„ì‚° ì‹œë„
        synchronized (sampleLock) {
            int validSamples = (int) Math.min(total, recentSamples.length);
            if (validSamples >= 10) {
                long[] sorted = new long[validSamples];
                System.arraycopy(recentSamples, 0, sorted, 0, validSamples);
                java.util.Arrays.sort(sorted);
                int index = (int) Math.ceil(percentile / 100.0 * validSamples) - 1;
                index = Math.max(0, Math.min(index, validSamples - 1));
                return sorted[index] / 1000.0; // ë§ˆì´í¬ë¡œì´ˆ -> ë°€ë¦¬ì´ˆ
            }
        }

        // í´ë°±: ë²„í‚· ê¸°ë°˜ ì¶”ì •
        long target = (long) (total * percentile / 100.0);
        long cumulative = 0;

        for (int i = 0; i < counts.length; i++) {
            cumulative += counts[i].sum();
            if (cumulative >= target) {
                if (i == counts.length - 1) {
                    // ë§ˆì§€ë§‰ ë²„í‚·: ê²½ê³„ê°’ + 50% ì¶”ì • ëŒ€ì‹  ì‹¤ì œ ë²„í‚· ì‹œì‘ê°’ ì‚¬ìš©
                    return buckets[i];
                }
                // ì„ í˜• ë³´ê°„
                double bucketStart = buckets[i];
                double bucketEnd = buckets[i + 1];
                long bucketCount = counts[i].sum();
                long prevCumulative = cumulative - bucketCount;
                double fraction = bucketCount > 0
                        ? (double) (target - prevCumulative) / bucketCount
                        : 0.5;
                return bucketStart + fraction * (bucketEnd - bucketStart);
            }
        }

        return buckets[buckets.length - 1];
    }

    /**
     * P50 (ì¤‘ì•™ê°’)
     */
    public double getP50() {
        return getPercentile(50);
    }

    /**
     * P95
     */
    public double getP95() {
        return getPercentile(95);
    }

    /**
     * P99
     */
    public double getP99() {
        return getPercentile(99);
    }

    /**
     * í‰ê· ê°’ (ë°€ë¦¬ì´ˆ)
     */
    public double getAverageMs() {
        long total = totalSamples.sum();
        if (total == 0)
            return 0;
        return (sumMicros.sum() / 1000.0) / total;
    }

    /**
     * JSON ì¶œë ¥ìš© Map ìƒì„±
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();

        // ë²„í‚· ë¼ë²¨ ìƒì„±
        String[] labels = new String[buckets.length];
        for (int i = 0; i < buckets.length; i++) {
            if (i == buckets.length - 1) {
                labels[i] = String.format(">=%.1fms", buckets[i]);
            } else {
                labels[i] = String.format("%.1f-%.1fms", buckets[i], buckets[i + 1]);
            }
        }

        map.put("buckets_ms", buckets);
        map.put("labels", labels);
        map.put("counts", getCounts());
        map.put("total_samples", getTotalSamples());
        map.put("average_ms", Math.round(getAverageMs() * 100) / 100.0);
        map.put("p50_ms", Math.round(getP50() * 100) / 100.0);
        map.put("p95_ms", Math.round(getP95() * 100) / 100.0);
        map.put("p99_ms", Math.round(getP99() * 100) / 100.0);

        return map;
    }

    /**
     * ì½˜ì†” ì¶œë ¥ìš© ë¬¸ìì—´
     */
    public String toAsciiChart() {
        StringBuilder sb = new StringBuilder();
        long[] countArray = getCounts();
        long maxCount = Arrays.stream(countArray).max().orElse(1);

        sb.append("Tick Time Distribution:\n");
        sb.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");

        for (int i = 0; i < buckets.length; i++) {
            String label;
            if (i == buckets.length - 1) {
                label = String.format(">=%5.1fms", buckets[i]);
            } else {
                label = String.format("%5.1f-%5.1fms", buckets[i], buckets[i + 1]);
            }

            int barLength = (int) ((countArray[i] * 30) / Math.max(maxCount, 1));
            String bar = "â–ˆ".repeat(barLength);

            double percentage = getTotalSamples() > 0
                    ? (countArray[i] * 100.0 / getTotalSamples())
                    : 0;

            sb.append(String.format("  %s â”‚ %s %d (%.1f%%)\n",
                    label, bar, countArray[i], percentage));
        }

        sb.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
        sb.append(String.format("  Total: %,d samples | P50: %.1fms | P95: %.1fms | P99: %.1fms\n",
                getTotalSamples(), getP50(), getP95(), getP99()));

        return sb.toString();
    }

    /**
     * ì´ˆê¸°í™”
     */
    public void reset() {
        for (LongAdder count : counts) {
            count.reset();
        }
        totalSamples.reset();
        sumMicros.reset();
        synchronized (sampleLock) {
            java.util.Arrays.fill(recentSamples, 0);
            sampleIndex = 0;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\aggregate\TickHistogram.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\aggregate\TimingData.java =====

package com.echo.aggregate;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

/**
 * íƒ€ì´ë° ë°ì´í„° ëˆ„ì  ë° í†µê³„ ê³„ì‚°
 * 
 * ê¸°ëŠ¥:
 * - 1ì´ˆ/5ì´ˆ/60ì´ˆ ë‹¨ìœ„ í†µê³„
 * - í‰ê· /ìµœëŒ€ê°’/í‘œì¤€í¸ì°¨ ê³„ì‚°
 * - í˜¸ì¶œ ë¹ˆë„ ì¶”ì 
 * - Heavy Function Top N ë­í‚¹
 */
public class TimingData {

    private final String name;

    // ì›ìì  ì¹´ìš´í„°
    private final LongAdder callCount = new LongAdder();
    private final LongAdder totalTime = new LongAdder();
    private final AtomicLong maxTime = new AtomicLong(0);
    private final AtomicLong minTime = new AtomicLong(Long.MAX_VALUE);

    // ìµœê·¼ ìƒ˜í”Œ (ìŠ¤íŒŒì´í¬ ê°ì§€ìš©)
    private final long[] recentSamples = new long[100];
    private int sampleIndex = 0;
    private final Object sampleLock = new Object();

    // ì‹œê°„ëŒ€ë³„ í†µê³„ (ë°€ë¦¬ì´ˆ ë‹¨ìœ„)
    private final RollingStats stats1s = new RollingStats(1_000);
    private final RollingStats stats5s = new RollingStats(5_000);
    private final RollingStats stats60s = new RollingStats(60_000);

    // ë¼ë²¨ë³„ ì„¸ë¶€ í†µê³„ (ì˜ˆ: ê°œë³„ Lua í•¨ìˆ˜)
    private final Map<String, SubTimingData> labelStats = new ConcurrentHashMap<>();

    public TimingData(String name) {
        this.name = name;
    }

    // ============================================================
    // ìƒ˜í”Œ ì¶”ê°€
    // ============================================================

    /**
     * ìƒˆ ìƒ˜í”Œ ì¶”ê°€
     * 
     * @param elapsedNanos ì†Œìš” ì‹œê°„ (ë‚˜ë…¸ì´ˆ)
     */
    public void addSample(long elapsedNanos) {
        addSample(elapsedNanos, null);
    }

    /**
     * ìƒˆ ìƒ˜í”Œ ì¶”ê°€ (ë¼ë²¨ í¬í•¨)
     * 
     * @param elapsedNanos ì†Œìš” ì‹œê°„ (ë‚˜ë…¸ì´ˆ)
     * @param label        ì„¸ë¶€ ë¼ë²¨ (null ê°€ëŠ¥)
     */
    public void addSample(long elapsedNanos, String label) {
        long elapsedMicros = elapsedNanos / 1000;

        // ê¸°ë³¸ í†µê³„ ì—…ë°ì´íŠ¸
        callCount.increment();
        totalTime.add(elapsedMicros);

        // ìµœëŒ€/ìµœì†Œ ì—…ë°ì´íŠ¸ (CAS)
        updateMax(elapsedMicros);
        updateMin(elapsedMicros);

        // ìµœê·¼ ìƒ˜í”Œ ì €ì¥
        synchronized (sampleLock) {
            recentSamples[sampleIndex] = elapsedMicros;
            sampleIndex = (sampleIndex + 1) % recentSamples.length;
        }

        // ë¡¤ë§ í†µê³„ ì—…ë°ì´íŠ¸
        long now = System.currentTimeMillis();
        stats1s.addSample(elapsedMicros, now);
        stats5s.addSample(elapsedMicros, now);
        stats60s.addSample(elapsedMicros, now);

        // ë¼ë²¨ë³„ í†µê³„
        if (label != null && !label.isEmpty()) {
            labelStats.computeIfAbsent(label, SubTimingData::new)
                    .addSample(elapsedMicros);
        }
    }

    private void updateMax(long value) {
        long current;
        do {
            current = maxTime.get();
            if (value <= current)
                return;
        } while (!maxTime.compareAndSet(current, value));
    }

    private void updateMin(long value) {
        long current;
        do {
            current = minTime.get();
            if (value >= current)
                return;
        } while (!minTime.compareAndSet(current, value));
    }

    // ============================================================
    // í†µê³„ ì¡°íšŒ
    // ============================================================

    public String getName() {
        return name;
    }

    public long getCallCount() {
        return callCount.sum();
    }

    /** í‰ê·  ì‹œê°„ (ë§ˆì´í¬ë¡œì´ˆ) */
    public double getAverageMicros() {
        long count = callCount.sum();
        return count == 0 ? 0 : (double) totalTime.sum() / count;
    }

    /** ìµœëŒ€ ì‹œê°„ (ë§ˆì´í¬ë¡œì´ˆ) */
    public long getMaxMicros() {
        return maxTime.get();
    }

    /** ìµœì†Œ ì‹œê°„ (ë§ˆì´í¬ë¡œì´ˆ) */
    public long getMinMicros() {
        long min = minTime.get();
        return min == Long.MAX_VALUE ? 0 : min;
    }

    /** ì´ ëˆ„ì  ì‹œê°„ (ë§ˆì´í¬ë¡œì´ˆ) */
    public long getTotalMicros() {
        return totalTime.sum();
    }

    // ì‹œê°„ëŒ€ë³„ í†µê³„
    public RollingStats getStats1s() {
        return stats1s;
    }

    public RollingStats getStats5s() {
        return stats5s;
    }

    public RollingStats getStats60s() {
        return stats60s;
    }

    /**
     * Top N Heavy ë¼ë²¨ (ì´ ì‹œê°„ ê¸°ì¤€)
     */
    public List<SubTimingData> getTopNByTotalTime(int n) {
        return labelStats.values().stream()
                .sorted((a, b) -> Long.compare(b.getTotalMicros(), a.getTotalMicros()))
                .limit(n)
                .toList();
    }

    /**
     * Top N Heavy ë¼ë²¨ (ìµœëŒ€ ì‹œê°„ ê¸°ì¤€ - ìŠ¤íŒŒì´í¬ ê°ì§€)
     */
    public List<SubTimingData> getTopNByMaxTime(int n) {
        return labelStats.values().stream()
                .sorted((a, b) -> Long.compare(b.getMaxMicros(), a.getMaxMicros()))
                .limit(n)
                .toList();
    }

    /**
     * Top N Heavy ë¼ë²¨ (í˜¸ì¶œ ë¹ˆë„ ê¸°ì¤€)
     */
    public List<SubTimingData> getTopNByCallCount(int n) {
        return labelStats.values().stream()
                .sorted((a, b) -> Long.compare(b.getCallCount(), a.getCallCount()))
                .limit(n)
                .toList();
    }

    /**
     * ëª¨ë“  ë¼ë²¨ í†µê³„ ì¡°íšŒ
     */
    public Map<String, SubTimingData> getLabelStats() {
        return Collections.unmodifiableMap(labelStats);
    }

    /**
     * ì´ˆê¸°í™”
     */
    public void reset() {
        callCount.reset();
        totalTime.reset();
        maxTime.set(0);
        minTime.set(Long.MAX_VALUE);

        synchronized (sampleLock) {
            Arrays.fill(recentSamples, 0);
            sampleIndex = 0;
        }

        stats1s.reset();
        stats5s.reset();
        stats60s.reset();

        labelStats.clear();
    }

    // ============================================================
    // ë‚´ë¶€ í´ë˜ìŠ¤: ë¡¤ë§ í†µê³„
    // ============================================================

    /**
     * ì‹œê°„ ìœˆë„ìš° ê¸°ë°˜ ë¡¤ë§ í†µê³„ (Zero-Allocation Ring Buffer)
     * 
     * Phase 1 ìµœì í™”:
     * - ArrayDeque â†’ ê³ ì • í¬ê¸° long[] (GC-Free)
     * - Stream API â†’ Running Sum (O(1) ì—°ì‚°)
     * - ìƒ˜í”Œ ê¸°ë°˜ ìœˆë„ìš° (í‹± ê¸°ë°˜, ~60 FPS ê°€ì •)
     */
    public static class RollingStats {
        // ìƒìˆ˜: 60 FPS ê¸°ì¤€
        public static final int SAMPLES_PER_SECOND = 60;
        public static final int WINDOW_1S = SAMPLES_PER_SECOND; // 60
        public static final int WINDOW_5S = SAMPLES_PER_SECOND * 5; // 300
        public static final int WINDOW_60S = SAMPLES_PER_SECOND * 60; // 3600

        private final int capacity;
        private final long[] values;
        private int head = 0; // ë‹¤ìŒ ì“¸ ìœ„ì¹˜
        private int size = 0; // í˜„ì¬ ìƒ˜í”Œ ìˆ˜

        // Running statistics (O(1) ì¡°íšŒ)
        private long runningSum = 0;
        private long runningMax = 0;

        // í˜¸í™˜ì„±ì„ ìœ„í•œ windowMs (deprecated, í‘œì‹œìš©)
        @Deprecated
        private final long windowMs;

        public RollingStats(long windowMs) {
            // ê¸°ì¡´ API í˜¸í™˜: windowMs â†’ ìƒ˜í”Œ ìˆ˜ ë³€í™˜
            this.windowMs = windowMs;
            if (windowMs <= 1_000) {
                this.capacity = WINDOW_1S;
            } else if (windowMs <= 5_000) {
                this.capacity = WINDOW_5S;
            } else {
                this.capacity = WINDOW_60S;
            }
            this.values = new long[capacity];
        }

        /**
         * ìƒˆ ìƒ˜í”Œ ì¶”ê°€ (O(1), Zero-Allocation)
         * 
         * @param value     ì¸¡ì •ê°’ (ë§ˆì´í¬ë¡œì´ˆ)
         * @param timestamp ë¬´ì‹œë¨ (í˜¸í™˜ì„±ìš©)
         */
        public void addSample(long value, long timestamp) {
            addSample(value);
        }

        /**
         * ìƒˆ ìƒ˜í”Œ ì¶”ê°€ (O(1), Zero-Allocation)
         */
        public synchronized void addSample(long value) {
            // Ring Bufferê°€ ê°€ë“ ì°¬ ê²½ìš° ê°€ì¥ ì˜¤ë˜ëœ ê°’ ì œê±°
            if (size == capacity) {
                runningSum -= values[head];
            }

            // ìƒˆ ê°’ ì €ì¥
            values[head] = value;
            runningSum += value;

            // Max ê°±ì‹  (ê°€ì¥ ì˜¤ë˜ëœ ê°’ì´ maxì˜€ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¬ê³„ì‚° í•„ìš”)
            if (size == capacity && values[(head + 1) % capacity] == runningMax) {
                recalculateMax();
            } else if (value > runningMax) {
                runningMax = value;
            }

            // í¬ì¸í„° ì´ë™
            head = (head + 1) % capacity;
            size = Math.min(size + 1, capacity);
        }

        /**
         * í‰ê· ê°’ ì¡°íšŒ (O(1))
         */
        public long getAverage() {
            return size == 0 ? 0 : runningSum / size;
        }

        /**
         * ìµœëŒ€ê°’ ì¡°íšŒ (O(1) í‰ê· , ë“œë¬¼ê²Œ O(n))
         */
        public long getMax() {
            return size == 0 ? 0 : runningMax;
        }

        /**
         * í˜„ì¬ ìƒ˜í”Œ ìˆ˜
         */
        public int getSampleCount() {
            return size;
        }

        /**
         * ë²„í¼ ìš©ëŸ‰
         */
        public int getCapacity() {
            return capacity;
        }

        /**
         * ìœˆë„ìš° ì‹œê°„ (deprecated - í˜¸í™˜ì„±ìš©)
         */
        @Deprecated
        public long getWindowMs() {
            return windowMs;
        }

        /**
         * í†µê³„ì  ì‹ ë¢°ë„ (0.0 ~ 1.0)
         * Event-driven Pointsì—ì„œ ë‚®ì€ í˜¸ì¶œ ë¹ˆë„ ê°ì§€ìš©
         */
        public double getConfidence() {
            return (double) size / capacity;
        }

        /**
         * í†µê³„ì ìœ¼ë¡œ ì˜ë¯¸ ìˆëŠ” ë°ì´í„°ì¸ì§€ (50% ì´ìƒ ì±„ì›Œì§)
         */
        public boolean isStatisticallyMeaningful() {
            return size >= capacity / 2;
        }

        /**
         * ì´ˆê¸°í™”
         */
        public void reset() {
            Arrays.fill(values, 0);
            head = 0;
            size = 0;
            runningSum = 0;
            runningMax = 0;
        }

        /**
         * ì˜¤ë˜ëœ ìƒ˜í”Œ ì •ë¦¬ (í˜¸í™˜ì„±ìš© - ìƒ˜í”Œ ê¸°ë°˜ì´ë¯€ë¡œ NOP)
         */
        public void performCleanup() {
            // ìƒ˜í”Œ ê¸°ë°˜ Ring Bufferì—ì„œëŠ” ìë™ìœ¼ë¡œ ê´€ë¦¬ë˜ë¯€ë¡œ ë¶ˆí•„ìš”
        }

        /**
         * ìµœëŒ€ê°’ ì¬ê³„ì‚° (O(n) - ë“œë¬¼ê²Œ í˜¸ì¶œ)
         */
        private void recalculateMax() {
            runningMax = 0;
            for (int i = 0; i < size; i++) {
                if (values[i] > runningMax) {
                    runningMax = values[i];
                }
            }
        }
    }

    // ============================================================
    // ë‚´ë¶€ í´ë˜ìŠ¤: ë¼ë²¨ë³„ ì„¸ë¶€ í†µê³„
    // ============================================================

    /**
     * ê°œë³„ ë¼ë²¨(í•¨ìˆ˜)ì— ëŒ€í•œ ì„¸ë¶€ í†µê³„
     */
    public static class SubTimingData {
        private final String label;
        private final LongAdder callCount = new LongAdder();
        private final LongAdder totalTime = new LongAdder();
        private final AtomicLong maxTime = new AtomicLong(0);

        public SubTimingData(String label) {
            this.label = label;
        }

        public void addSample(long elapsedMicros) {
            callCount.increment();
            totalTime.add(elapsedMicros);

            long current;
            do {
                current = maxTime.get();
                if (elapsedMicros <= current)
                    return;
            } while (!maxTime.compareAndSet(current, elapsedMicros));
        }

        public String getLabel() {
            return label;
        }

        public long getCallCount() {
            return callCount.sum();
        }

        public long getTotalMicros() {
            return totalTime.sum();
        }

        public long getMaxMicros() {
            return maxTime.get();
        }

        public double getAverageMicros() {
            long count = callCount.sum();
            return count == 0 ? 0 : (double) totalTime.sum() / count;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\aggregate\TimingData.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\command\EchoCommands.java =====

package com.echo.command;

import com.echo.aggregate.SpikeLog;
import com.echo.config.EchoConfig;
import com.echo.measure.EchoProfiler;
import com.echo.measure.MemoryProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.monitor.EchoMonitorServer;
import com.echo.pulse.PulseEventAdapter;
import com.echo.pulse.TickProfiler;
import com.echo.pulse.RenderProfiler;
import com.echo.report.EchoReport;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;

/**
 * Echo ì½˜ì†” ëª…ë ¹ì–´
 * 
 * ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´:
 * - /echo help - ë„ì›€ë§
 * - /echo enable - í”„ë¡œíŒŒì¼ë§ ì‹œì‘
 * - /echo disable - í”„ë¡œíŒŒì¼ë§ ì¤‘ì§€
 * - /echo status - í˜„ì¬ ìƒíƒœ ì¶œë ¥
 * - /echo report - ë¦¬í¬íŠ¸ ìƒì„±
 * - /echo reset - í†µê³„ ì´ˆê¸°í™”
 * - /echo lua on/off - Lua í”„ë¡œíŒŒì¼ë§ í† ê¸€
 * - /echo config threshold <ms> - ìŠ¤íŒŒì´í¬ ì„ê³„ê°’ ì„¤ì •
 * - /echo memory - ë©”ëª¨ë¦¬ ìƒíƒœ ì¶œë ¥
 */
public class EchoCommands {

    private static final Map<String, Consumer<String[]>> commands = new HashMap<>();
    private static boolean registered = false;

    /**
     * ëª…ë ¹ì–´ ë“±ë¡
     */
    public static void register() {
        if (registered)
            return;

        commands.put("help", EchoCommands::cmdHelp);
        commands.put("enable", EchoCommands::cmdEnable);
        commands.put("disable", EchoCommands::cmdDisable);
        commands.put("status", EchoCommands::cmdStatus);
        commands.put("report", EchoCommands::cmdReport);
        commands.put("reset", EchoCommands::cmdReset);
        commands.put("lua", EchoCommands::cmdLua);
        commands.put("config", EchoCommands::cmdConfig);
        commands.put("memory", EchoCommands::cmdMemory);
        commands.put("test", EchoCommands::cmdTest);
        commands.put("stack", EchoCommands::cmdStack); // Phase 4
        commands.put("overhead", EchoCommands::cmdOverhead); // Phase 4
        commands.put("monitor", EchoCommands::cmdMonitor); // Phase 4

        registered = true;
        System.out.println("[Echo] Commands registered");
    }

    /**
     * ëª…ë ¹ì–´ ì‹¤í–‰
     * 
     * @param args ëª…ë ¹ì–´ ì¸ì (ì²« ë²ˆì§¸ëŠ” ì„œë¸Œì»¤ë§¨ë“œ)
     * @return ì²˜ë¦¬ ì—¬ë¶€
     */
    public static boolean execute(String[] args) {
        if (args == null || args.length == 0) {
            cmdHelp(args);
            return true;
        }

        String subCommand = args[0].toLowerCase();
        Consumer<String[]> handler = commands.get(subCommand);

        if (handler != null) {
            handler.accept(args);
            return true;
        } else {
            System.out.println("[Echo] Unknown command: " + subCommand);
            System.out.println("[Echo] Use '/echo help' for available commands");
            return false;
        }
    }

    // ============================================================
    // Command Handlers
    // ============================================================

    private static void cmdHelp(String[] args) {
        System.out.println();
        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘           Echo Profiler Commands              â•‘");
        System.out.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        System.out.println("â•‘  /echo help        - Show this help           â•‘");
        System.out.println("â•‘  /echo enable      - Start profiling          â•‘");
        System.out.println("â•‘  /echo disable     - Stop profiling           â•‘");
        System.out.println("â•‘  /echo status      - Show current status      â•‘");
        System.out.println("â•‘  /echo report      - Generate report          â•‘");
        System.out.println("â•‘  /echo report json - Save JSON report         â•‘");
        System.out.println("â•‘  /echo reset       - Reset all statistics     â•‘");
        System.out.println("â•‘  /echo lua on      - Enable Lua profiling     â•‘");
        System.out.println("â•‘  /echo lua off     - Disable Lua profiling    â•‘");
        System.out.println("â•‘  /echo config threshold <ms> - Set spike threshold â•‘");
        System.out.println("â•‘  /echo memory      - Show memory status       â•‘");
        System.out.println("â•‘  /echo test        - Run quick test           â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println();
    }

    private static void cmdEnable(String[] args) {
        EchoProfiler.getInstance().enable();
    }

    private static void cmdDisable(String[] args) {
        EchoProfiler.getInstance().disable();
    }

    private static void cmdStatus(String[] args) {
        EchoProfiler profiler = EchoProfiler.getInstance();
        profiler.printStatus();

        // Enhanced Phase 3: ì¶”ê°€ ìƒíƒœ ì •ë³´
        System.out.println("âš™ï¸ CONFIGURATION");
        System.out.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
        System.out.printf("  Lua Profiling:   %s%n",
                profiler.isLuaProfilingEnabled() ? "âœ… ENABLED" : "âŒ DISABLED");
        System.out.printf("  Spike Threshold: %.2f ms%n",
                profiler.getSpikeLog().getThresholdMs());
        System.out.printf("  Stack Depth:     %d (current thread)%n",
                profiler.getCurrentStackDepth());
        System.out.printf("  Session Time:    %d seconds%n",
                profiler.getSessionDurationSeconds());
        System.out.println();

        // Pulse integration status
        if (PulseEventAdapter.isRegistered()) {
            TickProfiler tickProfiler = PulseEventAdapter.getTickProfiler();
            RenderProfiler renderProfiler = PulseEventAdapter.getRenderProfiler();

            System.out.println("ğŸ“¡ PULSE INTEGRATION");
            System.out.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
            if (tickProfiler != null) {
                System.out.printf("  Tick Count:     %,d%n", tickProfiler.getTickCount());
                System.out.printf("  Last Tick:      %.2f ms%n", tickProfiler.getLastTickDurationMs());
                System.out.printf("  Spike Threshold: %.2f ms%n", tickProfiler.getSpikeThresholdMs());
            }
            if (renderProfiler != null) {
                System.out.printf("  Frame Count:    %,d%n", renderProfiler.getFrameCount());
                System.out.printf("  Current FPS:    %.1f%n", renderProfiler.getCurrentFps());
                System.out.printf("  Last Frame:     %.2f ms%n", renderProfiler.getLastFrameDurationMs());
            }
            System.out.println();
        }
    }

    private static void cmdReport(String[] args) {
        EchoProfiler profiler = EchoProfiler.getInstance();
        EchoReport report = new EchoReport(profiler);
        String reportDir = EchoConfig.getInstance().getReportDirectory();

        if (args.length > 1) {
            String format = args[1].toLowerCase();
            try {
                switch (format) {
                    case "json":
                        String jsonPath = report.saveWithTimestamp(reportDir);
                        System.out.println("[Echo] JSON report saved: " + jsonPath);
                        break;
                    case "csv":
                        String csvPath = report.saveCsv(reportDir);
                        System.out.println("[Echo] CSV report saved: " + csvPath);
                        break;
                    case "html":
                        String htmlPath = report.saveHtml(reportDir);
                        System.out.println("[Echo] HTML report saved: " + htmlPath);
                        break;
                    default:
                        System.out.println("[Echo] Unknown format: " + format);
                        System.out.println("[Echo] Usage: /echo report [json|csv|html]");
                }
            } catch (Exception e) {
                System.err.println("[Echo] Failed to save report: " + e.getMessage());
            }
        } else {
            report.printToConsole();
        }
    }

    private static void cmdReset(String[] args) {
        EchoProfiler.getInstance().reset();
    }

    private static void cmdLua(String[] args) {
        if (args.length < 2) {
            System.out.println("[Echo] Usage: /echo lua <on|off>");
            return;
        }

        String toggle = args[1].toLowerCase();
        EchoProfiler profiler = EchoProfiler.getInstance();

        if ("on".equals(toggle)) {
            profiler.enableLuaProfiling();
        } else if ("off".equals(toggle)) {
            profiler.disableLuaProfiling();
        } else {
            System.out.println("[Echo] Usage: /echo lua <on|off>");
        }
    }

    private static void cmdConfig(String[] args) {
        EchoProfiler profiler = EchoProfiler.getInstance();
        SpikeLog spikeLog = profiler.getSpikeLog();

        // /echo config (no args) - show current config
        if (args.length < 2) {
            System.out.println();
            System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            System.out.println("â•‘           Echo Configuration                  â•‘");
            System.out.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
            System.out.printf("â•‘  Spike Threshold: %.2f ms                    â•‘%n", spikeLog.getThresholdMs());
            System.out.printf("â•‘  Lua Profiling:   %s                      â•‘%n",
                    profiler.isLuaProfilingEnabled() ? "ON " : "OFF");
            System.out.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
            System.out.println("â•‘  Usage:                                       â•‘");
            System.out.println("â•‘    /echo config get              - Show all   â•‘");
            System.out.println("â•‘    /echo config set threshold <ms>            â•‘");
            System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            System.out.println();
            return;
        }

        String action = args[1].toLowerCase();

        // /echo config get
        if ("get".equals(action)) {
            System.out.println("[Echo] Current Configuration:");
            System.out.printf("  spike.threshold = %.2f ms%n", spikeLog.getThresholdMs());
            System.out.printf("  lua.enabled = %s%n", profiler.isLuaProfilingEnabled());
            System.out.printf("  profiler.enabled = %s%n", profiler.isEnabled());
            return;
        }

        // /echo config set <key> <value>
        if ("set".equals(action)) {
            if (args.length < 4) {
                System.out.println("[Echo] Usage: /echo config set <key> <value>");
                System.out.println("[Echo]   Available keys: threshold");
                return;
            }

            String key = args[2].toLowerCase();
            String value = args[3];

            if ("threshold".equals(key)) {
                try {
                    double thresholdMs = Double.parseDouble(value);
                    if (thresholdMs <= 0) {
                        System.out.println("[Echo] Threshold must be positive");
                        return;
                    }
                    spikeLog.setThresholdMs(thresholdMs);
                    System.out.printf("[Echo] Spike threshold set to %.2f ms%n", thresholdMs);
                } catch (NumberFormatException e) {
                    System.out.println("[Echo] Invalid number: " + value);
                }
            } else {
                System.out.println("[Echo] Unknown config key: " + key);
                System.out.println("[Echo] Available keys: threshold");
            }
            return;
        }

        // Legacy: /echo config threshold <value> (backward compatibility)
        if ("threshold".equals(action)) {
            if (args.length < 3) {
                System.out.printf("[Echo] Current threshold: %.2f ms%n", spikeLog.getThresholdMs());
                return;
            }
            try {
                double thresholdMs = Double.parseDouble(args[2]);
                if (thresholdMs <= 0) {
                    System.out.println("[Echo] Threshold must be positive");
                    return;
                }
                spikeLog.setThresholdMs(thresholdMs);
            } catch (NumberFormatException e) {
                System.out.println("[Echo] Invalid number: " + args[2]);
            }
            return;
        }

        System.out.println("[Echo] Unknown config action: " + action);
        System.out.println("[Echo] Usage: /echo config [get|set <key> <value>]");
    }

    private static void cmdMemory(String[] args) {
        MemoryProfiler.printStatus();
    }

    private static void cmdTest(String[] args) {
        System.out.println("[Echo] Running quick profiling test...");

        EchoProfiler profiler = EchoProfiler.getInstance();
        boolean wasEnabled = profiler.isEnabled();
        long testStartTime = System.currentTimeMillis();

        if (!wasEnabled) {
            profiler.enable();
        }

        int testIterations = 100;
        int successCount = 0;

        // Simulate some profiling
        for (int i = 0; i < testIterations; i++) {
            try (var scope = profiler.scope(ProfilingPoint.TICK)) {
                // Simulate tick work
                Thread.sleep(1);

                try (var aiScope = profiler.scope(ProfilingPoint.ZOMBIE_AI, "pathfinding")) {
                    Thread.sleep(0, 500000); // 0.5ms
                }

                try (var renderScope = profiler.scope(ProfilingPoint.RENDER)) {
                    Thread.sleep(0, 300000); // 0.3ms
                }
                successCount++;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }

        long testDuration = System.currentTimeMillis() - testStartTime;

        System.out.println("[Echo] Test complete! " + successCount + "/" + testIterations + " ticks recorded.");
        profiler.printStatus();

        // Phase 3: ê²°ê³¼ íŒŒì¼ ì €ì¥
        saveTestResult(profiler, testIterations, successCount, testDuration);

        if (!wasEnabled) {
            profiler.disable();
        }
    }

    /**
     * Smoke Test ê²°ê³¼ë¥¼ íŒŒì¼ë¡œ ì €ì¥ (íšŒê·€ í…ŒìŠ¤íŠ¸ìš©)
     */
    private static void saveTestResult(EchoProfiler profiler, int iterations, int success, long durationMs) {
        try {
            java.io.File dir = new java.io.File("./echo_tests");
            if (!dir.exists()) {
                dir.mkdirs();
            }

            String timestamp = java.time.LocalDateTime.now()
                    .format(java.time.format.DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            java.io.File file = new java.io.File(dir, "smoke_test_" + timestamp + ".txt");

            try (java.io.PrintWriter writer = new java.io.PrintWriter(file)) {
                writer.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                writer.println("  Echo Profiler Smoke Test Report");
                writer.println("  " + java.time.LocalDateTime.now());
                writer.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                writer.println();
                writer.println("TEST SUMMARY");
                writer.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
                writer.println("  Iterations:    " + iterations);
                writer.println("  Success:       " + success);
                writer.println("  Duration:      " + durationMs + " ms");
                writer.println("  Result:        " + (success == iterations ? "âœ… PASS" : "âŒ FAIL"));
                writer.println();
                writer.println("PROFILER METRICS");
                writer.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

                for (ProfilingPoint point : ProfilingPoint.values()) {
                    var data = profiler.getTimingData(point);
                    if (data != null && data.getCallCount() > 0) {
                        writer.printf("  %-15s | calls: %,8d | avg: %6.2f ms | max: %6.2f ms%n",
                                point.getDisplayName(),
                                data.getCallCount(),
                                data.getAverageMicros() / 1000.0,
                                data.getMaxMicros() / 1000.0);
                    }
                }

                writer.println();
                writer.println("CONFIGURATION");
                writer.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
                writer.println("  Spike Threshold: " + profiler.getSpikeLog().getThresholdMs() + " ms");
                writer.println("  Lua Profiling:   " + profiler.isLuaProfilingEnabled());
                writer.println();
                writer.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            }

            System.out.println("[Echo] Test result saved: " + file.getAbsolutePath());
        } catch (Exception e) {
            System.err.println("[Echo] Failed to save test result: " + e.getMessage());
        }
    }

    /**
     * Phase 4: ìŠ¤íŒŒì´í¬ ìŠ¤íƒ ìº¡ì²˜ í† ê¸€
     */
    private static void cmdStack(String[] args) {
        SpikeLog spikeLog = EchoProfiler.getInstance().getSpikeLog();

        if (args.length < 2) {
            System.out.println("[Echo] Stack capture: " +
                    (spikeLog.isStackCaptureEnabled() ? "ENABLED" : "DISABLED"));
            System.out.println("[Echo] Usage: /echo stack <on|off>");
            System.out.println("[Echo] âš ï¸ Warning: Stack capture has significant performance cost!");
            return;
        }

        String toggle = args[1].toLowerCase();
        if ("on".equals(toggle)) {
            spikeLog.setStackCaptureEnabled(true);
        } else if ("off".equals(toggle)) {
            spikeLog.setStackCaptureEnabled(false);
        } else {
            System.out.println("[Echo] Usage: /echo stack <on|off>");
        }
    }

    /**
     * Phase 4: ë©”íƒ€ í”„ë¡œíŒŒì¼ë§ (í”„ë¡œíŒŒì¼ëŸ¬ ì˜¤ë²„í—¤ë“œ ì¸¡ì •)
     */
    private static void cmdOverhead(String[] args) {
        System.out.println("[Echo] Measuring profiler overhead...");

        EchoProfiler profiler = EchoProfiler.getInstance();
        boolean wasEnabled = profiler.isEnabled();

        if (!wasEnabled) {
            profiler.enable(false);
        }

        int iterations = 10000;

        // ì˜¤ë²„í—¤ë“œ ì—†ì´ ì¸¡ì •
        long baselineStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            // ë¹ˆ ë£¨í”„
        }
        long baselineTime = System.nanoTime() - baselineStart;

        // í”„ë¡œíŒŒì¼ë§ ì˜¤ë²„í—¤ë“œ ì¸¡ì •
        long profiledStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            long start = profiler.startRaw(ProfilingPoint.ECHO_OVERHEAD);
            profiler.endRaw(ProfilingPoint.ECHO_OVERHEAD, start);
        }
        long profiledTime = System.nanoTime() - profiledStart;

        // scope() API ì˜¤ë²„í—¤ë“œ ì¸¡ì •
        long scopeStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            try (var scope = profiler.scope(ProfilingPoint.ECHO_OVERHEAD)) {
                // ë¹ˆ ë£¨í”„
            }
        }
        long scopeTime = System.nanoTime() - scopeStart;

        if (!wasEnabled) {
            profiler.disable();
        }

        // ê²°ê³¼ ì¶œë ¥
        double rawOverheadNs = (profiledTime - baselineTime) / (double) iterations;
        double scopeOverheadNs = (scopeTime - baselineTime) / (double) iterations;

        System.out.println();
        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘         Echo Profiler Overhead Report         â•‘");
        System.out.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        System.out.printf("â•‘  Iterations:        %,d                   â•‘%n", iterations);
        System.out.printf("â•‘  Raw API overhead:  %.2f ns/call           â•‘%n", rawOverheadNs);
        System.out.printf("â•‘  Scope API overhead: %.2f ns/call          â•‘%n", scopeOverheadNs);
        System.out.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        System.out.println("â•‘  ğŸ’¡ Lower is better. <100ns is excellent.     â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println();
    }

    /**
     * Phase 4: HTTP ëª¨ë‹ˆí„° ì„œë²„ ì œì–´
     */
    private static void cmdMonitor(String[] args) {
        EchoMonitorServer server = EchoMonitorServer.getInstance();

        if (args.length < 2) {
            System.out.println("[Echo] Monitor server: " + (server.isRunning() ? "RUNNING" : "STOPPED"));
            System.out.println("[Echo] Usage: /echo monitor <start|stop>");
            return;
        }

        String action = args[1].toLowerCase();
        switch (action) {
            case "start":
                if (args.length > 2) {
                    try {
                        int port = Integer.parseInt(args[2]);
                        server.start(port);
                    } catch (NumberFormatException e) {
                        System.out.println("[Echo] Invalid port: " + args[2]);
                    }
                } else {
                    server.start();
                }
                break;
            case "stop":
                server.stop();
                break;
            default:
                System.out.println("[Echo] Usage: /echo monitor <start|stop>");
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\command\EchoCommands.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\config\EchoConfig.java =====

package com.echo.config;

import com.echo.EchoConstants;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Echo ì„¤ì • ê´€ë¦¬
 * 
 * JSON ê¸°ë°˜ ì„¤ì • íŒŒì¼ ë¡œë“œ/ì €ì¥
 */
public class EchoConfig {

    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    private static final String CONFIG_DIR = "./config";
    private static final String CONFIG_FILE = "echo.json";

    private static EchoConfig instance;

    // ============================================================
    // ì„¤ì • í•„ë“œ
    // ============================================================

    /** ìŠ¤íŒŒì´í¬ ì„ê³„ê°’ (ms) */
    private double spikeThresholdMs = EchoConstants.DEFAULT_SPIKE_THRESHOLD_MS;

    /** Lua í”„ë¡œíŒŒì¼ë§ ê¸°ë³¸ í™œì„±í™” */
    private boolean luaProfilingDefault = false;

    /** ë¦¬í¬íŠ¸ ìë™ ì €ì¥ */
    private boolean autoSaveReports = true;

    /** ë¦¬í¬íŠ¸ ì €ì¥ ê²½ë¡œ */
    private String reportDirectory = EchoConstants.DEFAULT_REPORT_DIR;

    /** ìŠ¤íƒ ìº¡ì²˜ í™œì„±í™” */
    private boolean stackCaptureEnabled = false;

    /** ë””ë²„ê·¸ ëª¨ë“œ */
    private boolean debugMode = false;

    /** Top N í•¨ìˆ˜ í‘œì‹œ ìˆ˜ */
    private int topNFunctions = EchoConstants.DEFAULT_TOP_N;

    // ============================================================
    // Singleton
    // ============================================================

    private EchoConfig() {
    }

    public static EchoConfig getInstance() {
        if (instance == null) {
            instance = new EchoConfig();
            instance.load();
        }
        return instance;
    }

    // ============================================================
    // ë¡œë“œ/ì €ì¥
    // ============================================================

    /**
     * ì„¤ì • íŒŒì¼ ë¡œë“œ
     */
    public void load() {
        Path configPath = Paths.get(CONFIG_DIR, CONFIG_FILE);

        if (!Files.exists(configPath)) {
            System.out.println("[Echo] Config file not found, using defaults");
            save(); // ê¸°ë³¸ê°’ìœ¼ë¡œ ìƒì„±
            return;
        }

        try (Reader reader = new FileReader(configPath.toFile())) {
            EchoConfig loaded = GSON.fromJson(reader, EchoConfig.class);
            if (loaded != null) {
                this.spikeThresholdMs = loaded.spikeThresholdMs;
                this.luaProfilingDefault = loaded.luaProfilingDefault;
                this.autoSaveReports = loaded.autoSaveReports;
                this.reportDirectory = loaded.reportDirectory;
                this.stackCaptureEnabled = loaded.stackCaptureEnabled;
                this.debugMode = loaded.debugMode;
                this.topNFunctions = loaded.topNFunctions;
            }
            System.out.println("[Echo] Config loaded from: " + configPath);
        } catch (Exception e) {
            System.err.println("[Echo] Failed to load config: " + e.getMessage());
        }
    }

    /**
     * ì„¤ì • íŒŒì¼ ì €ì¥
     */
    public void save() {
        Path configDir = Paths.get(CONFIG_DIR);
        Path configPath = configDir.resolve(CONFIG_FILE);

        try {
            if (!Files.exists(configDir)) {
                Files.createDirectories(configDir);
            }

            try (Writer writer = new FileWriter(configPath.toFile())) {
                GSON.toJson(this, writer);
            }
            System.out.println("[Echo] Config saved to: " + configPath);
        } catch (Exception e) {
            System.err.println("[Echo] Failed to save config: " + e.getMessage());
        }
    }

    /**
     * ì„¤ì • ë¦¬ì…‹
     */
    public void reset() {
        this.spikeThresholdMs = EchoConstants.DEFAULT_SPIKE_THRESHOLD_MS;
        this.luaProfilingDefault = false;
        this.autoSaveReports = true;
        this.reportDirectory = EchoConstants.DEFAULT_REPORT_DIR;
        this.stackCaptureEnabled = false;
        this.debugMode = false;
        this.topNFunctions = EchoConstants.DEFAULT_TOP_N;
        save();
        System.out.println("[Echo] Config reset to defaults");
    }

    // ============================================================
    // Getters / Setters
    // ============================================================

    public double getSpikeThresholdMs() {
        return spikeThresholdMs;
    }

    public void setSpikeThresholdMs(double spikeThresholdMs) {
        this.spikeThresholdMs = spikeThresholdMs;
    }

    public boolean isLuaProfilingDefault() {
        return luaProfilingDefault;
    }

    public void setLuaProfilingDefault(boolean luaProfilingDefault) {
        this.luaProfilingDefault = luaProfilingDefault;
    }

    public boolean isAutoSaveReports() {
        return autoSaveReports;
    }

    public void setAutoSaveReports(boolean autoSaveReports) {
        this.autoSaveReports = autoSaveReports;
    }

    public String getReportDirectory() {
        return reportDirectory;
    }

    public void setReportDirectory(String reportDirectory) {
        this.reportDirectory = reportDirectory;
    }

    public boolean isStackCaptureEnabled() {
        return stackCaptureEnabled;
    }

    public void setStackCaptureEnabled(boolean stackCaptureEnabled) {
        this.stackCaptureEnabled = stackCaptureEnabled;
    }

    public boolean isDebugMode() {
        return debugMode;
    }

    public void setDebugMode(boolean debugMode) {
        this.debugMode = debugMode;
    }

    public int getTopNFunctions() {
        return topNFunctions;
    }

    public void setTopNFunctions(int topNFunctions) {
        this.topNFunctions = topNFunctions;
    }

    /**
     * ì½˜ì†” ì¶œë ¥
     */
    public void printConfig() {
        System.out.println("\n[Echo] Current Configuration:");
        System.out.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
        System.out.printf("  spike.threshold     = %.2f ms%n", spikeThresholdMs);
        System.out.printf("  lua.default         = %s%n", luaProfilingDefault);
        System.out.printf("  report.auto_save    = %s%n", autoSaveReports);
        System.out.printf("  report.directory    = %s%n", reportDirectory);
        System.out.printf("  stack.capture       = %s%n", stackCaptureEnabled);
        System.out.printf("  debug.mode          = %s%n", debugMode);
        System.out.printf("  top_n               = %d%n", topNFunctions);
        System.out.println();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\config\EchoConfig.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\EchoConstants.java =====

package com.echo;

/**
 * Echo Profiler ì „ì—­ ìƒìˆ˜
 */
public final class EchoConstants {

    private EchoConstants() {
        // ìƒìˆ˜ í´ë˜ìŠ¤
    }

    // ============================================================
    // ë²„ì „
    // ============================================================

    /** í˜„ì¬ Echo ë²„ì „ */
    public static final String VERSION = "0.2.1";

    // ============================================================
    // ìŠ¤íŒŒì´í¬ ê°ì§€
    // ============================================================

    /** ê¸°ë³¸ ìŠ¤íŒŒì´í¬ ì„ê³„ê°’ (ms) - 30fps ê¸°ì¤€ 2í”„ë ˆì„ */
    public static final double DEFAULT_SPIKE_THRESHOLD_MS = 33.33;

    /** ìŠ¤íŒŒì´í¬ ë¡œê·¸ ìµœëŒ€ ì—”íŠ¸ë¦¬ ìˆ˜ */
    public static final int SPIKE_LOG_MAX_ENTRIES = 100;

    /** ìŠ¤íŒŒì´í¬ ìŠ¤íƒ ìº¡ì²˜ ìµœëŒ€ ê¹Šì´ */
    public static final int SPIKE_MAX_STACK_DEPTH = 10;

    // ============================================================
    // íˆìŠ¤í† ê·¸ë¨
    // ============================================================

    /** íˆìŠ¤í† ê·¸ë¨ ìµœê·¼ ìƒ˜í”Œ ë²„í¼ í¬ê¸° */
    public static final int HISTOGRAM_SAMPLE_BUFFER = 1000;

    /** ê¸°ë³¸ íˆìŠ¤í† ê·¸ë¨ ë²„í‚· ê²½ê³„ (ms) */
    public static final double[] DEFAULT_HISTOGRAM_BUCKETS = {
            0, 5, 10, 16.67, 20, 33.33, 50, 100, 200
    };

    // ============================================================
    // ë¡¤ë§ í†µê³„
    // ============================================================

    /** ì´ˆë‹¹ ì˜ˆìƒ ìƒ˜í”Œ ìˆ˜ (60 FPS ê¸°ì¤€) */
    public static final int SAMPLES_PER_SECOND = 60;

    /** 1ì´ˆ ìœˆë„ìš° ìƒ˜í”Œ ìˆ˜ */
    public static final int ROLLING_WINDOW_1S = SAMPLES_PER_SECOND;

    /** 5ì´ˆ ìœˆë„ìš° ìƒ˜í”Œ ìˆ˜ */
    public static final int ROLLING_WINDOW_5S = SAMPLES_PER_SECOND * 5;

    /** 60ì´ˆ ìœˆë„ìš° ìƒ˜í”Œ ìˆ˜ */
    public static final int ROLLING_WINDOW_60S = SAMPLES_PER_SECOND * 60;

    // ============================================================
    // ê°ì²´ í’€
    // ============================================================

    /** ProfilingScope í’€ í¬ê¸° */
    public static final int SCOPE_POOL_SIZE = 16;

    // ============================================================
    // ë¦¬í¬íŠ¸
    // ============================================================

    /** ê¸°ë³¸ Top N í•¨ìˆ˜ í‘œì‹œ ìˆ˜ */
    public static final int DEFAULT_TOP_N = 10;

    /** ê¸°ë³¸ ë¦¬í¬íŠ¸ ì €ì¥ ê²½ë¡œ */
    public static final String DEFAULT_REPORT_DIR = "./echo_reports";

    /** ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì €ì¥ ê²½ë¡œ */
    public static final String DEFAULT_TEST_DIR = "./echo_tests";

    // ============================================================
    // íƒ€ì„ì•„ì›ƒ ë° ìºì‹œ
    // ============================================================

    /** Lua í†µê³„ ìºì‹œ TTL (ms) */
    public static final long LUA_CACHE_TTL_MS = 1000;

    /** ìµœê·¼ ìƒ˜í”Œ ë²„í¼ í¬ê¸° */
    public static final int RECENT_SAMPLES_SIZE = 100;
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\EchoConstants.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\EchoMod.java =====

package com.echo;

import com.echo.command.EchoCommands;
import com.echo.measure.EchoProfiler;
import com.echo.pulse.PulseEventAdapter;

/**
 * Echo Mod ì§„ì…ì 
 * 
 * Pulse ëª¨ë“œ ë¡œë”ì—ì„œ ë¡œë“œë˜ëŠ” ë©”ì¸ í´ë˜ìŠ¤
 */
public class EchoMod {

    public static final String MOD_ID = "echo";
    public static final String MOD_NAME = "Echo Profiler";
    public static final String VERSION = "0.2.0";

    private static boolean initialized = false;

    /**
     * ëª¨ë“œ ì´ˆê¸°í™”
     * Pulseì—ì„œ í˜¸ì¶œë¨
     */
    public static void init() {
        if (initialized) {
            System.out.println("[Echo] Already initialized, skipping...");
            return;
        }

        System.out.println();
        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘     Echo Profiler v" + VERSION + " Initialized         â•‘");
        System.out.println("â•‘     \"Observe, Don't Patch\"                    â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println();

        // ëª…ë ¹ì–´ ë“±ë¡
        EchoCommands.register();

        // Pulse ì´ë²¤íŠ¸ ì–´ëŒ‘í„° ë“±ë¡
        PulseEventAdapter.register();

        initialized = true;

        System.out.println("[Echo] Use '/echo help' for available commands");
    }

    /**
     * ëª¨ë“œ ì¢…ë£Œ
     */
    public static void shutdown() {
        if (!initialized)
            return;

        EchoProfiler profiler = EchoProfiler.getInstance();
        if (profiler.isEnabled()) {
            System.out.println("[Echo] Auto-saving report before shutdown...");
            try {
                new com.echo.report.EchoReport(profiler)
                        .saveWithTimestamp("./echo_reports");
            } catch (Exception e) {
                // Phase 2: ìƒì„¸ ì—ëŸ¬ ë¡œê¹…
                System.err.println("[Echo] Failed to save report: " + e.getMessage());
                System.err.println("[Echo] Stack trace for debugging:");
                e.printStackTrace(System.err);
            }
        }

        System.out.println("[Echo] Shutdown complete");
        initialized = false;
    }

    /**
     * ì´ˆê¸°í™” ì—¬ë¶€ í™•ì¸
     */
    public static boolean isInitialized() {
        return initialized;
    }

    /**
     * ë²„ì „ ë¬¸ìì—´ ë°˜í™˜
     */
    public static String getVersion() {
        return VERSION;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\EchoMod.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\event\EchoEventListener.java =====

package com.echo.event;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;

/**
 * Echo ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
 * 
 * Pulse ì´ë²¤íŠ¸ ë²„ìŠ¤ì™€ ì—°ë™í•˜ì—¬ ìë™ìœ¼ë¡œ í”„ë¡œíŒŒì¼ë§ í¬ì¸íŠ¸ë¥¼ ì¸¡ì •í•©ë‹ˆë‹¤.
 * 
 * ì§€ì› ì´ë²¤íŠ¸:
 * - OnTick (ê²Œì„ í‹±)
 * - OnRenderTick (ë Œë”ë§)
 * - OnZombiesUpdate (ì¢€ë¹„ AI)
 */
public class EchoEventListener {

    private static final EchoProfiler profiler = EchoProfiler.getInstance();

    // í˜„ì¬ í™œì„± ìŠ¤ì½”í”„ (ìˆ˜ë™ ê´€ë¦¬ìš©)
    private static EchoProfiler.ProfilingScope currentTickScope = null;
    private static EchoProfiler.ProfilingScope currentRenderScope = null;

    /**
     * ê²Œì„ í‹± ì‹œì‘
     * Pulse OnTick.Pre ì´ë²¤íŠ¸ì—ì„œ í˜¸ì¶œ
     */
    public static void onTickStart() {
        if (!profiler.isEnabled())
            return;
        currentTickScope = profiler.scope(ProfilingPoint.TICK);
    }

    /**
     * ê²Œì„ í‹± ì¢…ë£Œ
     * Pulse OnTick.Post ì´ë²¤íŠ¸ì—ì„œ í˜¸ì¶œ
     */
    public static void onTickEnd() {
        if (currentTickScope != null) {
            currentTickScope.close();
            currentTickScope = null;
        }
    }

    /**
     * ë Œë”ë§ ì‹œì‘
     */
    public static void onRenderStart() {
        if (!profiler.isEnabled())
            return;
        currentRenderScope = profiler.scope(ProfilingPoint.RENDER);
    }

    /**
     * ë Œë”ë§ ì¢…ë£Œ
     */
    public static void onRenderEnd() {
        if (currentRenderScope != null) {
            currentRenderScope.close();
            currentRenderScope = null;
        }
    }

    /**
     * ì¢€ë¹„ AI ì—…ë°ì´íŠ¸ ë˜í¼
     * Callable ë°©ì‹ìœ¼ë¡œ ê¸°ì¡´ ë¡œì§ì„ ê°ì‹¸ì„œ ì¸¡ì •
     */
    public static void profileZombieAI(Runnable zombieUpdate) {
        if (!profiler.isEnabled()) {
            zombieUpdate.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.ZOMBIE_AI)) {
            zombieUpdate.run();
        }
    }

    /**
     * ë¬¼ë¦¬ ì—”ì§„ ì—…ë°ì´íŠ¸ ë˜í¼
     */
    public static void profilePhysics(Runnable physicsUpdate) {
        if (!profiler.isEnabled()) {
            physicsUpdate.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.PHYSICS)) {
            physicsUpdate.run();
        }
    }

    /**
     * ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ ë˜í¼
     */
    public static void profileNetwork(Runnable networkUpdate) {
        if (!profiler.isEnabled()) {
            networkUpdate.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.NETWORK)) {
            networkUpdate.run();
        }
    }

    /**
     * ì²­í¬ I/O ë˜í¼
     */
    public static void profileChunkIO(Runnable chunkIO, String chunkInfo) {
        if (!profiler.isEnabled()) {
            chunkIO.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.CHUNK_IO, chunkInfo)) {
            chunkIO.run();
        }
    }

    /**
     * Lua ì´ë²¤íŠ¸ ë˜í¼ (On-Demand)
     */
    public static void profileLuaEvent(Runnable luaCallback, String eventName) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            luaCallback.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_EVENT, eventName)) {
            luaCallback.run();
        }
    }

    /**
     * Lua í•¨ìˆ˜ í˜¸ì¶œ ë˜í¼ (On-Demand)
     */
    public static void profileLuaFunction(Runnable luaFunction, String functionName) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            luaFunction.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_FUNCTION, functionName)) {
            luaFunction.run();
        }
    }

    /**
     * ëª¨ë“œ í‹± í•¸ë“¤ëŸ¬ ë˜í¼
     */
    public static void profileModTick(Runnable modTick, String modId) {
        if (!profiler.isEnabled()) {
            modTick.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.MOD_TICK, modId)) {
            modTick.run();
        }
    }

    /**
     * ë²”ìš© í”„ë¡œíŒŒì¼ë§ ë˜í¼
     */
    public static void profile(ProfilingPoint point, Runnable task) {
        if (!profiler.isEnabled()) {
            task.run();
            return;
        }

        try (var scope = profiler.scope(point)) {
            task.run();
        }
    }

    /**
     * ë²”ìš© í”„ë¡œíŒŒì¼ë§ ë˜í¼ (ë¼ë²¨ í¬í•¨)
     */
    public static void profile(ProfilingPoint point, String label, Runnable task) {
        if (!profiler.isEnabled()) {
            task.run();
            return;
        }

        try (var scope = profiler.scope(point, label)) {
            task.run();
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\event\EchoEventListener.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\lua\LuaCallTracker.java =====

package com.echo.lua;

import com.echo.measure.EchoProfiler;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;

import com.echo.util.StringUtils;

/**
 * Lua í˜¸ì¶œ ì¶”ì ê¸°
 * 
 * Lua í•¨ìˆ˜/ì´ë²¤íŠ¸ í˜¸ì¶œì„ ì„¸ë¶€ì ìœ¼ë¡œ ì¶”ì í•˜ê³  í†µê³„ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 * On-Demand ë°©ì‹ìœ¼ë¡œ í™œì„±í™”ë©ë‹ˆë‹¤.
 */
public class LuaCallTracker {

    private static final LuaCallTracker INSTANCE = new LuaCallTracker();

    // í•¨ìˆ˜ë³„ í†µê³„
    private final Map<String, LuaFunctionStats> functionStats = new ConcurrentHashMap<>();

    // ì´ë²¤íŠ¸ë³„ í†µê³„
    private final Map<String, LuaEventStats> eventStats = new ConcurrentHashMap<>();

    // ì „ì²´ í†µê³„
    private final LongAdder totalCalls = new LongAdder();
    private final LongAdder totalTimeMicros = new LongAdder();

    // Top N ìºì‹œ
    private volatile List<LuaFunctionStats> topByTimeCached = new ArrayList<>();
    private volatile List<LuaFunctionStats> topByCallsCached = new ArrayList<>();
    private volatile long lastCacheUpdate = 0;
    private static final long CACHE_TTL_MS = 1000;

    private LuaCallTracker() {
    }

    public static LuaCallTracker getInstance() {
        return INSTANCE;
    }

    // ============================================================
    // ê¸°ë¡ API
    // ============================================================

    /**
     * Lua í•¨ìˆ˜ í˜¸ì¶œ ê¸°ë¡
     */
    public void recordFunctionCall(String functionName, long durationMicros) {
        if (!EchoProfiler.getInstance().isLuaProfilingEnabled())
            return;

        functionStats.computeIfAbsent(functionName, LuaFunctionStats::new)
                .record(durationMicros);

        totalCalls.increment();
        totalTimeMicros.add(durationMicros);
    }

    /**
     * Lua ì´ë²¤íŠ¸ í˜¸ì¶œ ê¸°ë¡
     */
    public void recordEventCall(String eventName, long durationMicros, int handlerCount) {
        if (!EchoProfiler.getInstance().isLuaProfilingEnabled())
            return;

        eventStats.computeIfAbsent(eventName, LuaEventStats::new)
                .record(durationMicros, handlerCount);
    }

    /**
     * í”„ë¡œíŒŒì¼ë§ ë˜í¼ - í•¨ìˆ˜
     */
    public void profileFunction(String functionName, Runnable function) {
        if (!EchoProfiler.getInstance().isLuaProfilingEnabled()) {
            function.run();
            return;
        }

        long start = System.nanoTime();
        try {
            function.run();
        } finally {
            long elapsed = (System.nanoTime() - start) / 1000;
            recordFunctionCall(functionName, elapsed);
        }
    }

    /**
     * í”„ë¡œíŒŒì¼ë§ ë˜í¼ - ì´ë²¤íŠ¸
     */
    public void profileEvent(String eventName, int handlerCount, Runnable event) {
        if (!EchoProfiler.getInstance().isLuaProfilingEnabled()) {
            event.run();
            return;
        }

        long start = System.nanoTime();
        try {
            event.run();
        } finally {
            long elapsed = (System.nanoTime() - start) / 1000;
            recordEventCall(eventName, elapsed, handlerCount);
        }
    }

    // ============================================================
    // ì¡°íšŒ API
    // ============================================================

    /**
     * ì´ Lua í˜¸ì¶œ ìˆ˜
     */
    public long getTotalCalls() {
        return totalCalls.sum();
    }

    /**
     * ì´ Lua ì‹¤í–‰ ì‹œê°„ (ë°€ë¦¬ì´ˆ)
     */
    public double getTotalTimeMs() {
        return totalTimeMicros.sum() / 1000.0;
    }

    /**
     * í•¨ìˆ˜ë³„ í†µê³„ ì¡°íšŒ
     */
    public LuaFunctionStats getFunctionStats(String functionName) {
        return functionStats.get(functionName);
    }

    /**
     * ëª¨ë“  í•¨ìˆ˜ í†µê³„
     */
    public Collection<LuaFunctionStats> getAllFunctionStats() {
        return Collections.unmodifiableCollection(functionStats.values());
    }

    /**
     * ì´ë²¤íŠ¸ë³„ í†µê³„ ì¡°íšŒ
     */
    public LuaEventStats getEventStats(String eventName) {
        return eventStats.get(eventName);
    }

    /**
     * ëª¨ë“  ì´ë²¤íŠ¸ í†µê³„
     */
    public Collection<LuaEventStats> getAllEventStats() {
        return Collections.unmodifiableCollection(eventStats.values());
    }

    /**
     * Top N í•¨ìˆ˜ (ì´ ì‹œê°„ ê¸°ì¤€)
     */
    public List<LuaFunctionStats> getTopFunctionsByTime(int n) {
        updateCacheIfNeeded();
        return topByTimeCached.size() <= n ? topByTimeCached : topByTimeCached.subList(0, n);
    }

    /**
     * Top N í•¨ìˆ˜ (í˜¸ì¶œ íšŸìˆ˜ ê¸°ì¤€)
     */
    public List<LuaFunctionStats> getTopFunctionsByCalls(int n) {
        updateCacheIfNeeded();
        return topByCallsCached.size() <= n ? topByCallsCached : topByCallsCached.subList(0, n);
    }

    private void updateCacheIfNeeded() {
        long now = System.currentTimeMillis();
        if (now - lastCacheUpdate < CACHE_TTL_MS)
            return;

        List<LuaFunctionStats> all = new ArrayList<>(functionStats.values());

        all.sort((a, b) -> Long.compare(b.getTotalMicros(), a.getTotalMicros()));
        topByTimeCached = new ArrayList<>(all);

        all.sort((a, b) -> Long.compare(b.getCallCount(), a.getCallCount()));
        topByCallsCached = new ArrayList<>(all);

        lastCacheUpdate = now;
    }

    /**
     * ì´ˆê¸°í™”
     */
    public void reset() {
        functionStats.clear();
        eventStats.clear();
        totalCalls.reset();
        totalTimeMicros.reset();
        topByTimeCached.clear();
        topByCallsCached.clear();
        System.out.println("[Echo] Lua call tracker RESET");
    }

    /**
     * ì½˜ì†” ì¶œë ¥
     */
    public void printStats(int topN) {
        System.out.println("\nğŸ”· LUA PROFILING STATS");
        System.out.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
        System.out.printf("  Total Calls: %,d | Total Time: %.2f ms%n",
                getTotalCalls(), getTotalTimeMs());
        System.out.println();

        System.out.println("  Top Functions by Time:");
        int rank = 1;
        for (LuaFunctionStats stats : getTopFunctionsByTime(topN)) {
            System.out.printf("    #%d %-25s | calls: %,6d | total: %6.2f ms | avg: %.3f ms%n",
                    rank++,
                    StringUtils.truncate(stats.getName(), 25),
                    stats.getCallCount(),
                    stats.getTotalMs(),
                    stats.getAverageMs());
        }

        if (!eventStats.isEmpty()) {
            System.out.println("\n  Events:");
            for (LuaEventStats stats : eventStats.values()) {
                System.out.printf("    %-25s | fires: %,6d | handlers: %,d | total: %.2f ms%n",
                        StringUtils.truncate(stats.getName(), 25),
                        stats.getFireCount(),
                        stats.getTotalHandlers(),
                        stats.getTotalMs());
            }
        }
        System.out.println();
    }

    // truncate method removed - using StringUtils.truncate()

    /**
     * JSON ì¶œë ¥ìš© Map
     */
    public Map<String, Object> toMap(int topN) {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("enabled", EchoProfiler.getInstance().isLuaProfilingEnabled());
        map.put("total_calls", getTotalCalls());
        map.put("total_time_ms", Math.round(getTotalTimeMs() * 100) / 100.0);

        List<Map<String, Object>> topFunctions = new ArrayList<>();
        int rank = 1;
        for (LuaFunctionStats stats : getTopFunctionsByTime(topN)) {
            topFunctions.add(stats.toMap(rank++));
        }
        map.put("top_functions_by_time", topFunctions);

        List<Map<String, Object>> events = new ArrayList<>();
        for (LuaEventStats stats : eventStats.values()) {
            events.add(stats.toMap());
        }
        map.put("events", events);

        return map;
    }

    // ============================================================
    // ë‚´ë¶€ í´ë˜ìŠ¤
    // ============================================================

    /**
     * ê°œë³„ Lua í•¨ìˆ˜ í†µê³„
     */
    public static class LuaFunctionStats {
        private final String name;
        private final LongAdder callCount = new LongAdder();
        private final LongAdder totalMicros = new LongAdder();
        private final java.util.concurrent.atomic.AtomicLong maxMicros = new java.util.concurrent.atomic.AtomicLong(0);

        public LuaFunctionStats(String name) {
            this.name = name;
        }

        public void record(long durationMicros) {
            callCount.increment();
            totalMicros.add(durationMicros);
            // CAS pattern for thread-safe max update
            long current;
            do {
                current = maxMicros.get();
                if (durationMicros <= current)
                    return;
            } while (!maxMicros.compareAndSet(current, durationMicros));
        }

        public String getName() {
            return name;
        }

        public long getCallCount() {
            return callCount.sum();
        }

        public long getTotalMicros() {
            return totalMicros.sum();
        }

        public long getMaxMicros() {
            return maxMicros.get();
        }

        public double getTotalMs() {
            return totalMicros.sum() / 1000.0;
        }

        public double getAverageMs() {
            long count = callCount.sum();
            return count == 0 ? 0 : getTotalMs() / count;
        }

        public double getMaxMs() {
            return maxMicros.get() / 1000.0;
        }

        public Map<String, Object> toMap(int rank) {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("rank", rank);
            map.put("name", name);
            map.put("call_count", getCallCount());
            map.put("total_time_ms", Math.round(getTotalMs() * 100) / 100.0);
            map.put("average_time_ms", Math.round(getAverageMs() * 1000) / 1000.0);
            map.put("max_time_ms", Math.round(getMaxMs() * 100) / 100.0);
            return map;
        }
    }

    /**
     * ê°œë³„ Lua ì´ë²¤íŠ¸ í†µê³„
     */
    public static class LuaEventStats {
        private final String name;
        private final LongAdder fireCount = new LongAdder();
        private final LongAdder totalHandlers = new LongAdder();
        private final LongAdder totalMicros = new LongAdder();

        public LuaEventStats(String name) {
            this.name = name;
        }

        public void record(long durationMicros, int handlerCount) {
            fireCount.increment();
            totalHandlers.add(handlerCount);
            totalMicros.add(durationMicros);
        }

        public String getName() {
            return name;
        }

        public long getFireCount() {
            return fireCount.sum();
        }

        public long getTotalHandlers() {
            return totalHandlers.sum();
        }

        public double getTotalMs() {
            return totalMicros.sum() / 1000.0;
        }

        public double getAverageHandlersPerFire() {
            long count = fireCount.sum();
            return count == 0 ? 0 : (double) totalHandlers.sum() / count;
        }

        public Map<String, Object> toMap() {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("name", name);
            map.put("fire_count", getFireCount());
            map.put("total_handlers", getTotalHandlers());
            map.put("avg_handlers_per_fire", Math.round(getAverageHandlersPerFire() * 10) / 10.0);
            map.put("total_time_ms", Math.round(getTotalMs() * 100) / 100.0);
            return map;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\lua\LuaCallTracker.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\measure\EchoProfiler.java =====

package com.echo.measure;

import com.echo.aggregate.TimingData;
import com.echo.aggregate.TickHistogram;
import com.echo.aggregate.SpikeLog;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Echo Profiler - ê³„ì¸µì  í”„ë¡œíŒŒì¼ë§ ì—”ì§„
 * 
 * Stack ê¸°ë°˜ push/popìœ¼ë¡œ ì¤‘ì²©ëœ í˜¸ì¶œ êµ¬ì¡°ë¥¼ ì¶”ì í•©ë‹ˆë‹¤.
 * ThreadLocalì„ ì‚¬ìš©í•˜ì—¬ ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œë„ ì•ˆì „í•©ë‹ˆë‹¤.
 */
public class EchoProfiler {

    private static final EchoProfiler INSTANCE = new EchoProfiler();

    // ============================================================
    // Phase 1 ìµœì í™”: Main Thread Fast-Path
    // ============================================================

    // ë©”ì¸ ìŠ¤ë ˆë“œ (Fast-Pathìš©)
    private static volatile Thread mainThread = null;

    // ë©”ì¸ ìŠ¤ë ˆë“œ ì „ìš© ìŠ¤íƒ (ThreadLocal ìš°íšŒ)
    private final Deque<ProfilingFrame> mainThreadStack = new ArrayDeque<>();

    // ============================================================
    // Core Fields
    // ============================================================

    // ìŠ¤ë ˆë“œë³„ í”„ë¡œíŒŒì¼ë§ ìŠ¤íƒ (ë©”ì¸ ìŠ¤ë ˆë“œ ì™¸)
    private final ThreadLocal<Deque<ProfilingFrame>> frameStack = ThreadLocal.withInitial(ArrayDeque::new);

    // Phase 1 ìµœì í™”: ProfilingScope ê°ì²´ í’€
    private final ThreadLocal<ProfilingScopePool> scopePool = ThreadLocal.withInitial(ProfilingScopePool::new);
    private final ProfilingScopePool mainThreadScopePool = new ProfilingScopePool();

    // í¬ì¸íŠ¸ë³„ ëˆ„ì  ë°ì´í„°
    private final Map<ProfilingPoint, TimingData> timingRegistry = new ConcurrentHashMap<>();

    // í‹± íˆìŠ¤í† ê·¸ë¨ (Phase 3)
    private final TickHistogram tickHistogram = new TickHistogram();

    // ìŠ¤íŒŒì´í¬ ë¡œê·¸ (Phase 3)
    private final SpikeLog spikeLog = new SpikeLog();

    // í”„ë¡œíŒŒì¼ë§ í™œì„±í™” ìƒíƒœ
    private volatile boolean enabled = false;

    // Lua í”„ë¡œíŒŒì¼ë§ (On-Demand)
    private volatile boolean luaProfilingEnabled = false;

    // ì„¸ì…˜ ì‹œì‘ ì‹œê°„
    private volatile long sessionStartTime = 0;

    private EchoProfiler() {
        // ëª¨ë“  ProfilingPointì— ëŒ€í•œ TimingData ì´ˆê¸°í™”
        for (ProfilingPoint point : ProfilingPoint.values()) {
            timingRegistry.put(point, new TimingData(point.name()));
        }
    }

    public static EchoProfiler getInstance() {
        return INSTANCE;
    }

    /**
     * ë©”ì¸ ìŠ¤ë ˆë“œ ì„¤ì • (ê²Œì„ ì‹œì‘ ì‹œ í˜¸ì¶œ)
     * ThreadLocal ìš°íšŒë¥¼ í†µí•´ ì„±ëŠ¥ í–¥ìƒ
     */
    public static void setMainThread(Thread thread) {
        mainThread = thread;
        System.out.println("[Echo] Main thread set: " + thread.getName());
    }

    /**
     * í˜„ì¬ ìŠ¤ë ˆë“œê°€ ë©”ì¸ ìŠ¤ë ˆë“œì¸ì§€ í™•ì¸
     */
    private boolean isMainThread() {
        return Thread.currentThread() == mainThread;
    }

    /**
     * í˜„ì¬ ìŠ¤ë ˆë“œì˜ í”„ë ˆì„ ìŠ¤íƒ íšë“ (Fast-Path ì ìš©)
     */
    private Deque<ProfilingFrame> getFrameStack() {
        if (isMainThread()) {
            return mainThreadStack;
        }
        return frameStack.get();
    }

    /**
     * í˜„ì¬ ìŠ¤ë ˆë“œì˜ ìŠ¤ì½”í”„ í’€ íšë“ (Fast-Path ì ìš©)
     */
    private ProfilingScopePool getScopePool() {
        if (isMainThread()) {
            return mainThreadScopePool;
        }
        return scopePool.get();
    }

    // ============================================================
    // í•µì‹¬ API: push / pop
    // ============================================================

    /**
     * í”„ë¡œíŒŒì¼ë§ êµ¬ê°„ ì‹œì‘
     * 
     * @param point ì¸¡ì • ëŒ€ìƒ
     * @return ì¸¡ì • ID (ë””ë²„ê·¸ìš©)
     */
    public long push(ProfilingPoint point) {
        if (!enabled)
            return -1;
        if (point.isLuaRelated() && !luaProfilingEnabled)
            return -1;

        ProfilingFrame frame = new ProfilingFrame(point, System.nanoTime());
        getFrameStack().push(frame);

        return frame.id;
    }

    /**
     * í”„ë¡œíŒŒì¼ë§ êµ¬ê°„ ì‹œì‘ (ì»¤ìŠ¤í…€ ë¼ë²¨)
     * 
     * @param point       ì¸¡ì • ëŒ€ìƒ
     * @param customLabel ì„¸ë¶€ ë¼ë²¨ (ì˜ˆ: í•¨ìˆ˜ëª…)
     */
    public long push(ProfilingPoint point, String customLabel) {
        if (!enabled)
            return -1;
        if (point.isLuaRelated() && !luaProfilingEnabled)
            return -1;

        ProfilingFrame frame = new ProfilingFrame(point, customLabel, System.nanoTime());
        getFrameStack().push(frame);

        return frame.id;
    }

    /**
     * í”„ë¡œíŒŒì¼ë§ êµ¬ê°„ ì¢…ë£Œ
     * 
     * @param point ì¢…ë£Œí•  ì¸¡ì • ëŒ€ìƒ (ê²€ì¦ìš©)
     */
    public void pop(ProfilingPoint point) {
        if (!enabled)
            return;

        Deque<ProfilingFrame> stack = getFrameStack();
        if (stack.isEmpty()) {
            System.err.println("[Echo] Warning: Unmatched pop for " + point);
            return;
        }

        ProfilingFrame frame = stack.pop();

        // ê²€ì¦: push/pop ë§¤ì¹­ í™•ì¸
        if (frame.point != point) {
            System.err.println("[Echo] Warning: Mismatched push/pop - expected "
                    + frame.point + ", got " + point);
        }

        long elapsed = System.nanoTime() - frame.startTime;
        long elapsedMicros = elapsed / 1000;

        // TimingDataì— ìƒ˜í”Œ ì¶”ê°€
        TimingData data = timingRegistry.get(point);
        if (data != null) {
            data.addSample(elapsed, frame.customLabel);
        }

        // TICK í¬ì¸íŠ¸ì¸ ê²½ìš° íˆìŠ¤í† ê·¸ë¨ì— ê¸°ë¡
        if (point == ProfilingPoint.TICK) {
            tickHistogram.addSample(elapsedMicros);
        }

        // ìŠ¤íŒŒì´í¬ ë¡œê·¸ì— ê¸°ë¡ (ì„ê³„ê°’ ì´ˆê³¼ ì‹œ)
        spikeLog.logSpike(elapsedMicros, point, frame.customLabel);
    }

    /**
     * ìë™ ì¢…ë£Œë¥¼ ìœ„í•œ try-with-resources ì§€ì› (Zero-Allocation)
     */
    public ProfilingScope scope(ProfilingPoint point) {
        push(point);
        return getScopePool().acquire(point, this);
    }

    public ProfilingScope scope(ProfilingPoint point, String label) {
        push(point, label);
        return getScopePool().acquire(point, this);
    }

    // ============================================================
    // Phase 1: Low-Level Raw API (ì™„ì „ Zero-Allocation)
    // ============================================================

    /**
     * ì›ì‹œ í”„ë¡œíŒŒì¼ë§ ì‹œì‘ (ê°ì²´ ìƒì„± ì—†ìŒ)
     * ë Œë” ë£¨í”„ ë“± ê·¹í•œ ì„±ëŠ¥ êµ¬ê°„ìš©
     * 
     * @param point ì¸¡ì • ëŒ€ìƒ
     * @return ì‹œì‘ ì‹œê°„ (ë‚˜ë…¸ì´ˆ), -1ì´ë©´ ë¹„í™œì„±í™” ìƒíƒœ
     */
    public long startRaw(ProfilingPoint point) {
        if (!enabled)
            return -1;
        if (point.isLuaRelated() && !luaProfilingEnabled)
            return -1;
        return System.nanoTime();
    }

    /**
     * ì›ì‹œ í”„ë¡œíŒŒì¼ë§ ì¢…ë£Œ (ê°ì²´ ìƒì„± ì—†ìŒ)
     * 
     * @param point     ì¸¡ì • ëŒ€ìƒ
     * @param startTime startRaw()ì—ì„œ ë°˜í™˜ë°›ì€ ì‹œì‘ ì‹œê°„
     */
    public void endRaw(ProfilingPoint point, long startTime) {
        if (startTime < 0)
            return;

        long elapsed = System.nanoTime() - startTime;
        long elapsedMicros = elapsed / 1000;

        // TimingDataì— ì§ì ‘ ê¸°ë¡ (ìŠ¤íƒ ì—†ìŒ)
        TimingData data = timingRegistry.get(point);
        if (data != null) {
            data.addSample(elapsed, null);
        }

        // TICK í¬ì¸íŠ¸ì¸ ê²½ìš° íˆìŠ¤í† ê·¸ë¨ì— ê¸°ë¡
        if (point == ProfilingPoint.TICK) {
            tickHistogram.addSample(elapsedMicros);
        }

        // ìŠ¤íŒŒì´í¬ ë¡œê·¸ì— ê¸°ë¡
        spikeLog.logSpike(elapsedMicros, point, null);
    }

    /**
     * ì›ì‹œ í”„ë¡œíŒŒì¼ë§ ì¢…ë£Œ (ë¼ë²¨ í¬í•¨)
     */
    public void endRaw(ProfilingPoint point, long startTime, String label) {
        if (startTime < 0)
            return;

        long elapsed = System.nanoTime() - startTime;
        long elapsedMicros = elapsed / 1000;

        TimingData data = timingRegistry.get(point);
        if (data != null) {
            data.addSample(elapsed, label);
        }

        if (point == ProfilingPoint.TICK) {
            tickHistogram.addSample(elapsedMicros);
        }

        spikeLog.logSpike(elapsedMicros, point, label);
    }

    // ============================================================
    // ì œì–´ API
    // ============================================================

    /**
     * í”„ë¡œíŒŒì¼ëŸ¬ í™œì„±í™” (ìƒˆ ì„¸ì…˜ ì‹œ í†µê³„ ì´ˆê¸°í™”)
     */
    public void enable() {
        enable(true);
    }

    /**
     * í”„ë¡œíŒŒì¼ëŸ¬ í™œì„±í™”
     * 
     * @param resetStats true: ê¸°ì¡´ í†µê³„ ì´ˆê¸°í™”, false: ê¸°ì¡´ í†µê³„ ìœ ì§€
     */
    public void enable(boolean resetStats) {
        if (!enabled && resetStats) {
            reset();
        }
        this.enabled = true;
        if (sessionStartTime == 0) {
            this.sessionStartTime = System.currentTimeMillis();
        }
        System.out.println("[Echo] Profiler ENABLED" + (resetStats ? " (stats reset)" : ""));
    }

    public void disable() {
        // Phase 2: ì§„í–‰ ì¤‘ ìŠ¤íƒ ê²½ê³  ë° ì •ë¦¬
        int orphanedFrames = clearActiveStacks();
        if (orphanedFrames > 0) {
            System.err.println("[Echo] Warning: " + orphanedFrames + " orphaned frames cleared on disable");
        }

        this.enabled = false;
        System.out.println("[Echo] Profiler DISABLED");
    }

    /**
     * ëª¨ë“  í™œì„± ìŠ¤íƒ ì •ë¦¬ (Session ì¢…ë£Œ ì‹œ)
     * 
     * @return ì •ë¦¬ëœ í”„ë ˆì„ ìˆ˜
     */
    private int clearActiveStacks() {
        int count = 0;

        // ë©”ì¸ ìŠ¤ë ˆë“œ ìŠ¤íƒ ì •ë¦¬
        count += mainThreadStack.size();
        mainThreadStack.clear();

        // í˜„ì¬ ìŠ¤ë ˆë“œì˜ ìŠ¤íƒ ì •ë¦¬ (ThreadLocal)
        Deque<ProfilingFrame> currentStack = frameStack.get();
        count += currentStack.size();
        currentStack.clear();

        return count;
    }

    public void enableLuaProfiling() {
        this.luaProfilingEnabled = true;
        System.out.println("[Echo] Lua Profiling ENABLED (On-Demand)");
    }

    public void disableLuaProfiling() {
        this.luaProfilingEnabled = false;
        System.out.println("[Echo] Lua Profiling DISABLED");
    }

    public boolean isEnabled() {
        return enabled;
    }

    public boolean isLuaProfilingEnabled() {
        return luaProfilingEnabled;
    }

    public long getSessionStartTime() {
        return sessionStartTime;
    }

    /**
     * ëª¨ë“  í†µê³„ ì´ˆê¸°í™”
     */
    public void reset() {
        timingRegistry.values().forEach(TimingData::reset);
        tickHistogram.reset();
        spikeLog.reset();
        sessionStartTime = System.currentTimeMillis();
        System.out.println("[Echo] All timing data RESET");
    }

    /**
     * ëª¨ë“  TimingData ì ‘ê·¼
     */
    public Map<ProfilingPoint, TimingData> getTimingData() {
        return timingRegistry;
    }

    public TimingData getTimingData(ProfilingPoint point) {
        return timingRegistry.get(point);
    }

    /**
     * í‹± íˆìŠ¤í† ê·¸ë¨ ì ‘ê·¼
     */
    public TickHistogram getTickHistogram() {
        return tickHistogram;
    }

    /**
     * ìŠ¤íŒŒì´í¬ ë¡œê·¸ ì ‘ê·¼
     */
    public SpikeLog getSpikeLog() {
        return spikeLog;
    }

    // ============================================================
    // í¸ì˜ ë©”ì„œë“œ
    // ============================================================

    /**
     * í˜„ì¬ ìŠ¤íƒ ê¹Šì´ í™•ì¸ (ë””ë²„ê·¸ìš©)
     */
    public int getCurrentStackDepth() {
        return getFrameStack().size();
    }

    /**
     * í˜„ì¬ ìµœìƒìœ„ í”„ë ˆì„ í™•ì¸ (ë””ë²„ê·¸ìš©)
     */
    public ProfilingPoint getCurrentPoint() {
        Deque<ProfilingFrame> stack = getFrameStack();
        if (stack.isEmpty())
            return null;
        return stack.peek().point;
    }

    /**
     * ì½˜ì†”ì— ê°„ë‹¨í•œ ìƒíƒœ ì¶œë ¥
     */
    public void printStatus() {
        System.out.println("\n[Echo] === Profiler Status ===");
        System.out.println("  Enabled: " + enabled);
        System.out.println("  Lua Profiling: " + luaProfilingEnabled);
        System.out.println("  Session Duration: " + getSessionDurationSeconds() + "s");
        System.out.println();

        for (ProfilingPoint point : ProfilingPoint.values()) {
            TimingData data = timingRegistry.get(point);
            if (data != null && data.getCallCount() > 0) {
                System.out.printf("  %-15s | calls: %,8d | avg: %6.2f ms | max: %6.2f ms%n",
                        point.getDisplayName(),
                        data.getCallCount(),
                        data.getAverageMicros() / 1000.0,
                        data.getMaxMicros() / 1000.0);
            }
        }
        System.out.println();
    }

    public long getSessionDurationSeconds() {
        if (sessionStartTime == 0)
            return 0;
        return (System.currentTimeMillis() - sessionStartTime) / 1000;
    }

    // ============================================================
    // ë‚´ë¶€ í´ë˜ìŠ¤
    // ============================================================

    /**
     * ìŠ¤íƒ í”„ë ˆì„ - ì§„í–‰ ì¤‘ì¸ ì¸¡ì • ì •ë³´
     */
    private static class ProfilingFrame {
        private static final AtomicLong idCounter = new AtomicLong(0);

        final long id;
        final ProfilingPoint point;
        final String customLabel;
        final long startTime;

        ProfilingFrame(ProfilingPoint point, long startTime) {
            this.id = idCounter.incrementAndGet();
            this.point = point;
            this.customLabel = null;
            this.startTime = startTime;
        }

        ProfilingFrame(ProfilingPoint point, String customLabel, long startTime) {
            this.id = idCounter.incrementAndGet();
            this.point = point;
            this.customLabel = customLabel;
            this.startTime = startTime;
        }
    }

    /**
     * try-with-resourcesìš© ìŠ¤ì½”í”„ (Poolable)
     */
    public static class ProfilingScope implements AutoCloseable {
        ProfilingPoint point;
        EchoProfiler profiler;
        ProfilingScopePool pool;

        void init(ProfilingPoint point, EchoProfiler profiler, ProfilingScopePool pool) {
            this.point = point;
            this.profiler = profiler;
            this.pool = pool;
        }

        @Override
        public void close() {
            profiler.pop(point);
            if (pool != null) {
                pool.release(this);
            }
        }
    }

    /**
     * ProfilingScope ê°ì²´ í’€ (Zero-Allocation)
     * ìŠ¤ë ˆë“œë‹¹ í•˜ë‚˜ì”© ìœ ì§€ë˜ì–´ ë™ê¸°í™” ë¶ˆí•„ìš”
     */
    static class ProfilingScopePool {
        private static final int POOL_SIZE = 16;
        private final ProfilingScope[] pool = new ProfilingScope[POOL_SIZE];
        private int index = 0;

        ProfilingScopePool() {
            for (int i = 0; i < POOL_SIZE; i++) {
                pool[i] = new ProfilingScope();
            }
        }

        ProfilingScope acquire(ProfilingPoint point, EchoProfiler profiler) {
            ProfilingScope scope;
            if (index > 0) {
                scope = pool[--index];
            } else {
                // í’€ì´ ë¹„ì–´ìˆìœ¼ë©´ ìƒˆë¡œ ìƒì„± (ë“œë¬¸ ê²½ìš°)
                scope = new ProfilingScope();
            }
            scope.init(point, profiler, this);
            return scope;
        }

        void release(ProfilingScope scope) {
            if (index < POOL_SIZE) {
                pool[index++] = scope;
            }
            // í’€ì´ ê°€ë“ ì°¨ë©´ ë²„ë¦¼ (GCê°€ ì •ë¦¬)
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\measure\EchoProfiler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\measure\MemoryProfiler.java =====

package com.echo.measure;

import java.lang.management.GarbageCollectorMXBean;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryUsage;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬
 * 
 * JVM ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë° GC ì´ë²¤íŠ¸ ì¶”ì 
 */
public class MemoryProfiler {

    private static final MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
    private static final List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();

    // ìµœê·¼ GC í†µê³„ (ë¸íƒ€ ê³„ì‚°ìš©)
    private static long lastGcCount = 0;
    private static long lastGcTime = 0;

    /**
     * í™ ì‚¬ìš©ëŸ‰ (ë°”ì´íŠ¸)
     */
    public static long getHeapUsed() {
        return memoryBean.getHeapMemoryUsage().getUsed();
    }

    /**
     * í™ ìµœëŒ€ í¬ê¸° (ë°”ì´íŠ¸)
     */
    public static long getHeapMax() {
        return memoryBean.getHeapMemoryUsage().getMax();
    }

    /**
     * í™ ì»¤ë°‹ í¬ê¸° (ë°”ì´íŠ¸)
     */
    public static long getHeapCommitted() {
        return memoryBean.getHeapMemoryUsage().getCommitted();
    }

    /**
     * í™ ì‚¬ìš©ë¥  (%)
     */
    public static double getHeapUsagePercent() {
        MemoryUsage usage = memoryBean.getHeapMemoryUsage();
        long max = usage.getMax();
        if (max <= 0) {
            max = usage.getCommitted();
        }
        return max > 0 ? (usage.getUsed() * 100.0 / max) : 0;
    }

    /**
     * Non-Heap ì‚¬ìš©ëŸ‰ (ë°”ì´íŠ¸) - Metaspace ë“±
     */
    public static long getNonHeapUsed() {
        return memoryBean.getNonHeapMemoryUsage().getUsed();
    }

    /**
     * ì´ GC íšŸìˆ˜
     */
    public static long getTotalGcCount() {
        return gcBeans.stream()
                .mapToLong(GarbageCollectorMXBean::getCollectionCount)
                .filter(c -> c >= 0)
                .sum();
    }

    /**
     * ì´ GC ì‹œê°„ (ë°€ë¦¬ì´ˆ)
     */
    public static long getTotalGcTimeMs() {
        return gcBeans.stream()
                .mapToLong(GarbageCollectorMXBean::getCollectionTime)
                .filter(t -> t >= 0)
                .sum();
    }

    /**
     * ìµœê·¼ GC íšŸìˆ˜ (ë§ˆì§€ë§‰ í˜¸ì¶œ ì´í›„ ì¦ê°€ë¶„)
     */
    public static long getRecentGcCount() {
        long current = getTotalGcCount();
        long delta = current - lastGcCount;
        lastGcCount = current;
        return delta;
    }

    /**
     * ìµœê·¼ GC ì‹œê°„ (ë§ˆì§€ë§‰ í˜¸ì¶œ ì´í›„ ì¦ê°€ë¶„, ë°€ë¦¬ì´ˆ)
     */
    public static long getRecentGcTimeMs() {
        long current = getTotalGcTimeMs();
        long delta = current - lastGcTime;
        lastGcTime = current;
        return delta;
    }

    /**
     * GC ì •ë³´ ì¡°íšŒ
     */
    public static Map<String, Object> getGcInfo() {
        Map<String, Object> info = new LinkedHashMap<>();
        for (GarbageCollectorMXBean gc : gcBeans) {
            Map<String, Object> gcEntry = new LinkedHashMap<>();
            gcEntry.put("count", gc.getCollectionCount());
            gcEntry.put("time_ms", gc.getCollectionTime());
            info.put(gc.getName(), gcEntry);
        }
        return info;
    }

    /**
     * ì½˜ì†” ì¶œë ¥ìš© ìƒíƒœ ë¬¸ìì—´
     */
    public static String getStatusString() {
        StringBuilder sb = new StringBuilder();
        sb.append("ğŸ’¾ MEMORY STATUS\n");
        sb.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
        sb.append(String.format("  Heap Used:     %,d MB / %,d MB (%.1f%%)%n",
                getHeapUsed() / (1024 * 1024),
                getHeapMax() / (1024 * 1024),
                getHeapUsagePercent()));
        sb.append(String.format("  Non-Heap:      %,d MB%n",
                getNonHeapUsed() / (1024 * 1024)));
        sb.append(String.format("  GC Count:      %,d%n", getTotalGcCount()));
        sb.append(String.format("  GC Time:       %,d ms%n", getTotalGcTimeMs()));
        return sb.toString();
    }

    /**
     * JSON ì¶œë ¥ìš© Map
     */
    public static Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();

        Map<String, Object> heap = new LinkedHashMap<>();
        heap.put("used_mb", Math.round(getHeapUsed() / (1024.0 * 1024.0) * 100) / 100.0);
        heap.put("max_mb", Math.round(getHeapMax() / (1024.0 * 1024.0) * 100) / 100.0);
        heap.put("committed_mb", Math.round(getHeapCommitted() / (1024.0 * 1024.0) * 100) / 100.0);
        heap.put("usage_percent", Math.round(getHeapUsagePercent() * 100) / 100.0);
        map.put("heap", heap);

        map.put("non_heap_mb", Math.round(getNonHeapUsed() / (1024.0 * 1024.0) * 100) / 100.0);

        Map<String, Object> gc = new LinkedHashMap<>();
        gc.put("total_count", getTotalGcCount());
        gc.put("total_time_ms", getTotalGcTimeMs());
        gc.put("collectors", getGcInfo());
        map.put("gc", gc);

        return map;
    }

    /**
     * ë©”ëª¨ë¦¬ í†µê³„ ì¶œë ¥
     */
    public static void printStatus() {
        System.out.println(getStatusString());
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\measure\MemoryProfiler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\measure\ProfilingPoint.java =====

package com.echo.measure;

/**
 * í”„ë¡œíŒŒì¼ë§ ì¸¡ì • í¬ì¸íŠ¸
 * 
 * ì¹´í…Œê³ ë¦¬:
 * - CORE: í•µì‹¬ ê²Œì„ ë£¨í”„
 * - SUBSYSTEM: ì£¼ìš” ì„œë¸Œì‹œìŠ¤í…œ
 * - LUA: Lua ê´€ë ¨ (On-Demand)
 * - CUSTOM: ì‚¬ìš©ì ì •ì˜
 */
public enum ProfilingPoint {

    // ============================================================
    // CORE - í•µì‹¬ ê²Œì„ ë£¨í”„
    // ============================================================

    /** ì „ì²´ ê²Œì„ í‹± */
    TICK(Category.CORE, "Game Tick"),

    /** ì „ì²´ ë Œë”ë§ í”„ë ˆì„ */
    FRAME(Category.CORE, "Render Frame"),

    // ============================================================
    // SUBSYSTEM - ì£¼ìš” ì„œë¸Œì‹œìŠ¤í…œ
    // ============================================================

    /** ë Œë”ë§ ì„œë¸Œì‹œìŠ¤í…œ */
    RENDER(Category.SUBSYSTEM, "Rendering"),

    /** ì›”ë“œ ë Œë”ë§ */
    RENDER_WORLD(Category.SUBSYSTEM, "World Rendering"),

    /** UI ë Œë”ë§ */
    RENDER_UI(Category.SUBSYSTEM, "UI Rendering"),

    /** ì‹œë®¬ë ˆì´ì…˜ ì—…ë°ì´íŠ¸ */
    SIMULATION(Category.SUBSYSTEM, "Simulation"),

    /** ë¬¼ë¦¬ ì—°ì‚° */
    PHYSICS(Category.SUBSYSTEM, "Physics"),

    /** ì¢€ë¹„ AI ì—…ë°ì´íŠ¸ */
    ZOMBIE_AI(Category.SUBSYSTEM, "Zombie AI"),

    /** NPC AI ì—…ë°ì´íŠ¸ */
    NPC_AI(Category.SUBSYSTEM, "NPC AI"),

    /** ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ */
    NETWORK(Category.SUBSYSTEM, "Network"),

    /** ì‚¬ìš´ë“œ ì²˜ë¦¬ */
    AUDIO(Category.SUBSYSTEM, "Audio"),

    /** ì²­í¬ ë¡œë”©/ì €ì¥ */
    CHUNK_IO(Category.SUBSYSTEM, "Chunk I/O"),

    // ============================================================
    // LUA - Lua ê´€ë ¨ (On-Demand)
    // ============================================================

    /** Lua ì´ë²¤íŠ¸ ë””ìŠ¤íŒ¨ì¹˜ */
    LUA_EVENT(Category.LUA, "Lua Event"),

    /** ê°œë³„ Lua í•¨ìˆ˜ í˜¸ì¶œ */
    LUA_FUNCTION(Category.LUA, "Lua Function"),

    /** Lua ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ */
    LUA_GC(Category.LUA, "Lua GC"),

    // ============================================================
    // CUSTOM - ì‚¬ìš©ì/ëª¨ë“œ ì •ì˜
    // ============================================================

    /** ëª¨ë“œ ì´ˆê¸°í™” */
    MOD_INIT(Category.CUSTOM, "Mod Initialization"),

    /** ëª¨ë“œ í‹± í•¸ë“¤ëŸ¬ */
    MOD_TICK(Category.CUSTOM, "Mod Tick Handler"),

    /** ì»¤ìŠ¤í…€ ì¸¡ì • 1-5 */
    CUSTOM_1(Category.CUSTOM, "Custom 1"),
    CUSTOM_2(Category.CUSTOM, "Custom 2"),
    CUSTOM_3(Category.CUSTOM, "Custom 3"),
    CUSTOM_4(Category.CUSTOM, "Custom 4"),
    CUSTOM_5(Category.CUSTOM, "Custom 5"),

    // ============================================================
    // INTERNAL - í”„ë¡œíŒŒì¼ëŸ¬ ë‚´ë¶€ ì§„ë‹¨ (Phase 4)
    // ============================================================

    /** Echo í”„ë¡œíŒŒì¼ëŸ¬ ìì²´ ì˜¤ë²„í—¤ë“œ (ë©”íƒ€ í”„ë¡œíŒŒì¼ë§) */
    ECHO_OVERHEAD(Category.INTERNAL, "Echo Overhead");

    // ============================================================
    // í•„ë“œ ë° ë©”ì„œë“œ
    // ============================================================

    private final Category category;
    private final String displayName;

    ProfilingPoint(Category category, String displayName) {
        this.category = category;
        this.displayName = displayName;
    }

    public Category getCategory() {
        return category;
    }

    public String getDisplayName() {
        return displayName;
    }

    /**
     * Lua ê´€ë ¨ í¬ì¸íŠ¸ ì—¬ë¶€ (On-Demand í† ê¸€ ëŒ€ìƒ)
     */
    public boolean isLuaRelated() {
        return category == Category.LUA;
    }

    /**
     * ì‚¬ìš©ì ì •ì˜ í¬ì¸íŠ¸ ì—¬ë¶€
     */
    public boolean isCustom() {
        return category == Category.CUSTOM;
    }

    /**
     * ë‚´ë¶€ ì§„ë‹¨ í¬ì¸íŠ¸ ì—¬ë¶€
     */
    public boolean isInternal() {
        return category == Category.INTERNAL;
    }

    // ============================================================
    // ì¹´í…Œê³ ë¦¬ ì—´ê±°í˜•
    // ============================================================

    public enum Category {
        CORE("Core", "#FF6B6B"),
        SUBSYSTEM("Subsystem", "#4ECDC4"),
        LUA("Lua", "#FFE66D"),
        CUSTOM("Custom", "#95E1D3"),
        INTERNAL("Internal", "#A9A9A9");

        private final String displayName;
        private final String color;

        Category(String displayName, String color) {
            this.displayName = displayName;
            this.color = color;
        }

        public String getDisplayName() {
            return displayName;
        }

        public String getColor() {
            return color;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\measure\ProfilingPoint.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\monitor\EchoMonitorServer.java =====

package com.echo.monitor;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.aggregate.TimingData;
import com.echo.aggregate.TickHistogram;
import com.echo.aggregate.SpikeLog;
import com.echo.measure.MemoryProfiler;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpExchange;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.nio.charset.StandardCharsets;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.Executors;

/**
 * Echo ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ HTTP ì„œë²„
 * 
 * ì™¸ë¶€ ë„êµ¬ì—ì„œ í”„ë¡œíŒŒì¼ë§ ë°ì´í„°ì— ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ê°„ë‹¨í•œ REST API ì œê³µ
 */
public class EchoMonitorServer {

    private static final int DEFAULT_PORT = 8765;
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static EchoMonitorServer instance;
    private HttpServer server;
    private boolean running = false;

    private EchoMonitorServer() {
    }

    public static EchoMonitorServer getInstance() {
        if (instance == null) {
            instance = new EchoMonitorServer();
        }
        return instance;
    }

    /**
     * ì„œë²„ ì‹œì‘
     */
    public void start() {
        start(DEFAULT_PORT);
    }

    public void start(int port) {
        if (running) {
            System.out.println("[Echo] Monitor server already running on port " + server.getAddress().getPort());
            return;
        }

        try {
            server = HttpServer.create(new InetSocketAddress(port), 0);
            server.setExecutor(Executors.newFixedThreadPool(2));

            // API ì—”ë“œí¬ì¸íŠ¸ ë“±ë¡
            server.createContext("/api/status", new StatusHandler());
            server.createContext("/api/summary", new SummaryHandler());
            server.createContext("/api/histogram", new HistogramHandler());
            server.createContext("/api/spikes", new SpikesHandler());
            server.createContext("/api/memory", new MemoryHandler());
            server.createContext("/", new RootHandler());

            server.start();
            running = true;
            System.out.println("[Echo] Monitor server started on http://localhost:" + port);
            System.out.println("[Echo] Endpoints: /api/status, /api/summary, /api/histogram, /api/spikes, /api/memory");
        } catch (IOException e) {
            System.err.println("[Echo] Failed to start monitor server: " + e.getMessage());
        }
    }

    /**
     * ì„œë²„ ì¤‘ì§€
     */
    public void stop() {
        if (!running || server == null) {
            System.out.println("[Echo] Monitor server not running");
            return;
        }

        server.stop(1);
        running = false;
        System.out.println("[Echo] Monitor server stopped");
    }

    public boolean isRunning() {
        return running;
    }

    // ============================================================
    // HTTP Handlers
    // ============================================================

    private static class RootHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            String response = "Echo Profiler Monitor API\n\n" +
                    "Endpoints:\n" +
                    "  GET /api/status    - Profiler status\n" +
                    "  GET /api/summary   - Tick summary\n" +
                    "  GET /api/histogram - Tick distribution\n" +
                    "  GET /api/spikes    - Recent spikes\n" +
                    "  GET /api/memory    - Memory stats\n";
            sendResponse(exchange, 200, response, "text/plain");
        }
    }

    private static class StatusHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            EchoProfiler profiler = EchoProfiler.getInstance();
            Map<String, Object> status = new LinkedHashMap<>();
            status.put("enabled", profiler.isEnabled());
            status.put("lua_profiling", profiler.isLuaProfilingEnabled());
            status.put("session_duration_seconds", profiler.getSessionDurationSeconds());
            status.put("current_stack_depth", profiler.getCurrentStackDepth());
            sendJsonResponse(exchange, status);
        }
    }

    private static class SummaryHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            EchoProfiler profiler = EchoProfiler.getInstance();
            TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);

            Map<String, Object> summary = new LinkedHashMap<>();
            if (tickData != null && tickData.getCallCount() > 0) {
                summary.put("total_ticks", tickData.getCallCount());
                summary.put("average_ms", round(tickData.getAverageMicros() / 1000.0));
                summary.put("max_ms", round(tickData.getMaxMicros() / 1000.0));
                summary.put("min_ms", round(tickData.getMinMicros() / 1000.0));

                TimingData.RollingStats stats5s = tickData.getStats5s();
                Map<String, Object> rolling = new LinkedHashMap<>();
                rolling.put("avg_ms", round(stats5s.getAverage() / 1000.0));
                rolling.put("max_ms", round(stats5s.getMax() / 1000.0));
                rolling.put("samples", stats5s.getSampleCount());
                summary.put("last_5s", rolling);
            }
            sendJsonResponse(exchange, summary);
        }
    }

    private static class HistogramHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            TickHistogram histogram = EchoProfiler.getInstance().getTickHistogram();
            sendJsonResponse(exchange, histogram.toMap());
        }
    }

    private static class SpikesHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            SpikeLog spikeLog = EchoProfiler.getInstance().getSpikeLog();
            sendJsonResponse(exchange, spikeLog.toMap());
        }
    }

    private static class MemoryHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            sendJsonResponse(exchange, MemoryProfiler.toMap());
        }
    }

    // ============================================================
    // Utility Methods
    // ============================================================

    private static void sendJsonResponse(HttpExchange exchange, Object data) throws IOException {
        String json = GSON.toJson(data);
        sendResponse(exchange, 200, json, "application/json");
    }

    private static void sendResponse(HttpExchange exchange, int status, String body, String contentType)
            throws IOException {
        exchange.getResponseHeaders().add("Content-Type", contentType + "; charset=UTF-8");
        exchange.getResponseHeaders().add("Access-Control-Allow-Origin", "*");
        byte[] bytes = body.getBytes(StandardCharsets.UTF_8);
        exchange.sendResponseHeaders(status, bytes.length);
        try (OutputStream os = exchange.getResponseBody()) {
            os.write(bytes);
        }
    }

    private static double round(double value) {
        return Math.round(value * 100.0) / 100.0;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\monitor\EchoMonitorServer.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\pulse\LuaProfiler.java =====

package com.echo.pulse;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;

/**
 * Lua í”„ë¡œíŒŒì¼ëŸ¬
 * 
 * Lua ì´ë²¤íŠ¸ ë° í•¨ìˆ˜ í˜¸ì¶œì„ ì¸¡ì •í•©ë‹ˆë‹¤.
 * On-Demand ë°©ì‹ìœ¼ë¡œ í•„ìš”í•  ë•Œë§Œ í™œì„±í™”í•©ë‹ˆë‹¤.
 * 
 * ì£¼ì˜: Lua í˜¸ì¶œì€ ë¹ˆë„ê°€ ë†’ìœ¼ë¯€ë¡œ ì„±ëŠ¥ ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 */
public class LuaProfiler {

    private static final EchoProfiler profiler = EchoProfiler.getInstance();

    /**
     * Lua ì´ë²¤íŠ¸ ë˜í¼
     */
    public static void profileEvent(String eventName, Runnable luaCallback) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            luaCallback.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_EVENT, eventName)) {
            luaCallback.run();
        }
    }

    /**
     * Lua í•¨ìˆ˜ í˜¸ì¶œ ë˜í¼
     */
    public static void profileFunction(String functionName, Runnable luaFunction) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            luaFunction.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_FUNCTION, functionName)) {
            luaFunction.run();
        }
    }

    /**
     * ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” Lua í•¨ìˆ˜ í˜¸ì¶œ ë˜í¼
     */
    public static <T> T profileFunctionWithResult(String functionName, java.util.function.Supplier<T> luaFunction) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            return luaFunction.get();
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_FUNCTION, functionName)) {
            return luaFunction.get();
        }
    }

    /**
     * Lua GC ì¸¡ì •
     */
    public static void profileGC(Runnable gcTask) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            gcTask.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_GC)) {
            gcTask.run();
        }
    }

    /**
     * Lua í”„ë¡œíŒŒì¼ë§ í™œì„±í™”
     */
    public static void enable() {
        profiler.enableLuaProfiling();
    }

    /**
     * Lua í”„ë¡œíŒŒì¼ë§ ë¹„í™œì„±í™”
     */
    public static void disable() {
        profiler.disableLuaProfiling();
    }

    /**
     * Lua í”„ë¡œíŒŒì¼ë§ ìƒíƒœ í™•ì¸
     */
    public static boolean isEnabled() {
        return profiler.isLuaProfilingEnabled();
    }

    /**
     * Lua í”„ë¡œíŒŒì¼ë§ í† ê¸€
     */
    public static boolean toggle() {
        if (profiler.isLuaProfilingEnabled()) {
            profiler.disableLuaProfiling();
            return false;
        } else {
            profiler.enableLuaProfiling();
            return true;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\pulse\LuaProfiler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\pulse\PulseEventAdapter.java =====

package com.echo.pulse;

/**
 * Pulse ì´ë²¤íŠ¸ ë²„ìŠ¤ ì–´ëŒ‘í„°
 * 
 * Pulse ëª¨ë“œ ë¡œë”ì˜ ì´ë²¤íŠ¸ë¥¼ Echo í”„ë¡œíŒŒì¼ëŸ¬ì™€ ì—°ê²°í•©ë‹ˆë‹¤.
 * ì´ˆê¸° ë²„ì „ì€ Mixin ì—†ì´ Callable wrapping ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤.
 */
public class PulseEventAdapter {

    private static boolean registered = false;
    private static TickProfiler tickProfiler;
    private static RenderProfiler renderProfiler;

    /**
     * Pulse ì´ë²¤íŠ¸ ë²„ìŠ¤ì— ë¦¬ìŠ¤ë„ˆ ë“±ë¡
     * EchoMod.init()ì—ì„œ í˜¸ì¶œë¨
     */
    public static void register() {
        if (registered) {
            System.out.println("[Echo] Pulse adapter already registered");
            return;
        }

        tickProfiler = new TickProfiler();
        renderProfiler = new RenderProfiler();

        // Pulse ì´ë²¤íŠ¸ ë²„ìŠ¤ ë“±ë¡ (ì‹¤ì œ êµ¬í˜„ì€ Pulse APIì— ë”°ë¼ ë‹¤ë¦„)
        // PulseEvents.TICK.register(tickProfiler::onTick);
        // PulseEvents.RENDER.register(renderProfiler::onRender);

        registered = true;
        System.out.println("[Echo] Pulse event adapter registered");
        System.out.println("[Echo]   - TickProfiler: OnTick.Pre / OnTick.Post");
        System.out.println("[Echo]   - RenderProfiler: OnRender.Pre / OnRender.Post");
    }

    /**
     * ì´ë²¤íŠ¸ ë²„ìŠ¤ì—ì„œ ë¦¬ìŠ¤ë„ˆ í•´ì œ
     */
    public static void unregister() {
        if (!registered)
            return;

        // ì´ë²¤íŠ¸ í•´ì œ
        registered = false;
        System.out.println("[Echo] Pulse event adapter unregistered");
    }

    /**
     * ë“±ë¡ ìƒíƒœ í™•ì¸
     */
    public static boolean isRegistered() {
        return registered;
    }

    /**
     * TickProfiler ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜
     */
    public static TickProfiler getTickProfiler() {
        return tickProfiler;
    }

    /**
     * RenderProfiler ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜
     */
    public static RenderProfiler getRenderProfiler() {
        return renderProfiler;
    }

    // ============================================================
    // ìˆ˜ë™ í˜¸ì¶œìš© API (Mixin ì—†ì´ ì‚¬ìš©í•  ë•Œ)
    // ============================================================

    /**
     * í‹± ì‹œì‘ ì‹œ í˜¸ì¶œ (ìˆ˜ë™)
     */
    public static void onTickStart() {
        if (tickProfiler != null) {
            tickProfiler.onTickPre();
        }
    }

    /**
     * í‹± ì¢…ë£Œ ì‹œ í˜¸ì¶œ (ìˆ˜ë™)
     */
    public static void onTickEnd() {
        if (tickProfiler != null) {
            tickProfiler.onTickPost();
        }
    }

    /**
     * ë Œë” ì‹œì‘ ì‹œ í˜¸ì¶œ (ìˆ˜ë™)
     */
    public static void onRenderStart() {
        if (renderProfiler != null) {
            renderProfiler.onRenderPre();
        }
    }

    /**
     * ë Œë” ì¢…ë£Œ ì‹œ í˜¸ì¶œ (ìˆ˜ë™)
     */
    public static void onRenderEnd() {
        if (renderProfiler != null) {
            renderProfiler.onRenderPost();
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\pulse\PulseEventAdapter.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\pulse\RenderProfiler.java =====

package com.echo.pulse;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;

/**
 * ë Œë” í”„ë¡œíŒŒì¼ëŸ¬
 * 
 * ë Œë”ë§ í”„ë ˆì„ ì‹œê°„ì„ ì¸¡ì •í•©ë‹ˆë‹¤.
 * Pulse OnRender ì´ë²¤íŠ¸ì™€ ì—°ë™ë©ë‹ˆë‹¤.
 */
public class RenderProfiler {

    private final EchoProfiler profiler = EchoProfiler.getInstance();

    // í˜„ì¬ í™œì„± ìŠ¤ì½”í”„
    private EchoProfiler.ProfilingScope currentScope = null;

    // í”„ë ˆì„ ì¹´ìš´í„°
    private long frameCount = 0;

    // FPS ê³„ì‚°ìš©
    private long fpsStartTime = 0;
    private int fpsFrameCount = 0;
    private double currentFps = 0;

    // ë§ˆì§€ë§‰ í”„ë ˆì„ ì‹œê°„
    private long lastFrameStartTime = 0;
    private long lastFrameDuration = 0;

    /**
     * ë Œë” ì‹œì‘ ì‹œ í˜¸ì¶œ
     */
    public void onRenderPre() {
        if (!profiler.isEnabled())
            return;

        lastFrameStartTime = System.nanoTime();
        currentScope = profiler.scope(ProfilingPoint.FRAME);
        frameCount++;
        fpsFrameCount++;

        // 1ì´ˆë§ˆë‹¤ FPS ê³„ì‚°
        long now = System.currentTimeMillis();
        if (fpsStartTime == 0) {
            fpsStartTime = now;
        } else if (now - fpsStartTime >= 1000) {
            currentFps = fpsFrameCount * 1000.0 / (now - fpsStartTime);
            fpsFrameCount = 0;
            fpsStartTime = now;
        }
    }

    /**
     * ë Œë” ì¢…ë£Œ ì‹œ í˜¸ì¶œ
     */
    public void onRenderPost() {
        if (currentScope == null)
            return;

        currentScope.close();
        currentScope = null;

        // í”„ë ˆì„ ì‹œê°„ ê³„ì‚°
        long elapsed = System.nanoTime() - lastFrameStartTime;
        lastFrameDuration = elapsed / 1000; // ë§ˆì´í¬ë¡œì´ˆ
    }

    /**
     * ì›”ë“œ ë Œë”ë§ ë˜í¼
     */
    public void profileWorldRender(Runnable worldRender) {
        if (!profiler.isEnabled()) {
            worldRender.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.RENDER_WORLD)) {
            worldRender.run();
        }
    }

    /**
     * UI ë Œë”ë§ ë˜í¼
     */
    public void profileUIRender(Runnable uiRender) {
        if (!profiler.isEnabled()) {
            uiRender.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.RENDER_UI)) {
            uiRender.run();
        }
    }

    // ============================================================
    // ì¡°íšŒ
    // ============================================================

    /**
     * ì´ í”„ë ˆì„ ì¹´ìš´íŠ¸
     */
    public long getFrameCount() {
        return frameCount;
    }

    /**
     * í˜„ì¬ FPS
     */
    public double getCurrentFps() {
        return currentFps;
    }

    /**
     * ë§ˆì§€ë§‰ í”„ë ˆì„ ì‹œê°„ (ë§ˆì´í¬ë¡œì´ˆ)
     */
    public long getLastFrameDurationMicros() {
        return lastFrameDuration;
    }

    /**
     * ë§ˆì§€ë§‰ í”„ë ˆì„ ì‹œê°„ (ë°€ë¦¬ì´ˆ)
     */
    public double getLastFrameDurationMs() {
        return lastFrameDuration / 1000.0;
    }

    /**
     * ì¹´ìš´í„° ì´ˆê¸°í™”
     */
    public void reset() {
        frameCount = 0;
        lastFrameDuration = 0;
        fpsStartTime = 0;
        fpsFrameCount = 0;
        currentFps = 0;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\pulse\RenderProfiler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\pulse\SubsystemProfiler.java =====

package com.echo.pulse;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;

/**
 * ì„œë¸Œì‹œìŠ¤í…œ í”„ë¡œíŒŒì¼ëŸ¬
 * 
 * ê°œë³„ ê²Œì„ ì„œë¸Œì‹œìŠ¤í…œ(Zombie AI, Physics, Network ë“±)ì„ ì¸¡ì •í•©ë‹ˆë‹¤.
 * Callable wrapping ë°©ì‹ìœ¼ë¡œ ê¸°ì¡´ ë¡œì§ì„ ê°ì‹¸ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */
public class SubsystemProfiler {

    private static final EchoProfiler profiler = EchoProfiler.getInstance();

    // ============================================================
    // AI ì„œë¸Œì‹œìŠ¤í…œ
    // ============================================================

    /**
     * ì¢€ë¹„ AI ì—…ë°ì´íŠ¸ ë˜í¼
     */
    public static void profileZombieAI(Runnable zombieUpdate) {
        profile(ProfilingPoint.ZOMBIE_AI, zombieUpdate);
    }

    /**
     * ì¢€ë¹„ AI ì—…ë°ì´íŠ¸ ë˜í¼ (ë¼ë²¨ í¬í•¨)
     */
    public static void profileZombieAI(String label, Runnable zombieUpdate) {
        profile(ProfilingPoint.ZOMBIE_AI, label, zombieUpdate);
    }

    /**
     * NPC AI ì—…ë°ì´íŠ¸ ë˜í¼
     */
    public static void profileNpcAI(Runnable npcUpdate) {
        profile(ProfilingPoint.NPC_AI, npcUpdate);
    }

    /**
     * NPC AI ì—…ë°ì´íŠ¸ ë˜í¼ (ë¼ë²¨ í¬í•¨)
     */
    public static void profileNpcAI(String label, Runnable npcUpdate) {
        profile(ProfilingPoint.NPC_AI, label, npcUpdate);
    }

    // ============================================================
    // ë¬¼ë¦¬/ì‹œë®¬ë ˆì´ì…˜
    // ============================================================

    /**
     * ë¬¼ë¦¬ ì—”ì§„ ì—…ë°ì´íŠ¸ ë˜í¼
     */
    public static void profilePhysics(Runnable physicsUpdate) {
        profile(ProfilingPoint.PHYSICS, physicsUpdate);
    }

    /**
     * ì‹œë®¬ë ˆì´ì…˜ ì—…ë°ì´íŠ¸ ë˜í¼
     */
    public static void profileSimulation(Runnable simulation) {
        profile(ProfilingPoint.SIMULATION, simulation);
    }

    // ============================================================
    // I/O & ë„¤íŠ¸ì›Œí¬
    // ============================================================

    /**
     * ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ ë˜í¼
     */
    public static void profileNetwork(Runnable networkUpdate) {
        profile(ProfilingPoint.NETWORK, networkUpdate);
    }

    /**
     * ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ ë˜í¼ (ë¼ë²¨ í¬í•¨)
     */
    public static void profileNetwork(String label, Runnable networkUpdate) {
        profile(ProfilingPoint.NETWORK, label, networkUpdate);
    }

    /**
     * ì²­í¬ I/O ë˜í¼
     */
    public static void profileChunkIO(Runnable chunkIO) {
        profile(ProfilingPoint.CHUNK_IO, chunkIO);
    }

    /**
     * ì²­í¬ I/O ë˜í¼ (ë¼ë²¨ í¬í•¨)
     */
    public static void profileChunkIO(String label, Runnable chunkIO) {
        profile(ProfilingPoint.CHUNK_IO, label, chunkIO);
    }

    // ============================================================
    // ì˜¤ë””ì˜¤
    // ============================================================

    /**
     * ì˜¤ë””ì˜¤ ì²˜ë¦¬ ë˜í¼
     */
    public static void profileAudio(Runnable audioUpdate) {
        profile(ProfilingPoint.AUDIO, audioUpdate);
    }

    // ============================================================
    // ë Œë”ë§
    // ============================================================

    /**
     * ë Œë”ë§ ë˜í¼
     */
    public static void profileRender(Runnable render) {
        profile(ProfilingPoint.RENDER, render);
    }

    /**
     * ì›”ë“œ ë Œë”ë§ ë˜í¼
     */
    public static void profileWorldRender(Runnable worldRender) {
        profile(ProfilingPoint.RENDER_WORLD, worldRender);
    }

    /**
     * UI ë Œë”ë§ ë˜í¼
     */
    public static void profileUIRender(Runnable uiRender) {
        profile(ProfilingPoint.RENDER_UI, uiRender);
    }

    // ============================================================
    // ëª¨ë“œ ê´€ë ¨
    // ============================================================

    /**
     * ëª¨ë“œ ì´ˆê¸°í™” ë˜í¼
     */
    public static void profileModInit(String modId, Runnable modInit) {
        profile(ProfilingPoint.MOD_INIT, modId, modInit);
    }

    /**
     * ëª¨ë“œ í‹± ë˜í¼
     */
    public static void profileModTick(String modId, Runnable modTick) {
        profile(ProfilingPoint.MOD_TICK, modId, modTick);
    }

    // ============================================================
    // ì»¤ìŠ¤í…€ ì¸¡ì •
    // ============================================================

    /**
     * ì»¤ìŠ¤í…€ ì¸¡ì • 1
     */
    public static void profileCustom1(String label, Runnable task) {
        profile(ProfilingPoint.CUSTOM_1, label, task);
    }

    /**
     * ì»¤ìŠ¤í…€ ì¸¡ì • 2
     */
    public static void profileCustom2(String label, Runnable task) {
        profile(ProfilingPoint.CUSTOM_2, label, task);
    }

    /**
     * ì»¤ìŠ¤í…€ ì¸¡ì • 3
     */
    public static void profileCustom3(String label, Runnable task) {
        profile(ProfilingPoint.CUSTOM_3, label, task);
    }

    // ============================================================
    // ë²”ìš© ë©”ì„œë“œ
    // ============================================================

    /**
     * ë²”ìš© í”„ë¡œíŒŒì¼ë§ ë˜í¼
     */
    public static void profile(ProfilingPoint point, Runnable task) {
        if (!profiler.isEnabled()) {
            task.run();
            return;
        }

        try (var scope = profiler.scope(point)) {
            task.run();
        }
    }

    /**
     * ë²”ìš© í”„ë¡œíŒŒì¼ë§ ë˜í¼ (ë¼ë²¨ í¬í•¨)
     */
    public static void profile(ProfilingPoint point, String label, Runnable task) {
        if (!profiler.isEnabled()) {
            task.run();
            return;
        }

        try (var scope = profiler.scope(point, label)) {
            task.run();
        }
    }

    /**
     * ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” í”„ë¡œíŒŒì¼ë§ ë˜í¼
     */
    public static <T> T profileWithResult(ProfilingPoint point, java.util.function.Supplier<T> task) {
        if (!profiler.isEnabled()) {
            return task.get();
        }

        try (var scope = profiler.scope(point)) {
            return task.get();
        }
    }

    /**
     * ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” í”„ë¡œíŒŒì¼ë§ ë˜í¼ (ë¼ë²¨ í¬í•¨)
     */
    public static <T> T profileWithResult(ProfilingPoint point, String label, java.util.function.Supplier<T> task) {
        if (!profiler.isEnabled()) {
            return task.get();
        }

        try (var scope = profiler.scope(point, label)) {
            return task.get();
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\pulse\SubsystemProfiler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\pulse\TickProfiler.java =====

package com.echo.pulse;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;

/**
 * í‹± í”„ë¡œíŒŒì¼ëŸ¬
 * 
 * ê²Œì„ í‹± ì‹œì‘/ì¢…ë£Œ ì‹œì ì„ ì¸¡ì •í•©ë‹ˆë‹¤.
 * Pulse OnTick ì´ë²¤íŠ¸ì™€ ì—°ë™ë©ë‹ˆë‹¤.
 */
public class TickProfiler {

    private final EchoProfiler profiler = EchoProfiler.getInstance();

    // í˜„ì¬ í™œì„± ìŠ¤ì½”í”„
    private EchoProfiler.ProfilingScope currentScope = null;

    // í‹± ì¹´ìš´í„°
    private long tickCount = 0;

    // ìŠ¤íŒŒì´í¬ ê°ì§€ ì„ê³„ê°’ (ë§ˆì´í¬ë¡œì´ˆ)
    private long spikeThresholdMicros = 33_000; // 33ms (2 í”„ë ˆì„)

    // ë§ˆì§€ë§‰ í‹± ì‹œê°„
    private long lastTickStartTime = 0;
    private long lastTickDuration = 0;

    /**
     * í‹± ì‹œì‘ ì‹œ í˜¸ì¶œ
     */
    public void onTickPre() {
        if (!profiler.isEnabled())
            return;

        lastTickStartTime = System.nanoTime();
        currentScope = profiler.scope(ProfilingPoint.TICK);
        tickCount++;
    }

    /**
     * í‹± ì¢…ë£Œ ì‹œ í˜¸ì¶œ
     */
    public void onTickPost() {
        if (currentScope == null)
            return;

        currentScope.close();
        currentScope = null;

        // í‹± ì‹œê°„ ê³„ì‚°
        long elapsed = System.nanoTime() - lastTickStartTime;
        lastTickDuration = elapsed / 1000; // ë§ˆì´í¬ë¡œì´ˆ

        // ìŠ¤íŒŒì´í¬ ê°ì§€
        if (lastTickDuration > spikeThresholdMicros) {
            onSpikeDetected(lastTickDuration);
        }
    }

    /**
     * ìŠ¤íŒŒì´í¬ ê°ì§€ ì‹œ í˜¸ì¶œ
     */
    private void onSpikeDetected(long durationMicros) {
        double durationMs = durationMicros / 1000.0;
        System.out.printf("[Echo] âš  SPIKE DETECTED: Tick #%d took %.2f ms (threshold: %.2f ms)%n",
                tickCount, durationMs, spikeThresholdMicros / 1000.0);
    }

    // ============================================================
    // ì„¤ì • ë° ì¡°íšŒ
    // ============================================================

    /**
     * ìŠ¤íŒŒì´í¬ ì„ê³„ê°’ ì„¤ì • (ë°€ë¦¬ì´ˆ)
     */
    public void setSpikeThresholdMs(double thresholdMs) {
        this.spikeThresholdMicros = (long) (thresholdMs * 1000);
        System.out.printf("[Echo] Spike threshold set to %.2f ms%n", thresholdMs);
    }

    /**
     * í˜„ì¬ ìŠ¤íŒŒì´í¬ ì„ê³„ê°’ (ë°€ë¦¬ì´ˆ)
     */
    public double getSpikeThresholdMs() {
        return spikeThresholdMicros / 1000.0;
    }

    /**
     * ì´ í‹± ì¹´ìš´íŠ¸
     */
    public long getTickCount() {
        return tickCount;
    }

    /**
     * ë§ˆì§€ë§‰ í‹± ì‹œê°„ (ë§ˆì´í¬ë¡œì´ˆ)
     */
    public long getLastTickDurationMicros() {
        return lastTickDuration;
    }

    /**
     * ë§ˆì§€ë§‰ í‹± ì‹œê°„ (ë°€ë¦¬ì´ˆ)
     */
    public double getLastTickDurationMs() {
        return lastTickDuration / 1000.0;
    }

    /**
     * ì¹´ìš´í„° ì´ˆê¸°í™”
     */
    public void reset() {
        tickCount = 0;
        lastTickDuration = 0;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\pulse\TickProfiler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\report\EchoReport.java =====

package com.echo.report;

import com.echo.aggregate.TimingData;
import com.echo.aggregate.TickHistogram;
import com.echo.aggregate.SpikeLog;
import com.echo.lua.LuaCallTracker;
import com.echo.measure.EchoProfiler;
import com.echo.measure.MemoryProfiler;
import com.echo.measure.ProfilingPoint;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.*;
import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.*;

import com.echo.util.StringUtils;

/**
 * Echo Report ìƒì„±ê¸°
 * 
 * JSON ë° í…ìŠ¤íŠ¸ í˜•ì‹ì˜ í”„ë¡œíŒŒì¼ë§ ë¦¬í¬íŠ¸ ìƒì„±
 */
public class EchoReport {

    // Use ISO_INSTANT format consistently for all dates
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    private static final String VERSION = "0.2.0";

    private final EchoProfiler profiler;
    private final int topN;

    public EchoReport(EchoProfiler profiler) {
        this(profiler, 10);
    }

    public EchoReport(EchoProfiler profiler, int topN) {
        this.profiler = profiler;
        this.topN = topN;
    }

    /**
     * JSON ë¦¬í¬íŠ¸ ìƒì„±
     */
    public String generateJson() {
        Map<String, Object> report = new LinkedHashMap<>();
        Map<String, Object> echoReport = new LinkedHashMap<>();

        echoReport.put("version", VERSION);
        echoReport.put("generated_at", formatInstant(Instant.now()));
        echoReport.put("session_duration_seconds", profiler.getSessionDurationSeconds());

        echoReport.put("summary", generateSummary());
        echoReport.put("subsystems", generateSubsystems());
        echoReport.put("heavy_functions", generateHeavyFunctions());
        echoReport.put("tick_histogram", generateHistogram());
        echoReport.put("spikes", generateSpikes());
        echoReport.put("memory", generateMemoryStats());
        echoReport.put("lua_profiling", generateLuaProfiling());
        echoReport.put("recommendations", generateRecommendations());
        echoReport.put("metadata", generateMetadata());

        report.put("echo_report", echoReport);
        return GSON.toJson(report);
    }

    /**
     * ì½˜ì†” ì¶œë ¥ìš© í…ìŠ¤íŠ¸ ë¦¬í¬íŠ¸
     */
    public String generateText() {
        StringBuilder sb = new StringBuilder();
        sb.append("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        sb.append("               ECHO PROFILER REPORT\n");
        sb.append("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

        // Summary
        TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);
        if (tickData != null && tickData.getCallCount() > 0) {
            sb.append("ğŸ“Š TICK SUMMARY\n");
            sb.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            sb.append(String.format("  Total Ticks:    %,d\n", tickData.getCallCount()));
            sb.append(String.format("  Average:        %.2f ms\n", tickData.getAverageMicros() / 1000.0));
            sb.append(String.format("  Max Spike:      %.2f ms\n", tickData.getMaxMicros() / 1000.0));
            sb.append(String.format("  Min:            %.2f ms\n", tickData.getMinMicros() / 1000.0));
            sb.append(String.format("  Session:        %d seconds\n", profiler.getSessionDurationSeconds()));
            sb.append("\n");
        }

        // Subsystems
        sb.append("ğŸ“ˆ SUBSYSTEM BREAKDOWN\n");
        sb.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");

        List<Map.Entry<ProfilingPoint, TimingData>> sorted = profiler.getTimingData().entrySet().stream()
                .filter(e -> e.getValue().getCallCount() > 0)
                .filter(e -> e.getKey().getCategory() == ProfilingPoint.Category.SUBSYSTEM)
                .sorted((a, b) -> Long.compare(b.getValue().getTotalMicros(), a.getValue().getTotalMicros()))
                .toList();

        for (Map.Entry<ProfilingPoint, TimingData> entry : sorted) {
            ProfilingPoint point = entry.getKey();
            TimingData data = entry.getValue();
            sb.append(String.format("  %-15s â”‚ avg: %6.2f ms â”‚ max: %6.2f ms â”‚ calls: %,d\n",
                    point.getDisplayName(),
                    data.getAverageMicros() / 1000.0,
                    data.getMaxMicros() / 1000.0,
                    data.getCallCount()));
        }

        // Rolling Stats (last 5s)
        sb.append("\nğŸ“‰ ROLLING STATS (Last 5s)\n");
        sb.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");

        if (tickData != null) {
            TimingData.RollingStats stats5s = tickData.getStats5s();
            sb.append(String.format("  Tick Avg (5s):  %.2f ms\n", stats5s.getAverage() / 1000.0));
            sb.append(String.format("  Tick Max (5s):  %.2f ms\n", stats5s.getMax() / 1000.0));
            sb.append(String.format("  Samples:        %d\n", stats5s.getSampleCount()));
        }

        // Heavy Functions
        sb.append("\nğŸ”¥ HEAVY FUNCTIONS (Top " + topN + ")\n");
        sb.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");

        List<RankedFunction> heavyFunctions = collectHeavyFunctions();
        if (heavyFunctions.isEmpty()) {
            sb.append("  (No labeled function data collected)\n");
        } else {
            int rank = 1;
            for (RankedFunction func : heavyFunctions) {
                if (rank > topN)
                    break;
                sb.append(String.format("  #%d %-30s â”‚ total: %6.2f ms â”‚ max: %6.2f ms â”‚ calls: %,d\n",
                        rank++,
                        StringUtils.truncate(func.label, 30),
                        func.totalMicros / 1000.0,
                        func.maxMicros / 1000.0,
                        func.callCount));
            }
        }

        sb.append("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        return sb.toString();
    }

    /**
     * ì½˜ì†”ì— ë¦¬í¬íŠ¸ ì¶œë ¥
     */
    public void printToConsole() {
        System.out.println(generateText());
    }

    /**
     * JSON íŒŒì¼ë¡œ ì €ì¥
     */
    public void saveToFile(String path) throws IOException {
        try (Writer writer = new FileWriter(path)) {
            writer.write(generateJson());
        }
        System.out.println("[Echo] Report saved to: " + path);
    }

    /**
     * íƒ€ì„ìŠ¤íƒ¬í”„ íŒŒì¼ëª…ìœ¼ë¡œ ìë™ ì €ì¥
     */
    public String saveWithTimestamp(String directory) throws IOException {
        String timestamp = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
                .format(java.time.LocalDateTime.now());
        String filename = "echo_report_" + timestamp + ".json";
        String fullPath = directory + File.separator + filename;

        File dir = new File(directory);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        saveToFile(fullPath);
        return fullPath;
    }

    /**
     * CSV ë¦¬í¬íŠ¸ ìƒì„±
     */
    public String generateCsv() {
        StringBuilder sb = new StringBuilder();

        // Header
        sb.append("Point,Category,CallCount,TotalMs,AvgMs,MaxMs,MinMs\n");

        // Data rows
        for (ProfilingPoint point : ProfilingPoint.values()) {
            TimingData data = profiler.getTimingData(point);
            if (data != null && data.getCallCount() > 0) {
                sb.append(String.format("%s,%s,%d,%.2f,%.2f,%.2f,%.2f\n",
                        point.name(),
                        point.getCategory().name(),
                        data.getCallCount(),
                        data.getTotalMicros() / 1000.0,
                        data.getAverageMicros() / 1000.0,
                        data.getMaxMicros() / 1000.0,
                        data.getMinMicros() / 1000.0));
            }
        }

        return sb.toString();
    }

    /**
     * CSV íŒŒì¼ë¡œ ì €ì¥
     */
    public String saveCsv(String directory) throws IOException {
        String timestamp = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
                .format(java.time.LocalDateTime.now());
        String filename = "echo_report_" + timestamp + ".csv";
        String fullPath = directory + File.separator + filename;

        File dir = new File(directory);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        try (Writer writer = new FileWriter(fullPath)) {
            writer.write(generateCsv());
        }
        System.out.println("[Echo] CSV report saved to: " + fullPath);
        return fullPath;
    }

    /**
     * HTML ë¦¬í¬íŠ¸ ìƒì„±
     */
    public String generateHtml() {
        TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);
        TickHistogram histogram = profiler.getTickHistogram();

        StringBuilder sb = new StringBuilder();
        sb.append("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n");
        sb.append("  <meta charset=\"UTF-8\">\n");
        sb.append("  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
        sb.append("  <title>Echo Profiler Report</title>\n");
        sb.append("  <style>\n");
        sb.append("    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; ");
        sb.append("           background: #1a1a2e; color: #eee; padding: 20px; }\n");
        sb.append("    .container { max-width: 1200px; margin: 0 auto; }\n");
        sb.append("    h1 { color: #4ecdc4; border-bottom: 2px solid #4ecdc4; padding-bottom: 10px; }\n");
        sb.append("    h2 { color: #ff6b6b; margin-top: 30px; }\n");
        sb.append("    .card { background: #16213e; border-radius: 8px; padding: 20px; margin: 15px 0; }\n");
        sb.append("    table { width: 100%; border-collapse: collapse; margin-top: 10px; }\n");
        sb.append("    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #333; }\n");
        sb.append("    th { background: #0f3460; color: #4ecdc4; }\n");
        sb.append("    tr:hover { background: #1a1a40; }\n");
        sb.append("    .metric { font-size: 2em; color: #4ecdc4; font-weight: bold; }\n");
        sb.append("    .label { color: #888; font-size: 0.9em; }\n");
        sb.append(
                "    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }\n");
        sb.append(
                "    .bar { height: 20px; background: linear-gradient(90deg, #4ecdc4, #44a08d); border-radius: 4px; }\n");
        sb.append("  </style>\n</head>\n<body>\n<div class=\"container\">\n");

        // Header
        sb.append("  <h1>ğŸ”Š Echo Profiler Report</h1>\n");
        sb.append("  <p>Generated: ").append(java.time.LocalDateTime.now()).append("</p>\n");

        // Summary Cards
        sb.append("  <h2>ğŸ“Š Summary</h2>\n");
        sb.append("  <div class=\"grid\">\n");

        if (tickData != null && tickData.getCallCount() > 0) {
            sb.append("    <div class=\"card\"><div class=\"metric\">")
                    .append(String.format("%,d", tickData.getCallCount()))
                    .append("</div><div class=\"label\">Total Ticks</div></div>\n");
            sb.append("    <div class=\"card\"><div class=\"metric\">")
                    .append(String.format("%.2f ms", tickData.getAverageMicros() / 1000.0))
                    .append("</div><div class=\"label\">Avg Tick Time</div></div>\n");
            sb.append("    <div class=\"card\"><div class=\"metric\">")
                    .append(String.format("%.2f ms", tickData.getMaxMicros() / 1000.0))
                    .append("</div><div class=\"label\">Max Spike</div></div>\n");
            sb.append("    <div class=\"card\"><div class=\"metric\">")
                    .append(String.format("%.1f ms", histogram.getP95()))
                    .append("</div><div class=\"label\">P95</div></div>\n");
        }
        sb.append("  </div>\n");

        // Subsystems Table
        sb.append("  <h2>ğŸ“ˆ Subsystems</h2>\n");
        sb.append("  <div class=\"card\">\n");
        sb.append("    <table>\n");
        sb.append("      <tr><th>Subsystem</th><th>Calls</th><th>Total</th><th>Avg</th><th>Max</th></tr>\n");

        for (ProfilingPoint point : ProfilingPoint.values()) {
            TimingData data = profiler.getTimingData(point);
            if (data != null && data.getCallCount() > 0 && point.getCategory() == ProfilingPoint.Category.SUBSYSTEM) {
                sb.append("      <tr>");
                sb.append("<td>").append(point.getDisplayName()).append("</td>");
                sb.append("<td>").append(String.format("%,d", data.getCallCount())).append("</td>");
                sb.append("<td>").append(String.format("%.2f ms", data.getTotalMicros() / 1000.0)).append("</td>");
                sb.append("<td>").append(String.format("%.2f ms", data.getAverageMicros() / 1000.0)).append("</td>");
                sb.append("<td>").append(String.format("%.2f ms", data.getMaxMicros() / 1000.0)).append("</td>");
                sb.append("</tr>\n");
            }
        }
        sb.append("    </table>\n  </div>\n");

        // Histogram
        sb.append("  <h2>ğŸ“‰ Tick Distribution</h2>\n");
        sb.append("  <div class=\"card\">\n");
        long[] counts = histogram.getCounts();
        double[] buckets = histogram.getBuckets();
        long maxCount = java.util.Arrays.stream(counts).max().orElse(1);

        for (int i = 0; i < buckets.length; i++) {
            String label = i == buckets.length - 1
                    ? String.format("â‰¥%.1fms", buckets[i])
                    : String.format("%.1f-%.1fms", buckets[i], buckets[i + 1]);
            int barWidth = (int) ((counts[i] * 100) / Math.max(maxCount, 1));

            sb.append("    <div style=\"margin: 8px 0;\">");
            sb.append("<span style=\"display:inline-block;width:100px;\">").append(label).append("</span>");
            sb.append("<div class=\"bar\" style=\"width:").append(barWidth).append("%;display:inline-block;\"></div>");
            sb.append(" <span>").append(counts[i]).append("</span>");
            sb.append("</div>\n");
        }
        sb.append("  </div>\n");

        sb.append("</div>\n</body>\n</html>");
        return sb.toString();
    }

    /**
     * HTML íŒŒì¼ë¡œ ì €ì¥
     */
    public String saveHtml(String directory) throws IOException {
        String timestamp = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
                .format(java.time.LocalDateTime.now());
        String filename = "echo_report_" + timestamp + ".html";
        String fullPath = directory + File.separator + filename;

        File dir = new File(directory);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        try (Writer writer = new FileWriter(fullPath)) {
            writer.write(generateHtml());
        }
        System.out.println("[Echo] HTML report saved to: " + fullPath);
        return fullPath;
    }

    // ============================================================
    // Private Methods
    // ============================================================

    private Map<String, Object> generateSummary() {
        Map<String, Object> summary = new LinkedHashMap<>();
        TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);

        if (tickData != null) {
            summary.put("total_ticks", tickData.getCallCount());
            summary.put("average_tick_ms", round(tickData.getAverageMicros() / 1000.0));
            summary.put("max_tick_spike_ms", round(tickData.getMaxMicros() / 1000.0));
            summary.put("min_tick_ms", round(tickData.getMinMicros() / 1000.0));
            summary.put("target_tick_ms", 16.67);

            // Performance score: 100 if avg <= 16.67ms, decreases by 5 per extra ms
            double avgMs = tickData.getAverageMicros() / 1000.0;
            double score = Math.max(0, 100 - Math.max(0, avgMs - 16.67) * 5);
            summary.put("performance_score", round(Math.min(100, score)));
        }

        return summary;
    }

    private List<Map<String, Object>> generateSubsystems() {
        List<Map<String, Object>> list = new ArrayList<>();

        for (ProfilingPoint point : ProfilingPoint.values()) {
            TimingData data = profiler.getTimingData(point);
            if (data != null && data.getCallCount() > 0) {
                Map<String, Object> item = new LinkedHashMap<>();
                item.put("name", point.name());
                item.put("display_name", point.getDisplayName());
                item.put("category", point.getCategory().name());

                Map<String, Object> stats = new LinkedHashMap<>();
                stats.put("call_count", data.getCallCount());
                stats.put("total_time_ms", round(data.getTotalMicros() / 1000.0));
                stats.put("average_time_ms", round(data.getAverageMicros() / 1000.0));
                stats.put("max_time_ms", round(data.getMaxMicros() / 1000.0));
                stats.put("min_time_ms", round(data.getMinMicros() / 1000.0));
                item.put("stats", stats);

                Map<String, Object> rolling = new LinkedHashMap<>();
                rolling.put("last_1s", createRollingStats(data.getStats1s()));
                rolling.put("last_5s", createRollingStats(data.getStats5s()));
                rolling.put("last_60s", createRollingStats(data.getStats60s()));
                item.put("rolling_stats", rolling);

                list.add(item);
            }
        }

        return list;
    }

    private Map<String, Object> createRollingStats(TimingData.RollingStats stats) {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("avg_ms", round(stats.getAverage() / 1000.0));
        map.put("max_ms", round(stats.getMax() / 1000.0));
        map.put("samples", stats.getSampleCount());
        return map;
    }

    private Map<String, Object> generateHeavyFunctions() {
        Map<String, Object> heavy = new LinkedHashMap<>();

        List<RankedFunction> byTotal = collectHeavyFunctions();

        List<Map<String, Object>> byTotalList = new ArrayList<>();
        int rank = 1;
        for (RankedFunction func : byTotal) {
            if (rank > topN)
                break;
            byTotalList.add(func.toMap(rank++));
        }
        heavy.put("by_total_time", byTotalList);

        // Sort by max spike
        List<RankedFunction> byMax = new ArrayList<>(byTotal);
        byMax.sort((a, b) -> Long.compare(b.maxMicros, a.maxMicros));

        List<Map<String, Object>> byMaxList = new ArrayList<>();
        rank = 1;
        for (RankedFunction func : byMax) {
            if (rank > topN)
                break;
            byMaxList.add(func.toMap(rank++));
        }
        heavy.put("by_max_spike", byMaxList);

        // Sort by call count
        List<RankedFunction> byCount = new ArrayList<>(byTotal);
        byCount.sort((a, b) -> Long.compare(b.callCount, a.callCount));

        List<Map<String, Object>> byCountList = new ArrayList<>();
        rank = 1;
        for (RankedFunction func : byCount) {
            if (rank > topN)
                break;
            byCountList.add(func.toMap(rank++));
        }
        heavy.put("by_call_frequency", byCountList);

        return heavy;
    }

    private List<RankedFunction> collectHeavyFunctions() {
        List<RankedFunction> functions = new ArrayList<>();

        for (Map.Entry<ProfilingPoint, TimingData> entry : profiler.getTimingData().entrySet()) {
            ProfilingPoint point = entry.getKey();
            TimingData data = entry.getValue();

            for (TimingData.SubTimingData sub : data.getLabelStats().values()) {
                functions.add(new RankedFunction(
                        sub.getLabel(),
                        point.name(),
                        sub.getCallCount(),
                        sub.getTotalMicros(),
                        sub.getMaxMicros()));
            }
        }

        // Sort by total time
        functions.sort((a, b) -> Long.compare(b.totalMicros, a.totalMicros));
        return functions;
    }

    private Map<String, Object> generateHistogram() {
        TickHistogram histogram = profiler.getTickHistogram();
        return histogram.toMap();
    }

    private Map<String, Object> generateSpikes() {
        SpikeLog spikeLog = profiler.getSpikeLog();
        return spikeLog.toMap();
    }

    private List<String> generateRecommendations() {
        List<String> recommendations = new ArrayList<>();

        TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);
        TickHistogram histogram = profiler.getTickHistogram();
        SpikeLog spikeLog = profiler.getSpikeLog();

        if (tickData != null && tickData.getCallCount() > 0) {
            double avgMs = tickData.getAverageMicros() / 1000.0;
            double maxMs = tickData.getMaxMicros() / 1000.0;

            // í‰ê·  í‹± ì‹œê°„ ê¶Œì¥ì‚¬í•­
            if (avgMs > 33.33) {
                recommendations.add("CRITICAL: Average tick time (" + round(avgMs)
                        + "ms) exceeds 33ms. Game is running below 30 FPS.");
            } else if (avgMs > 16.67) {
                recommendations.add("WARNING: Average tick time (" + round(avgMs)
                        + "ms) exceeds 16.67ms target. Consider optimization.");
            }

            // ìŠ¤íŒŒì´í¬ ê¶Œì¥ì‚¬í•­
            if (spikeLog.getTotalSpikes() > 10) {
                recommendations.add("High spike count (" + spikeLog.getTotalSpikes() + "). Investigate: "
                        + spikeLog.getWorstSpikeLabel());
            }

            // ìµœëŒ€ ìŠ¤íŒŒì´í¬ ê²½ê³ 
            if (maxMs > 100) {
                recommendations.add("SEVERE: Max tick spike (" + round(maxMs) + "ms) exceeded 100ms.");
            }

            // P95 ê¶Œì¥ì‚¬í•­
            double p95 = histogram.getP95();
            if (p95 > 33.33) {
                recommendations.add("P95 tick time (" + round(p95) + "ms) is high. 5% of ticks are causing stutters.");
            }
        }

        if (recommendations.isEmpty()) {
            recommendations.add("Performance looks good! No critical issues detected.");
        }

        return recommendations;
    }

    private Map<String, Object> generateMemoryStats() {
        return MemoryProfiler.toMap();
    }

    private Map<String, Object> generateLuaProfiling() {
        LuaCallTracker luaTracker = LuaCallTracker.getInstance();
        return luaTracker.toMap(topN);
    }

    private Map<String, Object> generateMetadata() {
        Map<String, Object> meta = new LinkedHashMap<>();
        meta.put("echo_version", VERSION);
        meta.put("java_version", System.getProperty("java.version"));
        meta.put("os", System.getProperty("os.name"));
        meta.put("session_start_time", formatInstant(
                Instant.ofEpochMilli(profiler.getSessionStartTime())));
        return meta;
    }

    private String formatInstant(Instant instant) {
        return DateTimeFormatter.ISO_INSTANT.format(instant);
    }

    private double round(double value) {
        return Math.round(value * 100.0) / 100.0;
    }

    // truncate method removed - using StringUtils.truncate()

    // ============================================================
    // Helper Class
    // ============================================================

    private static class RankedFunction {
        final String label;
        final String parentPoint;
        final long callCount;
        final long totalMicros;
        final long maxMicros;

        RankedFunction(String label, String parentPoint, long callCount, long totalMicros, long maxMicros) {
            this.label = label;
            this.parentPoint = parentPoint;
            this.callCount = callCount;
            this.totalMicros = totalMicros;
            this.maxMicros = maxMicros;
        }

        Map<String, Object> toMap(int rank) {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("rank", rank);
            map.put("label", label);
            map.put("parent_point", parentPoint);
            map.put("call_count", callCount);
            map.put("total_time_ms", Math.round(totalMicros / 10.0) / 100.0);
            map.put("average_time_ms", callCount > 0
                    ? Math.round((double) totalMicros / callCount / 10.0) / 100.0
                    : 0);
            map.put("max_time_ms", Math.round(maxMicros / 10.0) / 100.0);
            return map;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\report\EchoReport.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\util\StringUtils.java =====

package com.echo.util;

/**
 * ë¬¸ìì—´ ìœ í‹¸ë¦¬í‹°
 */
public final class StringUtils {

    private StringUtils() {
        // ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤
    }

    /**
     * ë¬¸ìì—´ì„ ìµœëŒ€ ê¸¸ì´ë¡œ ìë¦„
     * 
     * @param s      ì›ë³¸ ë¬¸ìì—´
     * @param maxLen ìµœëŒ€ ê¸¸ì´
     * @return ì˜ë¦° ë¬¸ìì—´ (ì´ˆê³¼ ì‹œ "..." ì¶”ê°€)
     */
    public static String truncate(String s, int maxLen) {
        if (s == null)
            return "";
        return s.length() <= maxLen ? s : s.substring(0, maxLen - 3) + "...";
    }

    /**
     * ë§ˆì´í¬ë¡œì´ˆë¥¼ ë°€ë¦¬ì´ˆ ë¬¸ìì—´ë¡œ ë³€í™˜
     */
    public static String formatMs(double micros) {
        return String.format("%.2f", micros / 1000.0);
    }

    /**
     * ë§ˆì´í¬ë¡œì´ˆë¥¼ ë°€ë¦¬ì´ˆë¡œ ë°˜ì˜¬ë¦¼
     */
    public static double toMs(long micros) {
        return Math.round(micros / 10.0) / 100.0;
    }

    /**
     * ë°€ë¦¬ì´ˆ í¬ë§· (ì†Œìˆ˜ì  2ìë¦¬)
     */
    public static String formatDuration(long micros) {
        return String.format("%.2f ms", micros / 1000.0);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\main\java\com\echo\util\StringUtils.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\test\java\com\echo\aggregate\SpikeLogTest.java =====

package com.echo.aggregate;

import com.echo.measure.ProfilingPoint;
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * SpikeLog ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
 */
class SpikeLogTest {

    private SpikeLog spikeLog;

    @BeforeEach
    void setUp() {
        spikeLog = new SpikeLog(10.0); // 10ms threshold
    }

    @Test
    @DisplayName("Initial state")
    void testInitialState() {
        assertEquals(0, spikeLog.getTotalSpikes());
        assertEquals(0.0, spikeLog.getWorstSpikeMs());
        assertEquals(10.0, spikeLog.getThresholdMs());
    }

    @Test
    @DisplayName("Spikes below threshold not logged")
    void testBelowThreshold() {
        spikeLog.logSpike(5000, ProfilingPoint.TICK, null); // 5ms < 10ms
        assertEquals(0, spikeLog.getTotalSpikes());
    }

    @Test
    @DisplayName("Spikes above threshold logged")
    void testAboveThreshold() {
        spikeLog.logSpike(15000, ProfilingPoint.TICK, null); // 15ms > 10ms
        assertEquals(1, spikeLog.getTotalSpikes());
    }

    @Test
    @DisplayName("Worst spike tracking")
    void testWorstSpike() {
        spikeLog.logSpike(20000, ProfilingPoint.TICK, "first");
        spikeLog.logSpike(50000, ProfilingPoint.TICK, "worst");
        spikeLog.logSpike(30000, ProfilingPoint.TICK, "third");

        assertEquals(50.0, spikeLog.getWorstSpikeMs());
        assertEquals("worst", spikeLog.getWorstSpikeLabel());
    }

    @Test
    @DisplayName("Threshold can be changed at runtime")
    void testThresholdChange() {
        spikeLog.setThresholdMs(5.0);
        assertEquals(5.0, spikeLog.getThresholdMs());

        spikeLog.logSpike(7000, ProfilingPoint.TICK, null); // 7ms > 5ms
        assertEquals(1, spikeLog.getTotalSpikes());
    }

    @Test
    @DisplayName("Recent spikes retrieval")
    void testRecentSpikes() {
        spikeLog.logSpike(15000, ProfilingPoint.TICK, "spike1");
        spikeLog.logSpike(20000, ProfilingPoint.RENDER, "spike2");

        var recent = spikeLog.getRecentSpikes(5);
        assertEquals(2, recent.size());
    }

    @Test
    @DisplayName("Reset clears all data")
    void testReset() {
        spikeLog.logSpike(20000, ProfilingPoint.TICK, "test");
        spikeLog.reset();

        assertEquals(0, spikeLog.getTotalSpikes());
        assertEquals(0.0, spikeLog.getWorstSpikeMs());
    }

    @Test
    @DisplayName("toMap generates valid output")
    void testToMap() {
        spikeLog.logSpike(20000, ProfilingPoint.TICK, "spike");

        var map = spikeLog.toMap();
        assertNotNull(map);
        assertTrue(map.containsKey("total_spikes"));
        assertTrue(map.containsKey("worst_spike_ms"));
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\test\java\com\echo\aggregate\SpikeLogTest.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\test\java\com\echo\aggregate\TimingDataTest.java =====

package com.echo.aggregate;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * TimingData ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
 */
class TimingDataTest {

    private TimingData data;

    @BeforeEach
    void setUp() {
        data = new TimingData("test");
    }

    @Test
    @DisplayName("Initial state")
    void testInitialState() {
        assertEquals("test", data.getName());
        assertEquals(0, data.getCallCount());
        assertEquals(0, data.getAverageMicros());
        assertEquals(0, data.getMaxMicros());
    }

    @Test
    @DisplayName("Add sample updates statistics")
    void testAddSample() {
        data.addSample(1000000); // 1ms in nanos

        assertEquals(1, data.getCallCount());
        assertEquals(1000, data.getAverageMicros()); // 1000 micros
    }

    @Test
    @DisplayName("Multiple samples average correctly")
    void testMultipleSamples() {
        data.addSample(1000000); // 1ms
        data.addSample(3000000); // 3ms

        assertEquals(2, data.getCallCount());
        assertEquals(2000, data.getAverageMicros()); // 2ms average
    }

    @Test
    @DisplayName("Max value tracking")
    void testMaxTracking() {
        data.addSample(1000000);
        data.addSample(5000000);
        data.addSample(2000000);

        assertEquals(5000, data.getMaxMicros());
    }

    @Test
    @DisplayName("Min value tracking")
    void testMinTracking() {
        data.addSample(5000000);
        data.addSample(1000000);
        data.addSample(3000000);

        assertEquals(1000, data.getMinMicros());
    }

    @Test
    @DisplayName("Labeled sub-timing data")
    void testLabeledData() {
        data.addSample(1000000, "func1");
        data.addSample(2000000, "func1");
        data.addSample(3000000, "func2");

        var labelStats = data.getLabelStats();
        assertEquals(2, labelStats.size());

        var func1Stats = labelStats.get("func1");
        assertEquals(2, func1Stats.getCallCount());
    }

    @Test
    @DisplayName("Top N by total time")
    void testTopN() {
        data.addSample(1000000, "slow");
        data.addSample(1000000, "slow");
        data.addSample(500000, "fast");

        var topN = data.getTopNByTotalTime(1);
        assertEquals(1, topN.size());
        assertEquals("slow", topN.get(0).getLabel());
    }

    @Test
    @DisplayName("Reset clears all data")
    void testReset() {
        data.addSample(1000000, "test");
        data.reset();

        assertEquals(0, data.getCallCount());
        assertTrue(data.getLabelStats().isEmpty());
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\test\java\com\echo\aggregate\TimingDataTest.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Echo\src\test\java\com\echo\measure\EchoProfilerTest.java =====

package com.echo.measure;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * EchoProfiler ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
 */
class EchoProfilerTest {

    private EchoProfiler profiler;

    @BeforeEach
    void setUp() {
        profiler = EchoProfiler.getInstance();
        profiler.reset();
        profiler.enable(true);
    }

    @AfterEach
    void tearDown() {
        profiler.disable();
    }

    @Test
    @DisplayName("Profiler singleton instance")
    void testSingleton() {
        EchoProfiler instance1 = EchoProfiler.getInstance();
        EchoProfiler instance2 = EchoProfiler.getInstance();
        assertSame(instance1, instance2);
    }

    @Test
    @DisplayName("Enable/Disable profiler")
    void testEnableDisable() {
        profiler.disable();
        assertFalse(profiler.isEnabled());

        profiler.enable();
        assertTrue(profiler.isEnabled());
    }

    @Test
    @DisplayName("Push/Pop records timing data")
    void testPushPop() {
        profiler.push(ProfilingPoint.TICK);
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        profiler.pop(ProfilingPoint.TICK);

        var data = profiler.getTimingData(ProfilingPoint.TICK);
        assertNotNull(data);
        assertEquals(1, data.getCallCount());
        assertTrue(data.getAverageMicros() > 0);
    }

    @Test
    @DisplayName("Scope API with try-with-resources")
    void testScopeApi() {
        try (var scope = profiler.scope(ProfilingPoint.ZOMBIE_AI)) {
            // Simulated work
            Thread.sleep(5);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        var data = profiler.getTimingData(ProfilingPoint.ZOMBIE_AI);
        assertNotNull(data);
        assertEquals(1, data.getCallCount());
    }

    @Test
    @DisplayName("Raw API for zero-allocation")
    void testRawApi() {
        long start = profiler.startRaw(ProfilingPoint.RENDER);
        assertTrue(start > 0);
        profiler.endRaw(ProfilingPoint.RENDER, start);

        var data = profiler.getTimingData(ProfilingPoint.RENDER);
        assertEquals(1, data.getCallCount());
    }

    @Test
    @DisplayName("Labeled profiling")
    void testLabeledProfiling() {
        try (var scope = profiler.scope(ProfilingPoint.ZOMBIE_AI, "pathfinding")) {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        var data = profiler.getTimingData(ProfilingPoint.ZOMBIE_AI);
        var labelStats = data.getLabelStats();
        assertTrue(labelStats.containsKey("pathfinding"));
    }

    @Test
    @DisplayName("Reset clears all data")
    void testReset() {
        try (var scope = profiler.scope(ProfilingPoint.TICK)) {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        profiler.reset();

        var data = profiler.getTimingData(ProfilingPoint.TICK);
        assertEquals(0, data.getCallCount());
    }

    @Test
    @DisplayName("Session duration tracking")
    void testSessionDuration() throws InterruptedException {
        Thread.sleep(100);
        // Session duration should be at least 0 seconds
        assertTrue(profiler.getSessionDurationSeconds() >= 0);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Echo\src\test\java\com\echo\measure\EchoProfilerTest.java =====

