
===== FILE START: C:\Users\MW\Downloads\coding\Pulse\.gradle =====


===== FILE END: C:\Users\MW\Downloads\coding\Pulse\.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\.idea\gradle.xml =====

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="GradleSettings">
    <option name="linkedExternalProjectsSettings">
      <GradleProjectSettings>
        <option name="externalProjectPath" value="$PROJECT_DIR$" />
        <option name="gradleHome" value="" />
        <option name="modules">
          <set>
            <option value="$PROJECT_DIR$" />
          </set>
        </option>
      </GradleProjectSettings>
    </option>
  </component>
</project>

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\.idea\gradle.xml =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\.idea\misc.xml =====

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ExternalStorageConfigurationManager" enabled="true" />
  <component name="FrameworkDetectionExcludesConfiguration">
    <file type="web" url="file://$PROJECT_DIR$" />
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="17" project-jdk-type="JavaSDK">
    <output url="file://$PROJECT_DIR$/out" />
  </component>
</project>

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\.idea\misc.xml =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\.idea\vcs.xml =====

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$" vcs="Git" />
  </component>
</project>

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\.idea\vcs.xml =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\.vscode\settings.json =====

{
    "java.compile.nullAnalysis.mode": "automatic",
    "java.configuration.updateBuildConfiguration": "interactive"
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\.vscode\settings.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\bin\main\mixins.pulse.json =====

{
  "required": true,
  "minVersion": "0.8",
  "package": "com.pulse.mixin",
  "mixins": [
    "MainScreenStateMixin",
    "GameClientMixin",
    "GameWindowMixin",
    "IsoWorldMixin",
    "IsoPlayerMixin"
  ],
  "client": [],
  "server": [],
  "injectors": {
    "defaultRequire": 0
  },
  "verbose": true
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\bin\main\mixins.pulse.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\build.gradle =====

plugins {
    id 'java'
    id 'eclipse'
    id 'idea'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'com.pulse'
version = '1.0.0-SNAPSHOT'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven/' }
}

dependencies {
    // Mixin Core
    implementation 'org.spongepowered:mixin:0.8.5'

    // JSON (Mixin config 파싱에 필요)
    implementation 'com.google.code.gson:gson:2.10.1'

    // ASM (바이트코드 조작)
    implementation 'org.ow2.asm:asm:9.5'
    implementation 'org.ow2.asm:asm-commons:9.5'
    implementation 'org.ow2.asm:asm-tree:9.5'
    implementation 'org.ow2.asm:asm-util:9.5'
    implementation 'org.ow2.asm:asm-analysis:9.5'

    // Guava (Mixin 내부에서 사용)
    implementation 'com.google.guava:guava:32.1.2-jre'

    // Game Code (컴파일 전용)
    compileOnly files('C:/SteamLibrary/steamapps/common/ProjectZomboid')
    compileOnly fileTree(dir: 'C:/SteamLibrary/steamapps/common/ProjectZomboid', include: ['*.jar'])
}

shadowJar {
    archiveBaseName.set('Pulse')
    archiveClassifier.set('')
    archiveVersion.set('')

    // 서비스 파일 병합 (중요!)
    mergeServiceFiles()

    // 중복 제외
    exclude 'META-INF/MANIFEST.MF'
    exclude 'META-INF/*.SF'
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'

    manifest {
        attributes(
            'Premain-Class': 'com.pulse.PulseAgent',
            'Agent-Class': 'com.pulse.PulseAgent',
            'Can-Retransform-Classes': 'true',
            'Can-Redefine-Classes': 'true',
            'Can-Set-Native-Method-Prefix': 'true',
            'Implementation-Title': 'Pulse',
            'Implementation-Version': project.version,
            'Multi-Release': 'true'
        )
    }
}

tasks.named('build') {
    dependsOn shadowJar
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.compilerArgs += ['-parameters']  // 메서드 파라미터 이름 유지
}

// 디버그: 종속성 트리 출력
task printDeps {
    doLast {
        configurations.runtimeClasspath.each { println it }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\build.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\build\resources\main\mixins.pulse.json =====

{
  "required": true,
  "minVersion": "0.8",
  "package": "com.pulse.mixin",
  "mixins": [
    "MainScreenStateMixin",
    "GameClientMixin",
    "GameWindowMixin",
    "IsoWorldMixin",
    "IsoPlayerMixin"
  ],
  "client": [],
  "server": [],
  "injectors": {
    "defaultRequire": 0
  },
  "verbose": true
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\build\resources\main\mixins.pulse.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\example-mod\build.gradle =====

plugins {
    id 'java'
}

group = 'com.example'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // Pulse API - 컴파일 타임에만 필요
    compileOnly files('../build/libs/Pulse-1.0.0-all.jar')
}

jar {
    // pulse.mod.json을 JAR 루트에 포함
    from('src/main/resources') {
        include 'pulse.mod.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Example Mod',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\example-mod\build.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\example-mod\src\main\java\com\example\examplemod\ExampleCommands.java =====

package com.example.examplemod;

import com.pulse.command.Arg;
import com.pulse.command.Command;
import com.pulse.command.CommandContext;
import com.pulse.command.CommandRegistry;

/**
 * 예제 명령어 클래스.
 * 
 * @Command 어노테이션을 사용한 명령어 정의 예제.
 */
public class ExampleCommands {

    /**
     * 명령어 등록
     */
    public static void register() {
        // 어노테이션 기반 등록
        CommandRegistry.register(new ExampleCommands());

        // 람다 기반 등록
        CommandRegistry.register("examplehelp", "Show example mod help", ctx -> {
            ctx.reply("═══════════════════════════════════════");
            ctx.reply("  Example Mod Commands");
            ctx.reply("═══════════════════════════════════════");
            ctx.reply("/examplestatus - Show current status");
            ctx.reply("/exampleheal [amount] - Heal player");
            ctx.reply("/exampletoggle <feature> - Toggle feature");
            ctx.reply("/examplehelp - Show this help");
            ctx.reply("═══════════════════════════════════════");
        });
    }

    // ─────────────────────────────────────────────────────────────
    // 명령어 핸들러
    // ─────────────────────────────────────────────────────────────

    @Command(name = "examplestatus", description = "Show example mod status", aliases = { "exstatus" })
    public void statusCommand(CommandContext ctx) {
        ctx.reply("Example Mod Status:");
        ctx.reply("  Debug Mode: " + ExampleConfig.debugMode);
        ctx.reply("  Log Interval: " + ExampleConfig.logInterval + " ticks");
        ctx.reply("  Damage Reduction: " + (ExampleConfig.damageReduction * 100) + "%");
        ctx.reply("  Fire Immunity: " + ExampleConfig.fireImmunity);
    }

    @Command(name = "exampleheal", description = "Heal the player", usage = "/exampleheal [amount]", playerOnly = true)
    public void healCommand(CommandContext ctx, @Arg(value = "amount", optional = true) Float amount) {
        float healAmount = amount != null ? amount : 100.0f;

        // 실제 힐 로직은 GameAccess API를 통해 구현
        // GameAccess.setPlayerHealth(GameAccess.getPlayerHealth() + healAmount);

        ctx.reply("Healed for " + healAmount + " HP!");
    }

    @Command(name = "exampletoggle", description = "Toggle a feature", usage = "/exampletoggle <debug|fire|nightvision>")
    public void toggleCommand(CommandContext ctx, @Arg(value = "feature") String feature) {
        switch (feature.toLowerCase()) {
            case "debug":
                ExampleConfig.debugMode = !ExampleConfig.debugMode;
                ctx.reply("Debug mode: " + (ExampleConfig.debugMode ? "ON" : "OFF"));
                break;

            case "fire":
                ExampleConfig.fireImmunity = !ExampleConfig.fireImmunity;
                ctx.reply("Fire immunity: " + (ExampleConfig.fireImmunity ? "ON" : "OFF"));
                break;

            case "nightvision":
            case "nv":
                ExampleConfig.nightVision = !ExampleConfig.nightVision;
                ctx.reply("Night vision: " + (ExampleConfig.nightVision ? "ON" : "OFF"));
                break;

            default:
                ctx.reply("Unknown feature: " + feature);
                ctx.reply("Available: debug, fire, nightvision");
                break;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\example-mod\src\main\java\com\example\examplemod\ExampleCommands.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\example-mod\src\main\java\com\example\examplemod\ExampleConfig.java =====

package com.example.examplemod;

import com.pulse.config.Config;
import com.pulse.config.ConfigValue;

/**
 * Example Mod 설정.
 * 
 * @Config 어노테이션이 붙은 클래스는 자동으로 JSON 설정 파일로 관리됩니다.
 *         파일 위치: config/examplemod.json
 */
@Config(modId = "examplemod")
public class ExampleConfig {

    // ─────────────────────────────────────────────────────────────
    // 일반 설정
    // ─────────────────────────────────────────────────────────────

    @ConfigValue(comment = "Enable debug logging")
    public static boolean debugMode = false;

    @ConfigValue(comment = "Status log interval in ticks (600 = 10 seconds)")
    public static int logInterval = 600;

    // ─────────────────────────────────────────────────────────────
    // 게임플레이 설정
    // ─────────────────────────────────────────────────────────────

    @ConfigValue(comment = "Damage reduction multiplier (0.0 - 1.0)")
    public static float damageReduction = 0.0f;

    @ConfigValue(comment = "Enable fire damage immunity")
    public static boolean fireImmunity = false;

    @ConfigValue(comment = "Enable night vision effect")
    public static boolean nightVision = false;

    // ─────────────────────────────────────────────────────────────
    // 알림 설정
    // ─────────────────────────────────────────────────────────────

    @ConfigValue(comment = "Show status notifications")
    public static boolean showNotifications = true;

    @ConfigValue(comment = "Notification display duration in ticks")
    public static int notificationDuration = 100;
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\example-mod\src\main\java\com\example\examplemod\ExampleConfig.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\example-mod\src\main\java\com\example\examplemod\ExampleMod.java =====

package com.example.examplemod;

import com.pulse.api.GameAccess;
import com.pulse.api.Pulse;
import com.pulse.attachment.DataAttachments;
import com.pulse.config.ConfigManager;
import com.pulse.event.EventBus;
import com.pulse.event.EventPriority;
import com.pulse.event.lifecycle.GameInitEvent;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.event.lifecycle.WorldLoadEvent;
import com.pulse.event.lifecycle.WorldUnloadEvent;
import com.pulse.event.player.PlayerDamageEvent;
import com.pulse.event.player.PlayerUpdateEvent;
import com.pulse.input.KeyBinding;
import com.pulse.input.KeyBindingRegistry;
import com.pulse.input.KeyCode;
import com.pulse.mod.PulseMod;
import com.pulse.scheduler.PulseScheduler;

/**
 * Example Mod - Pulse API 사용 예제
 *
 * 이 모드는 Pulse의 주요 기능을 보여줍니다:
 * - 설정 시스템 (@Config)
 * - 이벤트 구독 및 처리
 * - 명령어 시스템 (@Command)
 * - 데이터 첨부 (DataAttachments)
 * - 스케줄러 (PulseScheduler)
 * - 키 바인딩 (KeyBinding)
 * - GameAccess API 사용
 */
public class ExampleMod implements PulseMod {

    private static final String MOD_ID = "examplemod";
    private long lastLogTick = 0;

    // 키 바인딩
    private KeyBinding openMenuKey;
    private KeyBinding toggleDebugKey;

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "Example Mod initializing...");

        // 1. 설정 등록 및 로드
        ConfigManager.register(ExampleConfig.class);
        Pulse.log(MOD_ID, "Config loaded - Debug mode: " + ExampleConfig.debugMode);

        // 2. 명령어 등록
        ExampleCommands.register();
        Pulse.log(MOD_ID, "Commands registered");

        // 3. 이벤트 리스너 등록
        registerEventListeners();

        // 4. 키 바인딩 등록
        registerKeyBindings();

        // 5. 스케줄러 예제
        scheduleExampleTasks();

        Pulse.log(MOD_ID, "Example Mod initialized!");
    }

    private void registerEventListeners() {
        // 게임 초기화 완료 이벤트
        EventBus.subscribe(GameInitEvent.class, this::onGameInit);

        // 게임 틱 이벤트
        EventBus.subscribe(GameTickEvent.class, this::onGameTick);

        // 월드 로드/언로드 이벤트
        EventBus.subscribe(WorldLoadEvent.class, this::onWorldLoad);
        EventBus.subscribe(WorldUnloadEvent.class, this::onWorldUnload);

        // 플레이어 이벤트
        EventBus.subscribe(PlayerUpdateEvent.class, this::onPlayerUpdate);

        // 플레이어 데미지 이벤트 - 높은 우선순위로 설정 적용
        EventBus.subscribe(PlayerDamageEvent.class, this::onPlayerDamage, EventPriority.HIGH);
    }

    private void registerKeyBindings() {
        // 메뉴 열기 키 (M)
        openMenuKey = KeyBinding.create(MOD_ID, "open_menu")
                .defaultKey(KeyCode.KEY_M)
                .category("Example Mod")
                .build();
        KeyBindingRegistry.register(openMenuKey);

        // 디버그 토글 키 (Ctrl+D)
        toggleDebugKey = KeyBinding.create(MOD_ID, "toggle_debug")
                .defaultKey(KeyCode.KEY_D)
                .withCtrl()
                .category("Example Mod")
                .build();
        KeyBindingRegistry.register(toggleDebugKey);
    }

    private void scheduleExampleTasks() {
        // 게임 시작 후 5초(100틱) 뒤에 환영 메시지
        PulseScheduler.runLater(() -> {
            Pulse.log(MOD_ID, "Welcome to Example Mod! Press M to open menu.");
        }, 100, "welcome-message");

        // 1분마다 플레이어 데이터 자동 저장 (1200틱)
        PulseScheduler.runTimer(() -> {
            Object player = GameAccess.getLocalPlayer();
            if (player != null) {
                DataAttachments.save(player, "examplemod_player.json");
                if (ExampleConfig.debugMode) {
                    Pulse.log(MOD_ID, "Player data auto-saved");
                }
            }
        }, 1200, 1200, "auto-save");
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 핸들러
    // ─────────────────────────────────────────────────────────────

    private void onGameInit(GameInitEvent event) {
        Pulse.log(MOD_ID, "Game initialization complete!");
    }

    private void onGameTick(GameTickEvent event) {
        // 키 바인딩 체크
        checkKeyBindings();

        // 플레이어 데이터 업데이트
        updatePlayerData();

        // 설정된 간격으로 상태 로그 출력
        if (event.getTick() - lastLogTick >= ExampleConfig.logInterval) {
            lastLogTick = event.getTick();
            if (ExampleConfig.debugMode) {
                logGameStatus();
            }
        }
    }

    private void checkKeyBindings() {
        if (openMenuKey != null && openMenuKey.wasPressed()) {
            Pulse.log(MOD_ID, "Menu key pressed! (Placeholder for actual menu)");
        }

        if (toggleDebugKey != null && toggleDebugKey.wasPressed()) {
            ExampleConfig.debugMode = !ExampleConfig.debugMode;
            ConfigManager.save(ExampleConfig.class);
            Pulse.log(MOD_ID, "Debug mode: " + (ExampleConfig.debugMode ? "ON" : "OFF"));
        }
    }

    private void updatePlayerData() {
        Object player = GameAccess.getLocalPlayer();
        if (player == null)
            return;

        // 플레이어 데이터 가져오기 (없으면 자동 생성)
        PlayerExtraData data = DataAttachments.get(player, PlayerExtraData.TYPE);

        // 플레이 시간 증가
        data.incrementPlayTime();

        // 현재 위치 저장
        String location = String.format("%.0f, %.0f, %.0f",
                GameAccess.getPlayerX(),
                GameAccess.getPlayerY(),
                GameAccess.getPlayerZ());
        data.setLastLocation(location);
    }

    private void onWorldLoad(WorldLoadEvent event) {
        Pulse.log(MOD_ID, "World loaded: " + event.getWorldName());

        // 플레이어 데이터 로드 시도
        Object player = GameAccess.getLocalPlayer();
        if (player != null) {
            DataAttachments.load(player, "examplemod_player.json");
            PlayerExtraData data = DataAttachments.get(player, PlayerExtraData.TYPE);
            Pulse.log(MOD_ID, "Loaded player data: " + data);
        }

        // 월드 로드 시 게임 상태 출력
        if (ExampleConfig.debugMode) {
            logGameStatus();
        }
    }

    private void onWorldUnload(WorldUnloadEvent event) {
        Pulse.log(MOD_ID, "World unloaded");

        // 플레이어 데이터 저장
        Object player = GameAccess.getLocalPlayer();
        if (player != null) {
            DataAttachments.save(player, "examplemod_player.json");
            Pulse.log(MOD_ID, "Player data saved on world unload");
        }
    }

    private void onPlayerUpdate(PlayerUpdateEvent event) {
        // 플레이어 업데이트는 매우 빈번하므로 로그 생략
        // 필요시 여기서 플레이어 상태 모니터링 가능
    }

    private void onPlayerDamage(PlayerDamageEvent event) {
        float damage = event.getDamage();
        String type = event.getDamageType();

        if (ExampleConfig.debugMode) {
            Pulse.log(MOD_ID, String.format(
                    "Player taking %.1f damage (type: %s)", damage, type));
        }

        // 설정에 따른 데미지 감소
        if (ExampleConfig.damageReduction > 0) {
            float reducedDamage = damage * (1.0f - ExampleConfig.damageReduction);
            event.setDamage(reducedDamage);
            if (ExampleConfig.debugMode) {
                Pulse.log(MOD_ID, String.format(
                        "Damage reduced: %.1f -> %.1f", damage, reducedDamage));
            }
        }

        // 화염 면역 설정
        if (ExampleConfig.fireImmunity && "fire".equals(type)) {
            event.cancel();
            Pulse.log(MOD_ID, "Fire damage blocked!");
        }

        // 사망 시 데이터 업데이트
        if (!event.isCancelled() && damage >= GameAccess.getPlayerHealth()) {
            Object player = GameAccess.getLocalPlayer();
            if (player != null) {
                PlayerExtraData data = DataAttachments.get(player, PlayerExtraData.TYPE);
                data.addDeath();
            }
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    private void logGameStatus() {
        StringBuilder sb = new StringBuilder();
        sb.append("\n");
        sb.append("═══════════════════════════════════════\n");
        sb.append("       EXAMPLE MOD - GAME STATUS       \n");
        sb.append("═══════════════════════════════════════\n");

        // 월드 정보
        sb.append("World: ").append(GameAccess.isWorldLoaded() ? GameAccess.getWorldName() : "Not loaded").append("\n");

        // 시간 정보
        sb.append(String.format("Time: Day %d, %02d:%02d (%s)\n",
                GameAccess.getGameDay(),
                GameAccess.getGameHour(),
                GameAccess.getGameMinute(),
                GameAccess.isNight() ? "Night" : "Day"));

        // 플레이어 정보
        Object player = GameAccess.getLocalPlayer();
        if (player != null) {
            sb.append(String.format("Player: %.1f HP at (%.0f, %.0f, %.0f)\n",
                    GameAccess.getPlayerHealth(),
                    GameAccess.getPlayerX(),
                    GameAccess.getPlayerY(),
                    GameAccess.getPlayerZ()));
            sb.append("Status: ").append(GameAccess.isPlayerAlive() ? "Alive" : "Dead").append("\n");

            // 커스텀 데이터
            PlayerExtraData data = DataAttachments.get(player, PlayerExtraData.TYPE);
            sb.append(String.format("Stats: %d kills, %d deaths, %s played\n",
                    data.getKillCount(), data.getDeathCount(), data.getPlayTimeFormatted()));
        } else {
            sb.append("Player: Not spawned\n");
        }

        // 게임 상태
        sb.append("Mode: ").append(GameAccess.isSinglePlayer() ? "Singleplayer" : "Multiplayer").append("\n");
        sb.append("Paused: ").append(GameAccess.isPaused() ? "Yes" : "No").append("\n");

        sb.append("═══════════════════════════════════════");

        Pulse.log(MOD_ID, sb.toString());
    }

    // ─────────────────────────────────────────────────────────────
    // 라이프사이클
    // ─────────────────────────────────────────────────────────────

    @Override
    public void onWorldLoad() {
        // PulseMod 인터페이스의 월드 로드 콜백
        Pulse.log(MOD_ID, "PulseMod.onWorldLoad() called");
    }

    @Override
    public void onWorldUnload() {
        // PulseMod 인터페이스의 월드 언로드 콜백
        Pulse.log(MOD_ID, "PulseMod.onWorldUnload() called");
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Example Mod unloading...");

        // 설정 저장
        ConfigManager.save(ExampleConfig.class);

        // 플레이어 데이터 저장
        Object player = GameAccess.getLocalPlayer();
        if (player != null) {
            DataAttachments.save(player, "examplemod_player.json");
        }

        Pulse.log(MOD_ID, "Example Mod unloaded");
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\example-mod\src\main\java\com\example\examplemod\ExampleMod.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\example-mod\src\main\java\com\example\examplemod\PlayerExtraData.java =====

package com.example.examplemod;

import com.pulse.attachment.AttachmentType;

/**
 * 플레이어에 첨부할 커스텀 데이터 예제.
 * 
 * DataAttachments API를 사용하여 게임 객체에 붙일 수 있습니다.
 */
public class PlayerExtraData {

    /**
     * 커스텀 데이터 첨부 타입 정의.
     * - persistent(): JSON으로 저장됨
     * - copyOnDeath(): 사망 시 새 플레이어에 복사됨
     */
    public static final AttachmentType<PlayerExtraData> TYPE = AttachmentType
            .builder("examplemod", "player_extra", PlayerExtraData::new)
            .persistent()
            .copyOnDeath()
            .build();

    // ─────────────────────────────────────────────────────────────
    // 데이터 필드
    // ─────────────────────────────────────────────────────────────

    private int killCount = 0;
    private int deathCount = 0;
    private long playTime = 0; // 틱 단위
    private String lastLocation = "";
    private boolean hasCompletedTutorial = false;

    // ─────────────────────────────────────────────────────────────
    // Getters & Setters
    // ─────────────────────────────────────────────────────────────

    public int getKillCount() {
        return killCount;
    }

    public void addKill() {
        this.killCount++;
    }

    public int getDeathCount() {
        return deathCount;
    }

    public void addDeath() {
        this.deathCount++;
    }

    public long getPlayTime() {
        return playTime;
    }

    public void incrementPlayTime() {
        this.playTime++;
    }

    public String getPlayTimeFormatted() {
        long seconds = playTime / 60;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        return String.format("%02d:%02d:%02d", hours, minutes % 60, seconds % 60);
    }

    public String getLastLocation() {
        return lastLocation;
    }

    public void setLastLocation(String lastLocation) {
        this.lastLocation = lastLocation;
    }

    public boolean hasCompletedTutorial() {
        return hasCompletedTutorial;
    }

    public void setCompletedTutorial(boolean completed) {
        this.hasCompletedTutorial = completed;
    }

    @Override
    public String toString() {
        return String.format("PlayerExtraData{kills=%d, deaths=%d, playTime=%s}",
                killCount, deathCount, getPlayTimeFormatted());
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\example-mod\src\main\java\com\example\examplemod\PlayerExtraData.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\example-mod\src\main\resources\pulse.mod.json =====

{
  "id": "examplemod",
  "name": "Example Mod",
  "version": "1.0.0",
  "author": "Pulse Team",
  "description": "An example mod demonstrating Pulse API usage",
  "entrypoint": "com.example.examplemod.ExampleMod",
  "dependencies": [
    {
      "id": "Pulse",
      "version": ">=1.0.0"
    }
  ]
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\example-mod\src\main\resources\pulse.mod.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\.gradle =====


===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\bin\main\mixins.engineoptim.json =====

{
    "required": true,
    "package": "com.pulse.engineoptim.mixin",
    "compatibilityLevel": "JAVA_17",
    "mixins": [],
    "injectors": {
        "defaultRequire": 1
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\bin\main\mixins.engineoptim.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\bin\main\pulse.mod.json =====

{
    "id": "Pulse_engine_optim",
    "name": "Pulse Engine Optimizer",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Engine-level optimizations for Project Zomboid",
    "entrypoint": "com.pulse.engineoptim.EngineOptimMod",
    "mixins": [
        "mixins.engineoptim.json"
    ],
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\bin\main\pulse.mod.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\build.gradle =====

plugins {
    id 'java'
}

group = 'com.pulse.engineoptim'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven/' }
}

dependencies {
    compileOnly project(':')
    compileOnly 'org.spongepowered:mixin:0.8.5'
    compileOnly fileTree(dir: 'C:/SteamLibrary/steamapps/common/ProjectZomboid', include: ['*.jar'])
}

jar {
    archiveBaseName.set('Pulse-engine-optim')
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    
    from('src/main/resources') {
        include 'pulse.mod.json'
        include 'mixins.engineoptim.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Pulse Engine Optim',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\build.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\settings.gradle =====

rootProject.name = 'Pulse-engine-optim'

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\settings.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\src\main\java\com\pulse\engineoptim\EngineOptimConfig.java =====

package com.pulse.engineoptim;

import com.pulse.config.Config;
import com.pulse.config.ConfigValue;

/**
 * 엔진 최적화 설정.
 */
@Config(modId = "Pulse_engine_optim", fileName = "engine_optim.json")
public class EngineOptimConfig {

    @ConfigValue(key = "optimizeWorldLoading", comment = "Optimize world loading and chunk processing")
    public static boolean optimizeWorldLoading = true;

    @ConfigValue(key = "optimizeAiPathfinding", comment = "Optimize zombie AI pathfinding calculations")
    public static boolean optimizeAiPathfinding = true;

    @ConfigValue(key = "optimizeRendering", comment = "Optimize rendering performance (batching, culling)")
    public static boolean optimizeRendering = true;

    @ConfigValue(key = "safeMode", comment = "Disable risky optimizations if stability issues occur")
    public static boolean safeMode = false;
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\src\main\java\com\pulse\engineoptim\EngineOptimConfig.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\src\main\java\com\pulse\engineoptim\EngineOptimMod.java =====

package com.pulse.engineoptim;

import com.pulse.api.Pulse;
import com.pulse.mod.PulseMod;

/**
 * Pulse Engine Optimizer 모드 엔트리포인트.
 */
public class EngineOptimMod implements PulseMod {

    public static final String MOD_ID = "Pulse_engine_optim";

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "Initializing Engine Optimizer...");

        // 설정에 따른 최적화 활성화 상태 로깅
        OptimizationManager.registerOptimization("WorldLoading", EngineOptimConfig.optimizeWorldLoading);
        OptimizationManager.registerOptimization("AIPathfinding", EngineOptimConfig.optimizeAiPathfinding);
        OptimizationManager.registerOptimization("Rendering", EngineOptimConfig.optimizeRendering);

        if (EngineOptimConfig.safeMode) {
            Pulse.warn(MOD_ID, "Safe Mode is ENABLED. Some optimizations may be skipped for stability.");
        }

        Pulse.log(MOD_ID, "Engine Optimizer initialized!");
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\src\main\java\com\pulse\engineoptim\EngineOptimMod.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\src\main\java\com\pulse\engineoptim\OptimizationManager.java =====

package com.pulse.engineoptim;

import com.pulse.api.Pulse;
import java.util.HashSet;
import java.util.Set;

/**
 * 최적화 기능 관리자.
 */
public class OptimizationManager {

    private static final Set<String> activeOptimizations = new HashSet<>();
    private static final Set<String> failedOptimizations = new HashSet<>();

    public static void registerOptimization(String name, boolean enabled) {
        if (enabled) {
            activeOptimizations.add(name);
            Pulse.log("Pulse_engine_optim", "Optimization enabled: " + name);
        } else {
            Pulse.log("Pulse_engine_optim", "Optimization disabled: " + name);
        }
    }

    public static void reportFailure(String name, Throwable t) {
        failedOptimizations.add(name);
        activeOptimizations.remove(name);
        Pulse.error("Pulse_engine_optim", "Optimization failed: " + name, t);

        if (EngineOptimConfig.safeMode) {
            Pulse.warn("Pulse_engine_optim",
                    "SafeMode enabled - potentially dangerous optimizations will be skipped");
        }
    }

    public static boolean isOptimizationActive(String name) {
        return activeOptimizations.contains(name) && !failedOptimizations.contains(name);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\src\main\java\com\pulse\engineoptim\OptimizationManager.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\src\main\resources\mixins.engineoptim.json =====

{
    "required": true,
    "package": "com.pulse.engineoptim.mixin",
    "compatibilityLevel": "JAVA_17",
    "mixins": [],
    "injectors": {
        "defaultRequire": 1
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\src\main\resources\mixins.engineoptim.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\src\main\resources\pulse.mod.json =====

{
    "id": "Pulse_engine_optim",
    "name": "Pulse Engine Optimizer",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Engine-level optimizations for Project Zomboid",
    "entrypoint": "com.pulse.engineoptim.EngineOptimMod",
    "mixins": [
        "mixins.engineoptim.json"
    ],
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-engine-optim\src\main\resources\pulse.mod.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\.gradle =====


===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\bin\main\mixins.luaoptim.json =====

{
    "required": true,
    "package": "com.pulse.luaoptim.mixin",
    "compatibilityLevel": "JAVA_17",
    "mixins": [],
    "injectors": {
        "defaultRequire": 1
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\bin\main\mixins.luaoptim.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\bin\main\pulse.mod.json =====

{
    "id": "Pulse_lua_optim",
    "name": "Pulse Lua Optimizer",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Lua script performance optimization library",
    "entrypoint": "com.pulse.luaoptim.LuaOptimMod",
    "mixins": [
        "mixins.luaoptim.json"
    ],
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\bin\main\pulse.mod.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\build.gradle =====

plugins {
    id 'java'
}

group = 'com.pulse.luaoptim'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven/' }
}

dependencies {
    compileOnly project(':')
    compileOnly 'org.spongepowered:mixin:0.8.5'
    compileOnly fileTree(dir: 'C:/SteamLibrary/steamapps/common/ProjectZomboid', include: ['*.jar'])
}

jar {
    archiveBaseName.set('Pulse-lua-optim')
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    
    from('src/main/resources') {
        include 'pulse.mod.json'
        include 'mixins.luaoptim.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Pulse Lua Optim',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\build.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\settings.gradle =====

rootProject.name = 'Pulse-lua-optim'

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\settings.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\java\com\pulse\luaoptim\LuaCache.java =====

package com.pulse.luaoptim;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Lua 결과 캐싱 유틸리티.
 * 무거운 계산 결과를 재사용.
 */
public class LuaCache {

    private static final Map<String, CacheEntry> cache = new ConcurrentHashMap<>();

    private static class CacheEntry {
        final Object value;
        final long timestamp;

        CacheEntry(Object value) {
            this.value = value;
            this.timestamp = System.currentTimeMillis();
        }
    }

    /**
     * 캐시에서 값 가져오기
     */
    public static Object get(String key, long ttlMs) {
        if (!LuaOptimConfig.enableCaching)
            return null;

        CacheEntry entry = cache.get(key);
        if (entry == null)
            return null;

        if (System.currentTimeMillis() - entry.timestamp > ttlMs) {
            cache.remove(key); // 만료
            return null;
        }

        return entry.value;
    }

    /**
     * 값 캐싱
     */
    public static void put(String key, Object value) {
        if (!LuaOptimConfig.enableCaching)
            return;
        cache.put(key, new CacheEntry(value));
    }

    public static void clear() {
        cache.clear();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\java\com\pulse\luaoptim\LuaCache.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\java\com\pulse\luaoptim\LuaOptimConfig.java =====

package com.pulse.luaoptim;

import com.pulse.config.Config;
import com.pulse.config.ConfigValue;

@Config(modId = "Pulse_lua_optim", fileName = "lua_optim.json")
public class LuaOptimConfig {

    @ConfigValue(key = "enableThrottling", comment = "Enable function call throttling")
    public static boolean enableThrottling = true;

    @ConfigValue(key = "enableCaching", comment = "Enable result caching")
    public static boolean enableCaching = true;

    @ConfigValue(key = "debugMode", comment = "Enable debug logging for lua optimizations")
    public static boolean debugMode = false;
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\java\com\pulse\luaoptim\LuaOptimConfig.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\java\com\pulse\luaoptim\LuaOptimMod.java =====

package com.pulse.luaoptim;

import com.pulse.api.Pulse;
import com.pulse.mod.PulseMod;

public class LuaOptimMod implements PulseMod {

    public static final String MOD_ID = "Pulse_lua_optim";

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "Initializing Lua Optimizer...");

        // 초기화 로직 (필요시 전역 Lua 함수 등록 등)
        if (LuaOptimConfig.debugMode) {
            Pulse.log(MOD_ID, "Debug mode enabled");
        }

        Pulse.log(MOD_ID, "Lua Optimizer initialized!");
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\java\com\pulse\luaoptim\LuaOptimMod.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\java\com\pulse\luaoptim\LuaThrottle.java =====

package com.pulse.luaoptim;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Lua 함수 호출 쓰로틀링 유틸리티.
 * 마지막 실행 시간을 추적하여 너무 자주 호출되는 것을 방지.
 */
public class LuaThrottle {

    private static final Map<String, Long> lastExecutionTime = new ConcurrentHashMap<>();

    /**
     * 해당 키의 함수가 지금 실행 가능한지 확인 (쓰로틀링 체크)
     * 
     * @param key           식별자 (보통 함수 이름)
     * @param minIntervalMs 최소 실행 간격 (밀리초)
     * @return 실행 가능하면 true, 쓰로틀링 걸리면 false
     */
    public static boolean check(String key, long minIntervalMs) {
        if (!LuaOptimConfig.enableThrottling)
            return true;

        long now = System.currentTimeMillis();
        long last = lastExecutionTime.getOrDefault(key, 0L);

        if (now - last >= minIntervalMs) {
            lastExecutionTime.put(key, now);
            return true;
        }

        return false;
    }

    public static void clear() {
        lastExecutionTime.clear();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\java\com\pulse\luaoptim\LuaThrottle.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\resources\mixins.luaoptim.json =====

{
    "required": true,
    "package": "com.pulse.luaoptim.mixin",
    "compatibilityLevel": "JAVA_17",
    "mixins": [],
    "injectors": {
        "defaultRequire": 1
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\resources\mixins.luaoptim.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\resources\pulse.mod.json =====

{
    "id": "Pulse_lua_optim",
    "name": "Pulse Lua Optimizer",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Lua script performance optimization library",
    "entrypoint": "com.pulse.luaoptim.LuaOptimMod",
    "mixins": [
        "mixins.luaoptim.json"
    ],
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-lua-optim\src\main\resources\pulse.mod.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\.gradle =====


===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\bin\main\mixins.profiler.json =====

{
    "required": true,
    "package": "com.pulse.profiler.mixin",
    "compatibilityLevel": "JAVA_17",
    "mixins": [],
    "injectors": {
        "defaultRequire": 1
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\bin\main\mixins.profiler.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\bin\main\pulse.mod.json =====

{
    "id": "Pulse_profiler",
    "name": "Pulse Profiler",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Performance profiling tool for Project Zomboid",
    "entrypoint": "com.pulse.profiler.ProfilerMod",
    "mixins": [
        "mixins.profiler.json"
    ],
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\bin\main\pulse.mod.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\build.gradle =====

plugins {
    id 'java'
}

group = 'com.pulse.profiler'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven/' }
}

dependencies {
    // Pulse API - use project dependency for multi-project build
    compileOnly project(':')
    
    // Mixin
    compileOnly 'org.spongepowered:mixin:0.8.5'
    
    // PZ 게임 코드 (컴파일 전용)
    // compileOnly fileTree(dir: 'C:/SteamLibrary/steamapps/common/ProjectZomboid', include: ['*.jar'])
}

jar {
    archiveBaseName.set('Pulse-profiler')
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    
    from('src/main/resources') {
        include 'pulse.mod.json'
        include 'mixins.profiler.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Pulse Profiler',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\build.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\java\com\pulse\profiler\ProfilerConfig.java =====

package com.pulse.profiler;

import com.pulse.config.Config;
import com.pulse.config.ConfigValue;

/**
 * Profiler 설정.
 */
@Config(modId = "Pulse_profiler", fileName = "profiler.json")
public class ProfilerConfig {

    /**
     * 프로파일러 활성화 여부
     */
    @ConfigValue(key = "enabled", comment = "Enable profiler")
    public static boolean enabled = true;

    /**
     * 통계 로그 출력 간격 (틱 단위)
     */
    @ConfigValue(key = "logInterval", comment = "Statistics log interval in ticks (20 ticks = 1 second)")
    public static int logInterval = 1200; // 1분

    /**
     * 디버그 오버레이 표시 여부
     */
    @ConfigValue(key = "showOverlay", comment = "Show debug overlay")
    public static boolean showOverlay = true;

    /**
     * 상세 로그 출력
     */
    @ConfigValue(key = "verbose", comment = "Verbose logging")
    public static boolean verbose = false;

    /**
     * 최소 로그 시간 (나노초)
     * 이 시간 이상 걸린 구간만 로그
     */
    @ConfigValue(key = "minLogTimeNanos", comment = "Minimum time to log (nanoseconds)")
    public static long minLogTimeNanos = 1_000_000; // 1ms
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\java\com\pulse\profiler\ProfilerConfig.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\java\com\pulse\profiler\ProfilerMod.java =====

package com.pulse.profiler;

import com.pulse.api.Pulse;
import com.pulse.debug.DebugOverlayRegistry;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.mod.PulseMod;

/**
 * Pulse Profiler 모드 엔트리포인트.
 */
public class ProfilerMod implements PulseMod {

    public static final String MOD_ID = "Pulse_profiler";
    private int tickCounter = 0;

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "Initializing Pulse Profiler...");

        // 이벤트 등록
        EventBus.subscribe(GameTickEvent.class, this::onTick, MOD_ID);

        // 디버그 오버레이 등록
        if (ProfilerConfig.showOverlay) {
            DebugOverlayRegistry.register(MOD_ID, new ProfilerOverlay());
        }

        Pulse.log(MOD_ID, "Pulse Profiler initialized!");
    }

    private void onTick(GameTickEvent event) {
        if (!ProfilerConfig.enabled)
            return;

        tickCounter++;

        // 설정된 간격마다 통계 로그 출력
        if (tickCounter >= ProfilerConfig.logInterval) {
            PulseProfiler.logStats();
            tickCounter = 0;

            // 주기적으로 통계 리셋 (선택적)
            // PulseProfiler.reset();
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\java\com\pulse\profiler\ProfilerMod.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\java\com\pulse\profiler\ProfilerOverlay.java =====

package com.pulse.profiler;

import com.pulse.debug.DebugOverlayRenderer;
import com.pulse.debug.DebugRenderContext;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * 프로파일러 디버그 오버레이.
 * 현재 활성화된 프로파일링 섹션의 실시간 통계를 표시.
 */
public class ProfilerOverlay implements DebugOverlayRenderer {

    @Override
    public void render(DebugRenderContext ctx) {
        if (!ProfilerConfig.enabled) {
            ctx.drawLine("Profiler: Disabled");
            return;
        }

        Collection<ProfileSection> sections = PulseProfiler.getAllSections();
        if (sections.isEmpty()) {
            ctx.drawLine("Profiler: No data");
            return;
        }

        ctx.drawLine("Profiler Stats (" + sections.size() + " sections)");

        // 평균 시간 기준 정렬
        List<ProfileSection> sorted = new ArrayList<>(sections);
        sorted.sort((a, b) -> Long.compare(b.getAverageNanos(), a.getAverageNanos()));

        // 상위 10개만 표시
        int count = 0;
        for (ProfileSection section : sorted) {
            if (count++ >= 10)
                break;

            if (section.getCallCount() == 0)
                continue;

            String line = String.format("%s: %.2fms (max: %.2fms)",
                    section.getName(),
                    section.getAverageMs(),
                    section.getMaxNanos() / 1_000_000.0);

            ctx.drawLine(line);
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\java\com\pulse\profiler\ProfilerOverlay.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\java\com\pulse\profiler\ProfileSection.java =====

package com.pulse.profiler;

/**
 * 프로파일 구간 데이터.
 */
public class ProfileSection {

    private final String name;
    private long totalNanos = 0;
    private long callCount = 0;
    private long minNanos = Long.MAX_VALUE;
    private long maxNanos = 0;

    public ProfileSection(String name) {
        this.name = name;
    }

    /**
     * 측정 결과 기록
     */
    public synchronized void record(long elapsedNanos) {
        totalNanos += elapsedNanos;
        callCount++;
        minNanos = Math.min(minNanos, elapsedNanos);
        maxNanos = Math.max(maxNanos, elapsedNanos);
    }

    /**
     * 통계 초기화
     */
    public synchronized void reset() {
        totalNanos = 0;
        callCount = 0;
        minNanos = Long.MAX_VALUE;
        maxNanos = 0;
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public String getName() {
        return name;
    }

    public long getTotalNanos() {
        return totalNanos;
    }

    public long getCallCount() {
        return callCount;
    }

    public long getMinNanos() {
        return callCount > 0 ? minNanos : 0;
    }

    public long getMaxNanos() {
        return maxNanos;
    }

    public long getAverageNanos() {
        return callCount > 0 ? totalNanos / callCount : 0;
    }

    public double getTotalMs() {
        return totalNanos / 1_000_000.0;
    }

    public double getAverageMs() {
        return getAverageNanos() / 1_000_000.0;
    }

    @Override
    public String toString() {
        return String.format("%s: avg=%.3fms, total=%.3fms, calls=%d",
                name, getAverageMs(), getTotalMs(), callCount);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\java\com\pulse\profiler\ProfileSection.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\java\com\pulse\profiler\PulseProfiler.java =====

package com.pulse.profiler;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Pulse 프로파일러 유틸리티.
 * 코드 구간의 실행 시간을 측정.
 * 
 * 사용 예:
 * PulseProfiler.begin("my_section");
 * // ... 코드 ...
 * PulseProfiler.end("my_section");
 * 
 * // 또는 try-with-resources:
 * try (var section = PulseProfiler.section("my_section")) {
 * // ... 코드 ...
 * }
 */
public class PulseProfiler {

    private static final Map<String, ProfileSection> sections = new ConcurrentHashMap<>();
    private static final ThreadLocal<Map<String, Long>> startTimes = ThreadLocal.withInitial(HashMap::new);

    private static boolean enabled = true;

    // ─────────────────────────────────────────────────────────────
    // 프로파일링 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 프로파일 구간 시작
     */
    public static void begin(String name) {
        if (!enabled)
            return;
        startTimes.get().put(name, System.nanoTime());
    }

    /**
     * 프로파일 구간 종료
     */
    public static void end(String name) {
        if (!enabled)
            return;

        Long startTime = startTimes.get().remove(name);
        if (startTime == null) {
            System.err.println("[Pulse/Profiler] end() called without matching begin() for: " + name);
            return;
        }

        long elapsed = System.nanoTime() - startTime;

        ProfileSection section = sections.computeIfAbsent(name, ProfileSection::new);
        section.record(elapsed);
    }

    /**
     * AutoCloseable 프로파일 구간 (try-with-resources 용)
     */
    public static ProfileScope section(String name) {
        begin(name);
        return new ProfileScope(name);
    }

    // ─────────────────────────────────────────────────────────────
    // 통계
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 구간 통계 가져오기
     */
    public static Collection<ProfileSection> getAllSections() {
        return Collections.unmodifiableCollection(sections.values());
    }

    /**
     * 특정 구간 통계 가져오기
     */
    public static ProfileSection getSection(String name) {
        return sections.get(name);
    }

    /**
     * 모든 통계 초기화
     */
    public static void reset() {
        sections.clear();
    }

    /**
     * 통계 로그 출력
     */
    public static void logStats() {
        if (sections.isEmpty()) {
            System.out.println("[Pulse/Profiler] No profiling data collected");
            return;
        }

        System.out.println("[Pulse/Profiler] ═══════════════════════════════════════");
        System.out.println("[Pulse/Profiler] PROFILING STATISTICS");
        System.out.println("[Pulse/Profiler] ═══════════════════════════════════════");

        // 평균 시간 기준 내림차순 정렬
        List<ProfileSection> sorted = new ArrayList<>(sections.values());
        sorted.sort((a, b) -> Long.compare(b.getAverageNanos(), a.getAverageNanos()));

        for (ProfileSection section : sorted) {
            if (section.getCallCount() == 0)
                continue;

            System.out.printf("[Pulse/Profiler] %-30s avg: %8.3fms  total: %10.3fms  calls: %d%n",
                    section.getName(),
                    section.getAverageNanos() / 1_000_000.0,
                    section.getTotalNanos() / 1_000_000.0,
                    section.getCallCount());
        }

        System.out.println("[Pulse/Profiler] ═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // 제어
    // ─────────────────────────────────────────────────────────────

    public static void setEnabled(boolean enable) {
        enabled = enable;
    }

    public static boolean isEnabled() {
        return enabled;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    /**
     * AutoCloseable 프로파일 스코프
     */
    public static class ProfileScope implements AutoCloseable {
        private final String name;

        ProfileScope(String name) {
            this.name = name;
        }

        @Override
        public void close() {
            end(name);
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\java\com\pulse\profiler\PulseProfiler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\resources\mixins.profiler.json =====

{
    "required": true,
    "package": "com.pulse.profiler.mixin",
    "compatibilityLevel": "JAVA_17",
    "mixins": [],
    "injectors": {
        "defaultRequire": 1
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\resources\mixins.profiler.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\resources\pulse.mod.json =====

{
    "id": "Pulse_profiler",
    "name": "Pulse Profiler",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Performance profiling tool for Project Zomboid",
    "entrypoint": "com.pulse.profiler.ProfilerMod",
    "mixins": [
        "mixins.profiler.json"
    ],
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\first-party-mods\pulse-profiler\src\main\resources\pulse.mod.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\settings.gradle =====

rootProject.name = 'Pulse'

include 'first-party-mods:pulse-profiler'
include 'first-party-mods:pulse-engine-optim'
include 'first-party-mods:pulse-lua-optim'

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\settings.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\access\AccessWidener.java =====

package com.pulse.access;

import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 접근 확장기 (Access Widener).
 * 게임 클래스의 private/protected 멤버에 대한 접근을 제공.
 * 
 * Fabric의 Access Widener와 유사하지만 리플렉션 기반으로 런타임에 동작.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 클래스 접근
 * Class<?> clazz = AccessWidener.getClass("zombie.inventory.ItemContainer");
 * 
 * // 필드 접근
 * Object value = AccessWidener.getField(instance, "privateField");
 * AccessWidener.setField(instance, "privateField", newValue);
 * 
 * // 메서드 호출
 * Object result = AccessWidener.invoke(instance, "privateMethod", arg1, arg2);
 * 
 * // 생성자 호출
 * Object instance = AccessWidener.newInstance("zombie.SomeClass", arg1);
 * </pre>
 */
public class AccessWidener {

    private static final AccessWidener INSTANCE = new AccessWidener();

    // 캐시
    private final Map<String, Class<?>> classCache = new ConcurrentHashMap<>();
    private final Map<String, Field> fieldCache = new ConcurrentHashMap<>();
    private final Map<String, Method> methodCache = new ConcurrentHashMap<>();
    private final Map<String, Constructor<?>> constructorCache = new ConcurrentHashMap<>();

    // 게임 클래스로더
    private ClassLoader gameClassLoader;

    private AccessWidener() {
    }

    public static AccessWidener getInstance() {
        return INSTANCE;
    }

    /**
     * 게임 클래스로더 설정
     */
    public static void setGameClassLoader(ClassLoader loader) {
        INSTANCE.gameClassLoader = loader;
    }

    // ─────────────────────────────────────────────────────────────
    // 클래스 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * 클래스 가져오기
     */
    public static Class<?> getClass(String className) {
        return INSTANCE.loadClass(className);
    }

    private Class<?> loadClass(String className) {
        return classCache.computeIfAbsent(className, name -> {
            try {
                ClassLoader loader = gameClassLoader != null ? gameClassLoader : ClassLoader.getSystemClassLoader();
                return loader.loadClass(name);
            } catch (ClassNotFoundException e) {
                System.err.println("[Pulse/Access] Class not found: " + name);
                return null;
            }
        });
    }

    // ─────────────────────────────────────────────────────────────
    // 필드 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * 필드 값 가져오기
     */
    public static Object getField(Object instance, String fieldName) {
        return INSTANCE.getFieldValue(instance, fieldName);
    }

    /**
     * 정적 필드 값 가져오기
     */
    public static Object getStaticField(Class<?> clazz, String fieldName) {
        return INSTANCE.getFieldValue(clazz, null, fieldName);
    }

    /**
     * 정적 필드 값 가져오기 (클래스명)
     */
    public static Object getStaticField(String className, String fieldName) {
        Class<?> clazz = getClass(className);
        if (clazz == null)
            return null;
        return INSTANCE.getFieldValue(clazz, null, fieldName);
    }

    /**
     * 필드 값 설정
     */
    public static void setField(Object instance, String fieldName, Object value) {
        INSTANCE.setFieldValue(instance, fieldName, value);
    }

    /**
     * 정적 필드 값 설정
     */
    public static void setStaticField(Class<?> clazz, String fieldName, Object value) {
        INSTANCE.setFieldValue(clazz, null, fieldName, value);
    }

    private Object getFieldValue(Object instance, String fieldName) {
        if (instance == null)
            return null;
        return getFieldValue(instance.getClass(), instance, fieldName);
    }

    private Object getFieldValue(Class<?> clazz, Object instance, String fieldName) {
        Field field = findField(clazz, fieldName);
        if (field == null)
            return null;

        try {
            return field.get(instance);
        } catch (IllegalAccessException e) {
            System.err.println("[Pulse/Access] Cannot access field: " + fieldName);
            return null;
        }
    }

    private void setFieldValue(Object instance, String fieldName, Object value) {
        if (instance == null)
            return;
        setFieldValue(instance.getClass(), instance, fieldName, value);
    }

    private void setFieldValue(Class<?> clazz, Object instance, String fieldName, Object value) {
        Field field = findField(clazz, fieldName);
        if (field == null)
            return;

        try {
            // final 필드도 수정 가능하게
            if (Modifier.isFinal(field.getModifiers())) {
                Field modifiersField = Field.class.getDeclaredField("modifiers");
                modifiersField.setAccessible(true);
                modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
            }
            field.set(instance, value);
        } catch (Exception e) {
            System.err.println("[Pulse/Access] Cannot set field: " + fieldName);
        }
    }

    private Field findField(Class<?> clazz, String fieldName) {
        String key = clazz.getName() + "#" + fieldName;
        return fieldCache.computeIfAbsent(key, k -> {
            Class<?> current = clazz;
            while (current != null) {
                try {
                    Field field = current.getDeclaredField(fieldName);
                    field.setAccessible(true);
                    return field;
                } catch (NoSuchFieldException e) {
                    current = current.getSuperclass();
                }
            }
            System.err.println("[Pulse/Access] Field not found: " + fieldName);
            return null;
        });
    }

    // ─────────────────────────────────────────────────────────────
    // 메서드 호출
    // ─────────────────────────────────────────────────────────────

    /**
     * 메서드 호출
     */
    public static Object invoke(Object instance, String methodName, Object... args) {
        return INSTANCE.invokeMethod(instance, methodName, args);
    }

    /**
     * 정적 메서드 호출
     */
    public static Object invokeStatic(Class<?> clazz, String methodName, Object... args) {
        return INSTANCE.invokeMethod(clazz, null, methodName, args);
    }

    /**
     * 정적 메서드 호출 (클래스명)
     */
    public static Object invokeStatic(String className, String methodName, Object... args) {
        Class<?> clazz = getClass(className);
        if (clazz == null)
            return null;
        return INSTANCE.invokeMethod(clazz, null, methodName, args);
    }

    private Object invokeMethod(Object instance, String methodName, Object... args) {
        if (instance == null)
            return null;
        return invokeMethod(instance.getClass(), instance, methodName, args);
    }

    private Object invokeMethod(Class<?> clazz, Object instance, String methodName, Object... args) {
        Method method = findMethod(clazz, methodName, args);
        if (method == null)
            return null;

        try {
            return method.invoke(instance, args);
        } catch (Exception e) {
            System.err.println("[Pulse/Access] Cannot invoke method: " + methodName);
            e.printStackTrace();
            return null;
        }
    }

    private Method findMethod(Class<?> clazz, String methodName, Object... args) {
        // 간단한 캐시 키 생성
        StringBuilder keyBuilder = new StringBuilder(clazz.getName());
        keyBuilder.append("#").append(methodName).append("(");
        for (Object arg : args) {
            if (arg != null) {
                keyBuilder.append(arg.getClass().getName()).append(",");
            } else {
                keyBuilder.append("null,");
            }
        }
        keyBuilder.append(")");
        String key = keyBuilder.toString();

        return methodCache.computeIfAbsent(key, k -> {
            Class<?> current = clazz;
            while (current != null) {
                for (Method method : current.getDeclaredMethods()) {
                    if (method.getName().equals(methodName) &&
                            isCompatible(method.getParameterTypes(), args)) {
                        method.setAccessible(true);
                        return method;
                    }
                }
                current = current.getSuperclass();
            }
            System.err.println("[Pulse/Access] Method not found: " + methodName);
            return null;
        });
    }

    private boolean isCompatible(Class<?>[] paramTypes, Object[] args) {
        if (paramTypes.length != args.length)
            return false;
        for (int i = 0; i < paramTypes.length; i++) {
            if (args[i] != null && !isAssignable(paramTypes[i], args[i].getClass())) {
                return false;
            }
        }
        return true;
    }

    private boolean isAssignable(Class<?> target, Class<?> source) {
        if (target.isAssignableFrom(source))
            return true;
        // 기본형 처리
        if (target.isPrimitive()) {
            if (target == int.class && source == Integer.class)
                return true;
            if (target == long.class && source == Long.class)
                return true;
            if (target == double.class && source == Double.class)
                return true;
            if (target == float.class && source == Float.class)
                return true;
            if (target == boolean.class && source == Boolean.class)
                return true;
            if (target == byte.class && source == Byte.class)
                return true;
            if (target == short.class && source == Short.class)
                return true;
            if (target == char.class && source == Character.class)
                return true;
        }
        return false;
    }

    // ─────────────────────────────────────────────────────────────
    // 생성자
    // ─────────────────────────────────────────────────────────────

    /**
     * 인스턴스 생성
     */
    public static Object newInstance(String className, Object... args) {
        Class<?> clazz = getClass(className);
        if (clazz == null)
            return null;
        return INSTANCE.createInstance(clazz, args);
    }

    /**
     * 인스턴스 생성
     */
    public static Object newInstance(Class<?> clazz, Object... args) {
        return INSTANCE.createInstance(clazz, args);
    }

    private Object createInstance(Class<?> clazz, Object... args) {
        try {
            if (args.length == 0) {
                Constructor<?> constructor = clazz.getDeclaredConstructor();
                constructor.setAccessible(true);
                return constructor.newInstance();
            }

            // 적합한 생성자 찾기
            for (Constructor<?> constructor : clazz.getDeclaredConstructors()) {
                if (isCompatible(constructor.getParameterTypes(), args)) {
                    constructor.setAccessible(true);
                    return constructor.newInstance(args);
                }
            }

            System.err.println("[Pulse/Access] No matching constructor found");
            return null;
        } catch (Exception e) {
            System.err.println("[Pulse/Access] Cannot create instance of: " + clazz.getName());
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 캐시 비우기
     */
    public static void clearCache() {
        INSTANCE.classCache.clear();
        INSTANCE.fieldCache.clear();
        INSTANCE.methodCache.clear();
        INSTANCE.constructorCache.clear();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\access\AccessWidener.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\CapabilityFlags.java =====

package com.pulse.api;

import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Pulse 기능 지원 여부 체크 API.
 * Fuse/Nerve 등 모드가 런타임에 Pulse 버전과 기능 지원 여부를 확인할 수 있습니다.
 * 
 * <pre>
 * // 사용 예시
 * if (CapabilityFlags.supports(CapabilityFlags.LUA_BUDGET)) {
 *     // LuaBudgetManager 사용 가능
 *     LuaBudgetManager.getInstance().setBudget("mymod.tick", 5000);
 * }
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1")
public final class CapabilityFlags {

    // ═══════════════════════════════════════════════════════════════
    // 기본 제공 기능 상수
    // ═══════════════════════════════════════════════════════════════

    /** OptimizationPoint 시스템 지원 */
    public static final String OPTIMIZATION_POINT = "PULSE_OPTIMIZATION_POINT";

    /** LuaBridge V2 (확장 API) 지원 */
    public static final String LUA_BRIDGE_V2 = "LUA_BRIDGE_V2";

    /** Mixin Injection Validator 지원 */
    public static final String MIXIN_VALIDATOR = "MIXIN_INJECTION_VALIDATOR";

    /** Lua Budget Manager 지원 */
    public static final String LUA_BUDGET = "LUA_BUDGET_MANAGER";

    /** SafeGameAccess 지원 */
    public static final String SAFE_GAME_ACCESS = "SAFE_GAME_ACCESS";

    /** Echo 프로파일러 통합 */
    public static final String ECHO_INTEGRATION = "ECHO_INTEGRATION";

    /** DevMode 지원 */
    public static final String DEV_MODE = "DEV_MODE";

    // ═══════════════════════════════════════════════════════════════
    // 내부 상태
    // ═══════════════════════════════════════════════════════════════

    private static final Set<String> capabilities = ConcurrentHashMap.newKeySet();
    private static volatile boolean initialized = false;

    private CapabilityFlags() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // 초기화
    // ═══════════════════════════════════════════════════════════════

    /**
     * 기능 플래그 초기화 (Pulse 시작 시 자동 호출).
     */
    @InternalAPI
    public static void initialize() {
        if (initialized)
            return;

        // 1.0.1에서 지원하는 모든 기능 등록
        register(OPTIMIZATION_POINT);
        register(LUA_BRIDGE_V2);
        register(MIXIN_VALIDATOR);
        register(LUA_BUDGET);
        register(SAFE_GAME_ACCESS);
        register(DEV_MODE);

        // Echo는 별도 모드로 로드되므로 여기서는 등록하지 않음
        // Echo가 로드되면 Echo에서 ECHO_INTEGRATION을 등록

        initialized = true;
        System.out.println("[Pulse] CapabilityFlags initialized: " + capabilities.size() + " capabilities");
    }

    // ═══════════════════════════════════════════════════════════════
    // 공개 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 기능 지원 여부 확인.
     * 
     * @param capability 기능 이름 (예: "PULSE_OPTIMIZATION_POINT")
     * @return 지원하면 true
     */
    public static boolean supports(String capability) {
        if (!initialized)
            initialize();
        return capabilities.contains(capability);
    }

    /**
     * 여러 기능이 모두 지원되는지 확인.
     * 
     * @param requiredCapabilities 필요한 기능 목록
     * @return 모두 지원하면 true
     */
    public static boolean supportsAll(String... requiredCapabilities) {
        for (String cap : requiredCapabilities) {
            if (!supports(cap))
                return false;
        }
        return true;
    }

    /**
     * 여러 기능 중 하나라도 지원되는지 확인.
     * 
     * @param capabilities 기능 목록
     * @return 하나라도 지원하면 true
     */
    public static boolean supportsAny(String... capabilities) {
        for (String cap : capabilities) {
            if (supports(cap))
                return true;
        }
        return false;
    }

    /**
     * 지원되는 모든 기능 목록 반환.
     * 
     * @return 불변 Set
     */
    public static Set<String> getAllCapabilities() {
        if (!initialized)
            initialize();
        return Collections.unmodifiableSet(capabilities);
    }

    /**
     * 지원되는 기능 수.
     * 
     * @return 기능 수
     */
    public static int count() {
        if (!initialized)
            initialize();
        return capabilities.size();
    }

    // ═══════════════════════════════════════════════════════════════
    // 내부 API (모드 사용 불가)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 기능 등록 (내부용).
     * 
     * @param capability 기능 이름
     */
    @InternalAPI
    public static void register(String capability) {
        if (capability != null && !capability.isEmpty()) {
            capabilities.add(capability);
        }
    }

    /**
     * 기능 등록 해제 (내부용).
     * 
     * @param capability 기능 이름
     */
    @InternalAPI
    public static void unregister(String capability) {
        capabilities.remove(capability);
    }

    /**
     * 디버그 출력.
     */
    public static void printCapabilities() {
        System.out.println("═══════════════════════════════════════");
        System.out.println("  Pulse Capabilities (" + capabilities.size() + ")");
        System.out.println("═══════════════════════════════════════");
        for (String cap : capabilities) {
            System.out.println("  ✓ " + cap);
        }
        System.out.println("═══════════════════════════════════════");
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\CapabilityFlags.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\DevMode.java =====

package com.pulse.api;

/**
 * Pulse DevMode 관리자.
 * 개발 모드 플래그를 관리하고 디버그 기능을 제어.
 * 
 * 활성화 방법:
 * 1. JVM 옵션: -DPulse.devMode=true
 * 2. 코드에서: DevMode.enable()
 * 
 * DevMode가 활성화되면:
 * - 상세한 Mixin 진단 로그 출력
 * - 이벤트 예외 세부 정보 출력
 * - 의존성 문제 추가 정보 출력
 */
public final class DevMode {

    private static boolean enabled = false;
    private static boolean initialized = false;

    private DevMode() {
    } // 인스턴스화 방지

    // ─────────────────────────────────────────────────────────────
    // 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 시스템 프로퍼티에서 DevMode 상태 초기화
     */
    public static void initialize() {
        if (initialized)
            return;

        // 시스템 프로퍼티 확인
        String devModeProp = System.getProperty("Pulse.devMode", "false");
        enabled = "true".equalsIgnoreCase(devModeProp) || "1".equals(devModeProp);

        if (enabled) {
            System.out.println("[Pulse/DevMode] ═══════════════════════════════════════");
            System.out.println("[Pulse/DevMode] DEVELOPER MODE ENABLED");
            System.out.println("[Pulse/DevMode] Additional diagnostics will be shown");
            System.out.println("[Pulse/DevMode] ═══════════════════════════════════════");
        }

        initialized = true;
    }

    // ─────────────────────────────────────────────────────────────
    // 상태 관리
    // ─────────────────────────────────────────────────────────────

    /**
     * DevMode 활성화 여부 확인
     */
    public static boolean isEnabled() {
        if (!initialized) {
            initialize();
        }
        return enabled;
    }

    /**
     * DevMode 활성화
     */
    public static void enable() {
        enabled = true;
        if (!initialized) {
            initialized = true;
            System.out.println("[Pulse/DevMode] Developer mode enabled programmatically");
        }
    }

    /**
     * DevMode 비활성화
     */
    public static void disable() {
        enabled = false;
    }

    // ─────────────────────────────────────────────────────────────
    // 편의 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * DevMode일 때만 로그 출력
     */
    public static void log(String tag, String message) {
        if (isEnabled()) {
            System.out.println("[Pulse/Debug/" + tag + "] " + message);
        }
    }

    /**
     * DevMode일 때만 실행할 작업
     */
    public static void ifEnabled(Runnable action) {
        if (isEnabled()) {
            action.run();
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\DevMode.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\Experimental.java =====

package com.pulse.api;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 실험적 기능 마커.
 * 이 어노테이션이 붙은 API는 실험적이며 언제든 변경될 수 있음.
 * 
 * 사용 예:
 * 
 * <pre>
 * &#64;Experimental("Hot reload may cause memory leaks")
 * public void hotReload() { ... }
 * </pre>
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD })
public @interface Experimental {

    /**
     * 실험적인 이유 또는 주의사항.
     */
    String value() default "";

    /**
     * 안정화 예정 버전.
     */
    String targetVersion() default "";
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\Experimental.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\GameAccess.java =====

package com.pulse.api;

import com.pulse.PulseEnvironment;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * 게임 내부 접근 API.
 * 리플렉션을 사용하여 게임 코드에 접근.
 * 게임 버전 변경에 유연하게 대응 가능.
 */
public final class GameAccess {

    private GameAccess() {
    }

    // 캐시된 클래스/메서드/필드 참조
    private static Class<?> isoWorldClass;
    private static Class<?> isoPlayerClass;
    private static Class<?> gameTimeClass;
    private static Class<?> gameClientClass;
    private static Class<?> gameServerClass;
    private static Class<?> coreClass;

    @SuppressWarnings("unused") // Used in refresh() and for future caching
    private static Object cachedIsoWorldInstance;
    private static boolean classesInitialized = false;

    // ─────────────────────────────────────────────────────────────
    // 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 게임 클래스 초기화 (lazy loading)
     */
    private static void ensureInitialized() {
        if (classesInitialized)
            return;

        ClassLoader gameLoader = PulseEnvironment.getGameClassLoader();
        if (gameLoader == null) {
            // 아직 게임 클래스 로더가 없으면 시스템 클래스 로더 사용
            gameLoader = ClassLoader.getSystemClassLoader();
        }

        try {
            isoWorldClass = gameLoader.loadClass("zombie.iso.IsoWorld");
        } catch (ClassNotFoundException e) {
            // 무시 - 아직 로드되지 않음
        }

        try {
            isoPlayerClass = gameLoader.loadClass("zombie.characters.IsoPlayer");
        } catch (ClassNotFoundException e) {
            // 무시
        }

        try {
            gameTimeClass = gameLoader.loadClass("zombie.GameTime");
        } catch (ClassNotFoundException e) {
            // 무시
        }

        try {
            gameClientClass = gameLoader.loadClass("zombie.network.GameClient");
        } catch (ClassNotFoundException e) {
            // 무시
        }

        try {
            gameServerClass = gameLoader.loadClass("zombie.network.GameServer");
        } catch (ClassNotFoundException e) {
            // 무시
        }

        try {
            coreClass = gameLoader.loadClass("zombie.core.Core");
        } catch (ClassNotFoundException e) {
            // 무시
        }

        classesInitialized = true;
    }

    /**
     * 게임 클래스 참조 갱신 (게임 클래스 로더 변경 시 호출)
     */
    public static void refresh() {
        classesInitialized = false;
        cachedIsoWorldInstance = null;
        ensureInitialized();
    }

    // ─────────────────────────────────────────────────────────────
    // 월드
    // ─────────────────────────────────────────────────────────────

    /**
     * IsoWorld 인스턴스 가져오기
     */
    private static Object getIsoWorldInstance() {
        ensureInitialized();
        if (isoWorldClass == null)
            return null;

        try {
            // zombie.iso.IsoWorld.instance 필드 접근
            Field instanceField = isoWorldClass.getDeclaredField("instance");
            instanceField.setAccessible(true);
            return instanceField.get(null);
        } catch (Exception e) {
            // 대안: getInstance() 메서드 시도
            try {
                Method getInstance = isoWorldClass.getMethod("getInstance");
                return getInstance.invoke(null);
            } catch (Exception e2) {
                return null;
            }
        }
    }

    /**
     * 현재 월드가 로드되었는지 확인
     */
    public static boolean isWorldLoaded() {
        return getIsoWorldInstance() != null;
    }

    /**
     * 현재 월드 이름
     */
    public static String getWorldName() {
        Object world = getIsoWorldInstance();
        if (world == null)
            return "";

        try {
            Method getWorld = isoWorldClass.getMethod("getWorld");
            Object result = getWorld.invoke(world);
            return result != null ? result.toString() : "";
        } catch (Exception e) {
            return "";
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 플레이어
    // ─────────────────────────────────────────────────────────────

    /**
     * 로컬 플레이어 가져오기
     */
    public static Object getLocalPlayer() {
        ensureInitialized();
        if (isoPlayerClass == null)
            return null;

        try {
            // IsoPlayer.getInstance() 시도
            Method getInstance = isoPlayerClass.getMethod("getInstance");
            return getInstance.invoke(null);
        } catch (Exception e) {
            // 대안: IsoPlayer.players.get(0) 시도
            try {
                Field playersField = isoPlayerClass.getDeclaredField("players");
                playersField.setAccessible(true);
                Object players = playersField.get(null);
                if (players instanceof java.util.List<?> list && !list.isEmpty()) {
                    return list.get(0);
                }
            } catch (Exception e2) {
                // 무시
            }
            return null;
        }
    }

    /**
     * 플레이어가 살아있는지 확인
     */
    public static boolean isPlayerAlive() {
        Object player = getLocalPlayer();
        if (player == null)
            return false;

        try {
            // isDead() 메서드 호출
            Method isDead = player.getClass().getMethod("isDead");
            Object result = isDead.invoke(player);
            return result instanceof Boolean b && !b;
        } catch (Exception e) {
            // 플레이어 객체가 있으면 살아있다고 가정
            return true;
        }
    }

    /**
     * 플레이어 체력 가져오기
     */
    public static float getPlayerHealth() {
        Object player = getLocalPlayer();
        if (player == null)
            return 0;

        try {
            Method getHealth = player.getClass().getMethod("getHealth");
            Object result = getHealth.invoke(player);
            if (result instanceof Number num) {
                return num.floatValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 플레이어 위치 X
     */
    public static float getPlayerX() {
        Object player = getLocalPlayer();
        if (player == null)
            return 0;

        try {
            Method getX = player.getClass().getMethod("getX");
            Object result = getX.invoke(player);
            if (result instanceof Number num) {
                return num.floatValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 플레이어 위치 Y
     */
    public static float getPlayerY() {
        Object player = getLocalPlayer();
        if (player == null)
            return 0;

        try {
            Method getY = player.getClass().getMethod("getY");
            Object result = getY.invoke(player);
            if (result instanceof Number num) {
                return num.floatValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 플레이어 위치 Z (층)
     */
    public static float getPlayerZ() {
        Object player = getLocalPlayer();
        if (player == null)
            return 0;

        try {
            Method getZ = player.getClass().getMethod("getZ");
            Object result = getZ.invoke(player);
            if (result instanceof Number num) {
                return num.floatValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    // ─────────────────────────────────────────────────────────────
    // 시간
    // ─────────────────────────────────────────────────────────────

    /**
     * GameTime 인스턴스 가져오기
     */
    private static Object getGameTimeInstance() {
        ensureInitialized();
        if (gameTimeClass == null)
            return null;

        try {
            Method getInstance = gameTimeClass.getMethod("getInstance");
            return getInstance.invoke(null);
        } catch (Exception e) {
            // 대안: instance 필드 접근
            try {
                Field instanceField = gameTimeClass.getDeclaredField("instance");
                instanceField.setAccessible(true);
                return instanceField.get(null);
            } catch (Exception e2) {
                return null;
            }
        }
    }

    /**
     * 게임 내 시간 (시)
     */
    public static int getGameHour() {
        Object gameTime = getGameTimeInstance();
        if (gameTime == null)
            return 0;

        try {
            Method getHour = gameTimeClass.getMethod("getHour");
            Object result = getHour.invoke(gameTime);
            if (result instanceof Number num) {
                return num.intValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 게임 내 분
     */
    public static int getGameMinute() {
        Object gameTime = getGameTimeInstance();
        if (gameTime == null)
            return 0;

        try {
            Method getMinutes = gameTimeClass.getMethod("getMinutes");
            Object result = getMinutes.invoke(gameTime);
            if (result instanceof Number num) {
                return num.intValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 게임 내 일수
     */
    public static int getGameDay() {
        Object gameTime = getGameTimeInstance();
        if (gameTime == null)
            return 1;

        try {
            Method getDay = gameTimeClass.getMethod("getDay");
            Object result = getDay.invoke(gameTime);
            if (result instanceof Number num) {
                return num.intValue();
            }
        } catch (Exception e) {
            // 대안: NightsSurvived + 1
            try {
                Method getNights = gameTimeClass.getMethod("getNightsSurvived");
                Object result = getNights.invoke(gameTime);
                if (result instanceof Number num) {
                    return num.intValue() + 1;
                }
            } catch (Exception e2) {
                // 무시
            }
        }
        return 1;
    }

    /**
     * 게임 내 월
     */
    public static int getGameMonth() {
        Object gameTime = getGameTimeInstance();
        if (gameTime == null)
            return 7; // 기본값: 7월

        try {
            Method getMonth = gameTimeClass.getMethod("getMonth");
            Object result = getMonth.invoke(gameTime);
            if (result instanceof Number num) {
                return num.intValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 7;
    }

    /**
     * 게임 내 연도
     */
    public static int getGameYear() {
        Object gameTime = getGameTimeInstance();
        if (gameTime == null)
            return 1993; // 기본값

        try {
            Method getYear = gameTimeClass.getMethod("getYear");
            Object result = getYear.invoke(gameTime);
            if (result instanceof Number num) {
                return num.intValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 1993;
    }

    /**
     * 밤인지 확인
     */
    public static boolean isNight() {
        int hour = getGameHour();
        return hour < 6 || hour >= 21;
    }

    /**
     * 낮인지 확인
     */
    public static boolean isDay() {
        return !isNight();
    }

    // ─────────────────────────────────────────────────────────────
    // 게임 상태
    // ─────────────────────────────────────────────────────────────

    /**
     * 게임 일시정지 상태인지 확인
     */
    public static boolean isPaused() {
        ensureInitialized();

        // Core.getInstance().isGamePaused() 시도
        if (coreClass != null) {
            try {
                Method getInstance = coreClass.getMethod("getInstance");
                Object core = getInstance.invoke(null);
                if (core != null) {
                    Method isGamePaused = coreClass.getMethod("isGamePaused");
                    Object result = isGamePaused.invoke(core);
                    if (result instanceof Boolean b) {
                        return b;
                    }
                }
            } catch (Exception e) {
                // 무시
            }
        }

        // 대안: UIManager.bSuspend 확인
        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            Class<?> uiManagerClass = loader.loadClass("zombie.ui.UIManager");
            Field suspendField = uiManagerClass.getDeclaredField("bSuspend");
            suspendField.setAccessible(true);
            Object result = suspendField.get(null);
            if (result instanceof Boolean b) {
                return b;
            }
        } catch (Exception e) {
            // 무시
        }

        return false;
    }

    /**
     * 멀티플레이어인지 확인
     */
    public static boolean isMultiplayer() {
        ensureInitialized();

        // GameClient.bClient 확인
        if (gameClientClass != null) {
            try {
                Field bClientField = gameClientClass.getDeclaredField("bClient");
                bClientField.setAccessible(true);
                Object result = bClientField.get(null);
                if (result instanceof Boolean b && b) {
                    return true;
                }
            } catch (Exception e) {
                // 무시
            }
        }

        // GameServer.bServer 확인
        if (gameServerClass != null) {
            try {
                Field bServerField = gameServerClass.getDeclaredField("bServer");
                bServerField.setAccessible(true);
                Object result = bServerField.get(null);
                if (result instanceof Boolean b && b) {
                    return true;
                }
            } catch (Exception e) {
                // 무시
            }
        }

        return false;
    }

    /**
     * 서버인지 확인 (멀티플레이어)
     */
    public static boolean isServer() {
        ensureInitialized();

        if (gameServerClass != null) {
            try {
                Field bServerField = gameServerClass.getDeclaredField("bServer");
                bServerField.setAccessible(true);
                Object result = bServerField.get(null);
                if (result instanceof Boolean b) {
                    return b;
                }
            } catch (Exception e) {
                // 무시
            }
        }

        return false;
    }

    /**
     * 클라이언트인지 확인 (멀티플레이어)
     */
    public static boolean isClient() {
        ensureInitialized();

        if (gameClientClass != null) {
            try {
                Field bClientField = gameClientClass.getDeclaredField("bClient");
                bClientField.setAccessible(true);
                Object result = bClientField.get(null);
                if (result instanceof Boolean b) {
                    return b;
                }
            } catch (Exception e) {
                // 무시
            }
        }

        return false;
    }

    /**
     * 싱글플레이어인지 확인
     */
    public static boolean isSinglePlayer() {
        return !isMultiplayer();
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 리플렉션으로 정적 필드 값 가져오기
     */
    public static Object getStaticField(String className, String fieldName) {
        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            Class<?> clazz = loader.loadClass(className);
            Field field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
            return field.get(null);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 리플렉션으로 정적 메서드 호출
     */
    public static Object invokeStaticMethod(String className, String methodName, Object... args) {
        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            Class<?> clazz = loader.loadClass(className);

            // 인자 없는 메서드
            if (args.length == 0) {
                Method method = clazz.getMethod(methodName);
                return method.invoke(null);
            }

            // 인자 타입 추론
            Class<?>[] argTypes = new Class<?>[args.length];
            for (int i = 0; i < args.length; i++) {
                argTypes[i] = args[i] != null ? args[i].getClass() : Object.class;
            }

            Method method = clazz.getMethod(methodName, argTypes);
            return method.invoke(null, args);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 게임 클래스 로드
     */
    public static Class<?> getGameClass(String className) {
        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();
            return loader.loadClass(className);
        } catch (ClassNotFoundException e) {
            return null;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 좀비
    // ─────────────────────────────────────────────────────────────

    /**
     * 특정 위치 주변의 좀비 목록 가져오기
     * 
     * @param x      중심 X 좌표
     * @param y      중심 Y 좌표
     * @param radius 반경
     * @return 좀비 객체 리스트 (IsoZombie)
     */
    public static java.util.List<Object> getNearbyZombies(float x, float y, float radius) {
        java.util.List<Object> result = new java.util.ArrayList<>();
        ensureInitialized();

        try {
            // IsoWorld.instance.getCell().getZombieList() 접근
            Object world = getIsoWorldInstance();
            if (world == null)
                return result;

            Method getCellMethod = isoWorldClass.getMethod("getCell");
            Object cell = getCellMethod.invoke(world);
            if (cell == null)
                return result;

            Method getZombieListMethod = cell.getClass().getMethod("getZombieList");
            Object zombieList = getZombieListMethod.invoke(cell);

            if (zombieList instanceof java.util.List<?> list) {
                for (Object zombie : list) {
                    if (zombie == null)
                        continue;
                    try {
                        Method getX = zombie.getClass().getMethod("getX");
                        Method getY = zombie.getClass().getMethod("getY");
                        float zx = ((Number) getX.invoke(zombie)).floatValue();
                        float zy = ((Number) getY.invoke(zombie)).floatValue();

                        float dx = zx - x;
                        float dy = zy - y;
                        if (dx * dx + dy * dy <= radius * radius) {
                            result.add(zombie);
                        }
                    } catch (Exception e) {
                        // 개별 좀비 처리 실패 무시
                    }
                }
            }
        } catch (Exception e) {
            // 무시
        }

        return result;
    }

    /**
     * 현재 셀의 모든 좀비 목록 가져오기
     */
    public static java.util.List<Object> getAllZombies() {
        java.util.List<Object> result = new java.util.ArrayList<>();
        ensureInitialized();

        try {
            Object world = getIsoWorldInstance();
            if (world == null)
                return result;

            Method getCellMethod = isoWorldClass.getMethod("getCell");
            Object cell = getCellMethod.invoke(world);
            if (cell == null)
                return result;

            Method getZombieListMethod = cell.getClass().getMethod("getZombieList");
            Object zombieList = getZombieListMethod.invoke(cell);

            if (zombieList instanceof java.util.List<?> list) {
                for (Object zombie : list) {
                    if (zombie != null) {
                        result.add(zombie);
                    }
                }
            }
        } catch (Exception e) {
            // 무시
        }

        return result;
    }

    /**
     * 현재 셀의 좀비 수
     */
    public static int getZombieCount() {
        return getAllZombies().size();
    }

    // ─────────────────────────────────────────────────────────────
    // 아이템 / 인벤토리
    // ─────────────────────────────────────────────────────────────

    /**
     * 아이템 생성
     * 
     * @param itemType 아이템 타입 (예: "Base.Axe", "Base.Apple")
     * @return 생성된 InventoryItem 또는 null
     */
    public static Object createItem(String itemType) {
        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            Class<?> instanceManagerClass = loader.loadClass("zombie.inventory.InventoryItemFactory");
            Method createMethod = instanceManagerClass.getMethod("CreateItem", String.class);
            return createMethod.invoke(null, itemType);
        } catch (Exception e) {
            System.err.println("[Pulse/GameAccess] Failed to create item: " + itemType);
            return null;
        }
    }

    /**
     * 월드에 아이템 스폰
     * 
     * @param itemType 아이템 타입
     * @param x        X 좌표
     * @param y        Y 좌표
     * @param z        Z 좌표 (층)
     * @return 스폰된 아이템 또는 null
     */
    public static Object spawnItem(String itemType, float x, float y, float z) {
        Object item = createItem(itemType);
        if (item == null)
            return null;

        try {
            Object square = getSquare((int) x, (int) y, (int) z);
            if (square == null)
                return null;

            Method addItemMethod = square.getClass().getMethod("AddWorldInventoryItem",
                    item.getClass().getSuperclass(), float.class, float.class, float.class);
            addItemMethod.invoke(square, item, x % 1, y % 1, 0f);
            return item;
        } catch (Exception e) {
            System.err.println("[Pulse/GameAccess] Failed to spawn item: " + e.getMessage());
            return null;
        }
    }

    /**
     * 플레이어 인벤토리 아이템 목록
     */
    public static java.util.List<Object> getInventoryItems(Object player) {
        java.util.List<Object> result = new java.util.ArrayList<>();
        if (player == null)
            return result;

        try {
            Method getInventoryMethod = player.getClass().getMethod("getInventory");
            Object inventory = getInventoryMethod.invoke(player);
            if (inventory == null)
                return result;

            Method getItemsMethod = inventory.getClass().getMethod("getItems");
            Object items = getItemsMethod.invoke(inventory);

            if (items instanceof java.util.ArrayList<?> list) {
                result.addAll(list);
            }
        } catch (Exception e) {
            // 무시
        }

        return result;
    }

    /**
     * 플레이어 인벤토리에 아이템 추가
     */
    public static boolean addInventoryItem(Object player, Object item) {
        if (player == null || item == null)
            return false;

        try {
            Method getInventoryMethod = player.getClass().getMethod("getInventory");
            Object inventory = getInventoryMethod.invoke(player);
            if (inventory == null)
                return false;

            Method addItemMethod = inventory.getClass().getMethod("AddItem", item.getClass().getSuperclass());
            addItemMethod.invoke(inventory, item);
            return true;
        } catch (Exception e) {
            System.err.println("[Pulse/GameAccess] Failed to add item to inventory");
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 그리드 / 월드
    // ─────────────────────────────────────────────────────────────

    /**
     * 특정 좌표의 그리드 스퀘어 가져오기
     */
    public static Object getSquare(int x, int y, int z) {
        ensureInitialized();

        try {
            Object world = getIsoWorldInstance();
            if (world == null)
                return null;

            Method getCellMethod = isoWorldClass.getMethod("getCell");
            Object cell = getCellMethod.invoke(world);
            if (cell == null)
                return null;

            Method getGridSquareMethod = cell.getClass().getMethod("getGridSquare", int.class, int.class, int.class);
            return getGridSquareMethod.invoke(cell, x, y, z);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 특정 좌표의 건물 가져오기
     */
    public static Object getBuilding(int x, int y) {
        Object square = getSquare(x, y, 0);
        if (square == null)
            return null;

        try {
            Method getBuildingMethod = square.getClass().getMethod("getBuilding");
            return getBuildingMethod.invoke(square);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 범위 내 차량 목록
     */
    public static java.util.List<Object> getVehiclesInRange(float x, float y, float radius) {
        java.util.List<Object> result = new java.util.ArrayList<>();
        ensureInitialized();

        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            Class<?> vehicleManagerClass = loader.loadClass("zombie.vehicles.VehicleManager");
            Method getInstanceMethod = vehicleManagerClass.getMethod("instance");
            Object manager = getInstanceMethod.invoke(null);

            if (manager == null)
                return result;

            Method getVehiclesMethod = vehicleManagerClass.getMethod("getVehicles");
            Object vehicles = getVehiclesMethod.invoke(manager);

            if (vehicles instanceof java.util.ArrayList<?> list) {
                for (Object vehicle : list) {
                    if (vehicle == null)
                        continue;
                    try {
                        Method getX = vehicle.getClass().getMethod("getX");
                        Method getY = vehicle.getClass().getMethod("getY");
                        float vx = ((Number) getX.invoke(vehicle)).floatValue();
                        float vy = ((Number) getY.invoke(vehicle)).floatValue();

                        float dx = vx - x;
                        float dy = vy - y;
                        if (dx * dx + dy * dy <= radius * radius) {
                            result.add(vehicle);
                        }
                    } catch (Exception e) {
                        // 개별 차량 처리 실패 무시
                    }
                }
            }
        } catch (Exception e) {
            // 무시
        }

        return result;
    }

    /**
     * 현재 셀 가져오기
     */
    public static Object getCell() {
        ensureInitialized();

        try {
            Object world = getIsoWorldInstance();
            if (world == null)
                return null;

            Method getCellMethod = isoWorldClass.getMethod("getCell");
            return getCellMethod.invoke(world);
        } catch (Exception e) {
            return null;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 사운드 / 이펙트
    // ─────────────────────────────────────────────────────────────

    /**
     * 특정 위치에서 사운드 재생
     */
    public static void playSound(String soundName, float x, float y, float z) {
        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            // zombie.core.audio.BaseSoundManager 사용
            Class<?> soundManagerClass = loader.loadClass("zombie.core.audio.BaseSoundManager");
            Method getInstanceMethod = soundManagerClass.getMethod("instance");
            Object manager = getInstanceMethod.invoke(null);

            if (manager == null)
                return;

            Method playMethod = soundManagerClass.getMethod("playSound", String.class, float.class, float.class,
                    float.class);
            playMethod.invoke(manager, soundName, x, y, z);
        } catch (Exception e) {
            System.err.println("[Pulse/GameAccess] Failed to play sound: " + soundName);
        }
    }

    /**
     * 그리드 스퀘어에서 사운드 재생
     */
    public static void playWorldSound(String soundName, Object gridSquare) {
        if (gridSquare == null)
            return;

        try {
            Method getXMethod = gridSquare.getClass().getMethod("getX");
            Method getYMethod = gridSquare.getClass().getMethod("getY");
            Method getZMethod = gridSquare.getClass().getMethod("getZ");

            float x = ((Number) getXMethod.invoke(gridSquare)).floatValue();
            float y = ((Number) getYMethod.invoke(gridSquare)).floatValue();
            float z = ((Number) getZMethod.invoke(gridSquare)).floatValue();

            playSound(soundName, x, y, z);
        } catch (Exception e) {
            System.err.println("[Pulse/GameAccess] Failed to play world sound");
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 권한 / 상태 체크
    // ─────────────────────────────────────────────────────────────

    /**
     * 현재 플레이어가 관리자인지 확인 (멀티플레이어)
     */
    public static boolean isAdmin() {
        if (!isMultiplayer())
            return true; // 싱글플레이어는 항상 관리자

        Object player = getLocalPlayer();
        if (player == null)
            return false;

        try {
            // IsoPlayer.accessLevel 확인
            Method getAccessLevelMethod = player.getClass().getMethod("getAccessLevel");
            Object accessLevel = getAccessLevelMethod.invoke(player);

            if (accessLevel != null) {
                String level = accessLevel.toString().toLowerCase();
                return level.equals("admin") || level.equals("moderator") || level.equals("gm");
            }
        } catch (Exception e) {
            // 무시
        }

        return false;
    }

    /**
     * 현재 플레이어가 협동 호스트인지 확인
     */
    public static boolean isCoopHost() {
        ensureInitialized();

        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            Class<?> coopClass = loader.loadClass("zombie.characters.IsoPlayer");
            Field coopField = coopClass.getDeclaredField("isCoopHost");
            coopField.setAccessible(true);
            Object result = coopField.get(null);

            if (result instanceof Boolean b) {
                return b;
            }
        } catch (Exception e) {
            // 무시
        }

        return false;
    }

    /**
     * 디버그 모드인지 확인
     */
    public static boolean isDebugMode() {
        ensureInitialized();

        // Core.bDebug 확인
        if (coreClass != null) {
            try {
                Field debugField = coreClass.getDeclaredField("bDebug");
                debugField.setAccessible(true);
                Object result = debugField.get(null);
                if (result instanceof Boolean b) {
                    return b;
                }
            } catch (Exception e) {
                // 무시
            }
        }

        return false;
    }

    /**
     * 게임이 튜토리얼 모드인지 확인
     */
    public static boolean isTutorial() {
        ensureInitialized();

        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            Class<?> gameClass = loader.loadClass("zombie.core.Core");
            Method getInstance = gameClass.getMethod("getInstance");
            Object core = getInstance.invoke(null);

            if (core != null) {
                Method isTutorial = gameClass.getMethod("isTutorial");
                Object result = isTutorial.invoke(core);
                if (result instanceof Boolean b) {
                    return b;
                }
            }
        } catch (Exception e) {
            // 무시
        }

        return false;
    }

    // ─────────────────────────────────────────────────────────────
    // 멀티플레이어 전용 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 연결된 플레이어 목록 가져오기 (멀티플레이어)
     * 싱글플레이어에서는 로컬 플레이어만 포함된 리스트 반환
     * 
     * @return 플레이어 객체 리스트
     */
    public static java.util.List<Object> getAllPlayers() {
        java.util.List<Object> result = new java.util.ArrayList<>();
        ensureInitialized();

        if (isoPlayerClass == null)
            return result;

        try {
            // IsoPlayer.players 정적 필드 접근
            Field playersField = isoPlayerClass.getDeclaredField("players");
            playersField.setAccessible(true);
            Object players = playersField.get(null);

            if (players instanceof java.util.List<?> list) {
                for (Object player : list) {
                    if (player != null) {
                        result.add(player);
                    }
                }
            }
        } catch (Exception e) {
            // 대안: 로컬 플레이어만 반환
            Object local = getLocalPlayer();
            if (local != null) {
                result.add(local);
            }
        }

        return result;
    }

    /**
     * 현재 연결된 플레이어 수
     */
    public static int getPlayerCount() {
        return getAllPlayers().size();
    }

    /**
     * 이름으로 플레이어 찾기
     * 
     * @param username 플레이어 이름
     * @return 플레이어 객체 또는 null
     */
    public static Object getPlayerByName(String username) {
        if (username == null)
            return null;

        for (Object player : getAllPlayers()) {
            try {
                Method getUsernameMethod = player.getClass().getMethod("getUsername");
                Object name = getUsernameMethod.invoke(player);
                if (username.equalsIgnoreCase(String.valueOf(name))) {
                    return player;
                }
            } catch (Exception e) {
                // 무시
            }
        }
        return null;
    }

    // ─────────────────────────────────────────────────────────────
    // 좀비 스폰 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 특정 위치에 좀비 스폰
     * 
     * @param x X 좌표
     * @param y Y 좌표
     * @param z Z 좌표 (층)
     * @return 스폰된 좀비 객체 또는 null
     */
    public static Object spawnZombie(int x, int y, int z) {
        ensureInitialized();

        try {
            Object cell = getCell();
            if (cell == null)
                return null;

            // VirtualZombieManager 또는 직접 생성 시도
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            // zombie.characters.IsoZombie 직접 생성
            Class<?> zombieClass = loader.loadClass("zombie.characters.IsoZombie");
            Object zombie = zombieClass.getDeclaredConstructor(cell.getClass())
                    .newInstance(cell);

            // 위치 설정
            Method setXMethod = zombieClass.getMethod("setX", float.class);
            Method setYMethod = zombieClass.getMethod("setY", float.class);
            Method setZMethod = zombieClass.getMethod("setZ", float.class);

            setXMethod.invoke(zombie, (float) x);
            setYMethod.invoke(zombie, (float) y);
            setZMethod.invoke(zombie, (float) z);

            // 셀에 추가
            Method addToWorldMethod = zombieClass.getMethod("addToWorld");
            addToWorldMethod.invoke(zombie);

            System.out.println("[Pulse/GameAccess] Spawned zombie at " + x + ", " + y + ", " + z);
            return zombie;
        } catch (Exception e) {
            System.err.println("[Pulse/GameAccess] Failed to spawn zombie: " + e.getMessage());
            return null;
        }
    }

    /**
     * 플레이어 근처에 좀비 스폰
     * 
     * @param offsetX 플레이어로부터의 X 오프셋
     * @param offsetY 플레이어로부터의 Y 오프셋
     * @return 스폰된 좀비 객체 또는 null
     */
    public static Object spawnZombieNearPlayer(int offsetX, int offsetY) {
        int px = (int) getPlayerX();
        int py = (int) getPlayerY();
        int pz = (int) getPlayerZ();
        return spawnZombie(px + offsetX, py + offsetY, pz);
    }

    // ─────────────────────────────────────────────────────────────
    // 거리 계산 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 두 엔티티 간의 거리 계산
     * 
     * @param entity1 첫 번째 엔티티 (IsoGameCharacter, IsoObject 등)
     * @param entity2 두 번째 엔티티
     * @return 거리 (단위: 타일), 측정 불가 시 -1
     */
    public static float getDistance(Object entity1, Object entity2) {
        if (entity1 == null || entity2 == null)
            return -1;

        try {
            float x1 = getEntityX(entity1);
            float y1 = getEntityY(entity1);
            float x2 = getEntityX(entity2);
            float y2 = getEntityY(entity2);

            float dx = x2 - x1;
            float dy = y2 - y1;
            return (float) Math.sqrt(dx * dx + dy * dy);
        } catch (Exception e) {
            return -1;
        }
    }

    /**
     * 엔티티와 좌표 간의 거리 계산
     */
    public static float getDistanceToPoint(Object entity, float x, float y) {
        if (entity == null)
            return -1;

        try {
            float ex = getEntityX(entity);
            float ey = getEntityY(entity);
            float dx = x - ex;
            float dy = y - ey;
            return (float) Math.sqrt(dx * dx + dy * dy);
        } catch (Exception e) {
            return -1;
        }
    }

    /**
     * 플레이어와 엔티티 간의 거리 계산
     */
    public static float getDistanceToPlayer(Object entity) {
        Object player = getLocalPlayer();
        if (player == null || entity == null)
            return -1;
        return getDistance(player, entity);
    }

    /**
     * 엔티티의 X 좌표 가져오기
     */
    private static float getEntityX(Object entity) throws Exception {
        Method getX = entity.getClass().getMethod("getX");
        return ((Number) getX.invoke(entity)).floatValue();
    }

    /**
     * 엔티티의 Y 좌표 가져오기
     */
    private static float getEntityY(Object entity) throws Exception {
        Method getY = entity.getClass().getMethod("getY");
        return ((Number) getY.invoke(entity)).floatValue();
    }

    // ─────────────────────────────────────────────────────────────
    // 날씨 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 현재 날씨 상태 가져오기
     * 
     * @return 날씨 상태 문자열 (예: "sunny", "rain", "fog" 등)
     */
    public static String getWeather() {
        ensureInitialized();

        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            Class<?> climateClass = loader.loadClass("zombie.iso.weather.ClimateManager");
            Method getInstanceMethod = climateClass.getMethod("getInstance");
            Object climate = getInstanceMethod.invoke(null);

            if (climate != null) {
                // 비 확인
                Method isRainingMethod = climateClass.getMethod("isRaining");
                Object raining = isRainingMethod.invoke(climate);
                if (raining instanceof Boolean b && b) {
                    return "rain";
                }

                // 안개 확인
                try {
                    Method getFogMethod = climateClass.getMethod("getFogIntensity");
                    Object fog = getFogMethod.invoke(climate);
                    if (fog instanceof Number num && num.floatValue() > 0.3f) {
                        return "fog";
                    }
                } catch (Exception e) {
                    // 무시
                }

                // 눈 확인
                try {
                    Method isSnowingMethod = climateClass.getMethod("isSnowing");
                    Object snowing = isSnowingMethod.invoke(climate);
                    if (snowing instanceof Boolean b && b) {
                        return "snow";
                    }
                } catch (Exception e) {
                    // 무시
                }

                return "sunny";
            }
        } catch (Exception e) {
            // 무시
        }

        return "unknown";
    }

    /**
     * 비가 오는지 확인
     */
    public static boolean isRaining() {
        return "rain".equals(getWeather());
    }

    /**
     * 눈이 오는지 확인
     */
    public static boolean isSnowing() {
        return "snow".equals(getWeather());
    }

    /**
     * 안개가 끼었는지 확인
     */
    public static boolean isFoggy() {
        return "fog".equals(getWeather());
    }

    /**
     * 날씨 강도 설정 (비)
     * 
     * @param intensity 강도 (0.0 ~ 1.0)
     */
    public static void setRainIntensity(float intensity) {
        ensureInitialized();

        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();

            Class<?> climateClass = loader.loadClass("zombie.iso.weather.ClimateManager");
            Method getInstanceMethod = climateClass.getMethod("getInstance");
            Object climate = getInstanceMethod.invoke(null);

            if (climate != null) {
                Method setRainMethod = climateClass.getMethod("setRainIntensity", float.class);
                setRainMethod.invoke(climate, Math.max(0, Math.min(1, intensity)));
                System.out.println("[Pulse/GameAccess] Set rain intensity to " + intensity);
            }
        } catch (Exception e) {
            System.err.println("[Pulse/GameAccess] Failed to set rain: " + e.getMessage());
        }
    }

    /**
     * 비 시작
     */
    public static void startRain() {
        setRainIntensity(0.5f);
    }

    /**
     * 비 중지
     */
    public static void stopRain() {
        setRainIntensity(0f);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\GameAccess.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\IMC.java =====

package com.pulse.api;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 모드 간 통신 API (Inter-Mod Communication).
 * 서비스 로케이터 패턴 기반.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 서비스 등록
 * IMC.registerService("mymod:inventory_api", MyInventoryAPI.class, () -> new MyInventoryAPI());
 * 
 * // 서비스 사용
 * MyInventoryAPI api = IMC.getService("mymod:inventory_api", MyInventoryAPI.class);
 * if (api != null) {
 *     api.doSomething();
 * }
 * 
 * // 메시지 전송
 * IMC.sendMessage("othermod", "config_changed", myConfigData);
 * </pre>
 */
@PublicAPI(since = "1.0.0")
public class IMC {

    private static final IMC INSTANCE = new IMC();

    // 등록된 서비스
    private final Map<String, ServiceRegistration<?>> services = new ConcurrentHashMap<>();

    // 메시지 리스너
    private final Map<String, Map<String, MessageHandler>> messageHandlers = new ConcurrentHashMap<>();

    private IMC() {
    }

    // ─────────────────────────────────────────────────────────────
    // 서비스 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 서비스 등록.
     * 
     * @param id      서비스 식별자 (예: "mymod:my_api")
     * @param type    서비스 인터페이스/클래스
     * @param factory 서비스 인스턴스 생성자
     */
    public static <T> void registerService(String id, Class<T> type, Supplier<T> factory) {
        INSTANCE.services.put(id, new ServiceRegistration<>(type, factory));
        System.out.println("[Pulse/IMC] Registered service: " + id);
    }

    /**
     * 서비스 조회.
     * 
     * @param id   서비스 식별자
     * @param type 예상되는 타입
     * @return 서비스 인스턴스 또는 null
     */
    @SuppressWarnings("unchecked")
    public static <T> T getService(String id, Class<T> type) {
        ServiceRegistration<?> reg = INSTANCE.services.get(id);
        if (reg == null) {
            return null;
        }
        if (!type.isAssignableFrom(reg.type)) {
            System.err.println("[Pulse/IMC] Service type mismatch: " + id);
            return null;
        }
        return (T) reg.getInstance();
    }

    /**
     * 서비스 존재 여부 확인.
     */
    public static boolean hasService(String id) {
        return INSTANCE.services.containsKey(id);
    }

    /**
     * 서비스 등록 해제.
     */
    public static void unregisterService(String id) {
        INSTANCE.services.remove(id);
    }

    // ─────────────────────────────────────────────────────────────
    // 메시지 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 다른 모드에 메시지 전송.
     * 
     * @param targetModId 대상 모드 ID
     * @param messageType 메시지 타입
     * @param data        메시지 데이터
     */
    public static void sendMessage(String targetModId, String messageType, Object data) {
        Map<String, MessageHandler> handlers = INSTANCE.messageHandlers.get(targetModId);
        if (handlers == null) {
            return; // 수신자 없음
        }

        MessageHandler handler = handlers.get(messageType);
        if (handler == null) {
            handler = handlers.get("*"); // 와일드카드 핸들러
        }

        if (handler != null) {
            try {
                handler.handle(messageType, data);
            } catch (Exception e) {
                System.err.println("[Pulse/IMC] Error handling message: " + e.getMessage());
            }
        }
    }

    /**
     * 메시지 핸들러 등록.
     * 
     * @param modId       자신의 모드 ID
     * @param messageType 수신할 메시지 타입 ("*" = 모든 메시지)
     * @param handler     핸들러
     */
    public static void registerHandler(String modId, String messageType, MessageHandler handler) {
        INSTANCE.messageHandlers
                .computeIfAbsent(modId, k -> new ConcurrentHashMap<>())
                .put(messageType, handler);
    }

    /**
     * 등록된 모든 서비스 ID 조회.
     */
    public static java.util.Set<String> getRegisteredServices() {
        return java.util.Collections.unmodifiableSet(INSTANCE.services.keySet());
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface MessageHandler {
        void handle(String messageType, Object data);
    }

    private static class ServiceRegistration<T> {
        final Class<T> type;
        final Supplier<T> factory;
        private T instance;

        ServiceRegistration(Class<T> type, Supplier<T> factory) {
            this.type = type;
            this.factory = factory;
        }

        synchronized T getInstance() {
            if (instance == null) {
                instance = factory.get();
            }
            return instance;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\IMC.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\InternalAPI.java =====

package com.pulse.api;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 내부 API 마커.
 * 이 어노테이션이 붙은 클래스/메서드는 내부 구현용.
 * 
 * - 언제든 변경/제거 가능
 * - 외부 모드에서 사용 금지
 * - 문서화 대상 아님
 * 
 * 사용 예:
 * 
 * <pre>
 * @InternalAPI
 * public class MixinHelper { ... }
 * </pre>
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PACKAGE })
public @interface InternalAPI {

    /**
     * 내부 API 사용 이유 (선택적 문서화).
     */
    String reason() default "";
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\InternalAPI.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\lua\LuaBudgetManager.java =====

package com.pulse.api.lua;

import com.pulse.api.InternalAPI;
import com.pulse.api.PublicAPI;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Lua 실행 시간 Budget 관리자.
 * Nerve같은 Lua 최적화 모드가 Lua 실행 시간을 제어할 수 있습니다.
 * 
 * <pre>
 * // 사용 예시
 * LuaBudgetManager budget = LuaBudgetManager.getInstance();
 * 
 * // 틱당 5ms 예산 설정
 * budget.setBudget("nerve.tick", 5000); // 마이크로초
 * 
 * // Fallback 핸들러 등록
 * budget.setFallbackHandler("nerve.tick", () -> {
 *     System.out.println("Budget exceeded, skipping non-critical tasks");
 * });
 * 
 * // 실행
 * try (LuaExecutionContext ctx = budget.beginExecution("nerve.tick")) {
 *     while (ctx.hasRemainingBudget()) {
 *         // Lua 작업 수행
 *         luaBridge.call("SomeFunction");
 *         ctx.checkpoint();
 *     }
 * }
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class LuaBudgetManager {

    private static final LuaBudgetManager INSTANCE = new LuaBudgetManager();

    // 컨텍스트별 설정
    private final Map<String, BudgetConfig> configs = new ConcurrentHashMap<>();

    // 컨텍스트별 통계
    private final Map<String, LuaBudgetStats> stats = new ConcurrentHashMap<>();

    private LuaBudgetManager() {
    }

    /**
     * 싱글톤 인스턴스 반환.
     */
    public static LuaBudgetManager getInstance() {
        return INSTANCE;
    }

    // ═══════════════════════════════════════════════════════════════
    // Budget 설정
    // ═══════════════════════════════════════════════════════════════

    /**
     * Budget 설정.
     * 
     * @param contextId    컨텍스트 ID (예: "nerve.tick", "mymod.update")
     * @param budgetMicros 예산 (마이크로초)
     */
    public void setBudget(String contextId, long budgetMicros) {
        configs.computeIfAbsent(contextId, k -> new BudgetConfig()).budgetMicros = budgetMicros;

        // 통계도 초기화
        stats.computeIfAbsent(contextId, k -> new LuaBudgetStats());
    }

    /**
     * Budget 조회.
     * 
     * @param contextId 컨텍스트 ID
     * @return 설정된 예산 (마이크로초), 없으면 -1
     */
    public long getBudget(String contextId) {
        BudgetConfig config = configs.get(contextId);
        return config != null ? config.budgetMicros : -1;
    }

    /**
     * 남은 Budget 조회.
     * 활성 컨텍스트가 없으면 전체 budget 반환.
     * 
     * @param contextId 컨텍스트 ID
     * @return 남은 예산 (마이크로초)
     */
    public long getRemainingBudget(String contextId) {
        BudgetConfig config = configs.get(contextId);
        if (config == null)
            return -1;

        if (config.activeContext != null) {
            return config.activeContext.getRemainingMicros();
        }
        return config.budgetMicros;
    }

    // ═══════════════════════════════════════════════════════════════
    // 실행 컨텍스트
    // ═══════════════════════════════════════════════════════════════

    /**
     * 실행 컨텍스트 시작.
     * try-with-resources로 사용 권장.
     * 
     * @param contextId 컨텍스트 ID
     * @return 실행 컨텍스트
     */
    public LuaExecutionContext beginExecution(String contextId) {
        BudgetConfig config = configs.computeIfAbsent(contextId, k -> {
            BudgetConfig c = new BudgetConfig();
            c.budgetMicros = 10_000; // 기본 10ms
            return c;
        });

        LuaExecutionContext ctx = new LuaExecutionContext(
                contextId, config.budgetMicros, this);

        config.activeContext = ctx;
        return ctx;
    }

    /**
     * 컨텍스트 종료 (내부용).
     */
    @InternalAPI
    void endExecution(LuaExecutionContext ctx) {
        BudgetConfig config = configs.get(ctx.getContextId());
        if (config != null) {
            config.activeContext = null;

            // 통계 업데이트
            updateStats(ctx);

            // 예산 초과 시 fallback 호출
            if (ctx.getElapsedMicros() > config.budgetMicros && config.fallbackHandler != null) {
                try {
                    config.fallbackHandler.run();
                } catch (Exception e) {
                    System.err.println("[LuaBudgetManager] Fallback failed: " + e.getMessage());
                }
            }
        }
    }

    private void updateStats(LuaExecutionContext ctx) {
        LuaBudgetStats stat = stats.computeIfAbsent(ctx.getContextId(), k -> new LuaBudgetStats());

        long elapsed = ctx.getElapsedMicros();
        stat.totalExecutions++;
        stat.totalMicros += elapsed;
        stat.avgExecutionMicros = stat.totalMicros / stat.totalExecutions;

        if (elapsed > stat.maxExecutionMicros) {
            stat.maxExecutionMicros = elapsed;
        }

        if (elapsed > getBudget(ctx.getContextId())) {
            stat.budgetExceededCount++;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Fallback 핸들러
    // ═══════════════════════════════════════════════════════════════

    /**
     * Fallback 핸들러 설정.
     * Budget 초과 시 호출됨.
     * 
     * @param contextId 컨텍스트 ID
     * @param handler   핸들러
     */
    public void setFallbackHandler(String contextId, Runnable handler) {
        configs.computeIfAbsent(contextId, k -> new BudgetConfig()).fallbackHandler = handler;
    }

    /**
     * Fallback 핸들러 제거.
     * 
     * @param contextId 컨텍스트 ID
     */
    public void removeFallbackHandler(String contextId) {
        BudgetConfig config = configs.get(contextId);
        if (config != null) {
            config.fallbackHandler = null;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // 통계
    // ═══════════════════════════════════════════════════════════════

    /**
     * 통계 조회.
     * 
     * @param contextId 컨텍스트 ID
     * @return 통계 객체 (없으면 빈 통계)
     */
    public LuaBudgetStats getStats(String contextId) {
        return stats.getOrDefault(contextId, new LuaBudgetStats());
    }

    /**
     * 통계 초기화.
     * 
     * @param contextId 컨텍스트 ID
     */
    public void resetStats(String contextId) {
        stats.put(contextId, new LuaBudgetStats());
    }

    /**
     * 모든 통계 초기화.
     */
    public void resetAllStats() {
        stats.clear();
    }

    /**
     * 등록된 모든 컨텍스트 ID 조회.
     */
    public java.util.Set<String> getContextIds() {
        return java.util.Collections.unmodifiableSet(configs.keySet());
    }

    // ═══════════════════════════════════════════════════════════════
    // 리포트
    // ═══════════════════════════════════════════════════════════════

    /**
     * 전체 Budget 상태 리포트 출력.
     */
    public void printReport() {
        System.out.println("═══════════════════════════════════════════════");
        System.out.println("  Lua Budget Report");
        System.out.println("═══════════════════════════════════════════════");

        for (String contextId : configs.keySet()) {
            BudgetConfig config = configs.get(contextId);
            LuaBudgetStats stat = stats.getOrDefault(contextId, new LuaBudgetStats());

            System.out.printf("  [%s]%n", contextId);
            System.out.printf("    Budget: %.2fms%n", config.budgetMicros / 1000.0);
            System.out.printf("    Executions: %d (exceeded: %d)%n",
                    stat.totalExecutions, stat.budgetExceededCount);
            System.out.printf("    Avg: %.2fms, Max: %.2fms%n",
                    stat.avgExecutionMicros / 1000.0, stat.maxExecutionMicros / 1000.0);
        }

        System.out.println("═══════════════════════════════════════════════");
    }

    // ═══════════════════════════════════════════════════════════════
    // 내부 클래스
    // ═══════════════════════════════════════════════════════════════

    private static class BudgetConfig {
        long budgetMicros = 10_000; // 기본 10ms
        Runnable fallbackHandler;
        LuaExecutionContext activeContext;
    }

    /**
     * Lua Budget 통계.
     */
    @PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
    public static class LuaBudgetStats {
        public long totalExecutions = 0;
        public long budgetExceededCount = 0;
        public long avgExecutionMicros = 0;
        public long maxExecutionMicros = 0;
        public long totalMicros = 0;

        @Override
        public String toString() {
            return String.format("LuaBudgetStats[executions=%d, exceeded=%d, avg=%.2fms, max=%.2fms]",
                    totalExecutions, budgetExceededCount,
                    avgExecutionMicros / 1000.0, maxExecutionMicros / 1000.0);
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\lua\LuaBudgetManager.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\lua\LuaExecutionContext.java =====

package com.pulse.api.lua;

import com.pulse.api.PublicAPI;

/**
 * Lua 실행 컨텍스트.
 * try-with-resources 패턴을 지원하여 자동으로 budget 정산.
 * 
 * <pre>
 * // 사용 예시
 * LuaBudgetManager budget = LuaBudgetManager.getInstance();
 * 
 * try (LuaExecutionContext ctx = budget.beginExecution("mymod.update")) {
 *     while (ctx.hasRemainingBudget()) {
 *         doSomeLuaWork();
 *         ctx.checkpoint(); // 중간 체크
 *     }
 * } // 자동으로 정산됨
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class LuaExecutionContext implements AutoCloseable {

    private final String contextId;
    private final long budgetMicros;
    private final long startNanos;
    private final LuaBudgetManager manager;

    private volatile long lastCheckpointNanos;
    private volatile int checkpointCount = 0;
    private volatile boolean closed = false;

    /**
     * 컨텍스트 생성 (LuaBudgetManager 내부용).
     */
    LuaExecutionContext(String contextId, long budgetMicros, LuaBudgetManager manager) {
        this.contextId = contextId;
        this.budgetMicros = budgetMicros;
        this.manager = manager;
        this.startNanos = System.nanoTime();
        this.lastCheckpointNanos = startNanos;
    }

    /**
     * 컨텍스트 ID 반환.
     */
    public String getContextId() {
        return contextId;
    }

    /**
     * 설정된 Budget 반환 (마이크로초).
     */
    public long getBudgetMicros() {
        return budgetMicros;
    }

    /**
     * 경과 시간 반환 (마이크로초).
     */
    public long getElapsedMicros() {
        return (System.nanoTime() - startNanos) / 1000;
    }

    /**
     * 남은 Budget 반환 (마이크로초).
     * 음수면 이미 초과됨.
     */
    public long getRemainingMicros() {
        return budgetMicros - getElapsedMicros();
    }

    /**
     * 남은 Budget이 있는지 확인.
     * 
     * @return Budget이 남아있으면 true
     */
    public boolean hasRemainingBudget() {
        return getRemainingMicros() > 0;
    }

    /**
     * Budget 초과 여부 확인.
     * 
     * @return 초과했으면 true
     */
    public boolean isOverBudget() {
        return getRemainingMicros() < 0;
    }

    /**
     * 중간 체크포인트.
     * 긴 작업 중간에 호출하여 budget 상태 업데이트.
     * 
     * @return 남은 budget이 있으면 true
     */
    public boolean checkpoint() {
        lastCheckpointNanos = System.nanoTime();
        checkpointCount++;
        return hasRemainingBudget();
    }

    /**
     * 마지막 체크포인트 이후 경과 시간 (마이크로초).
     */
    public long getMicrosSinceLastCheckpoint() {
        return (System.nanoTime() - lastCheckpointNanos) / 1000;
    }

    /**
     * 체크포인트 호출 횟수.
     */
    public int getCheckpointCount() {
        return checkpointCount;
    }

    /**
     * 컨텍스트가 아직 활성 상태인지 확인.
     */
    public boolean isActive() {
        return !closed;
    }

    /**
     * 특정 작업에 필요한 budget이 남아있는지 확인.
     * 
     * @param requiredMicros 필요한 시간 (마이크로초)
     * @return 충분한 budget이 있으면 true
     */
    public boolean hasBudgetFor(long requiredMicros) {
        return getRemainingMicros() >= requiredMicros;
    }

    /**
     * Budget의 X% 이상 남았는지 확인.
     * 
     * @param percentRemaining 남아야 할 비율 (0.0 ~ 1.0)
     * @return 충분히 남았으면 true
     */
    public boolean hasPercentRemaining(double percentRemaining) {
        long required = (long) (budgetMicros * percentRemaining);
        return getRemainingMicros() >= required;
    }

    /**
     * 경과 시간의 비율 (0.0 ~ 1.0+).
     * 1.0 이상이면 budget 초과.
     */
    public double getElapsedRatio() {
        return (double) getElapsedMicros() / budgetMicros;
    }

    /**
     * 컨텍스트 종료.
     * AutoCloseable 구현으로 try-with-resources 지원.
     */
    @Override
    public void close() {
        if (!closed) {
            closed = true;
            manager.endExecution(this);
        }
    }

    @Override
    public String toString() {
        return String.format("LuaExecutionContext[%s, elapsed=%.2fms/%.2fms, remaining=%.2fms]",
                contextId,
                getElapsedMicros() / 1000.0,
                budgetMicros / 1000.0,
                getRemainingMicros() / 1000.0);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\lua\LuaExecutionContext.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\mixin\InjectionListener.java =====

package com.pulse.api.mixin;

import com.pulse.api.PublicAPI;

/**
 * Mixin 인젝션 이벤트 리스너 인터페이스.
 * 
 * <pre>
 * // 사용 예시
 * MixinInjectionValidator.addListener(new InjectionListener() {
 *     &#64;Override
 *     public void onInjectionSuccess(String mixinClass, String targetClass, long timeMs) {
 *         System.out.println("Mixin applied: " + mixinClass + " in " + timeMs + "ms");
 *     }
 * 
 *     &#64;Override
 *     public void onInjectionFailed(String mixinClass, String targetClass, String reason) {
 *         System.err.println("Mixin failed: " + mixinClass + " - " + reason);
 *     }
 * });
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public interface InjectionListener {

    /**
     * Mixin 인젝션 성공 시 호출.
     * 
     * @param mixinClass  Mixin 클래스 전체 경로
     * @param targetClass 대상 클래스 전체 경로
     * @param timeMs      인젝션에 걸린 시간 (밀리초)
     */
    void onInjectionSuccess(String mixinClass, String targetClass, long timeMs);

    /**
     * Mixin 인젝션 실패 시 호출.
     * 
     * @param mixinClass  Mixin 클래스 전체 경로
     * @param targetClass 대상 클래스 전체 경로
     * @param reason      실패 사유
     */
    void onInjectionFailed(String mixinClass, String targetClass, String reason);

    // ═══════════════════════════════════════════════════════════════
    // 기본 구현 제공
    // ═══════════════════════════════════════════════════════════════

    /**
     * 성공만 로깅하는 리스너.
     */
    static InjectionListener successLogger() {
        return new InjectionListener() {
            @Override
            public void onInjectionSuccess(String mixinClass, String targetClass, long timeMs) {
                System.out.println("[Mixin] ✓ " + mixinClass + " → " + targetClass + " (" + timeMs + "ms)");
            }

            @Override
            public void onInjectionFailed(String mixinClass, String targetClass, String reason) {
                // 무시
            }
        };
    }

    /**
     * 실패만 로깅하는 리스너.
     */
    static InjectionListener failureLogger() {
        return new InjectionListener() {
            @Override
            public void onInjectionSuccess(String mixinClass, String targetClass, long timeMs) {
                // 무시
            }

            @Override
            public void onInjectionFailed(String mixinClass, String targetClass, String reason) {
                System.err.println("[Mixin] ✗ " + mixinClass + " → " + targetClass + ": " + reason);
            }
        };
    }

    /**
     * 모든 이벤트 로깅하는 리스너.
     */
    static InjectionListener fullLogger() {
        return new InjectionListener() {
            @Override
            public void onInjectionSuccess(String mixinClass, String targetClass, long timeMs) {
                System.out.println("[Mixin] ✓ " + mixinClass + " → " + targetClass + " (" + timeMs + "ms)");
            }

            @Override
            public void onInjectionFailed(String mixinClass, String targetClass, String reason) {
                System.err.println("[Mixin] ✗ " + mixinClass + " → " + targetClass + ": " + reason);
            }
        };
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\mixin\InjectionListener.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\mixin\MixinInjectionValidator.java =====

package com.pulse.api.mixin;

import com.pulse.api.InternalAPI;
import com.pulse.api.PublicAPI;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Mixin 인젝션 검증 API.
 * Fuse/Nerve가 Mixin 인젝션 성공/실패를 확인하고 대응할 수 있습니다.
 * 
 * <pre>
 * // 사용 예시
 * InjectionResult result = MixinInjectionValidator.validateInjection(
 *         "com.fuse.mixin.ZombieAIMixin",
 *         "zombie.ai.ZombieAI");
 * 
 * if (!result.isSuccess()) {
 *     System.out.println("Mixin failed: " + result.getFailureReason());
 * }
 * 
 * // 콜백 등록
 * MixinInjectionValidator.onInjectionComplete(result -> {
 *     if (!result.isSuccess()) {
 *         Pulse.warn("Mixin failed: " + result.getMixinClass());
 *     }
 * });
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class MixinInjectionValidator {

    // 인젝션 결과 저장
    private static final Map<String, InjectionResult> results = new ConcurrentHashMap<>();

    // 콜백 리스너
    private static final List<Consumer<InjectionResult>> callbacks = new CopyOnWriteArrayList<>();
    private static final List<InjectionListener> listeners = new CopyOnWriteArrayList<>();

    private MixinInjectionValidator() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // 결과 기록 (내부용)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 성공한 인젝션 기록.
     */
    @InternalAPI
    public static void recordSuccess(String mixinClass, String targetClass, long timeMs) {
        InjectionResult result = new InjectionResult(mixinClass, targetClass, true, null, timeMs);
        results.put(createKey(mixinClass, targetClass), result);
        notifyListeners(result);
    }

    /**
     * 실패한 인젝션 기록.
     */
    @InternalAPI
    public static void recordFailure(String mixinClass, String targetClass, String reason) {
        InjectionResult result = new InjectionResult(mixinClass, targetClass, false, reason, 0);
        results.put(createKey(mixinClass, targetClass), result);
        notifyListeners(result);
    }

    private static String createKey(String mixinClass, String targetClass) {
        return mixinClass + "->" + targetClass;
    }

    private static void notifyListeners(InjectionResult result) {
        // Consumer callbacks
        for (Consumer<InjectionResult> callback : callbacks) {
            try {
                callback.accept(result);
            } catch (Exception e) {
                System.err.println("[MixinInjectionValidator] Callback failed: " + e.getMessage());
            }
        }

        // Listener callbacks
        for (InjectionListener listener : listeners) {
            try {
                if (result.isSuccess()) {
                    listener.onInjectionSuccess(result.getMixinClass(),
                            result.getTargetClass(), result.getInjectionTimeMs());
                } else {
                    listener.onInjectionFailed(result.getMixinClass(),
                            result.getTargetClass(), result.getFailureReason());
                }
            } catch (Exception e) {
                System.err.println("[MixinInjectionValidator] Listener failed: " + e.getMessage());
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // 조회 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 특정 Mixin 인젝션 결과 조회.
     * 
     * @param mixinClass  Mixin 클래스 전체 경로
     * @param targetClass 대상 클래스 전체 경로
     * @return 인젝션 결과 (없으면 null)
     */
    public static InjectionResult validateInjection(String mixinClass, String targetClass) {
        return results.get(createKey(mixinClass, targetClass));
    }

    /**
     * 특정 Mixin 인젝션 결과 조회 (Optional).
     */
    public static Optional<InjectionResult> findInjection(String mixinClass, String targetClass) {
        return Optional.ofNullable(validateInjection(mixinClass, targetClass));
    }

    /**
     * 모든 인젝션 결과 조회.
     * 
     * @return 불변 리스트
     */
    public static List<InjectionResult> getAllResults() {
        return Collections.unmodifiableList(new ArrayList<>(results.values()));
    }

    /**
     * 성공한 인젝션만 조회.
     * 
     * @return 성공한 인젝션 리스트
     */
    public static List<InjectionResult> getSuccessfulInjections() {
        return results.values().stream()
                .filter(InjectionResult::isSuccess)
                .collect(Collectors.toList());
    }

    /**
     * 실패한 인젝션만 조회.
     * 
     * @return 실패한 인젝션 리스트
     */
    public static List<InjectionResult> getFailedInjections() {
        return results.values().stream()
                .filter(r -> !r.isSuccess())
                .collect(Collectors.toList());
    }

    /**
     * 특정 타깃에 대한 모든 인젝션 조회.
     * 
     * @param targetClass 대상 클래스
     * @return 해당 타깃의 모든 인젝션 결과
     */
    public static List<InjectionResult> getInjectionsForTarget(String targetClass) {
        return results.values().stream()
                .filter(r -> r.getTargetClass().equals(targetClass))
                .collect(Collectors.toList());
    }

    /**
     * 전체 인젝션 수.
     */
    public static int getTotalCount() {
        return results.size();
    }

    /**
     * 성공한 인젝션 수.
     */
    public static int getSuccessCount() {
        return (int) results.values().stream().filter(InjectionResult::isSuccess).count();
    }

    /**
     * 실패한 인젝션 수.
     */
    public static int getFailureCount() {
        return (int) results.values().stream().filter(r -> !r.isSuccess()).count();
    }

    // ═══════════════════════════════════════════════════════════════
    // 콜백 등록
    // ═══════════════════════════════════════════════════════════════

    /**
     * 인젝션 완료 시 콜백 등록.
     * 
     * @param callback 콜백 함수
     */
    public static void onInjectionComplete(Consumer<InjectionResult> callback) {
        if (callback != null) {
            callbacks.add(callback);
        }
    }

    /**
     * 인젝션 리스너 등록.
     * 
     * @param listener 리스너
     */
    public static void addListener(InjectionListener listener) {
        if (listener != null) {
            listeners.add(listener);
        }
    }

    /**
     * 인젝션 리스너 제거.
     * 
     * @param listener 리스너
     */
    public static void removeListener(InjectionListener listener) {
        listeners.remove(listener);
    }

    // ═══════════════════════════════════════════════════════════════
    // 리포트
    // ═══════════════════════════════════════════════════════════════

    /**
     * 인젝션 상태 리포트 출력.
     */
    public static void printReport() {
        System.out.println("═══════════════════════════════════════════════");
        System.out.println("  Mixin Injection Report");
        System.out.println("═══════════════════════════════════════════════");
        System.out.printf("  Total: %d | Success: %d | Failed: %d%n",
                getTotalCount(), getSuccessCount(), getFailureCount());
        System.out.println("───────────────────────────────────────────────");

        // 실패한 것들 먼저 출력
        List<InjectionResult> failures = getFailedInjections();
        if (!failures.isEmpty()) {
            System.out.println("  ✗ Failed Injections:");
            for (InjectionResult r : failures) {
                System.out.printf("    - %s → %s%n", r.getMixinClass(), r.getTargetClass());
                System.out.printf("      Reason: %s%n", r.getFailureReason());
            }
        }

        System.out.println("═══════════════════════════════════════════════");
    }

    // ═══════════════════════════════════════════════════════════════
    // 결과 클래스
    // ═══════════════════════════════════════════════════════════════

    /**
     * Mixin 인젝션 결과.
     */
    @PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
    public static final class InjectionResult {
        private final String mixinClass;
        private final String targetClass;
        private final boolean success;
        private final String failureReason;
        private final long injectionTimeMs;
        private final long timestamp;

        InjectionResult(String mixinClass, String targetClass, boolean success,
                String failureReason, long injectionTimeMs) {
            this.mixinClass = mixinClass;
            this.targetClass = targetClass;
            this.success = success;
            this.failureReason = failureReason;
            this.injectionTimeMs = injectionTimeMs;
            this.timestamp = System.currentTimeMillis();
        }

        public String getMixinClass() {
            return mixinClass;
        }

        public String getTargetClass() {
            return targetClass;
        }

        public boolean isSuccess() {
            return success;
        }

        public String getFailureReason() {
            return failureReason;
        }

        public long getInjectionTimeMs() {
            return injectionTimeMs;
        }

        public long getTimestamp() {
            return timestamp;
        }

        @Override
        public String toString() {
            if (success) {
                return String.format("InjectionResult[%s → %s, OK, %dms]",
                        mixinClass, targetClass, injectionTimeMs);
            } else {
                return String.format("InjectionResult[%s → %s, FAILED: %s]",
                        mixinClass, targetClass, failureReason);
            }
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\mixin\MixinInjectionValidator.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\ModLogger.java =====

package com.pulse.api;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 모드별 로거.
 * 각 모드는 자신만의 로거를 사용하여 [Mod/{modId}] prefix로 로그 출력.
 * 
 * 사용 예:
 * ModLogger logger = ModLogger.getLogger("mymod");
 * logger.info("Mod initialized!");
 * // 출력: [Mod/mymod] Mod initialized!
 */
public class ModLogger {

    private static final Map<String, ModLogger> LOGGERS = new ConcurrentHashMap<>();

    private final String modId;
    private final String prefix;

    private ModLogger(String modId) {
        this.modId = modId;
        this.prefix = "[Mod/" + modId + "] ";
    }

    // ─────────────────────────────────────────────────────────────
    // 팩토리 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드별 로거 가져오기 (캐싱됨)
     */
    public static ModLogger getLogger(String modId) {
        return LOGGERS.computeIfAbsent(modId, ModLogger::new);
    }

    // ─────────────────────────────────────────────────────────────
    // 로깅 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * INFO 레벨 로그
     */
    public void info(String message) {
        System.out.println(prefix + message);
    }

    /**
     * INFO 레벨 로그 (포맷팅)
     */
    public void info(String format, Object... args) {
        System.out.println(prefix + String.format(format, args));
    }

    /**
     * DEBUG 레벨 로그 (DevMode일 때만)
     */
    public void debug(String message) {
        if (DevMode.isEnabled()) {
            System.out.println(prefix + "[DEBUG] " + message);
        }
    }

    /**
     * DEBUG 레벨 로그 (포맷팅, DevMode일 때만)
     */
    public void debug(String format, Object... args) {
        if (DevMode.isEnabled()) {
            System.out.println(prefix + "[DEBUG] " + String.format(format, args));
        }
    }

    /**
     * WARN 레벨 로그
     */
    public void warn(String message) {
        System.out.println(prefix + "[WARN] " + message);
    }

    /**
     * WARN 레벨 로그 (포맷팅)
     */
    public void warn(String format, Object... args) {
        System.out.println(prefix + "[WARN] " + String.format(format, args));
    }

    /**
     * ERROR 레벨 로그
     */
    public void error(String message) {
        System.err.println(prefix + "[ERROR] " + message);
    }

    /**
     * ERROR 레벨 로그 (예외 포함)
     */
    public void error(String message, Throwable t) {
        System.err.println(prefix + "[ERROR] " + message);
        t.printStackTrace(System.err);
    }

    /**
     * ERROR 레벨 로그 (포맷팅)
     */
    public void error(String format, Object... args) {
        System.err.println(prefix + "[ERROR] " + String.format(format, args));
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public String getModId() {
        return modId;
    }

    public String getPrefix() {
        return prefix;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\ModLogger.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\optimization\OptimizationPoint.java =====

package com.pulse.api.optimization;

import com.pulse.api.PublicAPI;
import java.util.Optional;

/**
 * 최적화 지점 정의.
 * 각 포인트는 Mixin 타깃 클래스와 Echo 프로파일러 라벨 prefix와 연결됩니다.
 * 
 * <p>
 * Tier 1 (Base): 핵심 병목 영역 - 7개
 * </p>
 * <p>
 * Tier 2 (Platform Extension): Pulse 생태계 확장용 - 3개
 * </p>
 * 
 * <pre>
 * // 사용 예시
 * OptimizationPoint point = OptimizationPoint.ZOMBIE_AI_UPDATE;
 * String target = point.getMixinTarget(); // "zombie.ai.ZombieAI"
 * String prefix = point.getEchoPrefix(); // "zombie.ai"
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public enum OptimizationPoint {

    // ═══════════════════════════════════════════════════════════════
    // Tier 1: Base - 핵심 병목 영역
    // ═══════════════════════════════════════════════════════════════

    /**
     * 메인 게임 틱 루프.
     * 전체 프레임 시간의 병목점을 파악하는 데 사용.
     */
    TICK_LOOP("zombie.gameStates.IngameState", "tick", 1),

    /**
     * 좀비 AI 업데이트.
     * AI 경로 탐색 및 상태 머신 처리.
     */
    ZOMBIE_AI_UPDATE("zombie.ai.ZombieAI", "zombie.ai", 1),

    /**
     * 청크 스트리밍.
     * 월드 청크 로드/언로드 처리.
     */
    CHUNK_STREAMING("zombie.iso.IsoChunkGrid", "chunk", 1),

    /**
     * Lua 이벤트 시스템.
     * Lua 모드의 이벤트 핸들러 호출.
     */
    LUA_EVENT("zombie.Lua.LuaEventManager", "lua.event", 1),

    /**
     * 네트워크 패킷 처리.
     * 클라이언트-서버 통신.
     */
    NETWORK_PACKET("zombie.network.GameClient", "network", 1),

    /**
     * 경로 탐색.
     * A* 알고리즘 기반 경로 계산.
     */
    PATHFINDING("zombie.ai.astar.AStarPathFinder", "pathfind", 1),

    /**
     * 메인 렌더링.
     * 화면 렌더링 파이프라인.
     */
    RENDER_MAIN("zombie.core.Core", "render", 1),

    // ═══════════════════════════════════════════════════════════════
    // Tier 2: Platform Extension - Pulse 생태계 확장
    // ═══════════════════════════════════════════════════════════════

    /**
     * 인벤토리 업데이트.
     * 컨테이너, 아이템 정렬/스캔/트랜잭션 처리.
     * 멀티플레이어에서 병목이 자주 발생하는 영역.
     */
    INVENTORY_UPDATE("zombie.inventory.InventoryContainer", "inventory", 2),

    /**
     * 차량 업데이트.
     * 차량 물리 연산, 충돌 처리, tick-based update.
     */
    VEHICLE_UPDATE("zombie.vehicles.BaseVehicle", "vehicle", 2),

    /**
     * 애니메이션 업데이트.
     * 모델 업데이트, 스킨, 애니메이션 처리.
     */
    ANIMATION_UPDATE("zombie.core.skinnedmodel.ModelManager", "animation", 2);

    // ═══════════════════════════════════════════════════════════════
    // 필드 및 메서드
    // ═══════════════════════════════════════════════════════════════

    private final String mixinTarget;
    private final String echoPrefix;
    private final int tier;

    OptimizationPoint(String mixinTarget, String echoPrefix, int tier) {
        this.mixinTarget = mixinTarget;
        this.echoPrefix = echoPrefix;
        this.tier = tier;
    }

    /**
     * Mixin 대상 클래스의 전체 경로 반환.
     * 
     * @return Mixin 대상 클래스 (예: "zombie.ai.ZombieAI")
     */
    public String getMixinTarget() {
        return mixinTarget;
    }

    /**
     * Echo 프로파일러 라벨 prefix 반환.
     * 
     * @return Echo 라벨 prefix (예: "zombie.ai")
     */
    public String getEchoPrefix() {
        return echoPrefix;
    }

    /**
     * Tier 레벨 반환.
     * 
     * @return 1 = Base, 2 = Platform Extension
     */
    public int getTier() {
        return tier;
    }

    /**
     * Echo 라벨 생성 헬퍼.
     * 
     * @param suffix 라벨 suffix (예: "update", "tick")
     * @return 전체 라벨 (예: "zombie.ai.update")
     */
    public String createEchoLabel(String suffix) {
        return echoPrefix + "." + suffix;
    }

    /**
     * ID로 OptimizationPoint 찾기.
     * 
     * @param id enum 이름 (예: "ZOMBIE_AI_UPDATE")
     * @return Optional containing the point, or empty if not found
     */
    public static Optional<OptimizationPoint> byId(String id) {
        try {
            return Optional.of(valueOf(id.toUpperCase()));
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
    }

    /**
     * Mixin 타깃으로 OptimizationPoint 찾기.
     * 
     * @param mixinTarget Mixin 대상 클래스 전체 경로
     * @return Optional containing the point, or empty if not found
     */
    public static Optional<OptimizationPoint> byMixinTarget(String mixinTarget) {
        for (OptimizationPoint point : values()) {
            if (point.mixinTarget.equals(mixinTarget)) {
                return Optional.of(point);
            }
        }
        return Optional.empty();
    }

    /**
     * Echo prefix로 OptimizationPoint 찾기.
     * 
     * @param prefix Echo 라벨 prefix
     * @return Optional containing the point, or empty if not found
     */
    public static Optional<OptimizationPoint> byEchoPrefix(String prefix) {
        for (OptimizationPoint point : values()) {
            if (point.echoPrefix.equals(prefix)) {
                return Optional.of(point);
            }
        }
        return Optional.empty();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\optimization\OptimizationPoint.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\optimization\OptimizationPointRegistry.java =====

package com.pulse.api.optimization;

import com.pulse.api.InternalAPI;
import com.pulse.api.PublicAPI;

import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

/**
 * OptimizationPoint 레지스트리.
 * 기본 제공 포인트와 모드가 커스텀 등록한 포인트를 관리합니다.
 * 
 * <pre>
 * // 커스텀 포인트 등록
 * OptimizationPointRegistry.register("MY_CUSTOM_POINT",
 *         "com.mymod.MyClass", "mymod.custom");
 * 
 * // 포인트 조회
 * OptimizationPointInfo info = OptimizationPointRegistry.get("ZOMBIE_AI_UPDATE");
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class OptimizationPointRegistry {

    // 커스텀 등록된 포인트
    private static final Map<String, OptimizationPointInfo> customPoints = new ConcurrentHashMap<>();

    // 초기화 플래그
    private static volatile boolean initialized = false;

    private OptimizationPointRegistry() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // 초기화
    // ═══════════════════════════════════════════════════════════════

    /**
     * 레지스트리 초기화 (Pulse 시작 시 자동 호출).
     */
    @InternalAPI
    public static void initialize() {
        if (initialized)
            return;

        // 기본 OptimizationPoint들을 등록
        for (OptimizationPoint point : OptimizationPoint.values()) {
            customPoints.put(point.name(), new OptimizationPointInfo(
                    point.name(),
                    point.getMixinTarget(),
                    point.getEchoPrefix(),
                    point.getTier(),
                    true // built-in
            ));
        }

        initialized = true;
        System.out.println("[Pulse] OptimizationPointRegistry initialized with "
                + OptimizationPoint.values().length + " built-in points");
    }

    // ═══════════════════════════════════════════════════════════════
    // 등록 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 커스텀 OptimizationPoint 등록.
     * 
     * @param id          고유 식별자 (대문자 권장, 예: "MY_CUSTOM_POINT")
     * @param mixinTarget Mixin 대상 클래스 전체 경로
     * @param echoPrefix  Echo 프로파일러 라벨 prefix
     * @return 등록 성공 여부 (이미 존재하면 false)
     */
    public static boolean register(String id, String mixinTarget, String echoPrefix) {
        return register(id, mixinTarget, echoPrefix, 3); // Tier 3 = custom
    }

    /**
     * 커스텀 OptimizationPoint 등록 (Tier 지정).
     * 
     * @param id          고유 식별자
     * @param mixinTarget Mixin 대상 클래스 전체 경로
     * @param echoPrefix  Echo 프로파일러 라벨 prefix
     * @param tier        Tier 레벨 (3 이상 권장)
     * @return 등록 성공 여부
     */
    public static boolean register(String id, String mixinTarget, String echoPrefix, int tier) {
        if (id == null || id.isEmpty())
            return false;
        if (mixinTarget == null || mixinTarget.isEmpty())
            return false;
        if (echoPrefix == null || echoPrefix.isEmpty())
            return false;

        String normalizedId = id.toUpperCase();

        if (customPoints.containsKey(normalizedId)) {
            System.out.println("[Pulse/WARN] OptimizationPoint already exists: " + normalizedId);
            return false;
        }

        customPoints.put(normalizedId, new OptimizationPointInfo(
                normalizedId, mixinTarget, echoPrefix, tier, false));

        System.out.println("[Pulse] Registered custom OptimizationPoint: " + normalizedId);
        return true;
    }

    // ═══════════════════════════════════════════════════════════════
    // 조회 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * ID로 OptimizationPointInfo 조회.
     * 
     * @param id 포인트 ID
     * @return OptimizationPointInfo or null if not found
     */
    public static OptimizationPointInfo get(String id) {
        if (!initialized)
            initialize();
        return customPoints.get(id.toUpperCase());
    }

    /**
     * ID로 OptimizationPointInfo 조회 (Optional 반환).
     * 
     * @param id 포인트 ID
     * @return Optional containing the info
     */
    public static Optional<OptimizationPointInfo> find(String id) {
        return Optional.ofNullable(get(id));
    }

    /**
     * 모든 등록된 포인트 반환.
     * 
     * @return 불변 컬렉션
     */
    public static Collection<OptimizationPointInfo> getAll() {
        if (!initialized)
            initialize();
        return Collections.unmodifiableCollection(customPoints.values());
    }

    /**
     * 등록 여부 확인.
     * 
     * @param id 포인트 ID
     * @return 등록되어 있으면 true
     */
    public static boolean isRegistered(String id) {
        if (!initialized)
            initialize();
        return customPoints.containsKey(id.toUpperCase());
    }

    /**
     * 등록된 포인트 수.
     * 
     * @return 전체 포인트 수 (built-in + custom)
     */
    public static int size() {
        if (!initialized)
            initialize();
        return customPoints.size();
    }

    /**
     * Mixin 타깃으로 포인트 찾기.
     * 
     * @param mixinTarget Mixin 대상 클래스
     * @return Optional containing the info
     */
    public static Optional<OptimizationPointInfo> findByMixinTarget(String mixinTarget) {
        if (!initialized)
            initialize();
        return customPoints.values().stream()
                .filter(info -> info.getMixinTarget().equals(mixinTarget))
                .findFirst();
    }

    /**
     * Echo prefix로 포인트 찾기.
     * 
     * @param echoPrefix Echo 라벨 prefix
     * @return Optional containing the info
     */
    public static Optional<OptimizationPointInfo> findByEchoPrefix(String echoPrefix) {
        if (!initialized)
            initialize();
        return customPoints.values().stream()
                .filter(info -> info.getEchoPrefix().equals(echoPrefix))
                .findFirst();
    }

    // ═══════════════════════════════════════════════════════════════
    // 정보 클래스
    // ═══════════════════════════════════════════════════════════════

    /**
     * OptimizationPoint 정보를 담는 불변 객체.
     */
    @PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
    public static final class OptimizationPointInfo {
        private final String id;
        private final String mixinTarget;
        private final String echoPrefix;
        private final int tier;
        private final boolean builtIn;

        OptimizationPointInfo(String id, String mixinTarget, String echoPrefix,
                int tier, boolean builtIn) {
            this.id = id;
            this.mixinTarget = mixinTarget;
            this.echoPrefix = echoPrefix;
            this.tier = tier;
            this.builtIn = builtIn;
        }

        public String getId() {
            return id;
        }

        public String getMixinTarget() {
            return mixinTarget;
        }

        public String getEchoPrefix() {
            return echoPrefix;
        }

        public int getTier() {
            return tier;
        }

        public boolean isBuiltIn() {
            return builtIn;
        }

        /**
         * Echo 라벨 생성.
         */
        public String createEchoLabel(String suffix) {
            return echoPrefix + "." + suffix;
        }

        @Override
        public String toString() {
            return String.format("OptimizationPoint[%s, tier=%d, target=%s, echo=%s]",
                    id, tier, mixinTarget, echoPrefix);
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\optimization\OptimizationPointRegistry.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\PublicAPI.java =====

package com.pulse.api;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 공개 API 마커.
 * 이 어노테이션이 붙은 클래스/메서드는 안정적인 공개 API로 간주됨.
 * 
 * - 시맨틱 버저닝 준수 (breaking change = major version)
 * - Deprecation 정책 적용 (최소 1 major version 유지)
 * - 문서화 의무
 * 
 * 사용 예:
 * 
 * <pre>
 * @PublicAPI(since = "1.0.0")
 * public class EventBus { ... }
 * </pre>
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR })
public @interface PublicAPI {

    /**
     * API가 도입된 버전.
     */
    String since() default "1.0.0";

    /**
     * API 상태.
     */
    Status status() default Status.STABLE;

    public enum Status {
        STABLE, // 안정 - 프로덕션 사용 가능
        EXPERIMENTAL, // 실험적 - 변경 가능
        BETA // 베타 - 대부분 안정, 마이너 변경 가능
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\PublicAPI.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\Pulse.java =====

package com.pulse.api;

import com.pulse.PulseEnvironment;
import com.pulse.event.EventBus;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModLoader;

import java.nio.file.Path;
import java.util.Collection;
import java.util.Optional;

/**
 * Pulse API 메인 진입점.
 * 모드 개발자가 사용하는 안정적인 API.
 * 
 * 사용 예:
 * if (Pulse.isModLoaded("othermod")) {
 * // othermod와 연동
 * }
 */
public final class Pulse {

    private Pulse() {
    } // 인스턴스화 방지

    // ─────────────────────────────────────────────────────────────
    // 버전 정보
    // ─────────────────────────────────────────────────────────────

    public static final String VERSION = "1.0.0";
    public static final String NAME = "Pulse";
    public static final int API_VERSION = 1;

    /**
     * Pulse 버전 반환
     */
    public static String getVersion() {
        return VERSION;
    }

    /**
     * API 버전 반환 (호환성 체크용)
     */
    public static int getApiVersion() {
        return API_VERSION;
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 관련
    // ─────────────────────────────────────────────────────────────

    /**
     * 특정 모드가 로드되었는지 확인
     */
    public static boolean isModLoaded(String modId) {
        return ModLoader.getInstance().isModLoaded(modId);
    }

    /**
     * 모드 컨테이너 가져오기
     */
    public static Optional<ModContainer> getMod(String modId) {
        return Optional.ofNullable(ModLoader.getInstance().getMod(modId));
    }

    /**
     * 로드된 모든 모드 목록
     */
    public static Collection<ModContainer> getAllMods() {
        return ModLoader.getInstance().getAllMods();
    }

    /**
     * 로드된 모드 수
     */
    public static int getModCount() {
        return ModLoader.getInstance().getModCount();
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 시스템
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 버스 접근
     */
    public static EventBus getEventBus() {
        return EventBus.getInstance();
    }

    // ─────────────────────────────────────────────────────────────
    // 환경 정보
    // ─────────────────────────────────────────────────────────────

    /**
     * Pulse이 완전히 초기화되었는지 확인
     */
    public static boolean isInitialized() {
        return PulseEnvironment.isInitialized();
    }

    /**
     * 게임 디렉토리 경로
     */
    public static Path getGameDirectory() {
        return Path.of(System.getProperty("user.dir"));
    }

    /**
     * mods 디렉토리 경로
     */
    public static Path getModsDirectory() {
        return ModLoader.getInstance().getModsDirectory();
    }

    /**
     * 설정 디렉토리 경로
     */
    public static Path getConfigDirectory() {
        return getGameDirectory().resolve("config");
    }

    // ─────────────────────────────────────────────────────────────
    // DevMode
    // ─────────────────────────────────────────────────────────────

    /**
     * DevMode 활성화 여부 확인
     */
    public static boolean isDevMode() {
        return DevMode.isEnabled();
    }

    /**
     * DevMode 활성화
     */
    public static void enableDevMode() {
        DevMode.enable();
    }

    // ─────────────────────────────────────────────────────────────
    // 로깅
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드별 로거 가져오기
     */
    public static ModLogger getLogger(String modId) {
        return ModLogger.getLogger(modId);
    }

    /**
     * Pulse 로그 출력
     */
    public static void log(String message) {
        System.out.println("[Pulse] " + message);
    }

    /**
     * 모드 로그 출력 (modId prefix 포함)
     */
    public static void log(String modId, String message) {
        System.out.println("[Mod/" + modId + "] " + message);
    }

    /**
     * Pulse 경고 출력
     */
    public static void warn(String message) {
        System.out.println("[Pulse/WARN] " + message);
    }

    /**
     * 모드 경고 출력
     */
    public static void warn(String modId, String message) {
        System.out.println("[Mod/" + modId + "/WARN] " + message);
    }

    /**
     * Pulse 에러 출력
     */
    public static void error(String message) {
        System.err.println("[Pulse/ERROR] " + message);
    }

    /**
     * 모드 에러 출력
     */
    public static void error(String modId, String message) {
        System.err.println("[Mod/" + modId + "/ERROR] " + message);
    }

    /**
     * Pulse 에러 출력 (예외 포함)
     */
    public static void error(String message, Throwable t) {
        System.err.println("[Pulse/ERROR] " + message);
        t.printStackTrace();
    }

    /**
     * 모드 에러 출력 (예외 포함)
     */
    public static void error(String modId, String message, Throwable t) {
        System.err.println("[Mod/" + modId + "/ERROR] " + message);
        t.printStackTrace();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\Pulse.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\SafeGameAccess.java =====

package com.pulse.api;

import java.lang.reflect.Method;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * Thread-safe하고 fallback을 제공하는 게임 객체 접근 API.
 * 안전한 리플렉션 wrapper로 예외 발생 시 fallback 값을 반환합니다.
 * 
 * <pre>
 * // 사용 예시 - 안전한 좀비 체력 조회
 * float health = SafeGameAccess.withZombie(zombie, z -> {
 *     Method getHealth = z.getClass().getMethod("getHealth");
 *     return (Float) getHealth.invoke(z);
 * }, 100.0f); // fallback 값
 * 
 * // 메인 스레드에서 실행
 * SafeGameAccess.runOnMainThread(() -> {
 *     // 게임 상태 변경
 * });
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class SafeGameAccess {

    // 메인 스레드 관련
    private static volatile Thread mainThread = null;
    private static final ConcurrentLinkedQueue<Runnable> mainThreadQueue = new ConcurrentLinkedQueue<>();
    private static final AtomicBoolean processingQueue = new AtomicBoolean(false);

    private SafeGameAccess() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // 메인 스레드 설정 (Pulse 내부용)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 메인 스레드 설정 (PulseAgent에서 호출).
     */
    @InternalAPI
    public static void setMainThread(Thread thread) {
        mainThread = thread;
    }

    /**
     * 현재 메인 스레드에서 실행 중인지 확인.
     */
    public static boolean isOnMainThread() {
        return mainThread != null && Thread.currentThread() == mainThread;
    }

    // ═══════════════════════════════════════════════════════════════
    // Zombie 관련 안전 접근
    // ═══════════════════════════════════════════════════════════════

    /**
     * 좀비 객체에 안전하게 접근.
     * 
     * @param zombie   좀비 객체 (IsoZombie)
     * @param accessor 접근자 함수
     * @param fallback 실패 시 반환값
     * @return 접근 결과 또는 fallback
     */
    public static <T> T withZombie(Object zombie, Function<Object, T> accessor, T fallback) {
        if (zombie == null)
            return fallback;
        try {
            return accessor.apply(zombie);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                System.err.println("[SafeGameAccess] Zombie access failed: " + e.getMessage());
            }
            return fallback;
        }
    }

    /**
     * 주변 좀비 목록 안전 조회.
     * 
     * @param x      중심 X 좌표
     * @param y      중심 Y 좌표
     * @param radius 반경
     * @return 좀비 리스트 Optional
     */
    public static Optional<List<Object>> getNearbyZombiesSafe(float x, float y, float radius) {
        try {
            List<Object> zombies = GameAccess.getNearbyZombies(x, y, radius);
            return Optional.ofNullable(zombies);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                System.err.println("[SafeGameAccess] getNearbyZombies failed: " + e.getMessage());
            }
            return Optional.empty();
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Chunk 관련 안전 접근
    // ═══════════════════════════════════════════════════════════════

    /**
     * 청크 객체에 안전하게 접근.
     * 
     * @param chunk    청크 객체 (IsoChunk)
     * @param accessor 접근자 함수
     * @param fallback 실패 시 반환값
     * @return 접근 결과 또는 fallback
     */
    public static <T> T withChunk(Object chunk, Function<Object, T> accessor, T fallback) {
        if (chunk == null)
            return fallback;
        try {
            return accessor.apply(chunk);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                System.err.println("[SafeGameAccess] Chunk access failed: " + e.getMessage());
            }
            return fallback;
        }
    }

    /**
     * 월드 좌표로 청크 안전 조회.
     * 
     * @param wx 월드 X 좌표
     * @param wy 월드 Y 좌표
     * @return 청크 Optional
     */
    public static Optional<Object> getChunkSafe(int wx, int wy) {
        try {
            Object world = getIsoWorldInstanceInternal();
            if (world == null)
                return Optional.empty();

            // IsoWorld.CurrentCell.getChunk(wx, wy)
            Method getCellMethod = world.getClass().getMethod("getCell");
            Object cell = getCellMethod.invoke(world);
            if (cell == null)
                return Optional.empty();

            Method getChunkMethod = cell.getClass().getMethod("getChunk", int.class, int.class);
            Object chunk = getChunkMethod.invoke(cell, wx, wy);
            return Optional.ofNullable(chunk);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                System.err.println("[SafeGameAccess] getChunk failed: " + e.getMessage());
            }
            return Optional.empty();
        }
    }

    /**
     * 내부용 IsoWorld 인스턴스 조회 (리플렉션).
     */
    private static Object getIsoWorldInstanceInternal() {
        try {
            Object world = GameAccess.getStaticField("zombie.iso.IsoWorld", "instance");
            if (world != null)
                return world;

            // 대안: 클래스 직접 로드 시도
            Class<?> isoWorldClass = GameAccess.getGameClass("zombie.iso.IsoWorld");
            if (isoWorldClass != null) {
                java.lang.reflect.Field instanceField = isoWorldClass.getDeclaredField("instance");
                instanceField.setAccessible(true);
                return instanceField.get(null);
            }
        } catch (Exception e) {
            // ignore
        }
        return null;
    }

    // ═══════════════════════════════════════════════════════════════
    // AI 관련 안전 접근
    // ═══════════════════════════════════════════════════════════════

    /**
     * AI 객체에 안전하게 접근.
     * 
     * @param ai       AI 객체
     * @param accessor 접근자 함수
     * @param fallback 실패 시 반환값
     * @return 접근 결과 또는 fallback
     */
    public static <T> T withAI(Object ai, Function<Object, T> accessor, T fallback) {
        if (ai == null)
            return fallback;
        try {
            return accessor.apply(ai);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                System.err.println("[SafeGameAccess] AI access failed: " + e.getMessage());
            }
            return fallback;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Lua 관련 안전 접근
    // ═══════════════════════════════════════════════════════════════

    /**
     * Lua 상태에 안전하게 접근.
     * 
     * @param accessor 접근자 함수
     * @param fallback 실패 시 반환값
     * @return 접근 결과 또는 fallback
     */
    public static <T> T withLuaState(Function<Object, T> accessor, T fallback) {
        try {
            // LuaManager.GlobalEnvironment 접근
            Object luaEnv = GameAccess.getStaticField("se.krka.kahlua.vm.LuaState", "instance");
            if (luaEnv == null) {
                // 대체 경로
                Object platform = GameAccess.getStaticField("se.krka.kahlua.j2se.J2SEPlatform", "instance");
                if (platform != null) {
                    Method newEnvMethod = platform.getClass().getMethod("newEnvironment");
                    luaEnv = newEnvMethod.invoke(platform);
                }
            }

            if (luaEnv != null) {
                return accessor.apply(luaEnv);
            }
            return fallback;
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                System.err.println("[SafeGameAccess] Lua state access failed: " + e.getMessage());
            }
            return fallback;
        }
    }

    /**
     * Lua 호출이 스레드 안전한지 확인.
     * PZ의 Lua는 기본적으로 메인 스레드에서만 호출 가능.
     * 
     * @return 현재 스레드에서 Lua 호출이 안전하면 true
     */
    public static boolean isLuaThreadSafe() {
        return isOnMainThread();
    }

    // ═══════════════════════════════════════════════════════════════
    // 스레드 안전 실행
    // ═══════════════════════════════════════════════════════════════

    /**
     * 메인 스레드에서 실행.
     * 이미 메인 스레드에 있다면 즉시 실행,
     * 아니면 큐에 추가되어 다음 틱에 실행.
     * 
     * @param action 실행할 액션
     */
    public static void runOnMainThread(Runnable action) {
        if (action == null)
            return;

        if (isOnMainThread()) {
            try {
                action.run();
            } catch (Exception e) {
                System.err.println("[SafeGameAccess] Main thread action failed: " + e.getMessage());
                if (DevMode.isEnabled()) {
                    e.printStackTrace();
                }
            }
        } else {
            mainThreadQueue.offer(action);
        }
    }

    /**
     * 메인 스레드에서 실행하고 결과 반환 (CompletableFuture).
     * 
     * @param action 실행할 작업
     * @return CompletableFuture with result
     */
    public static <T> CompletableFuture<T> callOnMainThread(Supplier<T> action) {
        CompletableFuture<T> future = new CompletableFuture<>();

        runOnMainThread(() -> {
            try {
                T result = action.get();
                future.complete(result);
            } catch (Exception e) {
                future.completeExceptionally(e);
            }
        });

        return future;
    }

    /**
     * 큐에 있는 모든 액션 처리 (게임 틱에서 호출).
     */
    @InternalAPI
    public static void processMainThreadQueue() {
        if (!processingQueue.compareAndSet(false, true))
            return;

        try {
            Runnable action;
            int processed = 0;
            while ((action = mainThreadQueue.poll()) != null && processed < 100) {
                try {
                    action.run();
                } catch (Exception e) {
                    System.err.println("[SafeGameAccess] Queued action failed: " + e.getMessage());
                }
                processed++;
            }
        } finally {
            processingQueue.set(false);
        }
    }

    /**
     * 큐 크기 반환.
     */
    public static int getQueueSize() {
        return mainThreadQueue.size();
    }

    // ═══════════════════════════════════════════════════════════════
    // 범용 안전 접근
    // ═══════════════════════════════════════════════════════════════

    /**
     * 임의 객체에 안전하게 accessor 적용.
     * 
     * @param target   대상 객체
     * @param accessor 접근자 함수
     * @param fallback 실패 시 반환값
     * @return 결과 또는 fallback
     */
    public static <T, R> R safely(T target, Function<T, R> accessor, R fallback) {
        if (target == null)
            return fallback;
        try {
            return accessor.apply(target);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                System.err.println("[SafeGameAccess] Safe access failed: " + e.getMessage());
            }
            return fallback;
        }
    }

    /**
     * 안전하게 메서드 호출.
     * 
     * @param target     대상 객체
     * @param methodName 메서드 이름
     * @param fallback   실패 시 반환값
     * @param args       인자들
     * @return 결과 또는 fallback
     */
    @SuppressWarnings("unchecked")
    public static <T> T safeInvoke(Object target, String methodName, T fallback, Object... args) {
        if (target == null)
            return fallback;
        try {
            Class<?>[] paramTypes = new Class<?>[args.length];
            for (int i = 0; i < args.length; i++) {
                paramTypes[i] = args[i] != null ? args[i].getClass() : Object.class;
            }

            Method method = target.getClass().getMethod(methodName, paramTypes);
            return (T) method.invoke(target, args);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                System.err.println("[SafeGameAccess] safeInvoke(" + methodName + ") failed: " + e.getMessage());
            }
            return fallback;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\api\SafeGameAccess.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\attachment\AttachmentType.java =====

package com.pulse.attachment;

import com.pulse.registry.Identifier;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 데이터 첨부 타입.
 * 게임 객체에 커스텀 데이터를 첨부하기 위한 타입 정의.
 * 
 * NeoForge의 Data Attachment와 유사한 개념.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 첨부 타입 정의
 * public static final AttachmentType<MyData> MY_DATA = AttachmentType.builder("mymod", "my_data", MyData::new)
 *         .persistent() // NBT 저장
 *         .copyOnDeath() // 사망 시 복사
 *         .build();
 * 
 * // 데이터 접근
 * MyData data = DataAttachments.get(entity, MY_DATA);
 * data.setValue(42);
 * </pre>
 * 
 * @param <T> 첨부 데이터 타입
 */
public class AttachmentType<T> {

    private final Identifier id;
    private final Supplier<T> defaultFactory;
    private final boolean persistent;
    private final boolean copyOnDeath;
    private final Serializer<T> serializer;

    // 등록된 모든 첨부 타입
    private static final Map<Identifier, AttachmentType<?>> REGISTRY = new ConcurrentHashMap<>();

    private AttachmentType(Identifier id, Supplier<T> defaultFactory,
            boolean persistent, boolean copyOnDeath,
            Serializer<T> serializer) {
        this.id = id;
        this.defaultFactory = defaultFactory;
        this.persistent = persistent;
        this.copyOnDeath = copyOnDeath;
        this.serializer = serializer;

        REGISTRY.put(id, this);
    }

    /**
     * 빌더 생성
     */
    public static <T> Builder<T> builder(String modId, String name, Supplier<T> defaultFactory) {
        return new Builder<>(Identifier.of(modId, name), defaultFactory);
    }

    /**
     * ID로 첨부 타입 가져오기
     */
    @SuppressWarnings("unchecked")
    public static <T> AttachmentType<T> get(Identifier id) {
        return (AttachmentType<T>) REGISTRY.get(id);
    }

    /**
     * 모든 등록된 첨부 타입
     */
    public static Collection<AttachmentType<?>> getAll() {
        return Collections.unmodifiableCollection(REGISTRY.values());
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public Identifier getId() {
        return id;
    }

    public Supplier<T> getDefaultFactory() {
        return defaultFactory;
    }

    public boolean isPersistent() {
        return persistent;
    }

    public boolean isCopyOnDeath() {
        return copyOnDeath;
    }

    public Serializer<T> getSerializer() {
        return serializer;
    }

    /**
     * 기본값 생성
     */
    public T createDefault() {
        return defaultFactory.get();
    }

    // ─────────────────────────────────────────────────────────────
    // 빌더
    // ─────────────────────────────────────────────────────────────

    public static class Builder<T> {
        private final Identifier id;
        private final Supplier<T> defaultFactory;
        private boolean persistent = false;
        private boolean copyOnDeath = false;
        private Serializer<T> serializer = null;

        private Builder(Identifier id, Supplier<T> defaultFactory) {
            this.id = id;
            this.defaultFactory = defaultFactory;
        }

        /**
         * 영구 저장 활성화
         */
        public Builder<T> persistent() {
            this.persistent = true;
            return this;
        }

        /**
         * 사망 시 복사
         */
        public Builder<T> copyOnDeath() {
            this.copyOnDeath = true;
            return this;
        }

        /**
         * 커스텀 직렬화기 설정
         */
        public Builder<T> serializer(Serializer<T> serializer) {
            this.serializer = serializer;
            return this;
        }

        public AttachmentType<T> build() {
            AttachmentType<T> type = new AttachmentType<>(
                    id, defaultFactory, persistent, copyOnDeath, serializer);
            System.out.println("[Pulse/Attachment] Registered: " + id);
            return type;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 직렬화 인터페이스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface Serializer<T> {
        /**
         * 객체를 Map으로 직렬화
         */
        Map<String, Object> serialize(T value);

        /**
         * Map에서 객체 복원
         */
        default T deserialize(Map<String, Object> data, Supplier<T> factory) {
            // 기본 구현: 팩토리로 새 객체 생성
            return factory.get();
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\attachment\AttachmentType.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\attachment\DataAttachments.java =====

package com.pulse.attachment;

import com.google.gson.*;
import com.pulse.registry.Identifier;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 데이터 첨부 관리자.
 * 게임 객체에 커스텀 데이터를 첨부하고 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 엔티티에 데이터 첨부
 * MyData data = DataAttachments.get(entity, MY_DATA);
 * 
 * // 데이터 설정
 * DataAttachments.set(entity, MY_DATA, newData);
 * 
 * // 데이터 제거
 * DataAttachments.remove(entity, MY_DATA);
 * 
 * // 존재 여부 확인
 * if (DataAttachments.has(entity, MY_DATA)) { ... }
 * 
 * // 영구 데이터 저장
 * DataAttachments.save(entity, "player_data.json");
 * 
 * // 영구 데이터 로드
 * DataAttachments.load(entity, "player_data.json");
 * </pre>
 */
public class DataAttachments {

    private static final DataAttachments INSTANCE = new DataAttachments();

    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .serializeNulls()
            .create();

    // 객체별 첨부 데이터
    // WeakHashMap을 사용하여 객체가 GC되면 자동으로 정리
    private final Map<Object, Map<AttachmentType<?>, Object>> attachments = Collections
            .synchronizedMap(new WeakHashMap<>());

    // 영구 저장용 디렉토리
    private Path saveDirectory;

    private DataAttachments() {
        String gameDir = System.getProperty("user.dir");
        this.saveDirectory = Paths.get(gameDir, "Pulse", "attachments");
    }

    public static DataAttachments getInstance() {
        return INSTANCE;
    }

    /**
     * 저장 디렉토리 설정
     */
    public static void setSaveDirectory(Path directory) {
        INSTANCE.saveDirectory = directory;
    }

    public static Path getSaveDirectory() {
        return INSTANCE.saveDirectory;
    }

    // ─────────────────────────────────────────────────────────────
    // 데이터 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * 첨부 데이터 가져오기 (없으면 생성)
     */
    public static <T> T get(Object holder, AttachmentType<T> type) {
        return INSTANCE.getData(holder, type);
    }

    /**
     * 첨부 데이터 가져오기 (Optional)
     */
    public static <T> Optional<T> getOptional(Object holder, AttachmentType<T> type) {
        return INSTANCE.getDataOptional(holder, type);
    }

    /**
     * 첨부 데이터 설정
     */
    public static <T> void set(Object holder, AttachmentType<T> type, T value) {
        INSTANCE.setData(holder, type, value);
    }

    /**
     * 첨부 데이터 제거
     */
    public static <T> void remove(Object holder, AttachmentType<T> type) {
        INSTANCE.removeData(holder, type);
    }

    /**
     * 첨부 데이터 존재 여부
     */
    public static <T> boolean has(Object holder, AttachmentType<T> type) {
        return INSTANCE.hasData(holder, type);
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 구현
    // ─────────────────────────────────────────────────────────────

    @SuppressWarnings("unchecked")
    private <T> T getData(Object holder, AttachmentType<T> type) {
        Map<AttachmentType<?>, Object> holderData = attachments.computeIfAbsent(
                holder, k -> new ConcurrentHashMap<>());

        return (T) holderData.computeIfAbsent(type, t -> type.createDefault());
    }

    @SuppressWarnings("unchecked")
    private <T> Optional<T> getDataOptional(Object holder, AttachmentType<T> type) {
        Map<AttachmentType<?>, Object> holderData = attachments.get(holder);
        if (holderData == null)
            return Optional.empty();
        return Optional.ofNullable((T) holderData.get(type));
    }

    private <T> void setData(Object holder, AttachmentType<T> type, T value) {
        Map<AttachmentType<?>, Object> holderData = attachments.computeIfAbsent(
                holder, k -> new ConcurrentHashMap<>());
        holderData.put(type, value);
    }

    private <T> void removeData(Object holder, AttachmentType<T> type) {
        Map<AttachmentType<?>, Object> holderData = attachments.get(holder);
        if (holderData != null) {
            holderData.remove(type);
        }
    }

    private <T> boolean hasData(Object holder, AttachmentType<T> type) {
        Map<AttachmentType<?>, Object> holderData = attachments.get(holder);
        return holderData != null && holderData.containsKey(type);
    }

    // ─────────────────────────────────────────────────────────────
    // 복사/이전
    // ─────────────────────────────────────────────────────────────

    /**
     * 한 객체에서 다른 객체로 모든 첨부 데이터 복사
     */
    public static void copyAll(Object from, Object to) {
        INSTANCE.copyAllData(from, to);
    }

    /**
     * copyOnDeath가 설정된 첨부 데이터만 복사 (사망 시 사용)
     */
    public static void copyOnDeath(Object from, Object to) {
        INSTANCE.copyDeathData(from, to);
    }

    private void copyAllData(Object from, Object to) {
        Map<AttachmentType<?>, Object> fromData = attachments.get(from);
        if (fromData == null || fromData.isEmpty())
            return;

        Map<AttachmentType<?>, Object> toData = attachments.computeIfAbsent(
                to, k -> new ConcurrentHashMap<>());
        toData.putAll(fromData);
    }

    private void copyDeathData(Object from, Object to) {
        Map<AttachmentType<?>, Object> fromData = attachments.get(from);
        if (fromData == null || fromData.isEmpty())
            return;

        Map<AttachmentType<?>, Object> toData = attachments.computeIfAbsent(
                to, k -> new ConcurrentHashMap<>());

        for (Map.Entry<AttachmentType<?>, Object> entry : fromData.entrySet()) {
            if (entry.getKey().isCopyOnDeath()) {
                toData.put(entry.getKey(), entry.getValue());
            }
        }
    }

    /**
     * 객체의 모든 첨부 데이터 제거
     */
    public static void clearAll(Object holder) {
        INSTANCE.attachments.remove(holder);
    }

    /**
     * 첨부 데이터 통계
     */
    public static int getAttachmentCount() {
        return INSTANCE.attachments.size();
    }

    // ─────────────────────────────────────────────────────────────
    // 직렬화/역직렬화
    // ─────────────────────────────────────────────────────────────

    /**
     * 객체의 영구 첨부 데이터를 JSON 파일로 저장.
     * 
     * @param holder   데이터 홀더 객체
     * @param filename 저장할 파일명 (예: "player_123.json")
     * @return 저장 성공 여부
     */
    public static boolean save(Object holder, String filename) {
        return INSTANCE.saveToFile(holder, filename);
    }

    /**
     * JSON 파일에서 영구 첨부 데이터를 로드.
     * 
     * @param holder   데이터 홀더 객체
     * @param filename 로드할 파일명
     * @return 로드 성공 여부
     */
    public static boolean load(Object holder, String filename) {
        return INSTANCE.loadFromFile(holder, filename);
    }

    /**
     * 모든 영구 첨부 데이터를 저장.
     * 각 객체는 hashCode 기반 파일명으로 저장됨.
     */
    public static void saveAll() {
        INSTANCE.saveAllPersistent();
    }

    @SuppressWarnings("unchecked")
    private boolean saveToFile(Object holder, String filename) {
        Map<AttachmentType<?>, Object> holderData = attachments.get(holder);
        if (holderData == null || holderData.isEmpty()) {
            return true; // 저장할 데이터 없음
        }

        try {
            // 디렉토리 생성
            Files.createDirectories(saveDirectory);

            Path filePath = saveDirectory.resolve(filename);

            // 영구 저장 가능한 데이터만 필터링
            JsonObject root = new JsonObject();
            root.addProperty("_version", "1.0");
            root.addProperty("_timestamp", System.currentTimeMillis());

            JsonObject dataObj = new JsonObject();

            for (Map.Entry<AttachmentType<?>, Object> entry : holderData.entrySet()) {
                AttachmentType<?> type = entry.getKey();

                if (!type.isPersistent()) {
                    continue;
                }

                Object value = entry.getValue();
                String key = type.getId().toString();

                // 직렬화
                AttachmentType.Serializer<Object> serializer = (AttachmentType.Serializer<Object>) type.getSerializer();

                if (serializer != null) {
                    // 커스텀 직렬화기 사용
                    Map<String, Object> serialized = serializer.serialize(value);
                    dataObj.add(key, GSON.toJsonTree(serialized));
                } else {
                    // 기본 GSON 직렬화
                    dataObj.add(key, GSON.toJsonTree(value));
                }
            }

            root.add("data", dataObj);

            // 파일에 쓰기
            String json = GSON.toJson(root);
            Files.writeString(filePath, json, StandardCharsets.UTF_8);

            System.out.println("[Pulse/Attachment] Saved: " + filePath.getFileName());
            return true;

        } catch (Exception e) {
            System.err.println("[Pulse/Attachment] Failed to save: " + filename);
            e.printStackTrace();
            return false;
        }
    }

    @SuppressWarnings("unchecked")
    private boolean loadFromFile(Object holder, String filename) {
        Path filePath = saveDirectory.resolve(filename);

        if (!Files.exists(filePath)) {
            return true; // 파일 없음 = 새 데이터
        }

        try {
            String json = Files.readString(filePath, StandardCharsets.UTF_8);
            JsonObject root = JsonParser.parseString(json).getAsJsonObject();

            if (!root.has("data")) {
                return true;
            }

            JsonObject dataObj = root.getAsJsonObject("data");

            Map<AttachmentType<?>, Object> holderData = attachments.computeIfAbsent(
                    holder, k -> new ConcurrentHashMap<>());

            for (String key : dataObj.keySet()) {
                Identifier id = Identifier.parse(key);
                AttachmentType<?> type = AttachmentType.get(id);

                if (type == null) {
                    System.err.println("[Pulse/Attachment] Unknown type: " + key);
                    continue;
                }

                JsonElement element = dataObj.get(key);

                AttachmentType.Serializer<Object> serializer = (AttachmentType.Serializer<Object>) type.getSerializer();

                Object value;
                if (serializer != null) {
                    // 커스텀 역직렬화
                    Map<String, Object> map = GSON.fromJson(element, Map.class);
                    value = serializer.deserialize(map, (java.util.function.Supplier<Object>) type.getDefaultFactory());
                } else {
                    // GSON으로 직접 역직렬화 시도
                    // 기본 팩토리로 새 객체 생성 후 필드 복사
                    value = type.createDefault();
                    if (element.isJsonObject()) {
                        // 리플렉션으로 필드 복사
                        copyJsonToObject(element.getAsJsonObject(), value);
                    }
                }

                holderData.put(type, value);
            }

            System.out.println("[Pulse/Attachment] Loaded: " + filePath.getFileName());
            return true;

        } catch (Exception e) {
            System.err.println("[Pulse/Attachment] Failed to load: " + filename);
            e.printStackTrace();
            return false;
        }
    }

    private void copyJsonToObject(JsonObject json, Object target) {
        try {
            for (java.lang.reflect.Field field : target.getClass().getDeclaredFields()) {
                if (java.lang.reflect.Modifier.isStatic(field.getModifiers())) {
                    continue;
                }

                String fieldName = field.getName();
                if (!json.has(fieldName)) {
                    continue;
                }

                field.setAccessible(true);
                JsonElement element = json.get(fieldName);

                Class<?> fieldType = field.getType();
                Object value = GSON.fromJson(element, fieldType);
                field.set(target, value);
            }
        } catch (Exception e) {
            System.err.println("[Pulse/Attachment] Failed to copy JSON to object: " + e.getMessage());
        }
    }

    private void saveAllPersistent() {
        int saved = 0;
        for (Map.Entry<Object, Map<AttachmentType<?>, Object>> entry : attachments.entrySet()) {
            Object holder = entry.getKey();

            // holder의 고유 식별자 생성
            String filename = "holder_" + System.identityHashCode(holder) + ".json";

            if (saveToFile(holder, filename)) {
                saved++;
            }
        }
        System.out.println("[Pulse/Attachment] Saved " + saved + " holder(s)");
    }

    /**
     * 특정 파일 삭제
     */
    public static boolean delete(String filename) {
        try {
            Path filePath = INSTANCE.saveDirectory.resolve(filename);
            return Files.deleteIfExists(filePath);
        } catch (IOException e) {
            return false;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\attachment\DataAttachments.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\command\Arg.java =====

package com.pulse.command;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 명령어 인자 어노테이션.
 * 메서드 파라미터에 적용.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.PARAMETER)
public @interface Arg {
    /**
     * 인자 이름
     */
    String value();

    /**
     * 선택적 인자 여부
     */
    boolean optional() default false;

    /**
     * 기본값 (선택적 인자용)
     */
    String defaultValue() default "";
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\command\Arg.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\command\Command.java =====

package com.pulse.command;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 명령어 메서드 마커 어노테이션.
 * 
 * 사용 예:
 * 
 * <pre>
 * public class MyCommands {
 *     {@literal @}Command(name = "heal", description = "Heal the player")
 *     public void healCommand(CommandContext ctx) {
 *         ctx.getSender().sendMessage("Healed!");
 *     }
 *     
 *     {@literal @}Command(name = "spawn", aliases = {"sp"}, permission = "mymod.spawn")
 *     public void spawnCommand(CommandContext ctx, @Arg("entity") String entity) {
 *         // ...
 *     }
 * }
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Command {
    /**
     * 명령어 이름 (필수)
     */
    String name();

    /**
     * 명령어 설명
     */
    String description() default "";

    /**
     * 사용법 (자동 생성if 비어있음)
     */
    String usage() default "";

    /**
     * 별칭
     */
    String[] aliases() default {};

    /**
     * 필요 권한
     */
    String permission() default "";

    /**
     * 플레이어만 사용 가능
     */
    boolean playerOnly() default false;

    /**
     * 콘솔만 사용 가능
     */
    boolean consoleOnly() default false;
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\command\Command.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\command\CommandContext.java =====

package com.pulse.command;

import java.util.*;

/**
 * 명령어 실행 컨텍스트.
 * 명령어 핸들러에 전달되는 정보.
 */
public class CommandContext {

    private final CommandSender sender;
    private final String commandName;
    private final String[] rawArgs;
    private int argIndex = 0;

    public CommandContext(CommandSender sender, String commandName, String[] args) {
        this.sender = sender;
        this.commandName = commandName;
        this.rawArgs = args != null ? args : new String[0];
    }

    // ─────────────────────────────────────────────────────────────
    // 기본 정보
    // ─────────────────────────────────────────────────────────────

    public CommandSender getSender() {
        return sender;
    }

    public String getCommandName() {
        return commandName;
    }

    public String[] getRawArgs() {
        return rawArgs;
    }

    public int getArgCount() {
        return rawArgs.length;
    }

    // ─────────────────────────────────────────────────────────────
    // 인자 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * 인자가 있는지 확인
     */
    public boolean hasArg(int index) {
        return index >= 0 && index < rawArgs.length;
    }

    /**
     * 인덱스로 인자 가져오기
     */
    public String getArg(int index) {
        if (index < 0 || index >= rawArgs.length) {
            return null;
        }
        return rawArgs[index];
    }

    /**
     * 인덱스로 인자 가져오기 (기본값)
     */
    public String getArg(int index, String defaultValue) {
        String arg = getArg(index);
        return arg != null ? arg : defaultValue;
    }

    /**
     * 다음 인자 가져오기
     */
    public String nextArg() {
        if (argIndex >= rawArgs.length) {
            return null;
        }
        return rawArgs[argIndex++];
    }

    /**
     * 다음 인자 가져오기 (기본값)
     */
    public String nextArg(String defaultValue) {
        String arg = nextArg();
        return arg != null ? arg : defaultValue;
    }

    /**
     * 나머지 인자 모두 합치기
     */
    public String getRemainingArgs() {
        if (argIndex >= rawArgs.length) {
            return "";
        }
        return String.join(" ", Arrays.copyOfRange(rawArgs, argIndex, rawArgs.length));
    }

    /**
     * 인덱스 이후 모든 인자 합치기
     */
    public String getArgsFrom(int index) {
        if (index >= rawArgs.length) {
            return "";
        }
        return String.join(" ", Arrays.copyOfRange(rawArgs, index, rawArgs.length));
    }

    // ─────────────────────────────────────────────────────────────
    // 타입 변환
    // ─────────────────────────────────────────────────────────────

    public Integer getInt(int index) {
        String arg = getArg(index);
        if (arg == null)
            return null;
        try {
            return Integer.parseInt(arg);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public int getInt(int index, int defaultValue) {
        Integer val = getInt(index);
        return val != null ? val : defaultValue;
    }

    public Double getDouble(int index) {
        String arg = getArg(index);
        if (arg == null)
            return null;
        try {
            return Double.parseDouble(arg);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public double getDouble(int index, double defaultValue) {
        Double val = getDouble(index);
        return val != null ? val : defaultValue;
    }

    public Boolean getBoolean(int index) {
        String arg = getArg(index);
        if (arg == null)
            return null;
        return "true".equalsIgnoreCase(arg) || "yes".equalsIgnoreCase(arg) || "1".equals(arg);
    }

    public boolean getBoolean(int index, boolean defaultValue) {
        Boolean val = getBoolean(index);
        return val != null ? val : defaultValue;
    }

    // ─────────────────────────────────────────────────────────────
    // 응답 헬퍼
    // ─────────────────────────────────────────────────────────────

    public void reply(String message) {
        sender.sendMessage(message);
    }

    public void replyError(String message) {
        sender.sendError(message);
    }

    public void replyFormat(String format, Object... args) {
        sender.sendMessage(String.format(format, args));
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\command\CommandContext.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\command\CommandRegistry.java =====

package com.pulse.command;

import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 명령어 레지스트리.
 * 모든 명령어를 등록하고 실행을 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 어노테이션 기반 등록
 * CommandRegistry.register(new MyCommands());
 * 
 * // 람다 기반 등록
 * CommandRegistry.register("hello", ctx -> {
 *     ctx.reply("Hello, " + ctx.getSender().getName() + "!");
 * });
 * 
 * // 명령어 실행 (채팅 훅에서 호출)
 * CommandRegistry.execute(sender, "/hello world");
 * </pre>
 */
public class CommandRegistry {

    private static final CommandRegistry INSTANCE = new CommandRegistry();

    // 등록된 명령어
    private final Map<String, RegisteredCommand> commands = new ConcurrentHashMap<>();

    // 명령어 접두사
    private String prefix = "/";

    private CommandRegistry() {
    }

    public static CommandRegistry getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 편의 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 어노테이션 기반 명령어 클래스 등록
     */
    public static void register(Object commandHandler) {
        INSTANCE.registerHandler(commandHandler);
    }

    /**
     * 람다 기반 명령어 등록
     */
    public static void register(String name, CommandExecutor executor) {
        INSTANCE.registerCommand(name, executor);
    }

    /**
     * 람다 기반 명령어 등록 (설명 포함)
     */
    public static void register(String name, String description, CommandExecutor executor) {
        INSTANCE.registerCommand(name, description, executor);
    }

    /**
     * 명령어 실행
     * 
     * @return true if command was found and executed
     */
    public static boolean execute(CommandSender sender, String input) {
        return INSTANCE.executeCommand(sender, input);
    }

    /**
     * 모든 명령어 가져오기
     */
    public static Collection<RegisteredCommand> getAll() {
        return INSTANCE.getAllCommands();
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 어노테이션 기반 핸들러 등록
     */
    public void registerHandler(Object handler) {
        Class<?> clazz = handler.getClass();

        for (Method method : clazz.getDeclaredMethods()) {
            Command annotation = method.getAnnotation(Command.class);
            if (annotation == null)
                continue;

            method.setAccessible(true);

            RegisteredCommand cmd = new RegisteredCommand(
                    annotation.name(),
                    annotation.description(),
                    annotation.usage(),
                    annotation.aliases(),
                    annotation.permission(),
                    annotation.playerOnly(),
                    annotation.consoleOnly(),
                    handler,
                    method);

            registerInternal(cmd);
        }
    }

    /**
     * 람다 기반 등록
     */
    public void registerCommand(String name, CommandExecutor executor) {
        registerCommand(name, "", executor);
    }

    public void registerCommand(String name, String description, CommandExecutor executor) {
        RegisteredCommand cmd = new RegisteredCommand(
                name, description, "", new String[0], "", false, false, executor, null);
        registerInternal(cmd);
    }

    private void registerInternal(RegisteredCommand cmd) {
        commands.put(cmd.getName().toLowerCase(), cmd);

        // 별칭 등록
        for (String alias : cmd.getAliases()) {
            commands.put(alias.toLowerCase(), cmd);
        }

        System.out.println("[Pulse/CMD] Registered command: /" + cmd.getName());
    }

    /**
     * 명령어 실행
     */
    public boolean executeCommand(CommandSender sender, String input) {
        // 접두사 확인
        if (!input.startsWith(prefix)) {
            return false;
        }

        // 파싱
        String withoutPrefix = input.substring(prefix.length()).trim();
        if (withoutPrefix.isEmpty()) {
            return false;
        }

        String[] parts = withoutPrefix.split("\\s+", 2);
        String cmdName = parts[0].toLowerCase();
        String[] args = parts.length > 1 ? parts[1].split("\\s+") : new String[0];

        // 명령어 찾기
        RegisteredCommand cmd = commands.get(cmdName);
        if (cmd == null) {
            return false;
        }

        // 권한 확인
        if (!cmd.getPermission().isEmpty() && !sender.hasPermission(cmd.getPermission())) {
            sender.sendError("You don't have permission to use this command.");
            return true;
        }

        // 플레이어 전용 확인
        if (cmd.isPlayerOnly() && !sender.isPlayer()) {
            sender.sendError("This command can only be used by players.");
            return true;
        }

        // 콘솔 전용 확인
        if (cmd.isConsoleOnly() && !sender.isConsole()) {
            sender.sendError("This command can only be used from console.");
            return true;
        }

        // 실행
        try {
            CommandContext ctx = new CommandContext(sender, cmdName, args);
            cmd.execute(ctx);
        } catch (Exception e) {
            sender.sendError("Error executing command: " + e.getMessage());
            e.printStackTrace();
        }

        return true;
    }

    public RegisteredCommand getCommand(String name) {
        return commands.get(name.toLowerCase());
    }

    public Collection<RegisteredCommand> getAllCommands() {
        // 중복 제거 (별칭으로 인해)
        return new HashSet<>(commands.values());
    }

    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }

    public String getPrefix() {
        return prefix;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface CommandExecutor {
        void execute(CommandContext ctx);
    }

    public static class RegisteredCommand {
        private final String name;
        private final String description;
        private final String usage;
        private final String[] aliases;
        private final String permission;
        private final boolean playerOnly;
        private final boolean consoleOnly;
        private final Object handler; // 어노테이션 기반
        private final Method method; // 어노테이션 기반
        private final CommandExecutor executor; // 람다 기반

        public RegisteredCommand(String name, String description, String usage,
                String[] aliases, String permission,
                boolean playerOnly, boolean consoleOnly,
                Object handler, Method method) {
            this.name = name;
            this.description = description;
            this.usage = usage;
            this.aliases = aliases;
            this.permission = permission;
            this.playerOnly = playerOnly;
            this.consoleOnly = consoleOnly;

            if (handler instanceof CommandExecutor exec) {
                this.handler = null;
                this.method = null;
                this.executor = exec;
            } else {
                this.handler = handler;
                this.method = method;
                this.executor = null;
            }
        }

        public void execute(CommandContext ctx) throws Exception {
            if (executor != null) {
                executor.execute(ctx);
            } else if (method != null && handler != null) {
                method.invoke(handler, ctx);
            }
        }

        // Getters
        public String getName() {
            return name;
        }

        public String getDescription() {
            return description;
        }

        public String getUsage() {
            return usage.isEmpty() ? "/" + name : usage;
        }

        public String[] getAliases() {
            return aliases;
        }

        public String getPermission() {
            return permission;
        }

        public boolean isPlayerOnly() {
            return playerOnly;
        }

        public boolean isConsoleOnly() {
            return consoleOnly;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\command\CommandRegistry.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\command\CommandSender.java =====

package com.pulse.command;

/**
 * 명령 발신자 인터페이스.
 * 플레이어, 콘솔, 또는 기타 소스.
 */
public interface CommandSender {

    /**
     * 발신자 이름
     */
    String getName();

    /**
     * 메시지 전송
     */
    void sendMessage(String message);

    /**
     * 오류 메시지 전송
     */
    void sendError(String message);

    /**
     * 플레이어인지 확인
     */
    boolean isPlayer();

    /**
     * 서버/콘솔인지 확인
     */
    boolean isConsole();

    /**
     * 권한 확인
     */
    boolean hasPermission(String permission);

    /**
     * 플레이어 객체 (플레이어인 경우)
     */
    Object getPlayer();

    // ─────────────────────────────────────────────────────────────
    // 구현체
    // ─────────────────────────────────────────────────────────────

    /**
     * 콘솔 발신자
     */
    CommandSender CONSOLE = new CommandSender() {
        @Override
        public String getName() {
            return "Console";
        }

        @Override
        public void sendMessage(String message) {
            System.out.println("[Pulse/CMD] " + message);
        }

        @Override
        public void sendError(String message) {
            System.err.println("[Pulse/CMD] ERROR: " + message);
        }

        @Override
        public boolean isPlayer() {
            return false;
        }

        @Override
        public boolean isConsole() {
            return true;
        }

        @Override
        public boolean hasPermission(String permission) {
            return true;
        }

        @Override
        public Object getPlayer() {
            return null;
        }
    };
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\command\CommandSender.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\config\Config.java =====

package com.pulse.config;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 설정 클래스 마커 어노테이션.
 * 이 어노테이션이 붙은 클래스는 ConfigManager에 의해 자동으로 처리됨.
 * 
 * 사용 예:
 * 
 * <pre>
 * {@literal @}Config(modId = "mymod", fileName = "config.json")
 * public class MyModConfig {
 *     {@literal @}ConfigValue(comment = "Enable feature X")
 *     public static boolean enableFeatureX = true;
 * }
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Config {
    /**
     * 모드 ID (필수)
     */
    String modId();

    /**
     * 설정 파일 이름 (선택, 기본값: modId.json)
     */
    String fileName() default "";

    /**
     * 설정 카테고리 (선택, 폴더 구분용)
     */
    String category() default "";
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\config\Config.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\config\ConfigManager.java =====

package com.pulse.config;

import com.google.gson.*;

import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Pulse 설정 관리자.
 * 
 * 모드별 설정 파일 자동 생성, 로드, 저장을 담당.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 설정 클래스 정의
 * {@literal @}Config(modId = "mymod")
 * public class MyModConfig {
 *     {@literal @}ConfigValue(comment = "Enable feature X")
 *     public static boolean enableFeatureX = true;
 *     
 *     {@literal @}ConfigValue(min = 0, max = 100)
 *     public static int someValue = 50;
 * }
 * 
 * // 등록 및 로드
 * ConfigManager.register(MyModConfig.class);
 * 
 * // 사용
 * if (MyModConfig.enableFeatureX) { ... }
 * 
 * // 저장
 * ConfigManager.save(MyModConfig.class);
 * </pre>
 */
public class ConfigManager {

    private static final ConfigManager INSTANCE = new ConfigManager();

    // 등록된 설정 스펙
    private final Map<Class<?>, ConfigSpec> specs = new ConcurrentHashMap<>();

    // 설정 디렉토리
    private Path configDirectory;

    // JSON 파서
    private final Gson gson = new GsonBuilder()
            .setPrettyPrinting()
            .serializeNulls()
            .create();

    private ConfigManager() {
        // 기본 설정 디렉토리: 게임 폴더/config
        String gameDir = System.getProperty("user.dir");
        this.configDirectory = Paths.get(gameDir, "config");
    }

    public static ConfigManager getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 편의 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 설정 클래스 등록 및 로드
     */
    public static void register(Class<?> configClass) {
        INSTANCE.registerConfig(configClass);
    }

    /**
     * 설정 저장
     */
    public static void save(Class<?> configClass) {
        INSTANCE.saveConfig(configClass);
    }

    /**
     * 설정 리로드
     */
    public static void reload(Class<?> configClass) {
        INSTANCE.loadConfig(configClass);
    }

    /**
     * 모든 설정 저장
     */
    public static void saveAll() {
        INSTANCE.saveAllConfigs();
    }

    /**
     * 모든 설정 리로드
     */
    public static void reloadAll() {
        INSTANCE.loadAllConfigs();
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 설정 클래스 등록
     */
    public void registerConfig(Class<?> configClass) {
        if (!configClass.isAnnotationPresent(Config.class)) {
            throw new IllegalArgumentException("Class must have @Config annotation: " + configClass.getName());
        }

        ConfigSpec spec = new ConfigSpec(configClass);
        specs.put(configClass, spec);

        System.out.println("[Pulse/Config] Registered config: " + spec.getModId());

        // 파일에서 로드 시도
        loadConfig(configClass);
    }

    /**
     * 설정 로드
     */
    public void loadConfig(Class<?> configClass) {
        ConfigSpec spec = specs.get(configClass);
        if (spec == null) {
            System.err.println("[Pulse/Config] Config not registered: " + configClass.getName());
            return;
        }

        Path configFile = getConfigPath(spec);

        if (!Files.exists(configFile)) {
            // 파일이 없으면 기본값으로 생성
            saveConfig(configClass);
            return;
        }

        try {
            String json = Files.readString(configFile, StandardCharsets.UTF_8);
            JsonObject root = JsonParser.parseString(json).getAsJsonObject();

            for (ConfigSpec.ConfigEntry entry : spec.getEntries()) {
                if (root.has(entry.getKey())) {
                    JsonElement element = root.get(entry.getKey());
                    Object value = parseValue(element, entry.getType());
                    if (value != null) {
                        entry.setValue(value);
                    }
                }
            }

            System.out.println("[Pulse/Config] Loaded: " + configFile.getFileName());

        } catch (Exception e) {
            System.err.println("[Pulse/Config] Failed to load " + configFile + ": " + e.getMessage());
            // 로드 실패 시 기본값 유지
        }
    }

    /**
     * 설정 저장
     */
    public void saveConfig(Class<?> configClass) {
        ConfigSpec spec = specs.get(configClass);
        if (spec == null) {
            System.err.println("[Pulse/Config] Config not registered: " + configClass.getName());
            return;
        }

        Path configFile = getConfigPath(spec);

        try {
            // 디렉토리 생성
            Files.createDirectories(configFile.getParent());

            // JSON 객체 구성
            JsonObject root = new JsonObject();

            // 메타데이터 주석
            root.addProperty("_comment", "Configuration for " + spec.getModId());

            for (ConfigSpec.ConfigEntry entry : spec.getEntries()) {
                Object value = entry.getValue();
                JsonElement element = serializeValue(value);

                // 주석이 있으면 _key_comment 형태로 추가
                if (!entry.getComment().isEmpty()) {
                    root.addProperty("_" + entry.getKey() + "_comment", entry.getComment());
                }

                root.add(entry.getKey(), element);
            }

            // 파일에 쓰기
            String json = gson.toJson(root);
            Files.writeString(configFile, json, StandardCharsets.UTF_8);

            System.out.println("[Pulse/Config] Saved: " + configFile.getFileName());

        } catch (Exception e) {
            System.err.println("[Pulse/Config] Failed to save " + configFile + ": " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * 모든 설정 저장
     */
    public void saveAllConfigs() {
        for (Class<?> configClass : specs.keySet()) {
            saveConfig(configClass);
        }
    }

    /**
     * 모든 설정 로드
     */
    public void loadAllConfigs() {
        for (Class<?> configClass : specs.keySet()) {
            loadConfig(configClass);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 직렬화/역직렬화 헬퍼
    // ─────────────────────────────────────────────────────────────

    private Path getConfigPath(ConfigSpec spec) {
        Path base = configDirectory;
        if (!spec.getCategory().isEmpty()) {
            base = base.resolve(spec.getCategory());
        }
        return base.resolve(spec.getFileName());
    }

    private Object parseValue(JsonElement element, Class<?> type) {
        if (element.isJsonNull())
            return null;

        try {
            if (type == boolean.class || type == Boolean.class) {
                return element.getAsBoolean();
            }
            if (type == int.class || type == Integer.class) {
                return element.getAsInt();
            }
            if (type == long.class || type == Long.class) {
                return element.getAsLong();
            }
            if (type == float.class || type == Float.class) {
                return element.getAsFloat();
            }
            if (type == double.class || type == Double.class) {
                return element.getAsDouble();
            }
            if (type == String.class) {
                return element.getAsString();
            }
            if (type.isArray()) {
                return gson.fromJson(element, type);
            }
            if (List.class.isAssignableFrom(type)) {
                return gson.fromJson(element, type);
            }

            // 기타 객체 타입
            return gson.fromJson(element, type);

        } catch (Exception e) {
            System.err.println("[Pulse/Config] Failed to parse value: " + e.getMessage());
            return null;
        }
    }

    private JsonElement serializeValue(Object value) {
        if (value == null)
            return JsonNull.INSTANCE;
        return gson.toJsonTree(value);
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    public void setConfigDirectory(Path directory) {
        this.configDirectory = directory;
    }

    public Path getConfigDirectory() {
        return configDirectory;
    }

    public ConfigSpec getSpec(Class<?> configClass) {
        return specs.get(configClass);
    }

    public Collection<ConfigSpec> getAllSpecs() {
        return Collections.unmodifiableCollection(specs.values());
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\config\ConfigManager.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\config\ConfigSpec.java =====

package com.pulse.config;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 설정 스펙.
 * 설정 클래스의 메타데이터를 담고 있음.
 */
public class ConfigSpec {

    private final Class<?> configClass;
    private final String modId;
    private final String fileName;
    private final String category;
    private final List<ConfigEntry> entries = new ArrayList<>();

    public ConfigSpec(Class<?> configClass) {
        this.configClass = configClass;

        Config config = configClass.getAnnotation(Config.class);
        if (config == null) {
            throw new IllegalArgumentException("Class must have @Config annotation");
        }

        this.modId = config.modId();
        this.fileName = config.fileName().isEmpty() ? modId + ".json" : config.fileName();
        this.category = config.category();

        // 필드 스캔
        scanFields();
    }

    private void scanFields() {
        for (Field field : configClass.getDeclaredFields()) {
            ConfigValue annotation = field.getAnnotation(ConfigValue.class);
            if (annotation != null) {
                field.setAccessible(true);

                String key = annotation.key().isEmpty() ? field.getName() : annotation.key();
                Object defaultValue = getFieldValue(field);

                ConfigEntry entry = new ConfigEntry(
                        key,
                        field,
                        annotation.comment(),
                        defaultValue,
                        annotation.min(),
                        annotation.max(),
                        annotation.requiresRestart(),
                        annotation.options(),
                        annotation.step(),
                        annotation.category());

                entries.add(entry);
            }
        }
    }

    private Object getFieldValue(Field field) {
        try {
            return field.get(null);
        } catch (IllegalAccessException e) {
            return null;
        }
    }

    // Getters

    public Class<?> getConfigClass() {
        return configClass;
    }

    public String getModId() {
        return modId;
    }

    public String getFileName() {
        return fileName;
    }

    public String getCategory() {
        return category;
    }

    public List<ConfigEntry> getEntries() {
        return entries;
    }

    /**
     * @Validate 메서드 실행.
     * @return 검증 성공 여부
     */
    public boolean runValidation() {
        for (Method method : configClass.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Validate.class)) {
                method.setAccessible(true);
                try {
                    Object result = method.invoke(null);
                    if (result instanceof Boolean b && !b) {
                        Validate validate = method.getAnnotation(Validate.class);
                        System.err.println("[Pulse/Config] Validation failed: " + validate.message());
                        return false;
                    }
                } catch (Exception e) {
                    System.err.println("[Pulse/Config] Validation error: " + e.getMessage());
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 모든 값을 기본값으로 리셋.
     */
    public void resetAll() {
        for (ConfigEntry entry : entries) {
            entry.reset();
        }
        System.out.println("[Pulse/Config] Reset all values to defaults for: " + modId);
    }

    public static class ConfigEntry {
        private final String key;
        private final Field field;
        private final String comment;
        private final Object defaultValue;
        private final double min;
        private final double max;
        private final boolean requiresRestart;
        private final String[] options;
        private final double step;
        private final String category;

        public ConfigEntry(String key, Field field, String comment, Object defaultValue,
                double min, double max, boolean requiresRestart,
                String[] options, double step, String category) {
            this.key = key;
            this.field = field;
            this.comment = comment;
            this.defaultValue = defaultValue;
            this.min = min;
            this.max = max;
            this.requiresRestart = requiresRestart;
            this.options = options;
            this.step = step;
            this.category = category;
        }

        public String getKey() {
            return key;
        }

        public Field getField() {
            return field;
        }

        public String getComment() {
            return comment;
        }

        public Object getDefaultValue() {
            return defaultValue;
        }

        public double getMin() {
            return min;
        }

        public double getMax() {
            return max;
        }

        public boolean requiresRestart() {
            return requiresRestart;
        }

        public Class<?> getType() {
            return field.getType();
        }

        public Object getValue() {
            try {
                return field.get(null);
            } catch (IllegalAccessException e) {
                return defaultValue;
            }
        }

        public void setValue(Object value) {
            try {
                // options 검증 (String 타입)
                if (options != null && options.length > 0 && value instanceof String strVal) {
                    List<String> optionList = Arrays.asList(options);
                    if (!optionList.contains(strVal)) {
                        System.err.println("[Pulse/Config] Invalid option '" + strVal +
                                "' for " + key + ", resetting to default");
                        value = defaultValue;
                    }
                }

                // 범위 검사 및 step 적용 (숫자 타입)
                if (value instanceof Number num) {
                    double val = num.doubleValue();

                    // step 적용 (반올림)
                    if (step > 0) {
                        val = Math.round(val / step) * step;
                    }

                    // min/max 범위 적용
                    if (min != Double.MIN_VALUE && val < min) {
                        val = min;
                    }
                    if (max != Double.MAX_VALUE && val > max) {
                        val = max;
                    }

                    value = convertToFieldType(val, field.getType());
                }

                field.set(null, value);
            } catch (IllegalAccessException e) {
                System.err.println("[Pulse/Config] Failed to set value for " + key);
            }
        }

        private Object convertToFieldType(double value, Class<?> type) {
            if (type == int.class || type == Integer.class)
                return (int) value;
            if (type == long.class || type == Long.class)
                return (long) value;
            if (type == float.class || type == Float.class)
                return (float) value;
            if (type == double.class || type == Double.class)
                return value;
            return value;
        }

        public void reset() {
            setValue(defaultValue);
        }

        public String[] getOptions() {
            return options;
        }

        public double getStep() {
            return step;
        }

        public String getCategory() {
            return category;
        }

        public boolean hasOptions() {
            return options != null && options.length > 0;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\config\ConfigSpec.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\config\ConfigValue.java =====

package com.pulse.config;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 설정 값 필드 어노테이션.
 * 설정 클래스 내의 필드에 적용하여 설정 메타데이터 제공.
 * 
 * 지원 타입:
 * - 기본형: boolean, int, long, float, double, String
 * - 배열: String[], int[] 등
 * - 리스트: List<String> 등
 * 
 * 사용 예:
 * 
 * <pre>
 * {@literal @}ConfigValue(comment = "Maximum items", min = 1, max = 1000)
 * public static int maxItems = 100;
 * 
 * {@literal @}ConfigValue(options = {"LOW", "MEDIUM", "HIGH"})
 * public static String quality = "MEDIUM";
 * 
 * {@literal @}ConfigValue(min = 0, max = 100, step = 5)
 * public static int volume = 50;
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface ConfigValue {
    /**
     * 설정 설명/주석
     */
    String comment() default "";

    /**
     * 설정 키 이름 (기본값: 필드 이름)
     */
    String key() default "";

    /**
     * 최소값 (숫자 타입에만 적용)
     */
    double min() default Double.MIN_VALUE;

    /**
     * 최대값 (숫자 타입에만 적용)
     */
    double max() default Double.MAX_VALUE;

    /**
     * 재시작 필요 여부
     */
    boolean requiresRestart() default false;

    /**
     * 허용 값 목록 (String/Enum 타입용)
     * 비어있으면 제한 없음
     */
    String[] options() default {};

    /**
     * 증감 단위 (슬라이더 UI용)
     * 0이면 연속 값
     */
    double step() default 0;

    /**
     * 카테고리 (UI 그룹화용)
     */
    String category() default "";

    /**
     * 숨김 여부 (고급 사용자용)
     */
    boolean hidden() default false;
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\config\ConfigValue.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\config\Validate.java =====

package com.pulse.config;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 설정 유효성 검사 메서드 표시.
 * 메서드는 boolean을 반환해야 하며, 설정 로드 후 호출됨.
 * 
 * 사용 예:
 * 
 * <pre>
 * {@literal @}Config(modId = "mymod")
 * public class MyConfig {
 *     {@literal @}ConfigValue
 *     public static int minValue = 10;
 *     
 *     {@literal @}ConfigValue
 *     public static int maxValue = 100;
 *     
 *     {@literal @}Validate
 *     public static boolean validate() {
 *         // minValue가 maxValue보다 작아야 함
 *         return minValue < maxValue;
 *     }
 * }
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Validate {
    /**
     * 검증 실패 시 메시지
     */
    String message() default "Validation failed";
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\config\Validate.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\content\DataLoader.java =====

package com.pulse.content;

import com.pulse.registry.Identifier;
import com.google.gson.*;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;

/**
 * JSON 기반 데이터 로더.
 * 아이템, 레시피 등을 JSON 파일에서 로드.
 */
public class DataLoader {

    @SuppressWarnings("unused") // Reserved for future JSON serialization
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    // ─────────────────────────────────────────────────────────────
    // 아이템 로딩
    // ─────────────────────────────────────────────────────────────

    /**
     * 디렉토리에서 모든 아이템 JSON 로드.
     */
    public static int loadItems(Path directory) throws IOException {
        int count = 0;

        if (!Files.exists(directory)) {
            System.out.println("[Pulse/Data] Items directory not found: " + directory);
            return 0;
        }

        try (var stream = Files.walk(directory)) {
            for (Path path : (Iterable<Path>) stream.filter(p -> p.toString().endsWith(".json"))::iterator) {
                try {
                    ItemDefinition item = loadItem(path);
                    if (item != null) {
                        ItemRegistry.register(item);
                        count++;
                    }
                } catch (Exception e) {
                    System.err.println("[Pulse/Data] Failed to load item: " + path);
                    e.printStackTrace();
                }
            }
        }

        System.out.println("[Pulse/Data] Loaded " + count + " items from " + directory);
        return count;
    }

    /**
     * 단일 아이템 JSON 로드.
     */
    public static ItemDefinition loadItem(Path path) throws IOException {
        String json = Files.readString(path, StandardCharsets.UTF_8);
        JsonObject obj = JsonParser.parseString(json).getAsJsonObject();

        String idStr = getOrDefault(obj, "id", path.getFileName().toString().replace(".json", ""));
        Identifier id = Identifier.parse(idStr);

        ItemDefinition item = new ItemDefinition(id)
                .name(getOrDefault(obj, "name", id.getPath()))
                .description(getOrDefault(obj, "description", ""))
                .icon(getOrDefault(obj, "icon", null))
                .weight(getFloatOrDefault(obj, "weight", 1.0f))
                .maxStack(getIntOrDefault(obj, "maxStackSize", 1));

        // 타입
        if (obj.has("type")) {
            item.type(ItemDefinition.ItemType.valueOf(obj.get("type").getAsString().toUpperCase()));
        }

        // 카테고리
        if (obj.has("category")) {
            item.category(ItemDefinition.ItemCategory.valueOf(obj.get("category").getAsString().toUpperCase()));
        }

        // 태그
        if (obj.has("tags") && obj.get("tags").isJsonArray()) {
            for (JsonElement tag : obj.getAsJsonArray("tags")) {
                item.tag(tag.getAsString());
            }
        }

        // 커스텀 속성
        if (obj.has("properties") && obj.get("properties").isJsonObject()) {
            for (var entry : obj.getAsJsonObject("properties").entrySet()) {
                item.property(entry.getKey(), jsonToValue(entry.getValue()));
            }
        }

        return item;
    }

    // ─────────────────────────────────────────────────────────────
    // 레시피 로딩
    // ─────────────────────────────────────────────────────────────

    /**
     * 디렉토리에서 모든 레시피 JSON 로드.
     */
    public static int loadRecipes(Path directory) throws IOException {
        int count = 0;

        if (!Files.exists(directory)) {
            System.out.println("[Pulse/Data] Recipes directory not found: " + directory);
            return 0;
        }

        try (var stream = Files.walk(directory)) {
            for (Path path : (Iterable<Path>) stream.filter(p -> p.toString().endsWith(".json"))::iterator) {
                try {
                    RecipeRegistry.Recipe recipe = loadRecipe(path);
                    if (recipe != null) {
                        RecipeRegistry.register(recipe);
                        count++;
                    }
                } catch (Exception e) {
                    System.err.println("[Pulse/Data] Failed to load recipe: " + path);
                    e.printStackTrace();
                }
            }
        }

        System.out.println("[Pulse/Data] Loaded " + count + " recipes from " + directory);
        return count;
    }

    /**
     * 단일 레시피 JSON 로드.
     */
    public static RecipeRegistry.Recipe loadRecipe(Path path) throws IOException {
        String json = Files.readString(path, StandardCharsets.UTF_8);
        JsonObject obj = JsonParser.parseString(json).getAsJsonObject();

        String idStr = getOrDefault(obj, "id", path.getFileName().toString().replace(".json", ""));
        Identifier id = Identifier.parse(idStr);

        Identifier output = Identifier.parse(obj.get("output").getAsString());
        int outputCount = getIntOrDefault(obj, "outputCount", 1);

        RecipeRegistry.Recipe recipe = new RecipeRegistry.Recipe(id, output, outputCount)
                .craftTime(getIntOrDefault(obj, "craftTime", 60))
                .category(getOrDefault(obj, "category", "General"));

        // 재료
        if (obj.has("ingredients") && obj.get("ingredients").isJsonArray()) {
            for (JsonElement elem : obj.getAsJsonArray("ingredients")) {
                JsonObject ing = elem.getAsJsonObject();
                Identifier item = Identifier.parse(ing.get("item").getAsString());
                int count = getIntOrDefault(ing, "count", 1);
                boolean isTool = getBoolOrDefault(ing, "tool", false);

                if (isTool) {
                    recipe.tool(item);
                } else {
                    recipe.ingredient(item, count);
                }
            }
        }

        // 필요 스킬
        if (obj.has("skills") && obj.get("skills").isJsonArray()) {
            for (JsonElement skill : obj.getAsJsonArray("skills")) {
                recipe.skill(skill.getAsString());
            }
        }

        return recipe;
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    private static String getOrDefault(JsonObject obj, String key, String defaultVal) {
        return obj.has(key) ? obj.get(key).getAsString() : defaultVal;
    }

    private static int getIntOrDefault(JsonObject obj, String key, int defaultVal) {
        return obj.has(key) ? obj.get(key).getAsInt() : defaultVal;
    }

    private static float getFloatOrDefault(JsonObject obj, String key, float defaultVal) {
        return obj.has(key) ? obj.get(key).getAsFloat() : defaultVal;
    }

    private static boolean getBoolOrDefault(JsonObject obj, String key, boolean defaultVal) {
        return obj.has(key) ? obj.get(key).getAsBoolean() : defaultVal;
    }

    private static Object jsonToValue(JsonElement elem) {
        if (elem.isJsonPrimitive()) {
            JsonPrimitive prim = elem.getAsJsonPrimitive();
            if (prim.isBoolean())
                return prim.getAsBoolean();
            if (prim.isNumber())
                return prim.getAsNumber();
            return prim.getAsString();
        }
        return elem.toString();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\content\DataLoader.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\content\ItemDefinition.java =====

package com.pulse.content;

import com.pulse.registry.Identifier;

import java.util.*;

/**
 * 커스텀 아이템 정의.
 * JSON 또는 코드로 아이템 속성 정의.
 */
public class ItemDefinition {

    private Identifier id;
    private String name;
    private String description;
    private String icon; // 아이콘 경로

    // 기본 속성
    private float weight = 1.0f;
    private int maxStackSize = 1;
    private ItemType type = ItemType.NORMAL;
    private ItemCategory category = ItemCategory.MISC;

    // 추가 속성
    private final Map<String, Object> properties = new HashMap<>();
    private final List<String> tags = new ArrayList<>();

    public ItemDefinition(Identifier id) {
        this.id = id;
        this.name = id.getPath();
    }

    public ItemDefinition(String namespace, String path) {
        this(Identifier.of(namespace, path));
    }

    // ─────────────────────────────────────────────────────────────
    // 빌더 패턴
    // ─────────────────────────────────────────────────────────────

    public ItemDefinition name(String name) {
        this.name = name;
        return this;
    }

    public ItemDefinition description(String description) {
        this.description = description;
        return this;
    }

    public ItemDefinition icon(String icon) {
        this.icon = icon;
        return this;
    }

    public ItemDefinition weight(float weight) {
        this.weight = weight;
        return this;
    }

    public ItemDefinition maxStack(int maxStackSize) {
        this.maxStackSize = maxStackSize;
        return this;
    }

    public ItemDefinition type(ItemType type) {
        this.type = type;
        return this;
    }

    public ItemDefinition category(ItemCategory category) {
        this.category = category;
        return this;
    }

    public ItemDefinition property(String key, Object value) {
        this.properties.put(key, value);
        return this;
    }

    public ItemDefinition tag(String tag) {
        this.tags.add(tag);
        return this;
    }

    public ItemDefinition tags(String... tags) {
        this.tags.addAll(Arrays.asList(tags));
        return this;
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public Identifier getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public String getIcon() {
        return icon;
    }

    public float getWeight() {
        return weight;
    }

    public int getMaxStackSize() {
        return maxStackSize;
    }

    public ItemType getType() {
        return type;
    }

    public ItemCategory getCategory() {
        return category;
    }

    public Object getProperty(String key) {
        return properties.get(key);
    }

    @SuppressWarnings("unchecked")
    public <T> T getProperty(String key, T defaultValue) {
        Object val = properties.get(key);
        return val != null ? (T) val : defaultValue;
    }

    public List<String> getTags() {
        return Collections.unmodifiableList(tags);
    }

    public boolean hasTag(String tag) {
        return tags.contains(tag);
    }

    // ─────────────────────────────────────────────────────────────
    // 열거형
    // ─────────────────────────────────────────────────────────────

    public enum ItemType {
        NORMAL, // 일반 아이템
        WEAPON, // 무기
        CLOTHING, // 의류
        CONTAINER, // 컨테이너
        FOOD, // 음식
        DRINKABLE, // 음료
        LITERATURE, // 책/잡지
        MOVEABLE, // 이동 가능 오브젝트
        RADIO, // 라디오
        GENERATOR // 발전기
    }

    public enum ItemCategory {
        MISC, // 기타
        WEAPONS, // 무기
        TOOLS, // 도구
        MEDICAL, // 의료
        FOOD, // 음식
        CLOTHING, // 의류
        MATERIALS, // 재료
        ELECTRONICS, // 전자
        LITERATURE // 문헌
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\content\ItemDefinition.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\content\ItemRegistry.java =====

package com.pulse.content;

import com.pulse.registry.Identifier;

import java.util.*;

/**
 * 아이템 레지스트리.
 * 커스텀 아이템 등록 및 조회.
 */
public class ItemRegistry {

    private static final ItemRegistry INSTANCE = new ItemRegistry();

    private final Map<Identifier, ItemDefinition> items = new LinkedHashMap<>();
    private final Map<String, Set<Identifier>> byTag = new HashMap<>();
    private final Map<ItemDefinition.ItemCategory, Set<Identifier>> byCategory = new HashMap<>();

    private ItemRegistry() {
    }

    public static ItemRegistry getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 아이템 등록.
     */
    public static void register(ItemDefinition item) {
        INSTANCE.registerInternal(item);
    }

    private void registerInternal(ItemDefinition item) {
        Identifier id = item.getId();

        if (items.containsKey(id)) {
            System.err.println("[Pulse/Items] Duplicate item ID: " + id);
            return;
        }

        items.put(id, item);

        // 태그 인덱싱
        for (String tag : item.getTags()) {
            byTag.computeIfAbsent(tag, k -> new HashSet<>()).add(id);
        }

        // 카테고리 인덱싱
        byCategory.computeIfAbsent(item.getCategory(), k -> new HashSet<>()).add(id);

        System.out.println("[Pulse/Items] Registered: " + id);
    }

    /**
     * 아이템 등록 해제.
     */
    public static void unregister(Identifier id) {
        INSTANCE.unregisterInternal(id);
    }

    private void unregisterInternal(Identifier id) {
        ItemDefinition item = items.remove(id);
        if (item != null) {
            // 태그에서 제거
            for (String tag : item.getTags()) {
                Set<Identifier> set = byTag.get(tag);
                if (set != null)
                    set.remove(id);
            }
            // 카테고리에서 제거
            Set<Identifier> catSet = byCategory.get(item.getCategory());
            if (catSet != null)
                catSet.remove(id);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * ID로 아이템 조회.
     */
    public static ItemDefinition get(Identifier id) {
        return INSTANCE.items.get(id);
    }

    /**
     * 문자열 ID로 조회.
     */
    public static ItemDefinition get(String id) {
        return get(Identifier.parse(id));
    }

    /**
     * 태그로 아이템 조회.
     */
    public static Set<ItemDefinition> getByTag(String tag) {
        Set<Identifier> ids = INSTANCE.byTag.get(tag);
        if (ids == null)
            return Collections.emptySet();

        Set<ItemDefinition> result = new HashSet<>();
        for (Identifier id : ids) {
            result.add(INSTANCE.items.get(id));
        }
        return result;
    }

    /**
     * 카테고리로 아이템 조회.
     */
    public static Set<ItemDefinition> getByCategory(ItemDefinition.ItemCategory category) {
        Set<Identifier> ids = INSTANCE.byCategory.get(category);
        if (ids == null)
            return Collections.emptySet();

        Set<ItemDefinition> result = new HashSet<>();
        for (Identifier id : ids) {
            result.add(INSTANCE.items.get(id));
        }
        return result;
    }

    /**
     * 모든 등록된 아이템.
     */
    public static Collection<ItemDefinition> getAll() {
        return Collections.unmodifiableCollection(INSTANCE.items.values());
    }

    /**
     * 등록된 아이템 수.
     */
    public static int count() {
        return INSTANCE.items.size();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\content\ItemRegistry.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\content\ItemTag.java =====

package com.pulse.content;

import com.pulse.registry.Identifier;

import java.util.*;

/**
 * 아이템 태그 시스템.
 * 아이템을 그룹화하여 레시피나 로직에서 사용.
 */
public class ItemTag {

    private static final Map<Identifier, ItemTag> TAGS = new HashMap<>();

    private final Identifier id;
    private final Set<Identifier> items = new HashSet<>();

    private ItemTag(Identifier id) {
        this.id = id;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 태그 생성 또는 가져오기.
     */
    public static ItemTag getOrCreate(Identifier id) {
        return TAGS.computeIfAbsent(id, ItemTag::new);
    }

    /**
     * 문자열 ID로 태그 가져오기.
     */
    public static ItemTag getOrCreate(String id) {
        return getOrCreate(Identifier.parse(id));
    }

    /**
     * 태그 가져오기 (없으면 null).
     */
    public static ItemTag get(Identifier id) {
        return TAGS.get(id);
    }

    /**
     * 모든 태그 ID 가져오기.
     */
    public static Set<Identifier> getAllTags() {
        return Collections.unmodifiableSet(TAGS.keySet());
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 태그에 아이템 추가.
     */
    public ItemTag add(Identifier item) {
        items.add(item);
        return this;
    }

    /**
     * 태그에 아이템들 추가.
     */
    public ItemTag addAll(Identifier... items) {
        this.items.addAll(Arrays.asList(items));
        return this;
    }

    /**
     * 태그에서 아이템 제거.
     */
    public ItemTag remove(Identifier item) {
        items.remove(item);
        return this;
    }

    /**
     * 아이템이 태그에 포함되는지 확인.
     */
    public boolean contains(Identifier item) {
        return items.contains(item);
    }

    /**
     * 태그의 모든 아이템 가져오기.
     */
    public Set<Identifier> getItems() {
        return Collections.unmodifiableSet(items);
    }

    /**
     * 태그 ID.
     */
    public Identifier getId() {
        return id;
    }

    /**
     * 태그 크기.
     */
    public int size() {
        return items.size();
    }

    @Override
    public String toString() {
        return "#" + id.toString();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\content\ItemTag.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\content\RecipeRegistry.java =====

package com.pulse.content;

import com.pulse.registry.Identifier;

import java.util.*;

/**
 * 레시피 레지스트리.
 * 제작 레시피 등록 및 관리.
 */
public class RecipeRegistry {

    private static final RecipeRegistry INSTANCE = new RecipeRegistry();

    private final Map<Identifier, Recipe> recipes = new LinkedHashMap<>();
    private final Map<Identifier, Set<Recipe>> byOutput = new HashMap<>();

    private RecipeRegistry() {
    }

    public static RecipeRegistry getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 레시피 등록.
     */
    public static void register(Recipe recipe) {
        INSTANCE.registerInternal(recipe);
    }

    private void registerInternal(Recipe recipe) {
        if (recipes.containsKey(recipe.getId())) {
            System.err.println("[Pulse/Recipes] Duplicate recipe ID: " + recipe.getId());
            return;
        }

        recipes.put(recipe.getId(), recipe);

        // 출력 아이템으로 인덱싱
        byOutput.computeIfAbsent(recipe.getOutput(), k -> new HashSet<>()).add(recipe);

        System.out.println("[Pulse/Recipes] Registered: " + recipe.getId());
    }

    /**
     * 레시피 제거.
     */
    public static void unregister(Identifier id) {
        Recipe recipe = INSTANCE.recipes.remove(id);
        if (recipe != null) {
            Set<Recipe> set = INSTANCE.byOutput.get(recipe.getOutput());
            if (set != null)
                set.remove(recipe);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 조회
    // ─────────────────────────────────────────────────────────────

    public static Recipe get(Identifier id) {
        return INSTANCE.recipes.get(id);
    }

    public static Set<Recipe> getRecipesFor(Identifier outputItem) {
        Set<Recipe> result = INSTANCE.byOutput.get(outputItem);
        return result != null ? Collections.unmodifiableSet(result) : Collections.emptySet();
    }

    public static Collection<Recipe> getAll() {
        return Collections.unmodifiableCollection(INSTANCE.recipes.values());
    }

    // ─────────────────────────────────────────────────────────────
    // 레시피 클래스
    // ─────────────────────────────────────────────────────────────

    public static class Recipe {
        private final Identifier id;
        private final Identifier output;
        private final int outputCount;
        private final List<Ingredient> ingredients = new ArrayList<>();
        private final List<String> requiredSkills = new ArrayList<>();
        private int craftTime = 60; // 틱
        private String category = "General";

        public Recipe(Identifier id, Identifier output) {
            this(id, output, 1);
        }

        public Recipe(Identifier id, Identifier output, int outputCount) {
            this.id = id;
            this.output = output;
            this.outputCount = outputCount;
        }

        // 빌더
        public Recipe ingredient(Identifier item, int count) {
            ingredients.add(new Ingredient(item, count, false));
            return this;
        }

        public Recipe tool(Identifier item) {
            ingredients.add(new Ingredient(item, 1, true));
            return this;
        }

        public Recipe skill(String skill) {
            requiredSkills.add(skill);
            return this;
        }

        public Recipe craftTime(int ticks) {
            this.craftTime = ticks;
            return this;
        }

        public Recipe category(String category) {
            this.category = category;
            return this;
        }

        // Getters
        public Identifier getId() {
            return id;
        }

        public Identifier getOutput() {
            return output;
        }

        public int getOutputCount() {
            return outputCount;
        }

        public List<Ingredient> getIngredients() {
            return Collections.unmodifiableList(ingredients);
        }

        public List<String> getRequiredSkills() {
            return Collections.unmodifiableList(requiredSkills);
        }

        public int getCraftTime() {
            return craftTime;
        }

        public String getCategory() {
            return category;
        }
    }

    public static class Ingredient {
        private final Identifier item;
        private final int count;
        private final boolean isTool; // 도구는 소비되지 않음

        public Ingredient(Identifier item, int count, boolean isTool) {
            this.item = item;
            this.count = count;
            this.isTool = isTool;
        }

        public Identifier getItem() {
            return item;
        }

        public int getCount() {
            return count;
        }

        public boolean isTool() {
            return isTool;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\content\RecipeRegistry.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\CrashReporter.java =====

package com.pulse.debug;

import com.pulse.mixin.MixinDiagnostics;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModLoader;

import java.io.*;
import java.nio.file.*;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * 크래시 리포터.
 * 예외 발생 시 상세 리포트 생성.
 * 
 * 기능:
 * - 예외 정보 및 스택트레이스
 * - 원인 모드 자동 추적
 * - Mixin 적용 현황
 * - 최근 로그 라인
 * - 시스템/게임 정보
 */
public class CrashReporter {

    private static Path crashLogDirectory = Paths.get("crash-reports");

    // 최근 로그 버퍼
    private static final int MAX_LOG_LINES = 100;
    private static final LinkedList<String> recentLogs = new LinkedList<>();
    private static final Object logLock = new Object();

    /**
     * 로그 라인 추가 (순환 버퍼).
     */
    public static void addLogLine(String line) {
        synchronized (logLock) {
            if (recentLogs.size() >= MAX_LOG_LINES) {
                recentLogs.removeFirst();
            }
            recentLogs.add(line);
        }
    }

    /**
     * 크래시 리포트 생성.
     */
    public static File report(Throwable throwable, String context) {
        String timestamp = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date());
        String filename = "crash-" + timestamp + ".txt";

        try {
            Files.createDirectories(crashLogDirectory);
            Path reportPath = crashLogDirectory.resolve(filename);

            StringBuilder report = new StringBuilder();

            // 헤더
            report.append("═══════════════════════════════════════════════════════════\n");
            report.append("               PULSE MOD LOADER CRASH REPORT               \n");
            report.append("═══════════════════════════════════════════════════════════\n\n");

            // 시간
            report.append("Time: ").append(new Date()).append("\n");
            report.append("Context: ").append(context != null ? context : "Unknown").append("\n\n");

            // 의심 모드 분석
            String suspectedMod = analyzeSuspectedMod(throwable);
            if (suspectedMod != null) {
                report.append("⚠️ SUSPECTED MOD: ").append(suspectedMod).append("\n\n");
            }

            // 예외 정보
            report.append("── EXCEPTION ─────────────────────────────────────────────\n");
            report.append(throwable.getClass().getName()).append(": ");
            report.append(throwable.getMessage()).append("\n\n");

            // 스택트레이스 (모드 표시 포함)
            report.append("── STACK TRACE ───────────────────────────────────────────\n");
            appendAnnotatedStackTrace(report, throwable);
            report.append("\n");

            // 원인 체인
            Throwable cause = throwable.getCause();
            while (cause != null) {
                report.append("── CAUSED BY ─────────────────────────────────────────────\n");
                report.append(cause.getClass().getName()).append(": ");
                report.append(cause.getMessage()).append("\n");
                appendAnnotatedStackTrace(report, cause);
                report.append("\n");
                cause = cause.getCause();
            }

            // 로드된 모드 목록
            report.append("── LOADED MODS ───────────────────────────────────────────\n");
            appendLoadedMods(report);
            report.append("\n");

            // Mixin 적용 현황
            report.append("── APPLIED MIXINS ────────────────────────────────────────\n");
            appendMixinInfo(report);
            report.append("\n");

            // 최근 로그
            report.append("── RECENT LOG LINES ──────────────────────────────────────\n");
            appendRecentLogs(report);
            report.append("\n");

            // 시스템 정보
            report.append("── SYSTEM INFO ───────────────────────────────────────────\n");
            appendSystemInfo(report);
            report.append("\n");

            // 푸터
            report.append("═══════════════════════════════════════════════════════════\n");
            report.append("Please report this crash to the mod developers.\n");
            if (suspectedMod != null) {
                report.append("The crash appears to be related to: ").append(suspectedMod).append("\n");
            }
            report.append("Include this file with your bug report.\n");
            report.append("═══════════════════════════════════════════════════════════\n");

            // 파일 저장
            Files.writeString(reportPath, report.toString());
            System.err.println("[Pulse/Crash] Report saved to: " + reportPath.toAbsolutePath());

            return reportPath.toFile();

        } catch (IOException e) {
            System.err.println("[Pulse/Crash] Failed to write crash report: " + e.getMessage());
            return null;
        }
    }

    /**
     * 스택트레이스에서 의심 모드 분석.
     */
    private static String analyzeSuspectedMod(Throwable throwable) {
        Set<String> suspectedMods = new LinkedHashSet<>();

        for (StackTraceElement element : throwable.getStackTrace()) {
            String modName = findModByClassName(element.getClassName());
            if (modName != null) {
                suspectedMods.add(modName);
            }
        }

        // 원인 체인도 분석
        Throwable cause = throwable.getCause();
        while (cause != null) {
            for (StackTraceElement element : cause.getStackTrace()) {
                String modName = findModByClassName(element.getClassName());
                if (modName != null) {
                    suspectedMods.add(modName);
                }
            }
            cause = cause.getCause();
        }

        if (suspectedMods.isEmpty()) {
            return null;
        }

        return String.join(", ", suspectedMods);
    }

    /**
     * 클래스 이름으로 모드 찾기.
     */
    private static String findModByClassName(String className) {
        ModLoader loader = ModLoader.getInstance();

        for (String modId : loader.getLoadedModIds()) {
            ModContainer mod = loader.getMod(modId);
            if (mod == null)
                continue;

            // 모드 엔트리포인트 확인
            String entrypoint = mod.getMetadata().getEntrypoint();
            if (entrypoint != null && entrypoint.contains(".")) {
                String packageName = entrypoint.substring(0, entrypoint.lastIndexOf('.'));
                if (className.startsWith(packageName)) {
                    return mod.getMetadata().getName() + " (" + modId + ")";
                }
            }

            // 모드 ID 기반 패키지 추정
            if (className.toLowerCase().contains(modId.toLowerCase())) {
                return mod.getMetadata().getName() + " (" + modId + ")";
            }
        }

        // Pulse 내부 패키지 확인
        if (className.startsWith("com.pulse.")) {
            return "Pulse (core)";
        }

        return null;
    }

    /**
     * 모드 표시가 포함된 스택트레이스 출력.
     */
    private static void appendAnnotatedStackTrace(StringBuilder report, Throwable throwable) {
        for (StackTraceElement element : throwable.getStackTrace()) {
            report.append("    at ").append(element.toString());

            String modName = findModByClassName(element.getClassName());
            if (modName != null) {
                report.append(" [").append(modName).append("]");
            }

            report.append("\n");
        }
    }

    /**
     * 로드된 모드 목록 출력.
     */
    private static void appendLoadedMods(StringBuilder report) {
        ModLoader loader = ModLoader.getInstance();
        List<String> modIds = new ArrayList<>(loader.getLoadedModIds());

        if (modIds.isEmpty()) {
            report.append("  (No mods loaded)\n");
            return;
        }

        for (String modId : modIds) {
            ModContainer mod = loader.getMod(modId);
            if (mod != null) {
                var meta = mod.getMetadata();
                report.append("  - ").append(meta.getName())
                        .append(" (").append(modId).append(") v").append(meta.getVersion())
                        .append(" [").append(mod.getState()).append("]\n");
            }
        }
    }

    /**
     * Mixin 적용 현황 출력.
     */
    private static void appendMixinInfo(StringBuilder report) {
        try {
            // MixinDiagnostics에서 정보 가져오기
            Map<String, List<String>> mixinInfo = MixinDiagnostics.getTransformationDetails();

            if (mixinInfo.isEmpty()) {
                report.append("  (No Mixin transformations recorded)\n");
                return;
            }

            for (var entry : mixinInfo.entrySet()) {
                report.append("  ").append(entry.getKey()).append(":\n");
                for (String mixin : entry.getValue()) {
                    report.append("    - ").append(mixin).append("\n");
                }
            }
        } catch (Exception e) {
            report.append("  (Unable to retrieve Mixin info: ").append(e.getMessage()).append(")\n");
        }
    }

    /**
     * 최근 로그 라인 출력.
     */
    private static void appendRecentLogs(StringBuilder report) {
        synchronized (logLock) {
            if (recentLogs.isEmpty()) {
                report.append("  (No recent logs captured)\n");
                return;
            }

            int count = Math.min(recentLogs.size(), 50); // 최대 50줄
            int start = recentLogs.size() - count;

            for (int i = start; i < recentLogs.size(); i++) {
                report.append("  ").append(recentLogs.get(i)).append("\n");
            }
        }
    }

    /**
     * 시스템 정보 출력.
     */
    private static void appendSystemInfo(StringBuilder report) {
        // Java 정보
        report.append("Java Version: ").append(System.getProperty("java.version")).append("\n");
        report.append("Java Vendor: ").append(System.getProperty("java.vendor")).append("\n");
        report.append("Java VM: ").append(System.getProperty("java.vm.name")).append(" ")
                .append(System.getProperty("java.vm.version")).append("\n");

        // OS 정보
        report.append("OS: ").append(System.getProperty("os.name")).append(" ")
                .append(System.getProperty("os.version")).append(" (")
                .append(System.getProperty("os.arch")).append(")\n");

        // 메모리 정보
        Runtime rt = Runtime.getRuntime();
        long usedMB = (rt.totalMemory() - rt.freeMemory()) / 1024 / 1024;
        long totalMB = rt.totalMemory() / 1024 / 1024;
        long maxMB = rt.maxMemory() / 1024 / 1024;
        report.append("Memory: ").append(usedMB).append("MB used / ")
                .append(totalMB).append("MB allocated / ")
                .append(maxMB).append("MB max\n");

        // CPU 정보
        report.append("CPU Cores: ").append(rt.availableProcessors()).append("\n");

        // Pulse 버전
        report.append("Pulse Version: 1.0.0-SNAPSHOT\n");

        // 작업 디렉토리
        report.append("Working Directory: ").append(System.getProperty("user.dir")).append("\n");
    }

    /**
     * 예외 핸들러 설치.
     */
    public static void installHandler() {
        Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {
            System.err.println("[Pulse/Crash] Uncaught exception in thread: " + thread.getName());
            report(throwable, "Uncaught exception in " + thread.getName());
        });
        System.out.println("[Pulse/Crash] Exception handler installed");
    }

    /**
     * 크래시 로그 디렉토리 설정.
     */
    public static void setLogDirectory(Path path) {
        crashLogDirectory = path;
    }

    /**
     * 크래시 로그 디렉토리 가져오기.
     */
    public static Path getLogDirectory() {
        return crashLogDirectory;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\CrashReporter.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\DebugOverlayRegistry.java =====

package com.pulse.debug;

import com.pulse.api.DevMode;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 디버그 오버레이 레지스트리.
 * 모드별 디버그 렌더러를 등록하고 관리.
 * 
 * 사용 예:
 * // 등록
 * DebugOverlayRegistry.register("mymod", ctx -> {
 * ctx.drawLine("FPS: " + fps);
 * });
 * 
 * // 렌더링 (Pulse 또는 게임에서 호출)
 * DebugOverlayRegistry.renderAll(ctx);
 */
public class DebugOverlayRegistry {

    private static final Map<String, DebugOverlayRenderer> renderers = new ConcurrentHashMap<>();
    private static boolean enabled = true;

    private DebugOverlayRegistry() {
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 디버그 오버레이 렌더러 등록
     */
    public static void register(String modId, DebugOverlayRenderer renderer) {
        renderers.put(modId, renderer);

        if (DevMode.isEnabled()) {
            System.out.println("[Pulse/Debug] Registered overlay renderer for: " + modId);
        }
    }

    /**
     * 디버그 오버레이 렌더러 해제
     */
    public static void unregister(String modId) {
        renderers.remove(modId);
    }

    // ─────────────────────────────────────────────────────────────
    // 렌더링
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 등록된 렌더러 실행
     */
    public static void renderAll(DebugRenderContext ctx) {
        if (!enabled)
            return;

        for (Map.Entry<String, DebugOverlayRenderer> entry : renderers.entrySet()) {
            String modId = entry.getKey();
            DebugOverlayRenderer renderer = entry.getValue();

            try {
                ctx.beginSection("[" + modId + "]");
                renderer.render(ctx);
                ctx.endSection();
            } catch (Exception e) {
                System.err.println("[Pulse/Debug] Error in overlay renderer for " + modId);
                if (DevMode.isEnabled()) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * 콘솔에 디버그 정보 출력 (렌더링 미지원 환경용)
     */
    public static void printToConsole() {
        if (!enabled || renderers.isEmpty())
            return;

        DebugRenderContext ctx = new DebugRenderContext();
        ctx.reset(0);

        System.out.println("[Pulse/Debug] ═══════════════════════════════════════");
        System.out.println("[Pulse/Debug] DEBUG OVERLAY OUTPUT");

        renderAll(ctx);

        System.out.print(ctx.getOutput());
        System.out.println("[Pulse/Debug] ═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // 제어
    // ─────────────────────────────────────────────────────────────

    /**
     * 오버레이 활성화/비활성화
     */
    public static void setEnabled(boolean enable) {
        enabled = enable;
    }

    public static boolean isEnabled() {
        return enabled;
    }

    /**
     * 등록된 렌더러 수
     */
    public static int getRendererCount() {
        return renderers.size();
    }

    /**
     * 등록된 모드 ID 목록
     */
    public static Set<String> getRegisteredMods() {
        return Collections.unmodifiableSet(renderers.keySet());
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\DebugOverlayRegistry.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\DebugOverlayRenderer.java =====

package com.pulse.debug;

/**
 * 디버그 오버레이 렌더러 인터페이스.
 * 모드가 게임 화면에 디버그 정보를 표시하기 위해 구현.
 * 
 * 사용 예:
 * DebugOverlayRegistry.register("mymod", ctx -> {
 * ctx.drawText(10, 10, "My Mod Debug Info");
 * ctx.drawText(10, 30, "Value: " + myValue);
 * });
 */
@FunctionalInterface
public interface DebugOverlayRenderer {

    /**
     * 디버그 오버레이 렌더링
     * 
     * @param ctx 렌더링 컨텍스트
     */
    void render(DebugRenderContext ctx);
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\DebugOverlayRenderer.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\DebugRenderContext.java =====

package com.pulse.debug;

/**
 * 디버그 렌더링 컨텍스트.
 * 디버그 오버레이에 정보를 그리기 위한 추상화 레이어.
 * 
 * 실제 구현은 PZ 렌더링 시스템과 연동 필요.
 * 이 버전은 콘솔 출력 기반 플레이스홀더.
 */
public class DebugRenderContext {

    private final StringBuilder buffer = new StringBuilder();
    private int currentY = 0;

    // ─────────────────────────────────────────────────────────────
    // 텍스트 그리기
    // ─────────────────────────────────────────────────────────────

    /**
     * 텍스트 그리기
     */
    public void drawText(int x, int y, String text) {
        // 플레이스홀더: 콘솔에 출력
        buffer.append(String.format("[%d,%d] %s\n", x, y, text));
    }

    /**
     * 색상 있는 텍스트 그리기
     */
    public void drawText(int x, int y, String text, int color) {
        drawText(x, y, text);
    }

    /**
     * 다음 줄에 텍스트 그리기 (자동 위치)
     */
    public void drawLine(String text) {
        drawText(10, currentY, text);
        currentY += 15;
    }

    // ─────────────────────────────────────────────────────────────
    // 도형 그리기
    // ─────────────────────────────────────────────────────────────

    /**
     * 사각형 그리기
     */
    public void drawRect(int x, int y, int width, int height, int color) {
        // 플레이스홀더
    }

    /**
     * 채워진 사각형 그리기
     */
    public void fillRect(int x, int y, int width, int height, int color) {
        // 플레이스홀더
    }

    /**
     * 선 그리기
     */
    public void drawLine(int x1, int y1, int x2, int y2, int color) {
        // 플레이스홀더
    }

    // ─────────────────────────────────────────────────────────────
    // 섹션
    // ─────────────────────────────────────────────────────────────

    /**
     * 섹션 시작 (구분선 + 제목)
     */
    public void beginSection(String title) {
        drawLine("═══════════════════════════════════════");
        drawLine(title);
        drawLine("───────────────────────────────────────");
    }

    /**
     * 섹션 종료
     */
    public void endSection() {
        currentY += 5;
    }

    // ─────────────────────────────────────────────────────────────
    // 출력
    // ─────────────────────────────────────────────────────────────

    /**
     * 버퍼 내용 반환 (콘솔 출력용)
     */
    public String getOutput() {
        return buffer.toString();
    }

    /**
     * 현재 Y 위치 초기화
     */
    public void reset(int startY) {
        currentY = startY;
        buffer.setLength(0);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\DebugRenderContext.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\DevConsole.java =====

package com.pulse.debug;

import com.pulse.mod.ModLoader;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModReloadManager;
import com.pulse.security.PermissionManager;
import com.pulse.security.PermissionManager.Permission;

import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.function.Consumer;

/**
 * 인게임 개발자 콘솔.
 * REPL 스타일 디버그 명령어 실행.
 * 
 * <p>
 * <b>멀티플레이어 보안:</b>
 * 서버 환경에서는 위험한 명령어(lua, mods reload/disable/enable)에 대해
 * 관리자 권한 검사를 수행합니다. 권한이 없는 유저는 해당 명령어를 실행할 수 없습니다.
 * </p>
 * 
 * 사용 예:
 * 
 * <pre>
 * DevConsole.execute("mods list");
 * DevConsole.execute("reload mymod");
 * DevConsole.execute("events monitor");
 * </pre>
 */
public class DevConsole {

    private static final DevConsole INSTANCE = new DevConsole();

    /** 위험 명령어 목록 - 권한 검사 필요 */
    private static final Set<String> PRIVILEGED_COMMANDS = Set.of("lua");
    private static final Set<String> MOD_MANAGE_SUBCOMMANDS = Set.of("reload", "disable", "enable");

    private final Map<String, ConsoleCommand> commands = new LinkedHashMap<>();
    private final Queue<String> outputBuffer = new ConcurrentLinkedQueue<>();
    private Consumer<String> outputHandler;
    private boolean eventMonitoring = false;

    /** 현재 콘솔 사용자의 권한 (플레이어 ID 또는 "pulse:system") */
    private static String currentExecutor = "pulse:system";
    private static boolean currentExecutorIsAdmin = false;

    /** 디버그 모드 여부 (개발 중에만 true) */
    private static boolean debugModeEnabled = false;

    /** 멀티플레이어 세션 여부 */
    private static boolean inMultiplayerSession = false;

    private DevConsole() {
        registerDefaultCommands();
    }

    public static DevConsole getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 권한 관리 (멀티플레이어 보안)
    // ─────────────────────────────────────────────────────────────

    /**
     * 현재 콘솔 실행자 설정.
     * 멀티플레이어 서버에서 콘솔 UI 열 때 호출해야 합니다.
     * 
     * @param executorId 플레이어 ID 또는 시스템 ID
     * @param isAdmin    관리자 권한 여부
     */
    public static void setCurrentExecutor(String executorId, boolean isAdmin) {
        currentExecutor = executorId != null ? executorId : "pulse:system";
        currentExecutorIsAdmin = isAdmin;
        System.out.println("[DevConsole] Executor set: " + currentExecutor + " (admin=" + isAdmin + ")");
    }

    /**
     * 현재 실행자가 관리자인지 확인.
     */
    public static boolean isCurrentExecutorAdmin() {
        return currentExecutorIsAdmin;
    }

    /**
     * 시스템 권한으로 리셋 (콘솔 UI 닫을 때 호출).
     */
    public static void resetExecutorToSystem() {
        currentExecutor = "pulse:system";
        currentExecutorIsAdmin = true;
    }

    /**
     * 디버그 모드 설정.
     * 개발 환경이나 싱글플레이 테스트 시 true로 설정하면 권한 검사 우회.
     * 
     * @param enabled 디버그 모드 활성화 여부
     */
    public static void setDebugMode(boolean enabled) {
        debugModeEnabled = enabled;
        System.out.println("[DevConsole] Debug mode: " + (enabled ? "ENABLED" : "DISABLED"));
    }

    /**
     * 디버그 모드 상태 확인.
     */
    public static boolean isDebugModeEnabled() {
        return debugModeEnabled;
    }

    /**
     * 멀티플레이어 세션 시작 시 호출.
     * 멀티플레이 서버 접속 시 자동으로 호출되어야 합니다.
     */
    public static void onMultiplayerSessionStart() {
        inMultiplayerSession = true;
        debugModeEnabled = false; // 멀티플레이에서는 디버그 모드 강제 비활성화
        System.out.println("[DevConsole] Multiplayer session started - security enforced");
    }

    /**
     * 멀티플레이어 세션 종료 시 호출.
     */
    public static void onMultiplayerSessionEnd() {
        inMultiplayerSession = false;
        resetExecutorToSystem();
        System.out.println("[DevConsole] Multiplayer session ended");
    }

    /**
     * 멀티플레이어 세션 여부 확인.
     */
    public static boolean isInMultiplayerSession() {
        return inMultiplayerSession;
    }

    // ─────────────────────────────────────────────────────────────
    // 명령어 실행
    // ─────────────────────────────────────────────────────────────

    /**
     * 명령어 실행.
     */
    public static String execute(String input) {
        return INSTANCE.executeInternal(input);
    }

    private String executeInternal(String input) {
        if (input == null || input.trim().isEmpty()) {
            return "";
        }

        String[] parts = input.trim().split("\\s+", 2);
        String cmdName = parts[0].toLowerCase();
        String args = parts.length > 1 ? parts[1] : "";

        // ═══════════════════════════════════════════════════════════════
        // [최우선] Project Zomboid 권한 직접 검사
        // ═══════════════════════════════════════════════════════════════
        // 클라이언트에서 위험한 명령어 시도 시, PZ의 실제 Admin 상태 확인
        // 이 검사는 외부 설정(setCurrentExecutor 등)에 의존하지 않음
        // ═══════════════════════════════════════════════════════════════

        if (PRIVILEGED_COMMANDS.contains(cmdName) ||
                ("mods".equals(cmdName) && args.length() > 0
                        && MOD_MANAGE_SUBCOMMANDS.contains(args.split("\\s+")[0].toLowerCase()))) {

            // PZ 멀티플레이어 클라이언트에서 Admin이 아니면 차단
            if (isInPZMultiplayerClient() && !isPZAdmin()) {
                System.err.println(
                        "[DevConsole] BLOCKED: Non-admin attempted privileged command in multiplayer: " + cmdName);
                return "§c[보안] Error: 관리자 권한이 없습니다. 이 명령어는 멀티플레이에서 관리자만 사용할 수 있습니다.";
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // 보안 검사 (Anti-Cheat) - 2차 검증
        // ═══════════════════════════════════════════════════════════════
        //
        // 검사 우회 조건 (아래 중 하나 충족 시):
        // 1. 디버그 모드 활성화 AND 싱글플레이어 (개발 테스트용)
        // 2. 현재 실행자가 관리자권한 보유
        //
        // 그 외 모든 경우에서 위험 명령어 차단
        // ═══════════════════════════════════════════════════════════════

        boolean bypassSecurity = (debugModeEnabled && !inMultiplayerSession) || currentExecutorIsAdmin;

        if (!bypassSecurity) {
            // Lua 명령어: CONSOLE_LUA_EXEC 권한 필요
            if (PRIVILEGED_COMMANDS.contains(cmdName)) {
                if (!PermissionManager.hasPermission(currentExecutor, Permission.CONSOLE_LUA_EXEC)) {
                    System.err.println("[DevConsole] BLOCKED: User '" + currentExecutor +
                            "' attempted privileged command: " + cmdName);
                    return "§c[보안] 권한 부족: '" + cmdName + "' 명령어는 관리자만 사용할 수 있습니다.";
                }
            }

            // 모드 관리 명령어: CONSOLE_MOD_MANAGE 권한 필요
            if ("mods".equals(cmdName) && args.length() > 0) {
                String subCmd = args.split("\\s+")[0].toLowerCase();
                if (MOD_MANAGE_SUBCOMMANDS.contains(subCmd)) {
                    if (!PermissionManager.hasPermission(currentExecutor, Permission.CONSOLE_MOD_MANAGE)) {
                        System.err.println("[DevConsole] BLOCKED: User '" + currentExecutor +
                                "' attempted mod management: mods " + subCmd);
                        return "§c[보안] 권한 부족: 'mods " + subCmd + "'는 관리자만 사용할 수 있습니다.";
                    }
                }
            }
        }
        // ═══════════════════════════════════════════════════════════════

        ConsoleCommand cmd = commands.get(cmdName);
        if (cmd == null) {
            return "Unknown command: " + cmdName + ". Type 'help' for available commands.";
        }

        try {
            return cmd.execute(args);
        } catch (Exception e) {
            return "Error: " + e.getMessage();
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 기본 명령어 등록
    // ─────────────────────────────────────────────────────────────

    private void registerDefaultCommands() {
        // help
        register("help", "Show available commands", args -> {
            StringBuilder sb = new StringBuilder("Available commands:\n");
            for (var entry : commands.entrySet()) {
                sb.append("  ").append(entry.getKey())
                        .append(" - ").append(entry.getValue().getDescription())
                        .append("\n");
            }
            return sb.toString();
        });

        // mods
        register("mods", "Mod management (list/info/reload/disable/enable)", args -> {
            String[] parts = args.split("\\s+", 2);
            String subCmd = parts.length > 0 ? parts[0] : "list";
            String modId = parts.length > 1 ? parts[1] : null;

            switch (subCmd) {
                case "list":
                    return listMods();
                case "info":
                    return modInfo(modId);
                case "reload":
                    return reloadMod(modId);
                case "disable":
                    return disableMod(modId);
                case "enable":
                    return enableMod(modId);
                default:
                    return "Usage: mods [list|info|reload|disable|enable] [modId]";
            }
        });

        // events
        register("events", "Event system (monitor/stats)", args -> {
            if (args.startsWith("monitor")) {
                eventMonitoring = !eventMonitoring;
                return "Event monitoring: " + (eventMonitoring ? "ON" : "OFF");
            }
            return "Usage: events [monitor|stats]";
        });

        // clear
        register("clear", "Clear output buffer", args -> {
            outputBuffer.clear();
            return "Output cleared.";
        });

        // lua
        register("lua", "Execute Lua code (Admin only in multiplayer)", args -> {
            // ═══════════════════════════════════════════════════════════════
            // Project Zomboid SandboxOptions 검사
            // 멀티플레이 서버에서 Lua 콘솔이 비허용되면 차단
            // ═══════════════════════════════════════════════════════════════
            if (inMultiplayerSession) {
                if (!isLuaConsoleAllowedByServer()) {
                    System.err.println("[DevConsole] BLOCKED: Lua console not allowed on this server");
                    return "§c[보안] 이 서버에서는 Lua 콘솔이 비활성화되어 있습니다.";
                }
            }

            try {
                Object result = com.pulse.lua.LuaBridge.call(args);
                return result != null ? result.toString() : "nil";
            } catch (Exception e) {
                return "Lua error: " + e.getMessage();
            }
        });
    }

    private String listMods() {
        StringBuilder sb = new StringBuilder("Loaded mods:\n");
        ModLoader loader = ModLoader.getInstance();
        for (String modId : loader.getLoadedModIds()) {
            ModContainer mod = loader.getMod(modId);
            String status = ModReloadManager.isEnabled(modId) ? "✓" : "✗";
            sb.append("  [").append(status).append("] ")
                    .append(modId).append(" v").append(mod.getMetadata().getVersion())
                    .append("\n");
        }
        return sb.toString();
    }

    private String modInfo(String modId) {
        if (modId == null)
            return "Usage: mods info <modId>";
        ModContainer mod = ModLoader.getInstance().getMod(modId);
        if (mod == null)
            return "Mod not found: " + modId;

        var meta = mod.getMetadata();
        return String.format(
                "=== %s ===\n" +
                        "ID: %s\n" +
                        "Version: %s\n" +
                        "Author: %s\n" +
                        "Description: %s\n" +
                        "State: %s\n",
                meta.getName(), meta.getId(), meta.getVersion(),
                meta.getAuthor(), meta.getDescription(), mod.getState());
    }

    private String reloadMod(String modId) {
        if (modId == null)
            return "Usage: mods reload <modId>";
        boolean success = ModReloadManager.softReload(modId);
        return success ? "Reloaded: " + modId : "Failed to reload: " + modId;
    }

    private String disableMod(String modId) {
        if (modId == null)
            return "Usage: mods disable <modId>";
        boolean success = ModReloadManager.disable(modId);
        return success ? "Disabled: " + modId : "Failed to disable: " + modId;
    }

    private String enableMod(String modId) {
        if (modId == null)
            return "Usage: mods enable <modId>";
        boolean success = ModReloadManager.enable(modId);
        return success ? "Enabled: " + modId : "Failed to enable: " + modId;
    }

    // ─────────────────────────────────────────────────────────────
    // 명령어 등록 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 커스텀 명령어 등록.
     */
    public static void register(String name, String description, CommandExecutor executor) {
        INSTANCE.commands.put(name.toLowerCase(), new ConsoleCommand(description, executor));
    }

    /**
     * 출력 핸들러 설정 (UI 연동용).
     */
    public static void setOutputHandler(Consumer<String> handler) {
        INSTANCE.outputHandler = handler;
    }

    /**
     * 콘솔에 출력.
     */
    public static void print(String message) {
        INSTANCE.outputBuffer.offer(message);
        if (INSTANCE.outputHandler != null) {
            INSTANCE.outputHandler.accept(message);
        }
        System.out.println("[DevConsole] " + message);
    }

    // ─────────────────────────────────────────────────────────────
    // Project Zomboid 연동 (SandboxOptions)
    // ─────────────────────────────────────────────────────────────

    /**
     * Project Zomboid 서버에서 Lua 콘솔이 허용되는지 확인.
     * SandboxOptions.instance.AllowedToLuaConsole.getValue() 호출.
     * 
     * PZ 런타임이 없는 경우 기본값 false (안전) 반환.
     * 
     * @return Lua 콘솔 허용 여부
     */
    private static boolean isLuaConsoleAllowedByServer() {
        try {
            // zombie.SandboxOptions 클래스 로드
            Class<?> sandboxOptionsClass = Class.forName("zombie.SandboxOptions");

            // SandboxOptions.instance 필드 획득
            java.lang.reflect.Field instanceField = sandboxOptionsClass.getField("instance");
            Object instance = instanceField.get(null);

            if (instance == null) {
                System.out.println("[DevConsole] SandboxOptions.instance is null, defaulting to blocked");
                return false;
            }

            // AllowedToLuaConsole 필드 획득
            java.lang.reflect.Field luaConsoleField = sandboxOptionsClass.getField("AllowedToLuaConsole");
            Object luaConsoleOption = luaConsoleField.get(instance);

            if (luaConsoleOption == null) {
                System.out.println("[DevConsole] AllowedToLuaConsole is null, defaulting to blocked");
                return false;
            }

            // getValue() 메서드 호출
            java.lang.reflect.Method getValueMethod = luaConsoleOption.getClass().getMethod("getValue");
            Object result = getValueMethod.invoke(luaConsoleOption);

            if (result instanceof Boolean) {
                return (Boolean) result;
            }

            System.out.println("[DevConsole] Unexpected getValue() result type: " + result);
            return false;

        } catch (ClassNotFoundException e) {
            // PZ 런타임 외부에서 실행 중 - 디버그 모드라면 허용
            if (debugModeEnabled) {
                return true;
            }
            System.out.println("[DevConsole] Not running in PZ runtime, Lua console blocked");
            return false;
        } catch (Exception e) {
            System.err.println("[DevConsole] Error checking SandboxOptions: " + e.getMessage());
            return false; // 오류 시 안전하게 차단
        }
    }

    /**
     * Project Zomboid 멀티플레이어 클라이언트에서 실행 중인지 확인.
     * GameWindow.bServer == false AND GameClient.bConnected == true 인 경우.
     * 
     * @return 멀티플레이어 클라이언트 여부
     */
    private static boolean isInPZMultiplayerClient() {
        // 먼저 Pulse 내부 플래그 확인 (더 빠름)
        if (inMultiplayerSession) {
            return true;
        }

        try {
            // GameWindow.bServer 확인 (서버인지)
            Class<?> gameWindowClass = Class.forName("zombie.GameWindow");
            java.lang.reflect.Field bServerField = gameWindowClass.getField("bServer");
            boolean isServer = bServerField.getBoolean(null);

            if (isServer) {
                return false; // 서버에서는 멀티플레이어 클라이언트가 아님
            }

            // GameClient.bConnected 확인 (멀티플레이어 접속 중인지)
            Class<?> gameClientClass = Class.forName("zombie.network.GameClient");
            java.lang.reflect.Field bConnectedField = gameClientClass.getField("bConnected");
            boolean isConnected = bConnectedField.getBoolean(null);

            return isConnected;

        } catch (ClassNotFoundException e) {
            // PZ 런타임 외부 - Pulse 내부 플래그에 의존
            return inMultiplayerSession;
        } catch (Exception e) {
            System.err.println("[DevConsole] Error checking multiplayer state: " + e.getMessage());
            return inMultiplayerSession;
        }
    }

    /**
     * 현재 플레이어가 Project Zomboid 서버 관리자인지 확인.
     * GameClient.isAdmin() 또는 유사한 API 호출.
     * 
     * @return 관리자 여부 (확인 실패 시 false - 안전)
     */
    private static boolean isPZAdmin() {
        // 항상 PZ 게임 엔진에서 직접 Admin 상태를 확인
        // (currentExecutorIsAdmin 플래그에 의존하지 않음 - 보안 강화)
        try {
            // 방법 1: GameClient.connection.isAdmin() 확인
            Class<?> gameClientClass = Class.forName("zombie.network.GameClient");
            java.lang.reflect.Field connectionField = gameClientClass.getDeclaredField("connection");
            connectionField.setAccessible(true);
            Object connection = connectionField.get(null);

            if (connection != null) {
                java.lang.reflect.Method isAdminMethod = connection.getClass().getMethod("isAdmin");
                Object result = isAdminMethod.invoke(connection);
                if (result instanceof Boolean) {
                    return (Boolean) result;
                }
            }

            // 방법 2: 백업 - Core.bDebug 확인 (디버그 모드에서는 허용)
            Class<?> coreClass = Class.forName("zombie.core.Core");
            java.lang.reflect.Field bDebugField = coreClass.getField("bDebug");
            boolean isDebug = bDebugField.getBoolean(null);
            if (isDebug) {
                return true;
            }

            return false;

        } catch (ClassNotFoundException e) {
            // PZ 런타임 외부 - 디버그 모드라면 허용
            return debugModeEnabled;
        } catch (Exception e) {
            System.err.println("[DevConsole] Error checking admin status: " + e.getMessage());
            return false; // 오류 시 안전하게 거부
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface CommandExecutor {
        String execute(String args);
    }

    private static class ConsoleCommand {
        private final String description;
        private final CommandExecutor executor;

        ConsoleCommand(String description, CommandExecutor executor) {
            this.description = description;
            this.executor = executor;
        }

        String getDescription() {
            return description;
        }

        String execute(String args) {
            return executor.execute(args);
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\DevConsole.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\EventMonitor.java =====

package com.pulse.debug;

import com.pulse.event.Event;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 이벤트 모니터.
 * 실시간으로 발생하는 이벤트 추적 및 통계.
 * 
 * 사용 예:
 * 
 * <pre>
 * EventMonitor.enable();
 * // ... 게임 플레이 ...
 * EventMonitor.printStats();
 * </pre>
 */
public class EventMonitor {

    private static final EventMonitor INSTANCE = new EventMonitor();

    private boolean enabled = false;
    private final Map<Class<? extends Event>, EventStats> stats = new ConcurrentHashMap<>();
    private final List<EventRecord> recentEvents = Collections.synchronizedList(new LinkedList<>());
    private static final int MAX_RECENT = 100;

    private EventMonitor() {
    }

    public static EventMonitor getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 제어
    // ─────────────────────────────────────────────────────────────

    public static void enable() {
        INSTANCE.enabled = true;
        System.out.println("[Pulse/EventMonitor] Monitoring enabled");
    }

    public static void disable() {
        INSTANCE.enabled = false;
        System.out.println("[Pulse/EventMonitor] Monitoring disabled");
    }

    public static boolean isEnabled() {
        return INSTANCE.enabled;
    }

    public static void reset() {
        INSTANCE.stats.clear();
        INSTANCE.recentEvents.clear();
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 기록 (EventBus에서 호출)
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 발생 기록.
     */
    public static void record(Event event, long processingTimeNs) {
        if (!INSTANCE.enabled)
            return;

        Class<? extends Event> type = event.getClass();

        // 통계 업데이트
        INSTANCE.stats.computeIfAbsent(type, k -> new EventStats(type))
                .record(processingTimeNs);

        // 최근 이벤트 저장
        synchronized (INSTANCE.recentEvents) {
            INSTANCE.recentEvents.add(new EventRecord(type, processingTimeNs));
            while (INSTANCE.recentEvents.size() > MAX_RECENT) {
                INSTANCE.recentEvents.remove(0);
            }
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 통계 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 통계 출력.
     */
    public static void printStats() {
        System.out.println("═══════════════════════════════════════");
        System.out.println("        EVENT MONITOR STATISTICS        ");
        System.out.println("═══════════════════════════════════════");

        List<EventStats> sorted = new ArrayList<>(INSTANCE.stats.values());
        sorted.sort((a, b) -> Long.compare(b.count.get(), a.count.get()));

        for (EventStats stat : sorted) {
            System.out.printf("  %-30s : %6d events, avg %.2fms\n",
                    stat.eventType.getSimpleName(),
                    stat.count.get(),
                    stat.getAverageMs());
        }

        System.out.println("═══════════════════════════════════════");
    }

    /**
     * 통계 맵 반환.
     */
    public static Map<Class<? extends Event>, EventStats> getStats() {
        return Collections.unmodifiableMap(INSTANCE.stats);
    }

    /**
     * 최근 이벤트 목록.
     */
    public static List<EventRecord> getRecentEvents() {
        return new ArrayList<>(INSTANCE.recentEvents);
    }

    // ─────────────────────────────────────────────────────────────
    // 데이터 클래스
    // ─────────────────────────────────────────────────────────────

    public static class EventStats {
        public final Class<? extends Event> eventType;
        public final AtomicLong count = new AtomicLong(0);
        public final AtomicLong totalTimeNs = new AtomicLong(0);

        EventStats(Class<? extends Event> eventType) {
            this.eventType = eventType;
        }

        void record(long processingTimeNs) {
            count.incrementAndGet();
            totalTimeNs.addAndGet(processingTimeNs);
        }

        public double getAverageMs() {
            long c = count.get();
            if (c == 0)
                return 0;
            return (totalTimeNs.get() / (double) c) / 1_000_000.0;
        }
    }

    public static class EventRecord {
        public final Class<? extends Event> eventType;
        public final long timestamp;
        public final long processingTimeNs;

        EventRecord(Class<? extends Event> eventType, long processingTimeNs) {
            this.eventType = eventType;
            this.timestamp = System.currentTimeMillis();
            this.processingTimeNs = processingTimeNs;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\EventMonitor.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\ModProfiler.java =====

package com.pulse.debug;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 모드별 성능 프로파일러.
 * 각 모드의 틱 시간, 메모리 사용량 추적.
 * 
 * 사용 예:
 * 
 * <pre>
 * ProfilerSection section = ModProfiler.start("mymod", "onTick");
 * try {
 *     // 작업 수행
 * } finally {
 *     section.end();
 * }
 * </pre>
 */
public class ModProfiler {

    private static final ModProfiler INSTANCE = new ModProfiler();

    private boolean enabled = false;
    private final Map<String, ModProfile> profiles = new ConcurrentHashMap<>();

    private ModProfiler() {
    }

    public static ModProfiler getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 제어
    // ─────────────────────────────────────────────────────────────

    public static void enable() {
        INSTANCE.enabled = true;
        System.out.println("[Pulse/Profiler] Profiling enabled");
    }

    public static void disable() {
        INSTANCE.enabled = false;
        System.out.println("[Pulse/Profiler] Profiling disabled");
    }

    public static boolean isEnabled() {
        return INSTANCE.enabled;
    }

    public static void reset() {
        INSTANCE.profiles.clear();
    }

    // ─────────────────────────────────────────────────────────────
    // 프로파일링 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 프로파일링 섹션 시작.
     */
    public static ProfilerSection start(String modId, String section) {
        if (!INSTANCE.enabled) {
            return ProfilerSection.NOOP;
        }
        return new ProfilerSection(modId, section, System.nanoTime());
    }

    /**
     * 람다로 프로파일링.
     */
    public static void profile(String modId, String section, Runnable task) {
        ProfilerSection s = start(modId, section);
        try {
            task.run();
        } finally {
            s.end();
        }
    }

    /**
     * 반환값이 있는 람다 프로파일링.
     */
    public static <T> T profileGet(String modId, String section, Supplier<T> task) {
        ProfilerSection s = start(modId, section);
        try {
            return task.get();
        } finally {
            s.end();
        }
    }

    /**
     * 프로파일링 결과 기록.
     */
    static void record(String modId, String section, long durationNs) {
        INSTANCE.profiles
                .computeIfAbsent(modId, k -> new ModProfile(modId))
                .record(section, durationNs);
    }

    // ─────────────────────────────────────────────────────────────
    // 결과 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * 프로파일링 결과 출력.
     */
    public static void printResults() {
        System.out.println("═══════════════════════════════════════");
        System.out.println("         MOD PROFILER RESULTS          ");
        System.out.println("═══════════════════════════════════════");

        for (ModProfile profile : INSTANCE.profiles.values()) {
            System.out.println("\n  [" + profile.modId + "]");
            double totalMs = 0;

            for (var entry : profile.sections.entrySet()) {
                SectionStats stats = entry.getValue();
                double avgMs = stats.getAverageMs();
                totalMs += avgMs * stats.count;
                System.out.printf("    %-25s : %6d calls, avg %.3fms\n",
                        entry.getKey(), stats.count, avgMs);
            }

            System.out.printf("    %-25s : %.2fms total\n", "TOTAL", totalMs);
        }

        System.out.println("\n═══════════════════════════════════════");
    }

    /**
     * 특정 모드의 프로파일 조회.
     */
    public static ModProfile getProfile(String modId) {
        return INSTANCE.profiles.get(modId);
    }

    // ─────────────────────────────────────────────────────────────
    // 데이터 클래스
    // ─────────────────────────────────────────────────────────────

    public static class ProfilerSection {
        static final ProfilerSection NOOP = new ProfilerSection(null, null, 0) {
            @Override
            public void end() {
            }
        };

        private final String modId;
        private final String section;
        private final long startNs;

        ProfilerSection(String modId, String section, long startNs) {
            this.modId = modId;
            this.section = section;
            this.startNs = startNs;
        }

        public void end() {
            long duration = System.nanoTime() - startNs;
            record(modId, section, duration);
        }
    }

    public static class ModProfile {
        public final String modId;
        public final Map<String, SectionStats> sections = new ConcurrentHashMap<>();

        ModProfile(String modId) {
            this.modId = modId;
        }

        void record(String section, long durationNs) {
            sections.computeIfAbsent(section, k -> new SectionStats())
                    .record(durationNs);
        }
    }

    public static class SectionStats {
        public long count = 0;
        public long totalNs = 0;
        public long minNs = Long.MAX_VALUE;
        public long maxNs = 0;

        synchronized void record(long durationNs) {
            count++;
            totalNs += durationNs;
            minNs = Math.min(minNs, durationNs);
            maxNs = Math.max(maxNs, durationNs);
        }

        public double getAverageMs() {
            if (count == 0)
                return 0;
            return (totalNs / (double) count) / 1_000_000.0;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\debug\ModProfiler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\distribution\ModRepository.java =====

package com.pulse.distribution;

import java.io.*;
import java.net.*;
import java.nio.file.*;
import java.util.*;

/**
 * 모드 저장소 클라이언트.
 * 공식/커뮤니티 모드 저장소에서 모드 검색 및 다운로드.
 */
public class ModRepository {

    private static final ModRepository INSTANCE = new ModRepository();

    private final List<String> repositoryUrls = new ArrayList<>();
    private Path downloadDirectory;

    private ModRepository() {
        // 기본 저장소
        repositoryUrls.add("https://pulse-mods.example.com");
        downloadDirectory = Paths.get("mods");
    }

    public static ModRepository getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 저장소 관리
    // ─────────────────────────────────────────────────────────────

    /**
     * 저장소 URL 추가.
     */
    public static void addRepository(String url) {
        INSTANCE.repositoryUrls.add(url);
    }

    /**
     * 다운로드 디렉토리 설정.
     */
    public static void setDownloadDirectory(Path path) {
        INSTANCE.downloadDirectory = path;
    }

    // ─────────────────────────────────────────────────────────────
    // 검색
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 검색.
     */
    public static List<ModInfo> search(String query) {
        return INSTANCE.searchInternal(query);
    }

    private List<ModInfo> searchInternal(String query) {
        List<ModInfo> results = new ArrayList<>();

        for (String repoUrl : repositoryUrls) {
            try {
                URL url = new URL(repoUrl + "/api/search?q=" + URLEncoder.encode(query, "UTF-8"));
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                conn.setConnectTimeout(5000);

                if (conn.getResponseCode() == 200) {
                    // JSON 응답 파싱 (간략화)
                    try (BufferedReader reader = new BufferedReader(
                            new InputStreamReader(conn.getInputStream()))) {
                        String line;
                        while ((line = reader.readLine()) != null) {
                            // 간단한 파싱 로직
                            if (line.contains("\"id\"")) {
                                results.add(parseModInfo(line));
                            }
                        }
                    }
                }
            } catch (Exception e) {
                System.err.println("[Pulse/Repo] Search failed for " + repoUrl);
            }
        }

        return results;
    }

    private ModInfo parseModInfo(String json) {
        // 간단한 파싱 (실제로는 Gson 사용)
        String id = extractValue(json, "id");
        String name = extractValue(json, "name");
        String version = extractValue(json, "version");
        String author = extractValue(json, "author");
        String downloadUrl = extractValue(json, "downloadUrl");
        int downloads = extractIntValue(json, "downloads");

        return new ModInfo(id, name, version, author, downloadUrl, downloads);
    }

    private String extractValue(String json, String key) {
        int start = json.indexOf("\"" + key + "\":\"");
        if (start < 0)
            return "";
        start += key.length() + 4;
        int end = json.indexOf("\"", start);
        return end > start ? json.substring(start, end) : "";
    }

    private int extractIntValue(String json, String key) {
        try {
            int start = json.indexOf("\"" + key + "\":");
            if (start < 0)
                return 0;
            start += key.length() + 3;
            int end = start;
            while (end < json.length() && Character.isDigit(json.charAt(end)))
                end++;
            return Integer.parseInt(json.substring(start, end));
        } catch (Exception e) {
            return 0;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 다운로드
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 다운로드.
     */
    public static File download(ModInfo modInfo) throws IOException {
        return INSTANCE.downloadInternal(modInfo);
    }

    private File downloadInternal(ModInfo modInfo) throws IOException {
        if (modInfo.downloadUrl == null || modInfo.downloadUrl.isEmpty()) {
            throw new IOException("No download URL for mod: " + modInfo.id);
        }

        Files.createDirectories(downloadDirectory);
        Path targetPath = downloadDirectory.resolve(modInfo.id + "-" + modInfo.version + ".jar");

        System.out.println("[Pulse/Repo] Downloading: " + modInfo.name);

        URL url = new URL(modInfo.downloadUrl);
        try (InputStream in = url.openStream()) {
            Files.copy(in, targetPath, StandardCopyOption.REPLACE_EXISTING);
        }

        System.out.println("[Pulse/Repo] Downloaded: " + targetPath);
        return targetPath.toFile();
    }

    /**
     * 의존성 포함 다운로드.
     */
    public static List<File> downloadWithDependencies(ModInfo modInfo) throws IOException {
        List<File> downloaded = new ArrayList<>();
        downloaded.add(download(modInfo));

        // 의존성 다운로드는 추후 구현

        return downloaded;
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 정보
    // ─────────────────────────────────────────────────────────────

    public static class ModInfo {
        public final String id;
        public final String name;
        public final String version;
        public final String author;
        public final String downloadUrl;
        public final int downloads;

        public ModInfo(String id, String name, String version, String author,
                String downloadUrl, int downloads) {
            this.id = id;
            this.name = name;
            this.version = version;
            this.author = author;
            this.downloadUrl = downloadUrl;
            this.downloads = downloads;
        }

        @Override
        public String toString() {
            return String.format("%s (%s) v%s by %s - %d downloads",
                    name, id, version, author, downloads);
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\distribution\ModRepository.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\distribution\UpdateChecker.java =====

package com.pulse.distribution;

import com.pulse.mod.ModLoader;
import com.pulse.mod.ModContainer;

import java.io.*;
import java.net.*;
import java.util.*;

/**
 * 모드 업데이트 확인.
 * 원격 저장소에서 모드의 새 버전 확인.
 */
public class UpdateChecker {

    private static final UpdateChecker INSTANCE = new UpdateChecker();

    private String updateServerUrl = "https://pulse-mods.example.com/api";
    private final Map<String, UpdateInfo> updateCache = new HashMap<>();
    private long lastCheckTime = 0;
    private static final long CHECK_INTERVAL = 3600000; // 1시간

    private UpdateChecker() {
    }

    public static UpdateChecker getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 업데이트 확인
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 모드의 업데이트 확인.
     */
    public static List<UpdateInfo> checkAll() {
        return INSTANCE.checkAllInternal();
    }

    private List<UpdateInfo> checkAllInternal() {
        List<UpdateInfo> updates = new ArrayList<>();

        if (System.currentTimeMillis() - lastCheckTime < CHECK_INTERVAL && !updateCache.isEmpty()) {
            return new ArrayList<>(updateCache.values());
        }

        for (String modId : ModLoader.getInstance().getLoadedModIds()) {
            try {
                UpdateInfo info = checkMod(modId);
                if (info != null && info.hasUpdate()) {
                    updates.add(info);
                    updateCache.put(modId, info);
                }
            } catch (Exception e) {
                System.err.println("[Pulse/Update] Failed to check: " + modId);
            }
        }

        lastCheckTime = System.currentTimeMillis();
        System.out.println("[Pulse/Update] Found " + updates.size() + " updates available");
        return updates;
    }

    /**
     * 특정 모드의 업데이트 확인.
     */
    public static UpdateInfo check(String modId) {
        return INSTANCE.checkMod(modId);
    }

    private UpdateInfo checkMod(String modId) {
        ModContainer mod = ModLoader.getInstance().getMod(modId);
        if (mod == null)
            return null;

        String currentVersion = mod.getMetadata().getVersion();

        try {
            // API 호출
            URL url = new URL(updateServerUrl + "/check?mod=" + modId + "&version=" + currentVersion);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.setConnectTimeout(5000);
            conn.setReadTimeout(5000);

            if (conn.getResponseCode() == 200) {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(conn.getInputStream()))) {

                    // 간단한 JSON 파싱 (예: {"latestVersion":"1.2.0","downloadUrl":"..."})
                    String line = reader.readLine();
                    if (line != null && line.contains("latestVersion")) {
                        String latestVersion = extractJsonValue(line, "latestVersion");
                        String downloadUrl = extractJsonValue(line, "downloadUrl");
                        String changelog = extractJsonValue(line, "changelog");

                        return new UpdateInfo(modId, currentVersion, latestVersion, downloadUrl, changelog);
                    }
                }
            }
        } catch (Exception e) {
            // 네트워크 오류 무시
        }

        return new UpdateInfo(modId, currentVersion, currentVersion, null, null);
    }

    private String extractJsonValue(String json, String key) {
        int start = json.indexOf("\"" + key + "\":\"");
        if (start < 0)
            return null;
        start += key.length() + 4;
        int end = json.indexOf("\"", start);
        if (end < 0)
            return null;
        return json.substring(start, end);
    }

    /**
     * 업데이트 서버 URL 설정.
     */
    public static void setServerUrl(String url) {
        INSTANCE.updateServerUrl = url;
    }

    // ─────────────────────────────────────────────────────────────
    // 업데이트 정보
    // ─────────────────────────────────────────────────────────────

    public static class UpdateInfo {
        private final String modId;
        private final String currentVersion;
        private final String latestVersion;
        private final String downloadUrl;
        private final String changelog;

        public UpdateInfo(String modId, String currentVersion, String latestVersion,
                String downloadUrl, String changelog) {
            this.modId = modId;
            this.currentVersion = currentVersion;
            this.latestVersion = latestVersion;
            this.downloadUrl = downloadUrl;
            this.changelog = changelog;
        }

        public boolean hasUpdate() {
            return !currentVersion.equals(latestVersion);
        }

        public String getModId() {
            return modId;
        }

        public String getCurrentVersion() {
            return currentVersion;
        }

        public String getLatestVersion() {
            return latestVersion;
        }

        public String getDownloadUrl() {
            return downloadUrl;
        }

        public String getChangelog() {
            return changelog;
        }

        @Override
        public String toString() {
            return modId + ": " + currentVersion + " -> " + latestVersion;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\distribution\UpdateChecker.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\chat\ChatEvent.java =====

package com.pulse.event.chat;

import com.pulse.event.Event;

/**
 * 채팅 관련 이벤트 기본 클래스.
 */
public abstract class ChatEvent extends Event {

    private final Object player; // IsoPlayer
    private String message;

    protected ChatEvent(Object player, String message) {
        this.player = player;
        this.message = message;
    }

    public Object getPlayer() {
        return player;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\chat\ChatEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\chat\ChatReceiveEvent.java =====

package com.pulse.event.chat;

/**
 * 채팅 메시지를 수신할 때 발생.
 */
public class ChatReceiveEvent extends ChatEvent {

    private final Object sender; // 메시지를 보낸 플레이어 (또는 null if system)

    public ChatReceiveEvent(Object player, String message, Object sender) {
        super(player, message);
        this.sender = sender;
    }

    public Object getSender() {
        return sender;
    }

    public boolean isSystemMessage() {
        return sender == null;
    }

    @Override
    public String getEventName() {
        return "ChatReceive";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\chat\ChatReceiveEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\chat\ChatSendEvent.java =====

package com.pulse.event.chat;

/**
 * 플레이어가 채팅 메시지를 보낼 때 발생.
 * 취소 가능 - 메시지 전송을 막을 수 있음.
 */
public class ChatSendEvent extends ChatEvent {

    private final ChatType chatType;

    public ChatSendEvent(Object player, String message, ChatType chatType) {
        super(player, message);
        this.chatType = chatType;
    }

    public ChatType getChatType() {
        return chatType;
    }

    @Override
    public String getEventName() {
        return "ChatSend";
    }

    public enum ChatType {
        SAY, // 일반 채팅
        SHOUT, // 외침
        WHISPER, // 속삭임
        RADIO, // 무전기
        ADMIN, // 관리자
        FACTION, // 팩션
        SAFEHOUSE // 세이프하우스
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\chat\ChatSendEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\chat\CommandEvent.java =====

package com.pulse.event.chat;

import com.pulse.event.Event;

/**
 * 명령어 실행 시 발생.
 */
public class CommandEvent extends Event {

    private final Object player;
    private final String command;
    private final String[] args;

    public CommandEvent(Object player, String command, String[] args) {
        this.player = player;
        this.command = command;
        this.args = args;
    }

    public Object getPlayer() {
        return player;
    }

    public String getCommand() {
        return command;
    }

    public String[] getArgs() {
        return args;
    }

    @Override
    public String getEventName() {
        return "Command";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\chat\CommandEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\environment\TimeChangeEvent.java =====

package com.pulse.event.environment;

import com.pulse.event.Event;

/**
 * 게임 내 시간 변경 이벤트.
 */
public class TimeChangeEvent extends Event {

    private final int hour;
    private final int minute;
    private final int day;
    private final int month;
    private final int year;

    public TimeChangeEvent(int hour, int minute, int day, int month, int year) {
        this.hour = hour;
        this.minute = minute;
        this.day = day;
        this.month = month;
        this.year = year;
    }

    public int getHour() {
        return hour;
    }

    public int getMinute() {
        return minute;
    }

    public int getDay() {
        return day;
    }

    public int getMonth() {
        return month;
    }

    public int getYear() {
        return year;
    }

    public boolean isDawn() {
        return hour >= 5 && hour < 7;
    }

    public boolean isDay() {
        return hour >= 7 && hour < 19;
    }

    public boolean isDusk() {
        return hour >= 19 && hour < 21;
    }

    public boolean isNight() {
        return hour >= 21 || hour < 5;
    }

    @Override
    public String getEventName() {
        return "TimeChange";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\environment\TimeChangeEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\environment\WeatherChangeEvent.java =====

package com.pulse.event.environment;

import com.pulse.event.Event;

/**
 * 날씨 변경 이벤트.
 */
public class WeatherChangeEvent extends Event {

    private final WeatherType previousWeather;
    private final WeatherType newWeather;
    private final float intensity;

    public WeatherChangeEvent(WeatherType previousWeather, WeatherType newWeather, float intensity) {
        this.previousWeather = previousWeather;
        this.newWeather = newWeather;
        this.intensity = intensity;
    }

    public WeatherType getPreviousWeather() {
        return previousWeather;
    }

    public WeatherType getNewWeather() {
        return newWeather;
    }

    public float getIntensity() {
        return intensity;
    }

    @Override
    public String getEventName() {
        return "WeatherChange";
    }

    public enum WeatherType {
        CLEAR,
        CLOUDY,
        RAIN,
        STORM,
        SNOW,
        FOG,
        BLIZZARD
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\environment\WeatherChangeEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\Event.java =====

package com.pulse.event;

/**
 * 모든 Pulse 이벤트의 기본 클래스.
 */
public abstract class Event {
    
    private boolean cancelled = false;
    private final boolean cancellable;
    
    protected Event() {
        this(false);
    }
    
    protected Event(boolean cancellable) {
        this.cancellable = cancellable;
    }
    
    /**
     * 이벤트 취소 (취소 가능한 이벤트만)
     */
    public void cancel() {
        if (!cancellable) {
            throw new UnsupportedOperationException("This event cannot be cancelled");
        }
        this.cancelled = true;
    }
    
    public boolean isCancelled() {
        return cancelled;
    }
    
    public boolean isCancellable() {
        return cancellable;
    }
    
    /**
     * 이벤트 이름 (디버깅용)
     */
    public String getEventName() {
        return getClass().getSimpleName();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\Event.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\EventBus.java =====

package com.pulse.event;

import com.pulse.api.DevMode;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Pulse 이벤트 버스.
 * 이벤트 등록, 발행, 구독을 관리.
 * 
 * 사용 예:
 * // 구독
 * EventBus.subscribe(GameTickEvent.class, event -> {
 * System.out.println("Game tick: " + event.getTick());
 * });
 * 
 * // 발행
 * EventBus.post(new GameTickEvent(tickCount));
 */
public class EventBus {

    private static final EventBus INSTANCE = new EventBus();

    // 이벤트 타입 → 리스너 목록
    private final Map<Class<? extends Event>, List<RegisteredListener<?>>> listeners = new ConcurrentHashMap<>();

    // 디버그 모드
    private boolean debug = false;

    // ─────────────────────────────────────────────────────────────
    // 싱글톤 접근
    // ─────────────────────────────────────────────────────────────

    public static EventBus getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 메서드 (편의용)
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 리스너 등록 (기본 우선순위)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener) {
        INSTANCE.register(eventType, listener, EventPriority.NORMAL, null);
    }

    /**
     * 이벤트 리스너 등록 (우선순위 지정)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener,
            EventPriority priority) {
        INSTANCE.register(eventType, listener, priority, null);
    }

    /**
     * 이벤트 리스너 등록 (modId 지정 - 예외 격리용)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener,
            String modId) {
        INSTANCE.register(eventType, listener, EventPriority.NORMAL, modId);
    }

    /**
     * 이벤트 리스너 등록 (우선순위 + modId 지정)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener,
            EventPriority priority, String modId) {
        INSTANCE.register(eventType, listener, priority, modId);
    }

    /**
     * 이벤트 리스너 해제
     */
    public static <T extends Event> void unsubscribe(Class<T> eventType, EventListener<T> listener) {
        INSTANCE.unregister(eventType, listener);
    }

    /**
     * 이벤트 발행
     */
    public static <T extends Event> T post(T event) {
        return INSTANCE.fire(event);
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 리스너 등록 (modId 없이)
     */
    public <T extends Event> void register(Class<T> eventType, EventListener<T> listener,
            EventPriority priority) {
        register(eventType, listener, priority, null);
    }

    /**
     * 리스너 등록 (modId 포함 - 예외 격리용)
     */
    public <T extends Event> void register(Class<T> eventType, EventListener<T> listener,
            EventPriority priority, String modId) {
        List<RegisteredListener<?>> list = listeners.computeIfAbsent(
                eventType,
                k -> new CopyOnWriteArrayList<>());

        RegisteredListener<T> registered = new RegisteredListener<>(listener, priority, modId);
        list.add(registered);

        // 우선순위로 정렬 (높은 것이 먼저)
        list.sort((a, b) -> Integer.compare(b.priority.getValue(), a.priority.getValue()));

        if (debug) {
            String modInfo = modId != null ? " from mod " + modId : "";
            System.out.println("[Pulse/Event] Registered listener for " +
                    eventType.getSimpleName() + " with priority " + priority + modInfo);
        }
    }

    /**
     * 리스너 해제
     */
    public <T extends Event> void unregister(Class<T> eventType, EventListener<T> listener) {
        List<RegisteredListener<?>> list = listeners.get(eventType);
        if (list != null) {
            list.removeIf(reg -> reg.listener == listener);
        }
    }

    /**
     * 이벤트 발행 (모든 리스너에 전달)
     */
    @SuppressWarnings("unchecked")
    public <T extends Event> T fire(T event) {
        List<RegisteredListener<?>> list = listeners.get(event.getClass());

        if (list == null || list.isEmpty()) {
            return event;
        }

        if (debug) {
            System.out.println("[Pulse/EventBus] Firing " + event.getEventName() +
                    " to " + list.size() + " listener(s)");
        }

        for (RegisteredListener<?> registered : list) {
            // 취소된 이벤트는 더 이상 전달하지 않음 (선택적)
            if (event.isCancelled()) {
                break;
            }

            try {
                ((EventListener<T>) registered.listener).onEvent(event);
            } catch (Exception e) {
                // 예외 격리: 어느 모드에서 문제가 발생했는지 명확히 로그
                String modId = registered.modId != null ? registered.modId : "unknown";
                System.err.println("[Pulse/Event] Exception in listener {" + modId +
                        "} for event {" + event.getEventName() + "}");

                // DevMode일 때 추가 정보
                if (DevMode.isEnabled()) {
                    System.err.println("[Pulse/Event]   Listener class: " +
                            registered.listener.getClass().getName());
                    System.err.println("[Pulse/Event]   Priority: " + registered.priority);
                }

                e.printStackTrace();

                // 예외가 발생해도 다른 리스너는 계속 실행됨 (격리)
            }
        }

        return event;
    }

    /**
     * 특정 이벤트 타입의 모든 리스너 해제
     */
    public void clearListeners(Class<? extends Event> eventType) {
        listeners.remove(eventType);
    }

    /**
     * 모든 리스너 해제
     */
    public void clearAll() {
        listeners.clear();
    }

    /**
     * 등록된 리스너 수
     */
    public int getListenerCount(Class<? extends Event> eventType) {
        List<RegisteredListener<?>> list = listeners.get(eventType);
        return list != null ? list.size() : 0;
    }

    /**
     * 특정 modId로 등록된 모든 리스너 해제.
     * 모드 비활성화/리로드 시 사용.
     * 
     * @param modId 해제할 모드 ID
     * @return 해제된 리스너 수
     */
    public static int unsubscribeAll(String modId) {
        return INSTANCE.unregisterAll(modId);
    }

    private int unregisterAll(String modId) {
        if (modId == null)
            return 0;

        int removed = 0;
        for (List<RegisteredListener<?>> list : listeners.values()) {
            int before = list.size();
            list.removeIf(reg -> modId.equals(reg.modId));
            removed += (before - list.size());
        }

        if (removed > 0) {
            System.out.println("[Pulse/Event] Unregistered " + removed +
                    " listeners for mod: " + modId);
        }
        return removed;
    }

    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    private static class RegisteredListener<T extends Event> {
        final EventListener<T> listener;
        final EventPriority priority;
        final String modId; // 예외 격리용 모드 식별자

        RegisteredListener(EventListener<T> listener, EventPriority priority, String modId) {
            this.listener = listener;
            this.priority = priority;
            this.modId = modId;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\EventBus.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\EventListener.java =====

package com.pulse.event;

/**
 * 이벤트 리스너 함수형 인터페이스.
 * 
 * 사용 예:
 * EventBus.subscribe(GameTickEvent.class, event -> {
 *     System.out.println("Tick!");
 * });
 */
@FunctionalInterface
public interface EventListener<T extends Event> {
    
    /**
     * 이벤트 처리
     * @param event 발생한 이벤트
     */
    void onEvent(T event);
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\EventListener.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\EventPriority.java =====

package com.pulse.event;

/**
 * 이벤트 리스너 우선순위.
 * 높은 우선순위가 먼저 실행됨.
 */
public enum EventPriority {
    
    /**
     * 가장 먼저 실행 (모니터링, 로깅용)
     */
    HIGHEST(100),
    
    /**
     * 높은 우선순위
     */
    HIGH(75),
    
    /**
     * 기본 우선순위
     */
    NORMAL(50),
    
    /**
     * 낮은 우선순위
     */
    LOW(25),
    
    /**
     * 가장 나중에 실행 (최종 처리용)
     */
    LOWEST(0);
    
    private final int value;
    
    EventPriority(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\EventPriority.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\gui\GuiCloseEvent.java =====

package com.pulse.event.gui;

import com.pulse.event.Event;

/**
 * GUI 닫힘 이벤트.
 */
public class GuiCloseEvent extends Event {

    private final Object gui;
    private final String guiType;

    public GuiCloseEvent(Object gui, String guiType) {
        this.gui = gui;
        this.guiType = guiType;
    }

    public Object getGui() {
        return gui;
    }

    public String getGuiType() {
        return guiType;
    }

    @Override
    public String getEventName() {
        return "GuiClose";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\gui\GuiCloseEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\gui\GuiOpenEvent.java =====

package com.pulse.event.gui;

import com.pulse.event.Event;

/**
 * GUI 열림 이벤트.
 * 취소 가능 - GUI 열기를 막을 수 있음.
 */
public class GuiOpenEvent extends Event {

    private final Object gui; // UIElement 또는 패널
    private final String guiType; // 식별자

    public GuiOpenEvent(Object gui, String guiType) {
        this.gui = gui;
        this.guiType = guiType;
    }

    public Object getGui() {
        return gui;
    }

    public String getGuiType() {
        return guiType;
    }

    @Override
    public String getEventName() {
        return "GuiOpen";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\gui\GuiOpenEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\gui\GuiRenderEvent.java =====

package com.pulse.event.gui;

import com.pulse.event.Event;

/**
 * GUI 렌더링 이벤트.
 * 커스텀 UI 요소를 그릴 수 있음.
 */
public class GuiRenderEvent extends Event {

    private final Object gui;
    private final String guiType;
    private final float deltaTime;

    public GuiRenderEvent(Object gui, String guiType, float deltaTime) {
        this.gui = gui;
        this.guiType = guiType;
        this.deltaTime = deltaTime;
    }

    public Object getGui() {
        return gui;
    }

    public String getGuiType() {
        return guiType;
    }

    public float getDeltaTime() {
        return deltaTime;
    }

    @Override
    public String getEventName() {
        return "GuiRender";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\gui\GuiRenderEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\inventory\InventoryEvent.java =====

package com.pulse.event.inventory;

import com.pulse.event.Event;

/**
 * 인벤토리 관련 이벤트 기본 클래스.
 */
public abstract class InventoryEvent extends Event {

    private final Object inventory; // IsoGameCharacter의 인벤토리
    private final Object item; // InventoryItem
    private final int slot;

    protected InventoryEvent(Object inventory, Object item, int slot) {
        this.inventory = inventory;
        this.item = item;
        this.slot = slot;
    }

    public Object getInventory() {
        return inventory;
    }

    public Object getItem() {
        return item;
    }

    public int getSlot() {
        return slot;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\inventory\InventoryEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\inventory\ItemAddedEvent.java =====

package com.pulse.event.inventory;

/**
 * 아이템이 인벤토리에 추가될 때 발생.
 */
public class ItemAddedEvent extends InventoryEvent {

    public ItemAddedEvent(Object inventory, Object item, int slot) {
        super(inventory, item, slot);
    }

    @Override
    public String getEventName() {
        return "ItemAdded";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\inventory\ItemAddedEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\inventory\ItemMovedEvent.java =====

package com.pulse.event.inventory;

/**
 * 아이템이 인벤토리 내에서 이동될 때 발생.
 */
public class ItemMovedEvent extends InventoryEvent {

    private final Object targetInventory;
    private final int targetSlot;

    public ItemMovedEvent(Object inventory, Object item, int slot,
            Object targetInventory, int targetSlot) {
        super(inventory, item, slot);
        this.targetInventory = targetInventory;
        this.targetSlot = targetSlot;
    }

    public Object getTargetInventory() {
        return targetInventory;
    }

    public int getTargetSlot() {
        return targetSlot;
    }

    @Override
    public String getEventName() {
        return "ItemMoved";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\inventory\ItemMovedEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\inventory\ItemRemovedEvent.java =====

package com.pulse.event.inventory;

/**
 * 아이템이 인벤토리에서 제거될 때 발생.
 */
public class ItemRemovedEvent extends InventoryEvent {

    public ItemRemovedEvent(Object inventory, Object item, int slot) {
        super(inventory, item, slot);
    }

    @Override
    public String getEventName() {
        return "ItemRemoved";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\inventory\ItemRemovedEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\lifecycle\GameInitEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 게임 라이프사이클 이벤트들
 */

// ─────────────────────────────────────────────────────────────
// 게임 시작/종료
// ─────────────────────────────────────────────────────────────

/**
 * 게임 초기화 완료 시 발생
 */
public class GameInitEvent extends Event {
    public GameInitEvent() {
        super(false);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\lifecycle\GameInitEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\lifecycle\GameTickEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 게임 틱마다 발생하는 이벤트
 */
public class GameTickEvent extends Event {
    
    private final long tick;
    private final float deltaTime;
    
    public GameTickEvent(long tick, float deltaTime) {
        super(false);  // 취소 불가
        this.tick = tick;
        this.deltaTime = deltaTime;
    }
    
    /**
     * 현재 틱 번호
     */
    public long getTick() {
        return tick;
    }
    
    /**
     * 이전 틱과의 시간 간격 (초)
     */
    public float getDeltaTime() {
        return deltaTime;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\lifecycle\GameTickEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\lifecycle\ModReloadEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 모드 리로드 이벤트.
 * 모드가 활성화/비활성화/리로드될 때 발생.
 */
public class ModReloadEvent extends Event {

    private final String modId;
    private final Action action;

    public enum Action {
        ENABLED, // 모드 활성화됨
        DISABLED, // 모드 비활성화됨
        RELOADED, // 소프트 리로드됨
        CONFIG_RELOADED, // 설정만 리로드됨
        HOT_SWAPPED // JAR 핫 스왑됨
    }

    public ModReloadEvent(String modId, Action action) {
        this.modId = modId;
        this.action = action;
    }

    public String getModId() {
        return modId;
    }

    public Action getAction() {
        return action;
    }

    @Override
    public String toString() {
        return "ModReloadEvent{modId='" + modId + "', action=" + action + "}";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\lifecycle\ModReloadEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\lifecycle\WorldLoadEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 월드 로드 시 발생
 */
public class WorldLoadEvent extends Event {
    
    private final String worldName;
    
    public WorldLoadEvent(String worldName) {
        super(false);
        this.worldName = worldName;
    }
    
    public String getWorldName() {
        return worldName;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\lifecycle\WorldLoadEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\lifecycle\WorldUnloadEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 월드 언로드 시 발생
 */
public class WorldUnloadEvent extends Event {
    
    public WorldUnloadEvent() {
        super(false);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\lifecycle\WorldUnloadEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\multiplayer\PlayerConnectEvent.java =====

package com.pulse.event.multiplayer;

import com.pulse.event.Event;

/**
 * 플레이어 서버 접속 이벤트.
 * 취소 가능 - 접속을 거부할 수 있음.
 */
public class PlayerConnectEvent extends Event {

    private final Object connection; // UdpConnection
    private final String username;
    private final String steamId;
    private String kickReason;

    public PlayerConnectEvent(Object connection, String username, String steamId) {
        super(true); // cancellable
        this.connection = connection;
        this.username = username;
        this.steamId = steamId;
    }

    public Object getConnection() {
        return connection;
    }

    public String getUsername() {
        return username;
    }

    public String getSteamId() {
        return steamId;
    }

    /**
     * 접속 거부 - cancel()과 함께 사용.
     */
    public void kick(String reason) {
        this.kickReason = reason;
        cancel();
    }

    public String getKickReason() {
        return kickReason;
    }

    @Override
    public String getEventName() {
        return "PlayerConnect";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\multiplayer\PlayerConnectEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\multiplayer\PlayerDisconnectEvent.java =====

package com.pulse.event.multiplayer;

import com.pulse.event.Event;

/**
 * 플레이어 서버 연결 종료 이벤트.
 */
public class PlayerDisconnectEvent extends Event {

    private final Object connection;
    private final String username;
    private final DisconnectReason reason;

    public PlayerDisconnectEvent(Object connection, String username, DisconnectReason reason) {
        this.connection = connection;
        this.username = username;
        this.reason = reason;
    }

    public Object getConnection() {
        return connection;
    }

    public String getUsername() {
        return username;
    }

    public DisconnectReason getReason() {
        return reason;
    }

    @Override
    public String getEventName() {
        return "PlayerDisconnect";
    }

    public enum DisconnectReason {
        QUIT, // 정상 종료
        TIMEOUT, // 타임아웃
        KICKED, // 강퇴
        BANNED, // 밴
        SERVER_FULL, // 서버 가득 참
        CONNECTION_LOST // 연결 끊김
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\multiplayer\PlayerDisconnectEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\npc\ZombieBehaviorEvent.java =====

package com.pulse.event.npc;

/**
 * 좀비 AI 행동 결정 시 발생.
 * 취소 가능 - 행동을 막거나 변경할 수 있음.
 */
public class ZombieBehaviorEvent extends ZombieEvent {

    private BehaviorType behavior;
    private Object target; // 대상 (플레이어, 위치 등)

    public ZombieBehaviorEvent(Object zombie, BehaviorType behavior, Object target) {
        super(zombie);
        this.behavior = behavior;
        this.target = target;
    }

    public BehaviorType getBehavior() {
        return behavior;
    }

    public void setBehavior(BehaviorType behavior) {
        this.behavior = behavior;
    }

    public Object getTarget() {
        return target;
    }

    public void setTarget(Object target) {
        this.target = target;
    }

    @Override
    public String getEventName() {
        return "ZombieBehavior";
    }

    public enum BehaviorType {
        IDLE, // 대기
        WANDER, // 배회
        CHASE, // 추적
        ATTACK, // 공격
        INVESTIGATE, // 조사 (소리/시야)
        FEED, // 시체 먹기
        CLIMB, // 등반
        BREAK_DOOR, // 문 부수기
        BREAK_WINDOW // 창문 부수기
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\npc\ZombieBehaviorEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\npc\ZombieDeathEvent.java =====

package com.pulse.event.npc;

/**
 * 좀비가 사망할 때 발생.
 */
public class ZombieDeathEvent extends ZombieEvent {

    private final Object killer; // IsoGameCharacter (플레이어 또는 다른 NPC)
    private final Object weapon; // 사용된 무기 (null 가능)

    public ZombieDeathEvent(Object zombie, Object killer, Object weapon) {
        super(zombie);
        this.killer = killer;
        this.weapon = weapon;
    }

    public Object getKiller() {
        return killer;
    }

    public Object getWeapon() {
        return weapon;
    }

    public boolean hasKiller() {
        return killer != null;
    }

    @Override
    public String getEventName() {
        return "ZombieDeath";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\npc\ZombieDeathEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\npc\ZombieEvent.java =====

package com.pulse.event.npc;

import com.pulse.event.Event;

/**
 * 좀비/NPC 관련 이벤트 기본 클래스.
 */
public abstract class ZombieEvent extends Event {

    private final Object zombie; // IsoZombie

    protected ZombieEvent(Object zombie) {
        this.zombie = zombie;
    }

    public Object getZombie() {
        return zombie;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\npc\ZombieEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\npc\ZombieSpawnEvent.java =====

package com.pulse.event.npc;

/**
 * 좀비가 스폰될 때 발생.
 * 취소 가능 - 스폰을 막을 수 있음.
 */
public class ZombieSpawnEvent extends ZombieEvent {

    private final float x, y, z;
    private final SpawnReason reason;

    public ZombieSpawnEvent(Object zombie, float x, float y, float z, SpawnReason reason) {
        super(zombie);
        this.x = x;
        this.y = y;
        this.z = z;
        this.reason = reason;
    }

    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }

    public float getZ() {
        return z;
    }

    public SpawnReason getReason() {
        return reason;
    }

    @Override
    public String getEventName() {
        return "ZombieSpawn";
    }

    public enum SpawnReason {
        NATURAL, // 자연 스폰
        MIGRATION, // 이동/마이그레이션
        SOUND, // 소리로 인한 스폰
        META, // 메타 이벤트
        RESPAWN, // 리스폰
        SCRIPTED // 스크립트에 의한 스폰
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\npc\ZombieSpawnEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\player\PlayerDamageEvent.java =====

package com.pulse.event.player;

/**
 * 플레이어가 데미지를 받을 때 발생 (취소 가능)
 */
public class PlayerDamageEvent extends PlayerEvent {
    
    private float damage;
    private final String damageType;
    
    public PlayerDamageEvent(Object player, float damage, String damageType) {
        super(player, true);  // 취소 가능
        this.damage = damage;
        this.damageType = damageType;
    }
    
    public float getDamage() {
        return damage;
    }
    
    /**
     * 데미지 양 수정
     */
    public void setDamage(float damage) {
        this.damage = Math.max(0, damage);
    }
    
    public String getDamageType() {
        return damageType;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\player\PlayerDamageEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\player\PlayerEvent.java =====

package com.pulse.event.player;

import com.pulse.access.AccessWidener;
import com.pulse.event.Event;

/**
 * 플레이어 관련 이벤트 기본 클래스.
 * 
 * 플레이어 객체는 Object 타입으로 저장됩니다.
 * 이는 의도적인 설계로, Pulse가 PZ 클래스에 직접 의존하지 않고
 * 런타임에 리플렉션을 통해 접근하기 위함입니다.
 * 
 * IsoPlayer 메서드 접근 예시:
 * 
 * <pre>
 * PlayerEvent event = ...;
 * // 직접 캐스팅 (PZ 클래스패스 필요)
 * IsoPlayer player = (IsoPlayer) event.getPlayer();
 * 
 * // 또는 헬퍼 메서드 사용
 * String username = event.getPlayerUsername();
 * float x = event.getPlayerX();
 * </pre>
 */
public abstract class PlayerEvent extends Event {

    private final Object player;

    protected PlayerEvent(Object player, boolean cancellable) {
        super(cancellable);
        this.player = player;
    }

    /**
     * 플레이어 객체 반환.
     * 런타임에서 zombie.characters.IsoPlayer 타입입니다.
     * 
     * @return 플레이어 객체 (IsoPlayer)
     */
    public Object getPlayer() {
        return player;
    }

    // ─────────────────────────────────────────────────────────────
    // 플레이어 정보 헬퍼 메서드 (리플렉션 기반)
    // ─────────────────────────────────────────────────────────────

    /**
     * 플레이어 유저네임 반환.
     */
    public String getPlayerUsername() {
        if (player == null)
            return null;
        try {
            Object result = AccessWidener.invoke(player, "getUsername");
            return result != null ? result.toString() : null;
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 플레이어 X 좌표.
     */
    public float getPlayerX() {
        if (player == null)
            return 0;
        try {
            Object result = AccessWidener.invoke(player, "getX");
            return result instanceof Number n ? n.floatValue() : 0;
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * 플레이어 Y 좌표.
     */
    public float getPlayerY() {
        if (player == null)
            return 0;
        try {
            Object result = AccessWidener.invoke(player, "getY");
            return result instanceof Number n ? n.floatValue() : 0;
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * 플레이어 Z 좌표 (층).
     */
    public float getPlayerZ() {
        if (player == null)
            return 0;
        try {
            Object result = AccessWidener.invoke(player, "getZ");
            return result instanceof Number n ? n.floatValue() : 0;
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * 플레이어 체력.
     */
    public float getPlayerHealth() {
        if (player == null)
            return 0;
        try {
            Object bodyDamage = AccessWidener.invoke(player, "getBodyDamage");
            if (bodyDamage != null) {
                Object result = AccessWidener.invoke(bodyDamage, "getOverallBodyHealth");
                return result instanceof Number n ? n.floatValue() : 0;
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 플레이어 생존 여부.
     */
    public boolean isPlayerAlive() {
        if (player == null)
            return false;
        try {
            Object result = AccessWidener.invoke(player, "isDead");
            return !(result instanceof Boolean b && b);
        } catch (Exception e) {
            return true;
        }
    }

    /**
     * 플레이어가 멀티플레이어 클라이언트인지.
     */
    public boolean isLocalPlayer() {
        if (player == null)
            return false;
        try {
            Object result = AccessWidener.invoke(player, "isLocalPlayer");
            return result instanceof Boolean b && b;
        } catch (Exception e) {
            return false;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\player\PlayerEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\player\PlayerUpdateEvent.java =====

package com.pulse.event.player;

/**
 * 플레이어 업데이트 시 발생
 */
public class PlayerUpdateEvent extends PlayerEvent {
    
    public PlayerUpdateEvent(Object player) {
        super(player, false);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\player\PlayerUpdateEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\save\PostLoadEvent.java =====

package com.pulse.event.save;

/**
 * 로드 후 이벤트.
 */
public class PostLoadEvent extends SaveEvent {

    private final boolean success;

    public PostLoadEvent(String saveName, SaveType saveType, boolean success) {
        super(saveName, saveType);
        this.success = success;
    }

    public boolean isSuccess() {
        return success;
    }

    @Override
    public String getEventName() {
        return "PostLoad";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\save\PostLoadEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\save\PostSaveEvent.java =====

package com.pulse.event.save;

/**
 * 저장 후 이벤트.
 */
public class PostSaveEvent extends SaveEvent {

    private final boolean success;

    public PostSaveEvent(String saveName, SaveType saveType, boolean success) {
        super(saveName, saveType);
        this.success = success;
    }

    public boolean isSuccess() {
        return success;
    }

    @Override
    public String getEventName() {
        return "PostSave";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\save\PostSaveEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\save\PreLoadEvent.java =====

package com.pulse.event.save;

/**
 * 로드 전 이벤트.
 */
public class PreLoadEvent extends SaveEvent {

    public PreLoadEvent(String saveName, SaveType saveType) {
        super(saveName, saveType);
    }

    @Override
    public String getEventName() {
        return "PreLoad";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\save\PreLoadEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\save\PreSaveEvent.java =====

package com.pulse.event.save;

/**
 * 저장 전 이벤트.
 * 모드 데이터를 저장하기 전에 준비할 수 있음.
 */
public class PreSaveEvent extends SaveEvent {

    public PreSaveEvent(String saveName, SaveType saveType) {
        super(saveName, saveType);
    }

    @Override
    public String getEventName() {
        return "PreSave";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\save\PreSaveEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\save\SaveEvent.java =====

package com.pulse.event.save;

import com.pulse.event.Event;

/**
 * 세이브 관련 이벤트 기본 클래스.
 */
public abstract class SaveEvent extends Event {

    private final String saveName;
    private final SaveType saveType;

    protected SaveEvent(String saveName, SaveType saveType) {
        this.saveName = saveName;
        this.saveType = saveType;
    }

    public String getSaveName() {
        return saveName;
    }

    public SaveType getSaveType() {
        return saveType;
    }

    public enum SaveType {
        WORLD, // 월드 데이터
        PLAYER, // 플레이어 데이터
        SERVER, // 서버 설정
        MOD // 모드 데이터
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\save\SaveEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\vehicle\VehicleCollisionEvent.java =====

package com.pulse.event.vehicle;

/**
 * 차량 충돌 시 발생.
 */
public class VehicleCollisionEvent extends VehicleEvent {

    private final Object otherObject; // 충돌 대상 (차량, 좀비, 건물 등)
    private final float impactForce;

    public VehicleCollisionEvent(Object vehicle, Object otherObject, float impactForce) {
        super(vehicle);
        this.otherObject = otherObject;
        this.impactForce = impactForce;
    }

    public Object getOtherObject() {
        return otherObject;
    }

    public float getImpactForce() {
        return impactForce;
    }

    @Override
    public String getEventName() {
        return "VehicleCollision";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\vehicle\VehicleCollisionEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\vehicle\VehicleEnterEvent.java =====

package com.pulse.event.vehicle;

/**
 * 플레이어가 차량에 탑승할 때 발생.
 * 취소 가능 - 탑승을 막을 수 있음.
 */
public class VehicleEnterEvent extends VehicleEvent {

    private final Object player;
    private final int seat; // 좌석 번호 (0 = 운전석)

    public VehicleEnterEvent(Object vehicle, Object player, int seat) {
        super(vehicle);
        this.player = player;
        this.seat = seat;
    }

    public Object getPlayer() {
        return player;
    }

    public int getSeat() {
        return seat;
    }

    public boolean isDriver() {
        return seat == 0;
    }

    @Override
    public String getEventName() {
        return "VehicleEnter";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\vehicle\VehicleEnterEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\vehicle\VehicleEvent.java =====

package com.pulse.event.vehicle;

import com.pulse.event.Event;

/**
 * 차량 관련 이벤트 기본 클래스.
 */
public abstract class VehicleEvent extends Event {

    private final Object vehicle; // BaseVehicle

    protected VehicleEvent(Object vehicle) {
        this.vehicle = vehicle;
    }

    public Object getVehicle() {
        return vehicle;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\vehicle\VehicleEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\vehicle\VehicleExitEvent.java =====

package com.pulse.event.vehicle;

/**
 * 플레이어가 차량에서 하차할 때 발생.
 */
public class VehicleExitEvent extends VehicleEvent {

    private final Object player;
    private final int seat;

    public VehicleExitEvent(Object vehicle, Object player, int seat) {
        super(vehicle);
        this.player = player;
        this.seat = seat;
    }

    public Object getPlayer() {
        return player;
    }

    public int getSeat() {
        return seat;
    }

    @Override
    public String getEventName() {
        return "VehicleExit";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\vehicle\VehicleExitEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\world\ChunkLoadEvent.java =====

package com.pulse.event.world;

import com.pulse.event.Event;

/**
 * 청크 로드 이벤트.
 */
public class ChunkLoadEvent extends Event {

    private final int chunkX;
    private final int chunkY;

    public ChunkLoadEvent(int chunkX, int chunkY) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
    }

    public int getChunkX() {
        return chunkX;
    }

    public int getChunkY() {
        return chunkY;
    }

    @Override
    public String getEventName() {
        return "ChunkLoad";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\world\ChunkLoadEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\world\ChunkUnloadEvent.java =====

package com.pulse.event.world;

import com.pulse.event.Event;

/**
 * 청크 언로드 이벤트.
 */
public class ChunkUnloadEvent extends Event {

    private final int chunkX;
    private final int chunkY;

    public ChunkUnloadEvent(int chunkX, int chunkY) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
    }

    public int getChunkX() {
        return chunkX;
    }

    public int getChunkY() {
        return chunkY;
    }

    @Override
    public String getEventName() {
        return "ChunkUnload";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\event\world\ChunkUnloadEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\input\KeyBinding.java =====

package com.pulse.input;

/**
 * 키 바인딩 정의.
 * 모드에서 사용할 키 조합을 정의.
 * 
 * 사용 예:
 * 
 * <pre>
 * KeyBinding myKey = KeyBinding.create("mymod", "open_menu")
 *         .defaultKey(KeyCode.KEY_M)
 *         .withCtrl()
 *         .category("My Mod")
 *         .build();
 * 
 * KeyBindingRegistry.register(myKey);
 * </pre>
 */
public class KeyBinding {

    private final String modId;
    private final String id;
    private final String translationKey;
    private final String category;

    // 기본 키
    private int defaultKeyCode;
    private boolean defaultCtrl = false;
    private boolean defaultShift = false;
    private boolean defaultAlt = false;

    // 현재 바인딩된 키
    private int keyCode;
    private boolean ctrl = false;
    private boolean shift = false;
    private boolean alt = false;

    // 상태
    private boolean pressed = false;
    private boolean wasPressed = false;
    private int pressCount = 0;

    private KeyBinding(String modId, String id, String translationKey, String category) {
        this.modId = modId;
        this.id = id;
        this.translationKey = translationKey;
        this.category = category;
    }

    /**
     * 빌더 생성
     */
    public static Builder create(String modId, String id) {
        return new Builder(modId, id);
    }

    // ─────────────────────────────────────────────────────────────
    // 상태 체크
    // ─────────────────────────────────────────────────────────────

    /**
     * 키가 현재 눌려있는지 확인
     */
    public boolean isPressed() {
        return pressed;
    }

    /**
     * 키가 이번 틱에 눌렸는지 확인 (1회성)
     * wasPressed()와 달리 호출 시 상태가 리셋되지 않음
     */
    public boolean isDown() {
        return pressed && !wasPressed;
    }

    /**
     * 키가 이번 틱에 눌렸는지 확인하고 상태 리셋
     * 1회 입력 처리에 사용
     */
    public boolean wasPressed() {
        if (pressCount > 0) {
            pressCount--;
            return true;
        }
        return false;
    }

    /**
     * 키가 이번 틱에 릴리즈되었는지 확인
     */
    public boolean isReleased() {
        return !pressed && wasPressed;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 상태 업데이트 (KeyBindingRegistry에서 호출)
    // ─────────────────────────────────────────────────────────────

    void updateState(boolean pressed) {
        this.wasPressed = this.pressed;
        this.pressed = pressed;

        if (pressed && !wasPressed) {
            pressCount++;
        }
    }

    void resetPressCount() {
        pressCount = 0;
    }

    // ─────────────────────────────────────────────────────────────
    // 키 설정
    // ─────────────────────────────────────────────────────────────

    /**
     * 키 바인딩 변경
     */
    public void setKey(int keyCode, boolean ctrl, boolean shift, boolean alt) {
        this.keyCode = keyCode;
        this.ctrl = ctrl;
        this.shift = shift;
        this.alt = alt;
    }

    /**
     * 기본값으로 리셋
     */
    public void resetToDefault() {
        this.keyCode = defaultKeyCode;
        this.ctrl = defaultCtrl;
        this.shift = defaultShift;
        this.alt = defaultAlt;
    }

    /**
     * 입력이 이 키 바인딩과 일치하는지 확인
     */
    public boolean matches(int inputKeyCode, boolean inputCtrl, boolean inputShift, boolean inputAlt) {
        return this.keyCode == inputKeyCode &&
                this.ctrl == inputCtrl &&
                this.shift == inputShift &&
                this.alt == inputAlt;
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public String getModId() {
        return modId;
    }

    public String getId() {
        return id;
    }

    public String getFullId() {
        return modId + ":" + id;
    }

    public String getTranslationKey() {
        return translationKey;
    }

    public String getCategory() {
        return category;
    }

    public int getKeyCode() {
        return keyCode;
    }

    public int getDefaultKeyCode() {
        return defaultKeyCode;
    }

    public boolean hasCtrl() {
        return ctrl;
    }

    public boolean hasShift() {
        return shift;
    }

    public boolean hasAlt() {
        return alt;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        if (ctrl)
            sb.append("Ctrl+");
        if (shift)
            sb.append("Shift+");
        if (alt)
            sb.append("Alt+");
        sb.append(KeyCode.getName(keyCode));
        return sb.toString();
    }

    // ─────────────────────────────────────────────────────────────
    // 빌더
    // ─────────────────────────────────────────────────────────────

    public static class Builder {
        private final String modId;
        private final String id;
        private String translationKey;
        private String category = "misc";
        private int keyCode = KeyCode.KEY_UNKNOWN;
        private boolean ctrl = false;
        private boolean shift = false;
        private boolean alt = false;

        private Builder(String modId, String id) {
            this.modId = modId;
            this.id = id;
            this.translationKey = "key." + modId + "." + id;
        }

        public Builder translationKey(String key) {
            this.translationKey = key;
            return this;
        }

        public Builder category(String category) {
            this.category = category;
            return this;
        }

        public Builder defaultKey(int keyCode) {
            this.keyCode = keyCode;
            return this;
        }

        public Builder withCtrl() {
            this.ctrl = true;
            return this;
        }

        public Builder withShift() {
            this.shift = true;
            return this;
        }

        public Builder withAlt() {
            this.alt = true;
            return this;
        }

        public KeyBinding build() {
            KeyBinding binding = new KeyBinding(modId, id, translationKey, category);
            binding.defaultKeyCode = keyCode;
            binding.defaultCtrl = ctrl;
            binding.defaultShift = shift;
            binding.defaultAlt = alt;
            binding.resetToDefault();
            return binding;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\input\KeyBinding.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\input\KeyBindingRegistry.java =====

package com.pulse.input;

import com.pulse.event.EventBus;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 키 바인딩 레지스트리.
 * 모든 키 바인딩을 관리하고 입력 처리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 키 바인딩 생성 및 등록
 * KeyBinding openMenu = KeyBinding.create("mymod", "open_menu")
 *         .defaultKey(KeyCode.KEY_M)
 *         .category("My Mod")
 *         .build();
 * 
 * KeyBindingRegistry.register(openMenu);
 * 
 * // 사용 (매 틱)
 * if (openMenu.wasPressed()) {
 *     openMyMenu();
 * }
 * </pre>
 */
public class KeyBindingRegistry {

    private static final KeyBindingRegistry INSTANCE = new KeyBindingRegistry();

    // 등록된 키 바인딩
    private final Map<String, KeyBinding> bindings = new ConcurrentHashMap<>();

    // 카테고리별 바인딩
    private final Map<String, List<KeyBinding>> byCategory = new ConcurrentHashMap<>();

    // 현재 키 상태
    private final Set<Integer> pressedKeys = ConcurrentHashMap.newKeySet();
    private boolean ctrlPressed = false;
    private boolean shiftPressed = false;
    private boolean altPressed = false;

    private KeyBindingRegistry() {
    }

    public static KeyBindingRegistry getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 편의 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 키 바인딩 등록
     */
    public static void register(KeyBinding binding) {
        INSTANCE.registerBinding(binding);
    }

    /**
     * 키 바인딩 가져오기
     */
    public static KeyBinding get(String modId, String id) {
        return INSTANCE.getBinding(modId + ":" + id);
    }

    /**
     * 모든 키 바인딩
     */
    public static Collection<KeyBinding> getAll() {
        return INSTANCE.getAllBindings();
    }

    /**
     * 카테고리별 키 바인딩
     */
    public static List<KeyBinding> getByCategory(String category) {
        return INSTANCE.getBindingsByCategory(category);
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    public void registerBinding(KeyBinding binding) {
        String fullId = binding.getFullId();

        if (bindings.containsKey(fullId)) {
            System.err.println("[Pulse/Input] Duplicate keybinding: " + fullId);
            return;
        }

        bindings.put(fullId, binding);
        byCategory.computeIfAbsent(binding.getCategory(), k -> new ArrayList<>())
                .add(binding);

        System.out.println("[Pulse/Input] Registered keybinding: " + fullId +
                " (" + binding + ")");
    }

    public KeyBinding getBinding(String fullId) {
        return bindings.get(fullId);
    }

    public Collection<KeyBinding> getAllBindings() {
        return Collections.unmodifiableCollection(bindings.values());
    }

    public List<KeyBinding> getBindingsByCategory(String category) {
        return byCategory.getOrDefault(category, Collections.emptyList());
    }

    public Set<String> getCategories() {
        return Collections.unmodifiableSet(byCategory.keySet());
    }

    // ─────────────────────────────────────────────────────────────
    // 입력 처리 (Mixin에서 호출)
    // ─────────────────────────────────────────────────────────────

    /**
     * 키 프레스 이벤트 처리
     */
    public void onKeyPress(int keyCode, boolean ctrl, boolean shift, boolean alt) {
        // 수정자 키 상태 업데이트
        this.ctrlPressed = ctrl;
        this.shiftPressed = shift;
        this.altPressed = alt;

        pressedKeys.add(keyCode);

        // 매칭되는 키 바인딩 업데이트
        for (KeyBinding binding : bindings.values()) {
            if (binding.matches(keyCode, ctrl, shift, alt)) {
                binding.updateState(true);
            }
        }

        // KeyEvent 발생
        EventBus.post(new KeyEvent(KeyEvent.Type.PRESS, keyCode, ctrl, shift, alt));
    }

    /**
     * 키 릴리즈 이벤트 처리
     */
    public void onKeyRelease(int keyCode, boolean ctrl, boolean shift, boolean alt) {
        this.ctrlPressed = ctrl;
        this.shiftPressed = shift;
        this.altPressed = alt;

        pressedKeys.remove(keyCode);

        // 매칭되는 키 바인딩 업데이트
        for (KeyBinding binding : bindings.values()) {
            if (binding.getKeyCode() == keyCode) {
                binding.updateState(false);
            }
        }

        // KeyEvent 발생
        EventBus.post(new KeyEvent(KeyEvent.Type.RELEASE, keyCode, ctrl, shift, alt));
    }

    /**
     * 특정 키가 현재 눌려있는지 확인
     */
    public boolean isKeyPressed(int keyCode) {
        return pressedKeys.contains(keyCode);
    }

    public boolean isCtrlPressed() {
        return ctrlPressed;
    }

    public boolean isShiftPressed() {
        return shiftPressed;
    }

    public boolean isAltPressed() {
        return altPressed;
    }

    /**
     * 모든 상태 리셋 (포커스 손실 시 등)
     */
    public void resetAll() {
        pressedKeys.clear();
        ctrlPressed = false;
        shiftPressed = false;
        altPressed = false;

        for (KeyBinding binding : bindings.values()) {
            binding.updateState(false);
            binding.resetPressCount();
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\input\KeyBindingRegistry.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\input\KeyCode.java =====

package com.pulse.input;

/**
 * 키 코드 상수.
 * LWJGL/GLFW 키 코드와 호환.
 */
public final class KeyCode {

    private KeyCode() {
    }

    // 알 수 없는 키
    public static final int KEY_UNKNOWN = -1;

    // 특수 키
    public static final int KEY_SPACE = 32;
    public static final int KEY_APOSTROPHE = 39; // '
    public static final int KEY_COMMA = 44; // ,
    public static final int KEY_MINUS = 45; // -
    public static final int KEY_PERIOD = 46; // .
    public static final int KEY_SLASH = 47; // /

    // 숫자 키 (상단)
    public static final int KEY_0 = 48;
    public static final int KEY_1 = 49;
    public static final int KEY_2 = 50;
    public static final int KEY_3 = 51;
    public static final int KEY_4 = 52;
    public static final int KEY_5 = 53;
    public static final int KEY_6 = 54;
    public static final int KEY_7 = 55;
    public static final int KEY_8 = 56;
    public static final int KEY_9 = 57;

    // 문자 키
    public static final int KEY_A = 65;
    public static final int KEY_B = 66;
    public static final int KEY_C = 67;
    public static final int KEY_D = 68;
    public static final int KEY_E = 69;
    public static final int KEY_F = 70;
    public static final int KEY_G = 71;
    public static final int KEY_H = 72;
    public static final int KEY_I = 73;
    public static final int KEY_J = 74;
    public static final int KEY_K = 75;
    public static final int KEY_L = 76;
    public static final int KEY_M = 77;
    public static final int KEY_N = 78;
    public static final int KEY_O = 79;
    public static final int KEY_P = 80;
    public static final int KEY_Q = 81;
    public static final int KEY_R = 82;
    public static final int KEY_S = 83;
    public static final int KEY_T = 84;
    public static final int KEY_U = 85;
    public static final int KEY_V = 86;
    public static final int KEY_W = 87;
    public static final int KEY_X = 88;
    public static final int KEY_Y = 89;
    public static final int KEY_Z = 90;

    // 기능 키
    public static final int KEY_ESCAPE = 256;
    public static final int KEY_ENTER = 257;
    public static final int KEY_TAB = 258;
    public static final int KEY_BACKSPACE = 259;
    public static final int KEY_INSERT = 260;
    public static final int KEY_DELETE = 261;
    public static final int KEY_RIGHT = 262;
    public static final int KEY_LEFT = 263;
    public static final int KEY_DOWN = 264;
    public static final int KEY_UP = 265;
    public static final int KEY_PAGE_UP = 266;
    public static final int KEY_PAGE_DOWN = 267;
    public static final int KEY_HOME = 268;
    public static final int KEY_END = 269;
    public static final int KEY_CAPS_LOCK = 280;
    public static final int KEY_SCROLL_LOCK = 281;
    public static final int KEY_NUM_LOCK = 282;
    public static final int KEY_PRINT_SCREEN = 283;
    public static final int KEY_PAUSE = 284;

    // F키
    public static final int KEY_F1 = 290;
    public static final int KEY_F2 = 291;
    public static final int KEY_F3 = 292;
    public static final int KEY_F4 = 293;
    public static final int KEY_F5 = 294;
    public static final int KEY_F6 = 295;
    public static final int KEY_F7 = 296;
    public static final int KEY_F8 = 297;
    public static final int KEY_F9 = 298;
    public static final int KEY_F10 = 299;
    public static final int KEY_F11 = 300;
    public static final int KEY_F12 = 301;

    // 넘패드
    public static final int KEY_KP_0 = 320;
    public static final int KEY_KP_1 = 321;
    public static final int KEY_KP_2 = 322;
    public static final int KEY_KP_3 = 323;
    public static final int KEY_KP_4 = 324;
    public static final int KEY_KP_5 = 325;
    public static final int KEY_KP_6 = 326;
    public static final int KEY_KP_7 = 327;
    public static final int KEY_KP_8 = 328;
    public static final int KEY_KP_9 = 329;

    // 수정자 키
    public static final int KEY_LEFT_SHIFT = 340;
    public static final int KEY_LEFT_CONTROL = 341;
    public static final int KEY_LEFT_ALT = 342;
    public static final int KEY_RIGHT_SHIFT = 344;
    public static final int KEY_RIGHT_CONTROL = 345;
    public static final int KEY_RIGHT_ALT = 346;

    /**
     * 키 코드를 이름으로 변환
     */
    public static String getName(int keyCode) {
        return switch (keyCode) {
            case KEY_UNKNOWN -> "Unknown";
            case KEY_SPACE -> "Space";
            case KEY_ESCAPE -> "Escape";
            case KEY_ENTER -> "Enter";
            case KEY_TAB -> "Tab";
            case KEY_BACKSPACE -> "Backspace";
            case KEY_DELETE -> "Delete";
            case KEY_UP -> "Up";
            case KEY_DOWN -> "Down";
            case KEY_LEFT -> "Left";
            case KEY_RIGHT -> "Right";
            case KEY_LEFT_SHIFT, KEY_RIGHT_SHIFT -> "Shift";
            case KEY_LEFT_CONTROL, KEY_RIGHT_CONTROL -> "Ctrl";
            case KEY_LEFT_ALT, KEY_RIGHT_ALT -> "Alt";
            default -> {
                if (keyCode >= KEY_A && keyCode <= KEY_Z) {
                    yield String.valueOf((char) keyCode);
                } else if (keyCode >= KEY_0 && keyCode <= KEY_9) {
                    yield String.valueOf((char) keyCode);
                } else if (keyCode >= KEY_F1 && keyCode <= KEY_F12) {
                    yield "F" + (keyCode - KEY_F1 + 1);
                } else if (keyCode >= KEY_KP_0 && keyCode <= KEY_KP_9) {
                    yield "Numpad " + (keyCode - KEY_KP_0);
                }
                yield "Key " + keyCode;
            }
        };
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\input\KeyCode.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\input\KeyEvent.java =====

package com.pulse.input;

import com.pulse.event.Event;

/**
 * 키 입력 이벤트.
 * 키 프레스/릴리즈 시 발생.
 */
public class KeyEvent extends Event {

    public enum Type {
        PRESS,
        RELEASE,
        REPEAT
    }

    private final Type type;
    private final int keyCode;
    private final boolean ctrl;
    private final boolean shift;
    private final boolean alt;

    public KeyEvent(Type type, int keyCode, boolean ctrl, boolean shift, boolean alt) {
        this.type = type;
        this.keyCode = keyCode;
        this.ctrl = ctrl;
        this.shift = shift;
        this.alt = alt;
    }

    public Type getType() {
        return type;
    }

    public int getKeyCode() {
        return keyCode;
    }

    public boolean hasCtrl() {
        return ctrl;
    }

    public boolean hasShift() {
        return shift;
    }

    public boolean hasAlt() {
        return alt;
    }

    public boolean isPress() {
        return type == Type.PRESS;
    }

    public boolean isRelease() {
        return type == Type.RELEASE;
    }

    public boolean isRepeat() {
        return type == Type.REPEAT;
    }

    /**
     * 특정 키와 일치하는지 확인
     */
    public boolean matches(int keyCode) {
        return this.keyCode == keyCode;
    }

    /**
     * 키 바인딩과 일치하는지 확인
     */
    public boolean matches(KeyBinding binding) {
        return binding.matches(keyCode, ctrl, shift, alt);
    }

    @Override
    public String getEventName() {
        return "KeyEvent";
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("KeyEvent[");
        sb.append(type).append(", ");
        if (ctrl)
            sb.append("Ctrl+");
        if (shift)
            sb.append("Shift+");
        if (alt)
            sb.append("Alt+");
        sb.append(KeyCode.getName(keyCode)).append("]");
        return sb.toString();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\input\KeyEvent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\lua\LuaBridge.java =====

package com.pulse.lua;

/**
 * Lua-Java 브릿지.
 * Java에서 Lua 함수를 호출하고 Lua에서 Java를 호출할 수 있도록 함.
 * 
 * PZ는 Kahlua2 기반 Lua 엔진을 사용하므로, 이 브릿지는 그에 맞춰 설계됨.
 * 
 * 사용 예:
 * 
 * <pre>
 * // Lua 함수 호출
 * LuaBridge.call("Events.OnTick.Add", myJavaCallback);
 * 
 * // Lua 전역 변수 접근
 * Object value = LuaBridge.getGlobal("SomeGlobalVar");
 * 
 * // Java 메서드를 Lua에 노출
 * LuaBridge.expose("MyMod", MyModAPI.class);
 * </pre>
 */
public class LuaBridge {

    private static final LuaBridge INSTANCE = new LuaBridge();

    private boolean initialized = false;
    private Object luaState; // KahluaThread 또는 LuaState

    private LuaBridge() {
    }

    public static LuaBridge getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 브릿지 초기화.
     * PulseAgent에서 게임 시작 시 호출됨.
     */
    public static void initialize() {
        INSTANCE.init();
    }

    private void init() {
        if (initialized)
            return;

        try {
            // PZ의 Lua 상태 가져오기 시도
            // zombie.Lua.LuaManager에 접근
            Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");
            java.lang.reflect.Field stateField = luaManagerClass.getDeclaredField("thread");
            stateField.setAccessible(true);
            luaState = stateField.get(null);

            if (luaState != null) {
                System.out.println("[Pulse/Lua] Lua state acquired successfully");
                initialized = true;
            } else {
                System.out.println("[Pulse/Lua] Lua state is null - game not fully loaded yet");
            }
        } catch (ClassNotFoundException e) {
            System.out.println("[Pulse/Lua] PZ Lua classes not found - running outside game?");
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Failed to initialize: " + e.getMessage());
        }
    }

    /**
     * 런타임에 Lua 상태가 사용 가능한지 확인.
     */
    public static boolean isAvailable() {
        return INSTANCE.initialized && INSTANCE.luaState != null;
    }

    // ─────────────────────────────────────────────────────────────
    // Lua 함수 호출
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 함수 호출.
     * 
     * @param functionPath 함수 경로 (예: "Events.OnTick.Add" 또는 단순히 "print")
     * @param args         인자들
     * @return 반환값 (없으면 null)
     */
    public static Object call(String functionPath, Object... args) {
        if (!isAvailable()) {
            System.err.println("[Pulse/Lua] Cannot call - Lua not available");
            return null;
        }
        return INSTANCE.callInternal(functionPath, args);
    }

    private Object callInternal(String functionPath, Object... args) {
        try {
            // zombie.Lua.LuaManager.call 사용
            Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");
            java.lang.reflect.Method callMethod = luaManagerClass.getMethod(
                    "call", String.class, Object[].class);

            return callMethod.invoke(null, functionPath, args);
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Call failed: " + functionPath);
            e.printStackTrace();
            return null;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 전역 변수 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 전역 변수 읽기.
     */
    public static Object getGlobal(String name) {
        if (!isAvailable())
            return null;
        return INSTANCE.getGlobalInternal(name);
    }

    private Object getGlobalInternal(String name) {
        try {
            Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");
            java.lang.reflect.Method getMethod = luaManagerClass.getMethod(
                    "getGlobalObject", String.class);

            return getMethod.invoke(null, name);
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Failed to get global: " + name);
            return null;
        }
    }

    /**
     * Lua 전역 변수 설정.
     */
    public static void setGlobal(String name, Object value) {
        if (!isAvailable())
            return;
        INSTANCE.setGlobalInternal(name, value);
    }

    private void setGlobalInternal(String name, Object value) {
        try {
            Object converted = LuaTypeConverter.javaToLua(value);

            Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");
            java.lang.reflect.Method setMethod = luaManagerClass.getMethod(
                    "setGlobalObject", String.class, Object.class);

            setMethod.invoke(null, name, converted);
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Failed to set global: " + name);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // Java 클래스 노출
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 클래스를 Lua 전역으로 노출.
     * 정적 메서드들이 Lua에서 호출 가능해짐.
     * 
     * @param globalName Lua에서 사용할 이름
     * @param clazz      노출할 클래스
     */
    public static void expose(String globalName, Class<?> clazz) {
        if (!isAvailable()) {
            // 나중에 초기화되면 노출하도록 예약
            PendingExposures.add(globalName, clazz);
            return;
        }
        INSTANCE.exposeInternal(globalName, clazz);
    }

    private void exposeInternal(String globalName, Class<?> clazz) {
        try {
            Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");
            java.lang.reflect.Method exposeMethod = luaManagerClass.getMethod(
                    "expose", String.class, Class.class);

            exposeMethod.invoke(null, globalName, clazz);
            System.out.println("[Pulse/Lua] Exposed: " + globalName + " -> " + clazz.getSimpleName());
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Failed to expose: " + globalName);
            e.printStackTrace();
        }
    }

    /**
     * 대기 중인 노출 처리 (초기화 후 호출).
     */
    public static void processPendingExposures() {
        if (!isAvailable())
            return;
        PendingExposures.processAll();
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스: 지연 노출 관리
    // ─────────────────────────────────────────────────────────────

    private static class PendingExposures {
        private static final java.util.Map<String, Class<?>> pending = new java.util.concurrent.ConcurrentHashMap<>();

        static void add(String name, Class<?> clazz) {
            pending.put(name, clazz);
        }

        static void processAll() {
            for (var entry : pending.entrySet()) {
                INSTANCE.exposeInternal(entry.getKey(), entry.getValue());
            }
            pending.clear();
        }
    }

    // ─────────────────────────────────────────────────────────────
    // Lua 코드 실행
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 코드 문자열 직접 실행.
     * 
     * @param luaCode 실행할 Lua 코드 문자열
     * @return 실행 결과 또는 null
     */
    public static Object executeLuaCode(String luaCode) {
        if (!isAvailable()) {
            System.err.println("[Pulse/Lua] Cannot execute - Lua not available");
            return null;
        }

        try {
            Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");

            // RunLua 메서드 시도
            try {
                java.lang.reflect.Method runMethod = luaManagerClass.getMethod("RunLua", String.class);
                return runMethod.invoke(null, luaCode);
            } catch (NoSuchMethodException e) {
                // 대안: LuaManager.convertor.load() 시도
                java.lang.reflect.Field convertorField = luaManagerClass.getDeclaredField("convertor");
                convertorField.setAccessible(true);
                Object convertor = convertorField.get(null);

                if (convertor != null) {
                    java.lang.reflect.Method loadMethod = convertor.getClass().getMethod("load",
                            String.class, String.class);
                    Object result = loadMethod.invoke(convertor, luaCode, "Pulse");
                    return result;
                }
            }
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Failed to execute code: " + e.getMessage());
            e.printStackTrace();
        }

        return null;
    }

    /**
     * 간단한 print 문 실행.
     */
    public static void luaPrint(String message) {
        executeLuaCode("print(\"" + message.replace("\"", "\\\"") + "\")");
    }

    // ─────────────────────────────────────────────────────────────
    // Lua 테이블 생성/조작
    // ─────────────────────────────────────────────────────────────

    /**
     * 새 Lua 테이블 생성.
     * 
     * @return Lua 테이블 객체 또는 null
     */
    public static Object createLuaTable() {
        if (!isAvailable()) {
            return null;
        }

        try {
            Class<?> kahluaTableClass = Class.forName("se.krka.kahlua.vm.KahluaTable");
            return kahluaTableClass.getDeclaredConstructor().newInstance();
        } catch (ClassNotFoundException e) {
            // 대안: LuaManager를 통한 테이블 생성
            try {
                Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");
                java.lang.reflect.Field envField = luaManagerClass.getDeclaredField("env");
                envField.setAccessible(true);
                Object env = envField.get(null);

                if (env != null) {
                    java.lang.reflect.Method newTableMethod = env.getClass().getMethod("newTable");
                    return newTableMethod.invoke(env);
                }
            } catch (Exception ex) {
                System.err.println("[Pulse/Lua] Failed to create table: " + ex.getMessage());
            }
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Failed to create table: " + e.getMessage());
        }

        return null;
    }

    /**
     * Lua 테이블에 값 설정.
     * 
     * @param table Lua 테이블 객체
     * @param key   키
     * @param value 값
     */
    public static void setTableField(Object table, String key, Object value) {
        if (table == null)
            return;

        try {
            java.lang.reflect.Method rawsetMethod = table.getClass().getMethod("rawset", Object.class, Object.class);
            Object converted = LuaTypeConverter.javaToLua(value);
            rawsetMethod.invoke(table, key, converted);
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Failed to set table field: " + key);
        }
    }

    /**
     * Lua 테이블에서 값 가져오기.
     */
    public static Object getTableField(Object table, String key) {
        if (table == null)
            return null;

        try {
            java.lang.reflect.Method rawgetMethod = table.getClass().getMethod("rawget", Object.class);
            return rawgetMethod.invoke(table, key);
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Failed to get table field: " + key);
            return null;
        }
    }

    /**
     * Java Map을 Lua 테이블로 변환하여 전역에 설정.
     * 
     * @param name 전역 변수 이름
     * @param map  변환할 Map
     */
    public static void setGlobalTable(String name, java.util.Map<String, Object> map) {
        if (!isAvailable())
            return;

        Object table = createLuaTable();
        if (table == null)
            return;

        for (var entry : map.entrySet()) {
            setTableField(table, entry.getKey(), entry.getValue());
        }

        setGlobal(name, table);
    }

    // ─────────────────────────────────────────────────────────────
    // Java 콜백 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 콜백을 Lua에서 호출 가능하게 등록.
     * 
     * @param name     Lua에서 호출할 이름
     * @param callback 콜백 함수
     */
    public static void registerCallback(String name, java.util.function.Function<Object[], Object> callback) {
        if (!isAvailable()) {
            System.err.println("[Pulse/Lua] Cannot register callback - Lua not available");
            return;
        }

        // LuaCallable 래퍼 생성
        Object wrapper = createCallableWrapper(callback);
        if (wrapper != null) {
            setGlobal(name, wrapper);
            System.out.println("[Pulse/Lua] Registered callback: " + name);
        }
    }

    /**
     * Java 함수를 Lua에서 호출 가능한 객체로 래핑.
     */
    private static Object createCallableWrapper(java.util.function.Function<Object[], Object> callback) {
        try {
            // LuaCaller 인터페이스의 동적 프록시 생성
            Class<?> luaCallerClass = Class.forName("se.krka.kahlua.vm.LuaCallable");

            return java.lang.reflect.Proxy.newProxyInstance(
                    luaCallerClass.getClassLoader(),
                    new Class<?>[] { luaCallerClass },
                    (proxy, method, args) -> {
                        if (method.getName().equals("call")) {
                            // args[0] = LuaCallFrame, args[1] = int argCount
                            Object callFrame = args[0];
                            int argCount = (int) args[1];

                            // 인자 추출
                            Object[] luaArgs = new Object[argCount];
                            for (int i = 0; i < argCount; i++) {
                                java.lang.reflect.Method getMethod = callFrame.getClass().getMethod("get", int.class);
                                luaArgs[i] = getMethod.invoke(callFrame, i);
                            }

                            // Java 콜백 호출
                            Object result = callback.apply(luaArgs);

                            // 결과 반환
                            if (result != null) {
                                java.lang.reflect.Method pushMethod = callFrame.getClass().getMethod("push",
                                        Object.class);
                                pushMethod.invoke(callFrame, LuaTypeConverter.javaToLua(result));
                                return 1;
                            }
                            return 0;
                        }
                        return null;
                    });
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Failed to create callable wrapper: " + e.getMessage());
            return null;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 상태 재초기화 (게임 재시작 시 호출).
     */
    public static void reinitialize() {
        INSTANCE.initialized = false;
        INSTANCE.luaState = null;
        initialize();
    }

    /**
     * 디버그: Lua 전역 변수 덤프.
     */
    public static void dumpGlobals() {
        if (!isAvailable())
            return;

        try {
            Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");
            java.lang.reflect.Field envField = luaManagerClass.getDeclaredField("env");
            envField.setAccessible(true);
            Object env = envField.get(null);

            System.out.println("[Pulse/Lua] === Global Variables ===");
            if (env != null) {
                System.out.println("[Pulse/Lua] Env type: " + env.getClass().getName());

                // keys() 메서드로 전역 변수 이름 가져오기
                try {
                    java.lang.reflect.Method keysMethod = env.getClass().getMethod("keys");
                    Object keys = keysMethod.invoke(env);

                    if (keys instanceof Iterable<?> iterable) {
                        int count = 0;
                        for (Object key : iterable) {
                            System.out.println("[Pulse/Lua]   - " + key);
                            count++;
                            if (count >= 50) {
                                System.out.println("[Pulse/Lua]   ... (truncated, " + count + "+ items)");
                                break;
                            }
                        }
                    } else if (keys != null) {
                        System.out.println("[Pulse/Lua] Keys type: " + keys.getClass().getName());
                    }
                } catch (NoSuchMethodException e) {
                    System.out.println("[Pulse/Lua] (keys() method not available)");
                }
            } else {
                System.out.println("[Pulse/Lua] (env is null)");
            }
            System.out.println("[Pulse/Lua] ========================");
        } catch (Exception e) {
            System.err.println("[Pulse/Lua] Failed to dump globals: " + e.getMessage());
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\lua\LuaBridge.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\lua\LuaEventAdapter.java =====

package com.pulse.lua;

import com.pulse.event.Event;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.event.lifecycle.WorldLoadEvent;
import com.pulse.event.lifecycle.WorldUnloadEvent;
import com.pulse.event.player.PlayerUpdateEvent;
import com.pulse.event.player.PlayerDamageEvent;
import com.pulse.event.npc.ZombieDeathEvent;
import com.pulse.event.npc.ZombieSpawnEvent;
import com.pulse.event.environment.TimeChangeEvent;
import com.pulse.event.environment.WeatherChangeEvent;
import com.pulse.event.vehicle.VehicleEnterEvent;
import com.pulse.event.vehicle.VehicleExitEvent;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * EventBus ↔ Lua 이벤트 양방향 어댑터.
 * 
 * Java 이벤트 → Lua 콜백:
 * 
 * <pre>
 * LuaEventAdapter.bridgeToLua(GameTickEvent.class, "OnTick");
 * </pre>
 * 
 * Lua 이벤트 → Java EventBus:
 * 
 * <pre>
 * LuaEventAdapter.bridgeFromLua("OnPlayerMove", PlayerMoveEvent.class,
 *         args -> new PlayerMoveEvent(args[0], args[1], args[2]));
 * </pre>
 */
public class LuaEventAdapter {

    private static final String MOD_ID = "pulse_lua_adapter";
    private static boolean standardMappingsInitialized = false;

    // Lua 이벤트 이름 → Java 이벤트 클래스
    private static final Map<String, LuaToJavaMapping<?>> luaToJavaMappings = new ConcurrentHashMap<>();

    // Java 이벤트 클래스 → Lua 이벤트 이름
    private static final Map<Class<? extends Event>, String> javaToLuaMappings = new ConcurrentHashMap<>();

    private LuaEventAdapter() {
    }

    // ─────────────────────────────────────────────────────────────
    // Java → Lua 브릿지
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 이벤트가 발생하면 Lua 이벤트로 전달.
     * 
     * @param eventClass   Java 이벤트 클래스
     * @param luaEventName PZ Lua 이벤트 이름 (예: "OnTick", "OnPlayerMove")
     */
    public static <T extends Event> void bridgeToLua(Class<T> eventClass, String luaEventName) {
        if (javaToLuaMappings.containsKey(eventClass)) {
            return; // 이미 등록됨
        }

        javaToLuaMappings.put(eventClass, luaEventName);

        EventBus.subscribe(eventClass, event -> {
            triggerLuaEvent(luaEventName, eventToLuaArgs(event));
        }, MOD_ID);

        System.out.println("[Pulse/LuaAdapter] Bridged " +
                eventClass.getSimpleName() + " → Lua:" + luaEventName);
    }

    /**
     * Lua 이벤트 트리거.
     */
    private static void triggerLuaEvent(String eventName, Object... args) {
        if (!LuaBridge.isAvailable())
            return;

        try {
            // Events.<eventName>.Trigger(args...)
            LuaBridge.call("Events." + eventName + ".Trigger", args);
        } catch (Exception e) {
            System.err.println("[Pulse/LuaAdapter] Failed to trigger Lua event: " + eventName);
        }
    }

    /**
     * Event 객체를 Lua 인자로 변환.
     */
    private static Object[] eventToLuaArgs(Event event) {
        // 이벤트 타입에 따라 적절한 인자 추출
        if (event instanceof GameTickEvent e) {
            return new Object[] { e.getTick() };
        }
        if (event instanceof PlayerUpdateEvent e) {
            return new Object[] { e.getPlayer() };
        }
        if (event instanceof PlayerDamageEvent e) {
            return new Object[] { e.getPlayer(), e.getDamage(), e.getDamageType() };
        }
        if (event instanceof ZombieDeathEvent e) {
            return new Object[] { e.getZombie(), e.getKiller() };
        }
        if (event instanceof ZombieSpawnEvent e) {
            return new Object[] { e.getZombie() };
        }
        if (event instanceof TimeChangeEvent e) {
            return new Object[] { e.getHour(), e.getMinute() };
        }
        if (event instanceof VehicleEnterEvent e) {
            return new Object[] { e.getVehicle(), e.getPlayer() };
        }
        if (event instanceof VehicleExitEvent e) {
            return new Object[] { e.getVehicle(), e.getPlayer() };
        }

        // 기본: 이벤트 객체 자체를 전달
        return new Object[] { event };
    }

    // ─────────────────────────────────────────────────────────────
    // Lua → Java 브릿지
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 이벤트를 Java EventBus로 전달.
     * 
     * @param luaEventName Lua 이벤트 이름
     * @param eventClass   Java 이벤트 클래스
     * @param factory      Lua 인자 → Java 이벤트 변환 함수
     */
    public static <T extends Event> void bridgeFromLua(
            String luaEventName,
            Class<T> eventClass,
            LuaEventFactory<T> factory) {

        luaToJavaMappings.put(luaEventName, new LuaToJavaMapping<>(eventClass, factory));

        // Lua에 Java 콜백 등록
        registerLuaCallback(luaEventName);

        System.out.println("[Pulse/LuaAdapter] Bridged Lua:" +
                luaEventName + " → " + eventClass.getSimpleName());
    }

    /**
     * Lua 이벤트에 Java 콜백 등록.
     */
    private static void registerLuaCallback(String luaEventName) {
        if (!LuaBridge.isAvailable()) {
            // 나중에 처리
            return;
        }

        try {
            // Lua 쪽에서 호출할 Java 메서드 노출
            // Events.<eventName>.Add(function) 형태로 등록

            // Java 콜백 객체 생성
            LuaCallback callback = args -> onLuaEvent(luaEventName, args);

            // Lua에 등록
            LuaBridge.call("Events." + luaEventName + ".Add", callback);
        } catch (Exception e) {
            System.err.println("[Pulse/LuaAdapter] Failed to register Lua callback: " + luaEventName);
        }
    }

    /**
     * Lua에서 호출되는 콜백.
     */
    @SuppressWarnings("unchecked")
    private static void onLuaEvent(String luaEventName, Object[] args) {
        LuaToJavaMapping<?> mapping = luaToJavaMappings.get(luaEventName);
        if (mapping == null)
            return;

        try {
            Event event = ((LuaToJavaMapping<Event>) mapping).factory.create(args);
            EventBus.post(event);
        } catch (Exception e) {
            System.err.println("[Pulse/LuaAdapter] Failed to create event from Lua: " + luaEventName);
            e.printStackTrace();
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 표준 이벤트 매핑 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 표준 PZ 이벤트 ↔ Pulse 이벤트 매핑 설정.
     */
    public static void initializeStandardMappings() {
        if (standardMappingsInitialized) {
            return;
        }

        int count = 0;

        // ═══════════════════════════════════════════════════════════
        // Java → Lua 방향
        // ═══════════════════════════════════════════════════════════

        // 라이프사이클 이벤트
        bridgeToLua(GameTickEvent.class, "OnPulseTick");
        count++;

        bridgeToLua(WorldLoadEvent.class, "OnPulseWorldLoad");
        count++;

        bridgeToLua(WorldUnloadEvent.class, "OnPulseWorldUnload");
        count++;

        // 플레이어 이벤트
        bridgeToLua(PlayerUpdateEvent.class, "OnPulsePlayerUpdate");
        count++;

        bridgeToLua(PlayerDamageEvent.class, "OnPulsePlayerDamage");
        count++;

        // 좀비 이벤트
        bridgeToLua(ZombieDeathEvent.class, "OnPulseZombieDeath");
        count++;

        bridgeToLua(ZombieSpawnEvent.class, "OnPulseZombieSpawn");
        count++;

        // 환경 이벤트
        bridgeToLua(TimeChangeEvent.class, "OnPulseTimeChange");
        count++;

        bridgeToLua(WeatherChangeEvent.class, "OnPulseWeatherChange");
        count++;

        // 차량 이벤트
        bridgeToLua(VehicleEnterEvent.class, "OnPulseVehicleEnter");
        count++;

        bridgeToLua(VehicleExitEvent.class, "OnPulseVehicleExit");
        count++;

        // ═══════════════════════════════════════════════════════════
        // Lua → Java 방향 (PZ 네이티브 이벤트 래핑)
        // ═══════════════════════════════════════════════════════════

        // 이 부분은 게임 이벤트를 Java EventBus로 변환
        // 실제 연결은 런타임에 LuaBridge가 사용 가능할 때 수행됨

        standardMappingsInitialized = true;
        System.out.println("[Pulse/LuaAdapter] Standard mappings initialized: " + count + " events");
    }

    /**
     * 매핑 현황 출력 (디버그용).
     */
    public static void printMappings() {
        System.out.println("[Pulse/LuaAdapter] === Event Mappings ===");
        System.out.println("[Pulse/LuaAdapter] Java → Lua:");
        for (var entry : javaToLuaMappings.entrySet()) {
            System.out.println("[Pulse/LuaAdapter]   " + entry.getKey().getSimpleName() + " → " + entry.getValue());
        }
        System.out.println("[Pulse/LuaAdapter] Lua → Java:");
        for (var entry : luaToJavaMappings.entrySet()) {
            System.out.println(
                    "[Pulse/LuaAdapter]   " + entry.getKey() + " → " + entry.getValue().eventClass.getSimpleName());
        }
        System.out.println("[Pulse/LuaAdapter] =====================");
    }

    /**
     * 매핑 개수 반환.
     */
    public static int getMappingCount() {
        return javaToLuaMappings.size() + luaToJavaMappings.size();
    }

    // ─────────────────────────────────────────────────────────────
    // 헬퍼 클래스/인터페이스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface LuaEventFactory<T extends Event> {
        T create(Object[] luaArgs);
    }

    @FunctionalInterface
    public interface LuaCallback {
        void call(Object[] args);
    }

    private static class LuaToJavaMapping<T extends Event> {
        final Class<T> eventClass;
        final LuaEventFactory<T> factory;

        LuaToJavaMapping(Class<T> eventClass, LuaEventFactory<T> factory) {
            this.eventClass = eventClass;
            this.factory = factory;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\lua\LuaEventAdapter.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\lua\LuaTypeConverter.java =====

package com.pulse.lua;

import java.util.List;
import java.util.Map;

/**
 * Java ↔ Lua 타입 변환기.
 * 양방향으로 타입을 안전하게 변환.
 */
public class LuaTypeConverter {

    private LuaTypeConverter() {
    }

    // ─────────────────────────────────────────────────────────────
    // Java → Lua
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 객체를 Lua 호환 객체로 변환.
     */
    public static Object javaToLua(Object javaValue) {
        if (javaValue == null) {
            return null;
        }

        // 기본 타입은 그대로 전달 (Kahlua가 처리)
        if (javaValue instanceof String ||
                javaValue instanceof Number ||
                javaValue instanceof Boolean) {
            return javaValue;
        }

        // 배열 → Lua 테이블 (인덱스 1부터)
        if (javaValue.getClass().isArray()) {
            return arrayToLuaTable(javaValue);
        }

        // List → Lua 테이블
        if (javaValue instanceof List<?>) {
            return listToLuaTable((List<?>) javaValue);
        }

        // Map → Lua 테이블
        if (javaValue instanceof Map<?, ?>) {
            return mapToLuaTable((Map<?, ?>) javaValue);
        }

        // 기타 객체는 그대로 (userdata로 전달됨)
        return javaValue;
    }

    private static Object arrayToLuaTable(Object array) {
        try {
            // KahluaTable 생성 시도
            Class<?> tableClass = Class.forName("se.krka.kahlua.vm.KahluaTable");
            Object table = tableClass.getDeclaredConstructor().newInstance();

            int length = java.lang.reflect.Array.getLength(array);
            for (int i = 0; i < length; i++) {
                Object item = java.lang.reflect.Array.get(array, i);
                // Lua는 1-based 인덱스
                tableClass.getMethod("rawset", Object.class, Object.class)
                        .invoke(table, (double) (i + 1), javaToLua(item));
            }
            return table;
        } catch (Exception e) {
            // 테이블 생성 실패 시 원본 반환
            return array;
        }
    }

    private static Object listToLuaTable(List<?> list) {
        try {
            Class<?> tableClass = Class.forName("se.krka.kahlua.vm.KahluaTable");
            Object table = tableClass.getDeclaredConstructor().newInstance();

            int i = 1;
            for (Object item : list) {
                tableClass.getMethod("rawset", Object.class, Object.class)
                        .invoke(table, (double) i++, javaToLua(item));
            }
            return table;
        } catch (Exception e) {
            return list;
        }
    }

    private static Object mapToLuaTable(Map<?, ?> map) {
        try {
            Class<?> tableClass = Class.forName("se.krka.kahlua.vm.KahluaTable");
            Object table = tableClass.getDeclaredConstructor().newInstance();

            for (var entry : map.entrySet()) {
                Object key = javaToLua(entry.getKey());
                Object value = javaToLua(entry.getValue());
                tableClass.getMethod("rawset", Object.class, Object.class)
                        .invoke(table, key, value);
            }
            return table;
        } catch (Exception e) {
            return map;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // Lua → Java
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 값을 Java 타입으로 변환.
     */
    @SuppressWarnings("unchecked")
    public static <T> T luaToJava(Object luaValue, Class<T> targetType) {
        if (luaValue == null) {
            return null;
        }

        // 이미 원하는 타입이면 그대로 반환
        if (targetType.isInstance(luaValue)) {
            return (T) luaValue;
        }

        // Lua number → 다양한 숫자 타입
        if (luaValue instanceof Double) {
            Double d = (Double) luaValue;
            if (targetType == Integer.class || targetType == int.class) {
                return (T) Integer.valueOf(d.intValue());
            }
            if (targetType == Long.class || targetType == long.class) {
                return (T) Long.valueOf(d.longValue());
            }
            if (targetType == Float.class || targetType == float.class) {
                return (T) Float.valueOf(d.floatValue());
            }
            if (targetType == Double.class || targetType == double.class) {
                return (T) d;
            }
        }

        // String 변환
        if (targetType == String.class) {
            return (T) String.valueOf(luaValue);
        }

        // Boolean 변환
        if (targetType == Boolean.class || targetType == boolean.class) {
            if (luaValue instanceof Boolean) {
                return (T) luaValue;
            }
            return (T) Boolean.TRUE; // Lua에서 nil과 false만 falsy
        }

        // KahluaTable → List
        if (targetType == List.class) {
            return (T) luaTableToList(luaValue);
        }

        // KahluaTable → Map
        if (targetType == Map.class) {
            return (T) luaTableToMap(luaValue);
        }

        // 변환 불가 - 원본 반환 시도
        try {
            return (T) luaValue;
        } catch (ClassCastException e) {
            return null;
        }
    }

    private static List<Object> luaTableToList(Object luaTable) {
        List<Object> result = new java.util.ArrayList<>();
        try {
            Class<?> tableClass = luaTable.getClass();
            java.lang.reflect.Method lenMethod = tableClass.getMethod("len");
            int len = ((Number) lenMethod.invoke(luaTable)).intValue();

            java.lang.reflect.Method rawgetMethod = tableClass.getMethod(
                    "rawget", Object.class);

            for (int i = 1; i <= len; i++) {
                Object value = rawgetMethod.invoke(luaTable, (double) i);
                result.add(value);
            }
        } catch (Exception e) {
            // 변환 실패
        }
        return result;
    }

    private static Map<Object, Object> luaTableToMap(Object luaTable) {
        Map<Object, Object> result = new java.util.LinkedHashMap<>();
        try {
            Class<?> tableClass = luaTable.getClass();

            // 테이블의 next() 메서드로 순회
            java.lang.reflect.Method nextMethod = tableClass.getMethod(
                    "next", Object.class);
            java.lang.reflect.Method rawgetMethod = tableClass.getMethod(
                    "rawget", Object.class);

            Object key = nextMethod.invoke(luaTable, (Object) null);
            while (key != null) {
                Object value = rawgetMethod.invoke(luaTable, key);
                result.put(key, value);
                key = nextMethod.invoke(luaTable, key);
            }
        } catch (Exception e) {
            // 변환 실패
        }
        return result;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\lua\LuaTypeConverter.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\GameClientMixin.java =====

package com.pulse.mixin;

import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.scheduler.PulseScheduler;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * GameClient Mixin.
 * 게임 클라이언트의 메인 업데이트 루프에 훅을 걸어 GameTickEvent 발생.
 */
@Mixin(targets = "zombie.network.GameClient")
public abstract class GameClientMixin {

    @Unique
    private static long Pulse$tickCount = 0;

    @Unique
    private static long Pulse$lastTickTime = System.nanoTime();

    /**
     * GameClient.update() 메서드 끝에서 GameTickEvent 발생 및 스케줄러 틱 처리
     */
    @Inject(method = "update", at = @At("RETURN"))
    private static void Pulse$onUpdate(CallbackInfo ci) {
        long currentTime = System.nanoTime();
        float deltaTime = (currentTime - Pulse$lastTickTime) / 1_000_000_000.0f;
        Pulse$lastTickTime = currentTime;

        Pulse$tickCount++;

        // 스케줄러 틱 처리
        PulseScheduler.getInstance().tick();

        // GameTickEvent 발생
        EventBus.post(new GameTickEvent(Pulse$tickCount, deltaTime));
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\GameClientMixin.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\GameWindowMixin.java =====

package com.pulse.mixin;

import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameInitEvent;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * GameWindow Mixin.
 * 게임 윈도우 초기화 시점에 GameInitEvent 발생.
 */
@Mixin(targets = "zombie.GameWindow")
public abstract class GameWindowMixin {

    @Unique
    private static boolean Pulse$initEventFired = false;

    /**
     * 게임 윈도우 초기화 완료 시 GameInitEvent 발생 (한 번만)
     */
    @Inject(method = "init", at = @At("RETURN"))
    private static void Pulse$onInit(CallbackInfo ci) {
        if (!Pulse$initEventFired) {
            Pulse$initEventFired = true;
            System.out.println("[Pulse] Game initialization complete, firing GameInitEvent");
            EventBus.post(new GameInitEvent());
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\GameWindowMixin.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\IsoPlayerMixin.java =====

package com.pulse.mixin;

import com.pulse.event.EventBus;
import com.pulse.event.player.PlayerDamageEvent;
import com.pulse.event.player.PlayerUpdateEvent;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * IsoPlayer Mixin.
 * 플레이어 업데이트 및 데미지 처리 훅.
 */
@Mixin(targets = "zombie.characters.IsoPlayer")
public abstract class IsoPlayerMixin {

    /**
     * 플레이어 업데이트 시 PlayerUpdateEvent 발생
     */
    @Inject(method = "update", at = @At("HEAD"))
    private void Pulse$onUpdate(CallbackInfo ci) {
        // this는 IsoPlayer 인스턴스
        EventBus.post(new PlayerUpdateEvent(this));
    }

    /**
     * 플레이어가 데미지를 받을 때 PlayerDamageEvent 발생
     * Hit() 메서드 시작 시점에 호출
     *
     * 참고: Project Zomboid의 실제 데미지 메서드 시그니처에 따라 조정 필요
     */
    @Inject(method = "Hit", at = @At("HEAD"), cancellable = true)
    private void Pulse$onHit(
            /* 실제 파라미터는 게임 버전에 따라 다를 수 있음 */
            CallbackInfo ci) {

        // 기본 데미지 값 (실제로는 파라미터에서 가져와야 함)
        float damage = 10.0f;
        String damageType = "unknown";

        PlayerDamageEvent event = new PlayerDamageEvent(this, damage, damageType);
        EventBus.post(event);

        // 이벤트가 취소되었으면 원래 메서드 실행 취소
        if (event.isCancelled()) {
            ci.cancel();
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\IsoPlayerMixin.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\IsoWorldMixin.java =====

package com.pulse.mixin;

import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.WorldLoadEvent;
import com.pulse.event.lifecycle.WorldUnloadEvent;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * IsoWorld Mixin.
 * 월드 로드/언로드 시 이벤트 발생.
 */
@Mixin(targets = "zombie.iso.IsoWorld")
public abstract class IsoWorldMixin {

    @Shadow
    public abstract String getWorld();

    /**
     * 월드 로드 완료 시점에 WorldLoadEvent 발생
     * init() 메서드 리턴 시점에 호출
     */
    @Inject(method = "init", at = @At("RETURN"))
    private void Pulse$onWorldInit(CallbackInfo ci) {
        String worldName = "Unknown";
        try {
            worldName = getWorld();
            if (worldName == null || worldName.isEmpty()) {
                worldName = "World";
            }
        } catch (Exception e) {
            // 월드 이름을 가져올 수 없는 경우 기본값 사용
        }

        System.out.println("[Pulse] World loaded: " + worldName);
        EventBus.post(new WorldLoadEvent(worldName));
    }

    /**
     * 월드 언로드 시점에 WorldUnloadEvent 발생
     */
    @Inject(method = "endWorld", at = @At("HEAD"))
    private void Pulse$onWorldEnd(CallbackInfo ci) {
        System.out.println("[Pulse] World unloading...");
        EventBus.post(new WorldUnloadEvent());
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\IsoWorldMixin.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\MainScreenStateMixin.java =====

package com.pulse.mixin;

import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * MainScreenState Mixin.
 * 게임 메인 화면 렌더링에 훅을 건다.
 */
@Mixin(targets = "zombie.gameStates.MainScreenState")
public abstract class MainScreenStateMixin {

    @Inject(method = "render", at = @At("HEAD"))
    private void Pulse$onRenderHead(CallbackInfo ci) {
        // 렌더링 훅 - 필요시 여기에 로직 추가
    }

    @Inject(method = "render", at = @At("RETURN"))
    private void Pulse$onRenderReturn(CallbackInfo ci) {
        // 렌더링 완료 훅 - 필요시 여기에 로직 추가
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\MainScreenStateMixin.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\MixinDiagnostics.java =====

package com.pulse.mixin;

import com.pulse.api.DevMode;
import com.pulse.api.mixin.MixinInjectionValidator;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Mixin 진단 도구.
 * 적용된 Mixin 추적 및 잠재적 충돌 감지.
 * 
 * DevMode가 활성화되면 상세한 리포트 출력.
 */
public class MixinDiagnostics {

    private static final MixinDiagnostics INSTANCE = new MixinDiagnostics();

    // 타겟 클래스 → 적용된 Mixin 정보 목록
    private final Map<String, List<MixinInfo>> appliedMixins = new ConcurrentHashMap<>();

    // 로드 실패한 Mixin 목록
    private final List<FailedMixin> failedMixins = new ArrayList<>();

    public static MixinDiagnostics getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // Mixin 추적
    // ─────────────────────────────────────────────────────────────

    /**
     * Mixin 적용 기록
     */
    public void recordMixinApplied(String targetClass, String mixinClass,
            String modId, int priority) {
        long startTime = System.currentTimeMillis();
        MixinInfo info = new MixinInfo(mixinClass, modId, priority);
        appliedMixins.computeIfAbsent(targetClass, k -> new ArrayList<>()).add(info);
        long elapsed = System.currentTimeMillis() - startTime;

        // v1.0.1: MixinInjectionValidator에도 성공 기록
        try {
            MixinInjectionValidator.recordSuccess(mixinClass, targetClass, elapsed);
        } catch (Exception e) {
            // ignore - Validator가 초기화되지 않았을 수 있음
        }

        if (DevMode.isEnabled()) {
            System.out.println("[Pulse/Mixin] Applied " + mixinClass +
                    " to " + targetClass + " (mod: " + modId + ", priority: " + priority + ")");
        }
    }

    /**
     * Mixin 실패 기록
     */
    public void recordMixinFailed(String mixinClass, String modId,
            String targetClass, String reason) {
        FailedMixin failed = new FailedMixin(mixinClass, modId, targetClass, reason);
        failedMixins.add(failed);

        // v1.0.1: MixinInjectionValidator에도 실패 기록
        try {
            MixinInjectionValidator.recordFailure(mixinClass, targetClass, reason);
        } catch (Exception e) {
            // ignore - Validator가 초기화되지 않았을 수 있음
        }

        System.err.println("[Pulse/Mixin] Failed " + mixinClass + " from " + modId +
                " to " + targetClass + ": " + reason);
    }

    // ─────────────────────────────────────────────────────────────
    // 충돌 감지
    // ─────────────────────────────────────────────────────────────

    /**
     * 잠재적 충돌 검사 및 경고
     */
    public void checkConflicts() {
        if (!DevMode.isEnabled())
            return;

        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");
        System.out.println("[Pulse/Mixin] Checking for potential Mixin conflicts...");

        int conflictCount = 0;

        for (Map.Entry<String, List<MixinInfo>> entry : appliedMixins.entrySet()) {
            String targetClass = entry.getKey();
            List<MixinInfo> mixins = entry.getValue();

            if (mixins.size() > 1) {
                // 동일 타겟에 여러 Mixin - 잠재적 충돌
                Set<String> mods = new HashSet<>();
                for (MixinInfo info : mixins) {
                    mods.add(info.modId);
                }

                if (mods.size() > 1) {
                    // 다른 모드의 Mixin이 같은 클래스를 수정
                    System.out.println("[Pulse/Mixin] Potential conflict on " + targetClass + ":");
                    for (MixinInfo info : mixins) {
                        System.out.println("[Pulse/Mixin]   - " + info.modId +
                                ": " + info.mixinClass + " (priority: " + info.priority + ")");
                    }
                    conflictCount++;
                }
            }
        }

        if (conflictCount == 0) {
            System.out.println("[Pulse/Mixin] No conflicts detected.");
        } else {
            System.out.println("[Pulse/Mixin] " + conflictCount + " potential conflict(s) found.");
        }

        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // 리포트
    // ─────────────────────────────────────────────────────────────

    /**
     * 전체 Mixin 적용 상태 리포트
     */
    public void printReport() {
        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");
        System.out.println("[Pulse/Mixin] MIXIN APPLICATION REPORT");
        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");

        System.out.println("[Pulse/Mixin] Applied Mixins by Target:");
        for (Map.Entry<String, List<MixinInfo>> entry : appliedMixins.entrySet()) {
            System.out.println("[Pulse/Mixin]   " + entry.getKey() + ":");
            for (MixinInfo info : entry.getValue()) {
                System.out.println("[Pulse/Mixin]     - " + info.mixinClass +
                        " (" + info.modId + ", p=" + info.priority + ")");
            }
        }

        if (!failedMixins.isEmpty()) {
            System.out.println("[Pulse/Mixin] Failed Mixins:");
            for (FailedMixin failed : failedMixins) {
                System.out.println("[Pulse/Mixin]   ✗ " + failed.mixinClass +
                        " from " + failed.modId + " → " + failed.targetClass);
                System.out.println("[Pulse/Mixin]     Reason: " + failed.reason);
            }
        }

        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public int getAppliedCount() {
        return appliedMixins.values().stream().mapToInt(List::size).sum();
    }

    public int getFailedCount() {
        return failedMixins.size();
    }

    public List<MixinInfo> getMixinsForTarget(String targetClass) {
        return appliedMixins.getOrDefault(targetClass, Collections.emptyList());
    }

    /**
     * 크래시 리포트용 변환 상세 정보 반환.
     * 
     * @return 타겟 클래스 → Mixin 클래스 목록 맵
     */
    public static Map<String, List<String>> getTransformationDetails() {
        Map<String, List<String>> result = new LinkedHashMap<>();

        for (Map.Entry<String, List<MixinInfo>> entry : INSTANCE.appliedMixins.entrySet()) {
            List<String> mixinNames = new ArrayList<>();
            for (MixinInfo info : entry.getValue()) {
                mixinNames.add(info.mixinClass + " (" + info.modId + ")");
            }
            result.put(entry.getKey(), mixinNames);
        }

        return result;
    }

    /**
     * 적용된 Mixin 목록 문자열로 반환.
     */
    public static List<String> getAppliedMixins() {
        List<String> result = new ArrayList<>();
        for (Map.Entry<String, List<MixinInfo>> entry : INSTANCE.appliedMixins.entrySet()) {
            for (MixinInfo info : entry.getValue()) {
                result.add(info.mixinClass + " → " + entry.getKey() + " (" + info.modId + ")");
            }
        }
        return result;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    public static class MixinInfo {
        public final String mixinClass;
        public final String modId;
        public final int priority;

        public MixinInfo(String mixinClass, String modId, int priority) {
            this.mixinClass = mixinClass;
            this.modId = modId;
            this.priority = priority;
        }
    }

    public static class FailedMixin {
        public final String mixinClass;
        public final String modId;
        public final String targetClass;
        public final String reason;

        public FailedMixin(String mixinClass, String modId,
                String targetClass, String reason) {
            this.mixinClass = mixinClass;
            this.modId = modId;
            this.targetClass = targetClass;
            this.reason = reason;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 통계 메서드 (평가 개선사항)
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드별 적용된 Mixin 수 반환.
     * 
     * @return 모드 ID → Mixin 수 맵
     */
    public Map<String, Integer> getMixinCountByMod() {
        Map<String, Integer> counts = new HashMap<>();
        for (List<MixinInfo> infos : appliedMixins.values()) {
            for (MixinInfo info : infos) {
                counts.merge(info.modId, 1, (a, b) -> a + b);
            }
        }
        return counts;
    }

    /**
     * 가장 많이 Mixin이 적용된 클래스 TOP N 반환.
     * 
     * @param n 반환할 개수
     * @return (클래스명, Mixin 수) 리스트
     */
    public List<Map.Entry<String, Integer>> getTopMixedClasses(int n) {
        List<Map.Entry<String, Integer>> entries = new ArrayList<>();
        for (Map.Entry<String, List<MixinInfo>> entry : appliedMixins.entrySet()) {
            entries.add(new AbstractMap.SimpleEntry<>(entry.getKey(), entry.getValue().size()));
        }
        entries.sort((a, b) -> Integer.compare(b.getValue(), a.getValue()));
        return entries.subList(0, Math.min(n, entries.size()));
    }

    /**
     * 동일 타겟, 동일 모드 내에서 우선순위 충돌 검사.
     * 같은 모드에서 같은 타겟에 다른 우선순위의 Mixin이 있으면 경고.
     */
    public void checkPriorityConflicts() {
        if (!DevMode.isEnabled())
            return;

        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");
        System.out.println("[Pulse/Mixin] Checking priority conflicts...");

        int conflictCount = 0;

        for (Map.Entry<String, List<MixinInfo>> entry : appliedMixins.entrySet()) {
            String targetClass = entry.getKey();
            List<MixinInfo> mixins = entry.getValue();

            // 같은 모드 내 우선순위별 그룹화
            Map<String, List<Integer>> modPriorities = new HashMap<>();
            for (MixinInfo info : mixins) {
                modPriorities.computeIfAbsent(info.modId, k -> new ArrayList<>()).add(info.priority);
            }

            // 같은 모드에서 여러 우선순위 있으면 경고
            for (Map.Entry<String, List<Integer>> modEntry : modPriorities.entrySet()) {
                List<Integer> priorities = modEntry.getValue();
                if (priorities.size() > 1) {
                    Set<Integer> uniquePriorities = new HashSet<>(priorities);
                    if (uniquePriorities.size() > 1) {
                        System.out.println("[Pulse/Mixin] Priority variation in " + modEntry.getKey() +
                                " for " + targetClass + ": " + uniquePriorities);
                        conflictCount++;
                    }
                }
            }
        }

        if (conflictCount == 0) {
            System.out.println("[Pulse/Mixin] No priority conflicts detected.");
        } else {
            System.out.println("[Pulse/Mixin] " + conflictCount + " priority variation(s) found.");
        }

        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");
    }

    /**
     * 전체 진단 실행 (충돌 + 우선순위 검사).
     */
    public void runFullDiagnostics() {
        printReport();
        checkConflicts();
        checkPriorityConflicts();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\MixinDiagnostics.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\MixinHelper.java =====

package com.pulse.mixin;

import com.pulse.api.DevMode;
import com.pulse.event.Event;
import com.pulse.event.EventBus;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

import java.util.function.Function;

/**
 * Mixin 개발 유틸리티.
 * Mixin 클래스에서 자주 사용되는 패턴을 헬퍼 메서드로 제공.
 * 
 * 사용 예:
 * 
 * <pre>
 * {@literal @}Mixin(IsoZombie.class)
 * public class ZombieMixin {
 *     {@literal @}Inject(method = "update", at = @At("HEAD"), cancellable = true)
 *     private void onUpdate(CallbackInfo ci) {
 *         IsoZombie zombie = MixinHelper.self(this);
 *         ZombieUpdateEvent event = new ZombieUpdateEvent(zombie);
 *         MixinHelper.fireEvent(event, ci);  // 자동으로 취소 처리
 *     }
 * }
 * </pre>
 */
public final class MixinHelper {

    private MixinHelper() {
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 발행 헬퍼
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 발행 및 취소 처리.
     * 이벤트가 취소되면 CallbackInfo.cancel()을 자동 호출.
     * 
     * @param event 발행할 이벤트
     * @param ci    Mixin CallbackInfo
     * @return true if event was cancelled
     */
    public static boolean fireEvent(Event event, CallbackInfo ci) {
        EventBus.post(event);
        if (event.isCancellable() && event.isCancelled()) {
            ci.cancel();
            return true;
        }
        return false;
    }

    /**
     * 이벤트 발행만 수행 (취소 처리 없음).
     * 
     * @param event 발행할 이벤트
     * @return 발행된 이벤트 (체이닝용)
     */
    public static <T extends Event> T fire(T event) {
        EventBus.post(event);
        return event;
    }

    /**
     * 반환값이 있는 이벤트 발행.
     * 이벤트가 취소되면 지정된 반환값으로 설정.
     * 
     * @param event       발행할 이벤트
     * @param cir         Mixin CallbackInfoReturnable
     * @param returnValue 취소 시 반환할 값
     * @return true if event was cancelled
     */
    public static <T> boolean fireEventWithReturn(
            Event event,
            CallbackInfoReturnable<T> cir,
            T returnValue) {
        EventBus.post(event);
        if (event.isCancellable() && event.isCancelled()) {
            cir.setReturnValue(returnValue);
            return true;
        }
        return false;
    }

    /**
     * 조건부 이벤트 발행.
     * 조건이 참일 때만 이벤트 발행.
     * 
     * @param condition 발행 조건
     * @param event     발행할 이벤트
     * @param ci        Mixin CallbackInfo
     * @return true if event was cancelled
     */
    public static boolean fireEventIf(boolean condition, Event event, CallbackInfo ci) {
        if (!condition)
            return false;
        return fireEvent(event, ci);
    }

    // ─────────────────────────────────────────────────────────────
    // 캐스팅 헬퍼
    // ─────────────────────────────────────────────────────────────

    /**
     * Mixin에서 this를 원본 타입으로 캐스팅.
     * 
     * <pre>
     * // Mixin 클래스 내에서:
     * IsoZombie zombie = MixinHelper.self(this);
     * </pre>
     * 
     * @param mixinThis Mixin 클래스의 this
     * @return 원본 타입으로 캐스팅된 객체
     */
    @SuppressWarnings("unchecked")
    public static <T> T self(Object mixinThis) {
        return (T) mixinThis;
    }

    /**
     * 안전한 캐스팅 (실패 시 null 반환).
     * 
     * @param obj   캐스팅할 객체
     * @param clazz 타겟 클래스
     * @return 캐스팅된 객체 또는 null
     */
    public static <T> T safeCast(Object obj, Class<T> clazz) {
        if (obj == null)
            return null;
        if (clazz.isInstance(obj)) {
            return clazz.cast(obj);
        }
        return null;
    }

    // ─────────────────────────────────────────────────────────────
    // 반환값 조작 헬퍼
    // ─────────────────────────────────────────────────────────────

    /**
     * 반환값 설정 및 메서드 종료.
     * 
     * @param cir   Mixin CallbackInfoReturnable
     * @param value 반환할 값
     */
    public static <T> void setReturn(CallbackInfoReturnable<T> cir, T value) {
        cir.setReturnValue(value);
    }

    /**
     * 조건부 반환값 설정.
     * 
     * @param condition 조건
     * @param cir       Mixin CallbackInfoReturnable
     * @param value     반환할 값
     * @return true if return value was set
     */
    public static <T> boolean setReturnIf(boolean condition, CallbackInfoReturnable<T> cir, T value) {
        if (condition) {
            cir.setReturnValue(value);
            return true;
        }
        return false;
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * null-safe 비교.
     */
    public static boolean equals(Object a, Object b) {
        if (a == b)
            return true;
        if (a == null || b == null)
            return false;
        return a.equals(b);
    }

    /**
     * 디버그 로그 출력.
     * 
     * @param mixinName Mixin 클래스 이름
     * @param message   로그 메시지
     */
    public static void debug(String mixinName, String message) {
        System.out.println("[Pulse/Mixin/" + mixinName + "] " + message);
    }

    /**
     * 메서드 주입 성공 로그.
     * 
     * @param targetClass  타겟 클래스
     * @param targetMethod 타겟 메서드
     */
    public static void logInjection(String targetClass, String targetMethod) {
        System.out.println("[Pulse/Mixin] Injected: " + targetClass + "." + targetMethod);
    }

    // ─────────────────────────────────────────────────────────────
    // @ModifyVariable / @Redirect 헬퍼
    // ─────────────────────────────────────────────────────────────

    /**
     * 로컬 변수 수정 헬퍼 (@ModifyVariable 용).
     * 
     * <pre>
     * {@literal @}ModifyVariable(method = "update", at = @At("HEAD"))
     * private float modifySpeed(float original) {
     *     return MixinHelper.modifyLocal(original, speed -> speed * 1.5f);
     * }
     * </pre>
     * 
     * @param original 원본 값
     * @param modifier 수정 함수
     * @return 수정된 값
     */
    public static <T> T modifyLocal(T original, Function<T, T> modifier) {
        return modifier.apply(original);
    }

    /**
     * 메서드 반환값 수정 헬퍼 (@Redirect 용).
     * 
     * <pre>
     * {@literal @}Redirect(method = "update", at = @At(value = "INVOKE", target = "..."))
     * private float redirectDamage(float original) {
     *     return MixinHelper.redirect(original, dmg -> dmg * 0.5f);
     * }
     * </pre>
     * 
     * @param original   원본 값
     * @param redirector 리다이렉트 함수
     * @return 수정된 값
     */
    public static <T> T redirect(T original, Function<T, T> redirector) {
        return redirector.apply(original);
    }

    /**
     * DevMode일 때만 디버그 로그 출력.
     * 
     * @param mixinName Mixin 이름
     * @param message   로그 메시지
     */
    public static void debugIf(String mixinName, String message) {
        if (DevMode.isEnabled()) {
            debug(mixinName, message);
        }
    }

    /**
     * DevMode일 때만 주입 로그 출력.
     * 
     * @param targetClass  타겟 클래스
     * @param targetMethod 타겟 메서드
     */
    public static void logInjectionIf(String targetClass, String targetMethod) {
        if (DevMode.isEnabled()) {
            logInjection(targetClass, targetMethod);
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mixin\MixinHelper.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\EntryPoints.java =====

package com.pulse.mod;

/**
 * 환경별 엔트리포인트 정의.
 * 클라이언트/서버/공통 각각 다른 초기화 클래스 지정 가능.
 * 
 * pulse.mod.json 예:
 * 
 * <pre>
 * "entryPoints": {
 *     "common": "com.example.ModCommon",
 *     "client": "com.example.ModClient", 
 *     "server": "com.example.ModServer"
 * }
 * </pre>
 */
public class EntryPoints {

    private String common; // 공통 (항상 실행)
    private String client; // 클라이언트 전용
    private String server; // 서버 전용

    public String getCommon() {
        return common;
    }

    public void setCommon(String common) {
        this.common = common;
    }

    public String getClient() {
        return client;
    }

    public void setClient(String client) {
        this.client = client;
    }

    public String getServer() {
        return server;
    }

    public void setServer(String server) {
        this.server = server;
    }

    /**
     * 현재 환경에 맞는 엔트리포인트 반환.
     */
    public String getForEnvironment(Environment env) {
        switch (env) {
            case CLIENT:
                return client != null ? client : common;
            case SERVER:
                return server != null ? server : common;
            default:
                return common;
        }
    }

    public enum Environment {
        CLIENT,
        SERVER,
        INTEGRATED // 싱글플레이 (클라이언트 + 서버)
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\EntryPoints.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\ModContainer.java =====

package com.pulse.mod;

import java.net.URLClassLoader;

/**
 * 로드된 모드를 나타내는 컨테이너.
 * 메타데이터, 클래스로더, 모드 인스턴스를 관리.
 */
public class ModContainer {

    private final ModMetadata metadata;
    private final URLClassLoader classLoader;
    private Object modInstance; // entrypoint 클래스의 인스턴스
    private ModState state = ModState.DISCOVERED;

    public ModContainer(ModMetadata metadata, URLClassLoader classLoader) {
        this.metadata = metadata;
        this.classLoader = classLoader;
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 상태
    // ─────────────────────────────────────────────────────────────

    public enum ModState {
        DISCOVERED, // JAR 발견됨
        METADATA_LOADED, // 메타데이터 파싱 완료
        DEPENDENCIES_RESOLVED, // 의존성 확인 완료
        MIXINS_APPLIED, // Mixin 적용됨
        INITIALIZED, // 초기화 완료
        LOADED, // 정상 로드됨 (활성 상태)
        DISABLED, // 비활성화됨 (핫 리로드)
        ERRORED // 에러 발생
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 엔트리포인트 클래스를 로드하고 인스턴스화
     */
    public void initialize() throws Exception {
        String entrypoint = metadata.getEntrypoint();
        if (entrypoint == null || entrypoint.isEmpty()) {
            System.out.println("[Pulse/Mod] " + metadata.getId() + " has no entrypoint, skipping initialization");
            state = ModState.INITIALIZED;
            return;
        }

        try {
            System.out.println("[Pulse/Mod] Initializing mod: " + metadata.getId());

            // 엔트리포인트 클래스 로드
            Class<?> entryClass = classLoader.loadClass(entrypoint);

            // PulseMod 인터페이스 구현 여부 확인
            if (PulseMod.class.isAssignableFrom(entryClass)) {
                modInstance = entryClass.getDeclaredConstructor().newInstance();
                ((PulseMod) modInstance).onInitialize();
                System.out.println("[Pulse/Mod] ✓ " + metadata.getId() + " initialized successfully");
            } else {
                System.err.println("[Pulse/Mod] WARNING: " + entrypoint +
                        " does not implement PulseMod interface");
                modInstance = entryClass.getDeclaredConstructor().newInstance();
            }

            state = ModState.INITIALIZED;
            metadata.setLoaded(true);

        } catch (Exception e) {
            state = ModState.ERRORED;
            System.err.println("[Pulse/Mod] Failed to initialize mod: " + metadata.getId());
            throw e;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public ModMetadata getMetadata() {
        return metadata;
    }

    public String getId() {
        return metadata.getId();
    }

    public String getVersion() {
        return metadata.getVersion();
    }

    public URLClassLoader getClassLoader() {
        return classLoader;
    }

    public Object getModInstance() {
        return modInstance;
    }

    @SuppressWarnings("unchecked")
    public <T> T getModInstance(Class<T> type) {
        if (type.isInstance(modInstance)) {
            return (T) modInstance;
        }
        return null;
    }

    public ModState getState() {
        return state;
    }

    public void setState(ModState state) {
        this.state = state;
    }

    public boolean isLoaded() {
        return state == ModState.INITIALIZED;
    }

    public boolean hasError() {
        return state == ModState.ERRORED;
    }

    @Override
    public String toString() {
        return String.format("ModContainer[%s v%s, state=%s]",
                metadata.getId(), metadata.getVersion(), state);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\ModContainer.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\ModLoader.java =====

package com.pulse.mod;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import org.spongepowered.asm.mixin.Mixins;

import java.io.*;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.*;
import java.util.*;
import java.util.jar.*;
import java.util.stream.Collectors;

/**
 * Pulse 모드 로더.
 * mods/ 폴더에서 모드 JAR를 발견하고 로드.
 */
public class ModLoader {

    private static ModLoader instance;

    private final Path modsDirectory;
    private final Map<String, ModContainer> mods = new LinkedHashMap<>();
    private final List<ModContainer> loadOrder = new ArrayList<>();
    private final Gson gson = new GsonBuilder().setPrettyPrinting().create();

    private boolean discoveryComplete = false;
    private boolean initialized = false;

    // ─────────────────────────────────────────────────────────────
    // 싱글톤
    // ─────────────────────────────────────────────────────────────

    public static ModLoader getInstance() {
        if (instance == null) {
            instance = new ModLoader();
        }
        return instance;
    }

    private ModLoader() {
        // 게임 디렉토리에서 mods 폴더 찾기
        String gameDir = System.getProperty("user.dir");
        this.modsDirectory = Paths.get(gameDir, "mods");

        System.out.println("[Pulse/ModLoader] Mods directory: " + modsDirectory.toAbsolutePath());
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 발견
    // ─────────────────────────────────────────────────────────────

    /**
     * mods/ 폴더에서 모든 모드 JAR 스캔
     */
    public void discoverMods() {
        if (discoveryComplete) {
            System.out.println("[Pulse/ModLoader] Discovery already complete");
            return;
        }

        System.out.println("[Pulse/ModLoader] ═══════════════════════════════════════");
        System.out.println("[Pulse/ModLoader] Discovering mods...");

        // mods 폴더 생성 (없으면)
        try {
            if (!Files.exists(modsDirectory)) {
                Files.createDirectories(modsDirectory);
                System.out.println("[Pulse/ModLoader] Created mods directory");
            }
        } catch (IOException e) {
            System.err.println("[Pulse/ModLoader] Failed to create mods directory: " + e.getMessage());
            return;
        }

        // JAR 파일 스캔
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(modsDirectory, "*.jar")) {
            for (Path jarPath : stream) {
                try {
                    discoverMod(jarPath);
                } catch (Exception e) {
                    System.err.println("[Pulse/ModLoader] Failed to load mod: " + jarPath.getFileName());
                    e.printStackTrace();
                }
            }
        } catch (IOException e) {
            System.err.println("[Pulse/ModLoader] Failed to scan mods directory: " + e.getMessage());
        }

        discoveryComplete = true;
        System.out.println("[Pulse/ModLoader] Discovered " + mods.size() + " mod(s)");
        System.out.println("[Pulse/ModLoader] ═══════════════════════════════════════");
    }

    /**
     * 단일 JAR 파일에서 모드 메타데이터 로드
     */
    private void discoverMod(Path jarPath) throws Exception {
        System.out.println("[Pulse/ModLoader] Scanning: " + jarPath.getFileName());

        try (JarFile jar = new JarFile(jarPath.toFile())) {
            // pulse.mod.json 찾기
            JarEntry metadataEntry = jar.getJarEntry("pulse.mod.json");

            if (metadataEntry == null) {
                System.out.println("[Pulse/ModLoader]   - No pulse.mod.json found, skipping");
                return;
            }

            // 메타데이터 파싱
            ModMetadata metadata;
            try (InputStream is = jar.getInputStream(metadataEntry);
                    InputStreamReader reader = new InputStreamReader(is)) {
                metadata = gson.fromJson(reader, ModMetadata.class);
            }

            // 유효성 검사
            if (metadata.getId() == null || metadata.getId().isEmpty()) {
                System.err.println("[Pulse/ModLoader]   - Invalid mod: missing 'id' field");
                return;
            }

            // 중복 체크
            if (mods.containsKey(metadata.getId())) {
                System.err.println("[Pulse/ModLoader]   - Duplicate mod ID: " + metadata.getId());
                return;
            }

            metadata.setSourceFile(jarPath.toAbsolutePath().toString());

            // 클래스로더 생성
            URL jarUrl = jarPath.toUri().toURL();
            URLClassLoader classLoader = new URLClassLoader(
                    new URL[] { jarUrl },
                    getClass().getClassLoader() // 부모 클래스로더
            );

            // 모드 컨테이너 생성
            ModContainer container = new ModContainer(metadata, classLoader);
            container.setState(ModContainer.ModState.METADATA_LOADED);

            mods.put(metadata.getId(), container);

            System.out.println("[Pulse/ModLoader]   ✓ " + metadata);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 의존성 해결 및 로드 순서 결정
    // ─────────────────────────────────────────────────────────────

    /**
     * 의존성 검사 및 로드 순서 결정 (토폴로지 정렬)
     */
    public void resolveDependencies() {
        System.out.println("[Pulse/ModLoader] Resolving dependencies...");

        List<String> errors = new ArrayList<>();

        // 각 모드의 의존성 검사
        for (ModContainer container : mods.values()) {
            ModMetadata metadata = container.getMetadata();

            for (ModMetadata.Dependency dep : metadata.getDependencies()) {
                // Pulse 자체는 항상 존재
                if ("Pulse".equals(dep.getId())) {
                    continue;
                }

                ModContainer depMod = mods.get(dep.getId());

                if (depMod == null) {
                    if (dep.isOptional()) {
                        System.out.println("[Pulse/ModLoader]   - " + metadata.getId() +
                                ": optional dependency '" + dep.getId() + "' not found");
                    } else {
                        errors.add(metadata.getId() + " requires " + dep.getId() + " " + dep.getVersion());
                    }
                } else {
                    // 버전 비교 로직
                    String actualVersion = depMod.getMetadata().getVersion();
                    String requiredVersion = dep.getVersion();

                    if (requiredVersion != null && !requiredVersion.isEmpty() && !"*".equals(requiredVersion)) {
                        if (VersionComparator.matches(actualVersion, requiredVersion)) {
                            System.out.println("[Pulse/ModLoader]   - " + metadata.getId() +
                                    " → " + dep.getId() + " v" + actualVersion + " ✓");
                        } else {
                            errors.add(metadata.getId() + " requires " + dep.getId() + " " +
                                    requiredVersion + " but found " + actualVersion);
                        }
                    } else {
                        System.out.println("[Pulse/ModLoader]   - " + metadata.getId() +
                                " → " + dep.getId() + " v" + actualVersion + " ✓");
                    }
                }
            }
        }

        // 충돌 검사
        for (ModContainer container : mods.values()) {
            ModMetadata metadata = container.getMetadata();
            for (String conflictId : metadata.getConflicts()) {
                if (mods.containsKey(conflictId)) {
                    errors.add(metadata.getId() + " conflicts with " + conflictId);
                    System.err.println("[Pulse/ModLoader] ✗ Conflict detected: " +
                            metadata.getId() + " and " + conflictId + " cannot be loaded together");
                }
            }
        }

        if (!errors.isEmpty()) {
            System.err.println("[Pulse/ModLoader] Dependency/Conflict errors:");
            for (String error : errors) {
                System.err.println("[Pulse/ModLoader]   ✗ " + error);
            }
        }

        // 토폴로지 정렬로 로드 순서 결정
        loadOrder.clear();
        Set<String> visited = new HashSet<>();
        Set<String> visiting = new HashSet<>();

        for (String modId : mods.keySet()) {
            if (!visited.contains(modId)) {
                topologicalSort(modId, visited, visiting, loadOrder);
            }
        }

        // 의존성 해결 완료 표시
        for (ModContainer container : loadOrder) {
            container.setState(ModContainer.ModState.DEPENDENCIES_RESOLVED);
        }

        System.out.println("[Pulse/ModLoader] Load order: " +
                loadOrder.stream().map(ModContainer::getId).collect(Collectors.joining(" → ")));
    }

    private void topologicalSort(String modId, Set<String> visited, Set<String> visiting,
            List<ModContainer> result) {
        if (visited.contains(modId))
            return;
        if (visiting.contains(modId)) {
            System.err.println("[Pulse/ModLoader] Circular dependency detected: " + modId);
            return;
        }

        visiting.add(modId);

        ModContainer container = mods.get(modId);
        if (container != null) {
            // 의존성 먼저 처리
            for (ModMetadata.Dependency dep : container.getMetadata().getDependencies()) {
                if (mods.containsKey(dep.getId())) {
                    topologicalSort(dep.getId(), visited, visiting, result);
                }
            }

            result.add(container);
        }

        visiting.remove(modId);
        visited.add(modId);
    }

    // ─────────────────────────────────────────────────────────────
    // Mixin 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 모드의 Mixin config 등록
     */
    public void registerMixins() {
        System.out.println("[Pulse/ModLoader] Registering mod mixins...");

        for (ModContainer container : loadOrder) {
            ModMetadata metadata = container.getMetadata();
            List<String> mixinConfigs = metadata.getMixins();

            if (mixinConfigs == null || mixinConfigs.isEmpty()) {
                continue;
            }

            for (String mixinConfig : mixinConfigs) {
                try {
                    System.out.println("[Pulse/Mixin] Registered mixin config " +
                            mixinConfig + " from " + metadata.getId());
                    Mixins.addConfiguration(mixinConfig);
                } catch (Exception e) {
                    System.err.println("[Pulse/Mixin] ✗ Failed to register " +
                            mixinConfig + " from " + metadata.getId() + ": " + e.getMessage());
                }
            }

            container.setState(ModContainer.ModState.MIXINS_APPLIED);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 모드 초기화 (엔트리포인트 호출)
     */
    public void initializeMods() {
        if (initialized) {
            System.out.println("[Pulse/ModLoader] Mods already initialized");
            return;
        }

        System.out.println("[Pulse/ModLoader] ═══════════════════════════════════════");
        System.out.println("[Pulse/ModLoader] Initializing mods...");

        int success = 0;
        int failed = 0;

        for (ModContainer container : loadOrder) {
            try {
                container.initialize();
                success++;
            } catch (Exception e) {
                failed++;
                System.err.println("[Pulse/ModLoader] ✗ " + container.getId() + " failed:");
                e.printStackTrace();
            }
        }

        initialized = true;

        System.out.println("[Pulse/ModLoader] ═══════════════════════════════════════");
        System.out.println("[Pulse/ModLoader] Initialization complete: " +
                success + " loaded, " + failed + " failed");
        System.out.println("[Pulse/ModLoader] ═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    public ModContainer getMod(String id) {
        return mods.get(id);
    }

    public Collection<ModContainer> getAllMods() {
        return Collections.unmodifiableCollection(mods.values());
    }

    public List<ModContainer> getLoadOrder() {
        return Collections.unmodifiableList(loadOrder);
    }

    public int getModCount() {
        return mods.size();
    }

    public Set<String> getLoadedModIds() {
        return Collections.unmodifiableSet(mods.keySet());
    }

    public boolean isModLoaded(String id) {
        ModContainer container = mods.get(id);
        return container != null && container.isLoaded();
    }

    public Path getModsDirectory() {
        return modsDirectory;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\ModLoader.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\ModMetadata.java =====

package com.pulse.mod;

import java.util.ArrayList;
import java.util.List;

/**
 * 모드 메타데이터.
 * 각 모드의 pulse.mod.json 파일에서 파싱됨.
 * 
 * 예시 pulse.mod.json:
 * {
 * "id": "mymod",
 * "name": "My Awesome Mod",
 * "version": "1.0.0",
 * "author": "ModAuthor",
 * "description": "A cool mod for Project Zomboid",
 * "entrypoint": "com.example.mymod.MyMod",
 * "mixins": ["mixins.mymod.json"],
 * "dependencies": [
 * { "id": "Pulse", "version": ">=1.0.0" },
 * { "id": "othermod", "version": ">=2.0.0", "optional": true }
 * ]
 * }
 */
public class ModMetadata {

    private String id;
    private String name;
    private String version;
    private String author;
    private String description;
    private String entrypoint;
    private List<String> mixins = new ArrayList<>();
    private List<Dependency> dependencies = new ArrayList<>();
    private List<String> conflicts = new ArrayList<>();

    // Phase 2 추가 필드
    private String license;
    private String loaderVersion; // 필요한 Pulse 버전 (예: ">=1.0.0")
    private String gameVersion; // 필요한 PZ 버전 (예: "41.78+")
    private List<String> authors = new ArrayList<>();
    private EntryPoints entryPoints; // 환경별 엔트리포인트
    private List<String> accessWideners = new ArrayList<>();
    private List<String> permissions = new ArrayList<>();
    private String loadOrder; // 로드 순서 힌트 (예: "after:othermod")
    private String homepage;
    private String issues; // 이슈 트래커 URL
    private String source; // 소스 코드 URL

    // 런타임에 설정되는 필드
    private transient String sourceFile; // JAR 파일 경로
    private transient boolean loaded = false;

    // ─────────────────────────────────────────────────────────────
    // Getters & Setters
    // ─────────────────────────────────────────────────────────────

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getEntrypoint() {
        return entrypoint;
    }

    public void setEntrypoint(String entrypoint) {
        this.entrypoint = entrypoint;
    }

    public List<String> getMixins() {
        return mixins;
    }

    public void setMixins(List<String> mixins) {
        this.mixins = mixins != null ? mixins : new ArrayList<>();
    }

    public List<Dependency> getDependencies() {
        return dependencies;
    }

    public void setDependencies(List<Dependency> dependencies) {
        this.dependencies = dependencies != null ? dependencies : new ArrayList<>();
    }

    public List<String> getConflicts() {
        return conflicts;
    }

    public void setConflicts(List<String> conflicts) {
        this.conflicts = conflicts != null ? conflicts : new ArrayList<>();
    }

    public List<String> getPermissions() {
        return permissions;
    }

    public void setPermissions(List<String> permissions) {
        this.permissions = permissions != null ? permissions : new ArrayList<>();
    }

    public String getLicense() {
        return license;
    }

    public void setLicense(String license) {
        this.license = license;
    }

    public String getLoaderVersion() {
        return loaderVersion;
    }

    public void setLoaderVersion(String loaderVersion) {
        this.loaderVersion = loaderVersion;
    }

    public String getGameVersion() {
        return gameVersion;
    }

    public void setGameVersion(String gameVersion) {
        this.gameVersion = gameVersion;
    }

    public List<String> getAuthors() {
        return authors;
    }

    public void setAuthors(List<String> authors) {
        this.authors = authors != null ? authors : new ArrayList<>();
    }

    public EntryPoints getEntryPoints() {
        return entryPoints;
    }

    public void setEntryPoints(EntryPoints entryPoints) {
        this.entryPoints = entryPoints;
    }

    public List<String> getAccessWideners() {
        return accessWideners;
    }

    public void setAccessWideners(List<String> accessWideners) {
        this.accessWideners = accessWideners != null ? accessWideners : new ArrayList<>();
    }

    public String getLoadOrder() {
        return loadOrder;
    }

    public void setLoadOrder(String loadOrder) {
        this.loadOrder = loadOrder;
    }

    public String getHomepage() {
        return homepage;
    }

    public void setHomepage(String homepage) {
        this.homepage = homepage;
    }

    public String getIssues() {
        return issues;
    }

    public void setIssues(String issues) {
        this.issues = issues;
    }

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public String getSourceFile() {
        return sourceFile;
    }

    public void setSourceFile(String sourceFile) {
        this.sourceFile = sourceFile;
    }

    public boolean isLoaded() {
        return loaded;
    }

    public void setLoaded(boolean loaded) {
        this.loaded = loaded;
    }

    // ─────────────────────────────────────────────────────────────
    // 의존성 클래스
    // ─────────────────────────────────────────────────────────────

    public static class Dependency {
        private String id;
        private String version;
        private boolean optional = false;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getVersion() {
            return version;
        }

        public void setVersion(String version) {
            this.version = version;
        }

        public boolean isOptional() {
            return optional;
        }

        public void setOptional(boolean optional) {
            this.optional = optional;
        }

        @Override
        public String toString() {
            return id + " " + version + (optional ? " (optional)" : "");
        }
    }

    @Override
    public String toString() {
        return String.format("%s (%s) v%s by %s", name, id, version, author);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\ModMetadata.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\ModReloadManager.java =====

package com.pulse.mod;

import com.pulse.config.ConfigManager;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.ModReloadEvent;

import java.io.File;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 모드 핫 리로드 매니저.
 * 런타임에 모드를 비활성화/재활성화할 수 있는 기능 제공.
 * 
 * 제한사항:
 * - Mixin이 적용된 모드는 완전한 언로드가 불가능
 * - 리로드는 설정 및 이벤트 리스너만 갱신
 * - 바이트코드 변경은 게임 재시작 필요
 * 
 * 사용 예:
 * 
 * <pre>
 * // 모드 비활성화
 * ModReloadManager.disable("mymod");
 * 
 * // 모드 재활성화
 * ModReloadManager.enable("mymod");
 * 
 * // 설정만 리로드
 * ModReloadManager.reloadConfig("mymod");
 * 
 * // 전체 소프트 리로드 (Mixin 제외)
 * ModReloadManager.softReload("mymod");
 * </pre>
 */
public class ModReloadManager {

    private static final ModReloadManager INSTANCE = new ModReloadManager();

    // 비활성화된 모드 목록
    private final Set<String> disabledMods = ConcurrentHashMap.newKeySet();

    private ModReloadManager() {
    }

    public static ModReloadManager getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 활성화/비활성화
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 비활성화.
     * 이벤트 리스너 해제, 스케줄러 태스크 취소.
     * 
     * @param modId 비활성화할 모드 ID
     * @return 성공 여부
     */
    public static boolean disable(String modId) {
        return INSTANCE.disableMod(modId);
    }

    /**
     * 모드 활성화.
     * 비활성화된 모드를 다시 활성화.
     * 
     * @param modId 활성화할 모드 ID
     * @return 성공 여부
     */
    public static boolean enable(String modId) {
        return INSTANCE.enableMod(modId);
    }

    /**
     * 모드가 활성 상태인지 확인.
     */
    public static boolean isEnabled(String modId) {
        return !INSTANCE.disabledMods.contains(modId);
    }

    /**
     * 비활성화된 모드 목록.
     */
    public static Set<String> getDisabledMods() {
        return Collections.unmodifiableSet(INSTANCE.disabledMods);
    }

    private boolean disableMod(String modId) {
        ModLoader loader = ModLoader.getInstance();
        ModContainer container = loader.getMod(modId);

        if (container == null) {
            System.err.println("[Pulse/Reload] Mod not found: " + modId);
            return false;
        }

        if (disabledMods.contains(modId)) {
            System.out.println("[Pulse/Reload] Mod already disabled: " + modId);
            return true;
        }

        try {
            System.out.println("[Pulse/Reload] Disabling mod: " + modId);

            // 1. 모드의 onUnload 호출
            PulseMod instance = container.getModInstance(PulseMod.class);
            if (instance != null) {
                try {
                    instance.onUnload();
                } catch (Exception e) {
                    System.err.println("[Pulse/Reload] Error in onUnload: " + e.getMessage());
                }
            }

            // 2. 설정 저장
            ConfigManager.saveAll();

            // 3. 비활성화 상태로 표시
            disabledMods.add(modId);
            container.setState(ModContainer.ModState.DISABLED);

            // 4. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.DISABLED));

            System.out.println("[Pulse/Reload] Mod disabled: " + modId);
            return true;

        } catch (Exception e) {
            System.err.println("[Pulse/Reload] Failed to disable mod: " + modId);
            e.printStackTrace();
            return false;
        }
    }

    private boolean enableMod(String modId) {
        ModLoader loader = ModLoader.getInstance();
        ModContainer container = loader.getMod(modId);

        if (container == null) {
            System.err.println("[Pulse/Reload] Mod not found: " + modId);
            return false;
        }

        if (!disabledMods.contains(modId)) {
            System.out.println("[Pulse/Reload] Mod already enabled: " + modId);
            return true;
        }

        try {
            System.out.println("[Pulse/Reload] Enabling mod: " + modId);

            // 1. 활성화 상태로 표시
            disabledMods.remove(modId);
            container.setState(ModContainer.ModState.LOADED);

            // 2. 설정 리로드
            reloadConfigInternal(modId);

            // 3. 모드의 onInitialize 다시 호출
            PulseMod instance = container.getModInstance(PulseMod.class);
            if (instance != null) {
                try {
                    instance.onInitialize();
                } catch (Exception e) {
                    System.err.println("[Pulse/Reload] Error in onInitialize: " + e.getMessage());
                }
            }

            // 4. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.ENABLED));

            System.out.println("[Pulse/Reload] Mod enabled: " + modId);
            return true;

        } catch (Exception e) {
            System.err.println("[Pulse/Reload] Failed to enable mod: " + modId);
            e.printStackTrace();
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 리로드
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 설정만 리로드.
     * 파일에서 설정을 다시 읽어옴.
     */
    public static boolean reloadConfig(String modId) {
        return INSTANCE.reloadConfigInternal(modId);
    }

    /**
     * 모드 소프트 리로드.
     * 설정 리로드 + 이벤트 리스너 재등록.
     * Mixin 변경은 반영되지 않음.
     */
    public static boolean softReload(String modId) {
        return INSTANCE.softReloadMod(modId);
    }

    /**
     * 모든 모드 설정 리로드.
     */
    public static void reloadAllConfigs() {
        ConfigManager.reloadAll();
        System.out.println("[Pulse/Reload] All configs reloaded");
    }

    private boolean reloadConfigInternal(String modId) {
        try {
            // modId에 해당하는 설정 클래스를 알 수 없으므로 전체 리로드
            ConfigManager.reloadAll();
            System.out.println("[Pulse/Reload] Config reloaded for: " + modId);
            return true;
        } catch (Exception e) {
            System.err.println("[Pulse/Reload] Failed to reload config: " + modId);
            e.printStackTrace();
            return false;
        }
    }

    private boolean softReloadMod(String modId) {
        ModLoader loader = ModLoader.getInstance();
        ModContainer container = loader.getMod(modId);

        if (container == null) {
            System.err.println("[Pulse/Reload] Mod not found: " + modId);
            return false;
        }

        try {
            System.out.println("[Pulse/Reload] Soft reloading mod: " + modId);

            PulseMod instance = container.getModInstance(PulseMod.class);

            // 1. onUnload 호출 (정리)
            if (instance != null) {
                try {
                    instance.onUnload();
                } catch (Exception e) {
                    System.err.println("[Pulse/Reload] Error in onUnload: " + e.getMessage());
                }
            }

            // 2. 설정 리로드
            reloadConfigInternal(modId);

            // 3. onInitialize 호출 (재초기화)
            if (instance != null) {
                try {
                    instance.onInitialize();
                } catch (Exception e) {
                    System.err.println("[Pulse/Reload] Error in onInitialize: " + e.getMessage());
                }
            }

            // 4. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.RELOADED));

            System.out.println("[Pulse/Reload] Mod soft reloaded: " + modId);
            return true;

        } catch (Exception e) {
            System.err.println("[Pulse/Reload] Failed to soft reload mod: " + modId);
            e.printStackTrace();
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 핫 스왑 (실험적)
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 JAR 파일 핫 스왑 (실험적).
     * 새 JAR 파일을 로드하여 모드 클래스를 교체 시도.
     * 
     * ⚠️ 제한 사항:
     * - JVM은 이미 로드된 클래스를 교체할 수 없음
     * - 새 클래스만 새 로더에서 로드됨
     * - 완전한 핫 스왑은 게임 재시작 필요
     */
    public static boolean hotSwap(String modId, File newJarFile) {
        return INSTANCE.hotSwapMod(modId, newJarFile);
    }

    private boolean hotSwapMod(String modId, File newJarFile) {
        if (!newJarFile.exists() || !newJarFile.getName().endsWith(".jar")) {
            System.err.println("[Pulse/Reload] Invalid JAR file: " + newJarFile);
            return false;
        }

        try {
            System.out.println("[Pulse/Reload] Hot swapping mod: " + modId);
            System.out.println("[Pulse/Reload] New JAR: " + newJarFile.getAbsolutePath());

            // 1. 현재 모드 비활성화
            disable(modId);

            // 2. 새 클래스 로더로 JAR 로드
            URL jarUrl = newJarFile.toURI().toURL();
            @SuppressWarnings("resource")
            URLClassLoader newLoader = new URLClassLoader(
                    new URL[] { jarUrl },
                    getClass().getClassLoader());

            // 3. 새 entrypoint 로드 시도
            ModLoader loader = ModLoader.getInstance();
            ModContainer container = loader.getMod(modId);

            if (container != null) {
                String entrypoint = container.getMetadata().getEntrypoint();
                if (entrypoint != null && !entrypoint.isEmpty()) {
                    try {
                        Class<?> newModClass = newLoader.loadClass(entrypoint);
                        Object newInstance = newModClass.getDeclaredConstructor().newInstance();

                        if (newInstance instanceof PulseMod) {
                            // 새 인스턴스로 교체 (리플렉션)
                            java.lang.reflect.Field instanceField = ModContainer.class.getDeclaredField("modInstance");
                            instanceField.setAccessible(true);
                            instanceField.set(container, newInstance);

                            System.out.println("[Pulse/Reload] Loaded new mod instance");
                        }
                    } catch (ClassNotFoundException e) {
                        System.out.println("[Pulse/Reload] Entrypoint not found in new JAR, using existing");
                    }
                }
            }

            // 4. 다시 활성화
            enable(modId);

            // 5. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.HOT_SWAPPED));

            System.out.println("[Pulse/Reload] Hot swap complete (partial - JVM limitations apply)");
            return true;

        } catch (Exception e) {
            System.err.println("[Pulse/Reload] Hot swap failed: " + modId);
            e.printStackTrace();
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 비활성화 여부를 확인하고 실행을 스킵할지 결정.
     * 이벤트 핸들러 등에서 사용.
     */
    public static boolean shouldSkip(String modId) {
        return INSTANCE.disabledMods.contains(modId);
    }

    /**
     * 모든 모드 상태 출력.
     */
    public static void printStatus() {
        System.out.println("═══════════════════════════════════════");
        System.out.println("       MOD RELOAD MANAGER STATUS       ");
        System.out.println("═══════════════════════════════════════");

        ModLoader loader = ModLoader.getInstance();
        for (String modId : loader.getLoadedModIds()) {
            ModContainer mod = loader.getMod(modId);
            String status = INSTANCE.disabledMods.contains(mod.getId()) ? "DISABLED" : "ENABLED";
            System.out.println("  " + mod.getId() + " v" + mod.getMetadata().getVersion() +
                    " [" + status + "]");
        }

        System.out.println("═══════════════════════════════════════");
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\ModReloadManager.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\PulseMod.java =====

package com.pulse.mod;

/**
 * 모드 엔트리포인트 인터페이스.
 * 모든 Pulse 모드는 이 인터페이스를 구현해야 함.
 * 
 * 예시:
 * public class MyMod implements PulseMod {
 *     @Override
 *     public void onInitialize() {
 *         System.out.println("My mod loaded!");
 *         // 이벤트 리스너 등록, 설정 로드 등
 *     }
 * }
 */
public interface PulseMod {
    
    /**
     * 모드 초기화 시 호출됨.
     * 이벤트 리스너 등록, 설정 로드 등을 수행.
     */
    void onInitialize();
    
    /**
     * 모드가 언로드될 때 호출됨 (선택적 구현).
     * 리소스 정리 등을 수행.
     */
    default void onUnload() {
        // 기본 구현: 아무것도 안 함
    }
    
    /**
     * 게임 월드가 로드된 후 호출됨 (선택적 구현).
     */
    default void onWorldLoad() {
        // 기본 구현: 아무것도 안 함
    }
    
    /**
     * 게임 월드가 언로드될 때 호출됨 (선택적 구현).
     */
    default void onWorldUnload() {
        // 기본 구현: 아무것도 안 함
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\PulseMod.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\VersionComparator.java =====

package com.pulse.mod;

import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Semantic Versioning (SemVer) 기반 버전 비교 유틸리티.
 * 
 * 지원하는 버전 형식:
 * - 1.0.0
 * - 1.0.0-alpha
 * - 1.0.0-beta.1
 * - 1.0.0+build.123
 * 
 * 지원하는 비교 연산자:
 * - = 또는 없음: 정확히 일치
 * - >: 초과
 * - >=: 이상
 * - <: 미만
 * - <=: 이하
 * - ~: 마이너 버전 호환 (예: ~1.2.3 → >=1.2.3 <1.3.0)
 * - ^: 메이저 버전 호환 (예: ^1.2.3 → >=1.2.3 <2.0.0)
 * - *: 모든 버전
 * 
 * 사용 예:
 * 
 * <pre>
 * Version v1 = Version.parse("1.2.3");
 * Version v2 = Version.parse("1.3.0");
 * 
 * v1.compareTo(v2); // -1 (v1 < v2)
 * 
 * VersionComparator.matches("1.2.3", ">=1.0.0"); // true
 * VersionComparator.matches("1.2.3", "~1.2.0"); // true
 * VersionComparator.matches("2.0.0", "^1.2.3"); // false
 * </pre>
 */
public class VersionComparator {

    // ─────────────────────────────────────────────────────────────
    // Version 클래스
    // ─────────────────────────────────────────────────────────────

    /**
     * SemVer 버전을 표현하는 불변 클래스.
     */
    public static class Version implements Comparable<Version> {

        // SemVer 정규식: major.minor.patch[-prerelease][+build]
        private static final Pattern SEMVER_PATTERN = Pattern.compile(
                "^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:-([a-zA-Z0-9.]+))?(?:\\+([a-zA-Z0-9.]+))?$");

        private final int major;
        private final int minor;
        private final int patch;
        private final String prerelease;
        private final String build;

        public Version(int major, int minor, int patch, String prerelease, String build) {
            this.major = major;
            this.minor = minor;
            this.patch = patch;
            this.prerelease = prerelease;
            this.build = build;
        }

        public Version(int major, int minor, int patch) {
            this(major, minor, patch, null, null);
        }

        /**
         * 버전 문자열 파싱.
         * 
         * @param version 버전 문자열 (예: "1.2.3-alpha")
         * @return 파싱된 Version 객체, 실패 시 null
         */
        public static Version parse(String version) {
            if (version == null || version.trim().isEmpty()) {
                return null;
            }

            version = version.trim();

            // v 접두사 제거 (v1.0.0 → 1.0.0)
            if (version.startsWith("v") || version.startsWith("V")) {
                version = version.substring(1);
            }

            Matcher matcher = SEMVER_PATTERN.matcher(version);
            if (!matcher.matches()) {
                System.err.println("[Pulse/Version] Invalid version format: " + version);
                return null;
            }

            int major = Integer.parseInt(matcher.group(1));
            int minor = matcher.group(2) != null ? Integer.parseInt(matcher.group(2)) : 0;
            int patch = matcher.group(3) != null ? Integer.parseInt(matcher.group(3)) : 0;
            String prerelease = matcher.group(4);
            String build = matcher.group(5);

            return new Version(major, minor, patch, prerelease, build);
        }

        public int getMajor() {
            return major;
        }

        public int getMinor() {
            return minor;
        }

        public int getPatch() {
            return patch;
        }

        public String getPrerelease() {
            return prerelease;
        }

        public String getBuild() {
            return build;
        }

        public boolean isPrerelease() {
            return prerelease != null && !prerelease.isEmpty();
        }

        @Override
        public int compareTo(Version other) {
            if (other == null)
                return 1;

            // 메이저 비교
            int result = Integer.compare(this.major, other.major);
            if (result != 0)
                return result;

            // 마이너 비교
            result = Integer.compare(this.minor, other.minor);
            if (result != 0)
                return result;

            // 패치 비교
            result = Integer.compare(this.patch, other.patch);
            if (result != 0)
                return result;

            // 프리릴리스 비교
            // 프리릴리스가 있으면 없는 것보다 낮음 (1.0.0-alpha < 1.0.0)
            if (this.prerelease == null && other.prerelease == null) {
                return 0;
            }
            if (this.prerelease == null) {
                return 1; // this가 릴리스, other가 프리릴리스
            }
            if (other.prerelease == null) {
                return -1; // this가 프리릴리스, other가 릴리스
            }

            // 둘 다 프리릴리스인 경우 문자열 비교
            return comparePrerelease(this.prerelease, other.prerelease);
        }

        private int comparePrerelease(String a, String b) {
            String[] partsA = a.split("\\.");
            String[] partsB = b.split("\\.");

            int length = Math.max(partsA.length, partsB.length);
            for (int i = 0; i < length; i++) {
                String partA = i < partsA.length ? partsA[i] : "";
                String partB = i < partsB.length ? partsB[i] : "";

                boolean aIsNumeric = partA.matches("\\d+");
                boolean bIsNumeric = partB.matches("\\d+");

                int result;
                if (aIsNumeric && bIsNumeric) {
                    result = Integer.compare(Integer.parseInt(partA), Integer.parseInt(partB));
                } else if (aIsNumeric) {
                    result = -1; // 숫자가 문자열보다 낮음
                } else if (bIsNumeric) {
                    result = 1;
                } else {
                    result = partA.compareTo(partB);
                }

                if (result != 0)
                    return result;
            }

            return 0;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null || getClass() != obj.getClass())
                return false;
            Version other = (Version) obj;
            return major == other.major &&
                    minor == other.minor &&
                    patch == other.patch &&
                    Objects.equals(prerelease, other.prerelease);
        }

        @Override
        public int hashCode() {
            return Objects.hash(major, minor, patch, prerelease);
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(major).append(".").append(minor).append(".").append(patch);
            if (prerelease != null) {
                sb.append("-").append(prerelease);
            }
            if (build != null) {
                sb.append("+").append(build);
            }
            return sb.toString();
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 버전 비교 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 버전이 요구사항을 만족하는지 확인.
     * 
     * @param version     확인할 버전 (예: "1.2.3")
     * @param requirement 요구사항 (예: ">=1.0.0", "~1.2.0", "^1.0.0")
     * @return 만족하면 true
     */
    public static boolean matches(String version, String requirement) {
        if (version == null || version.isEmpty()) {
            return false;
        }
        if (requirement == null || requirement.isEmpty() || "*".equals(requirement)) {
            return true; // 요구사항 없음 = 모든 버전 허용
        }

        Version ver = Version.parse(version);
        if (ver == null) {
            return false;
        }

        return matchesRequirement(ver, requirement.trim());
    }

    /**
     * 두 버전을 비교.
     * 
     * @return v1 < v2 → 음수, v1 == v2 → 0, v1 > v2 → 양수
     */
    public static int compare(String v1, String v2) {
        Version ver1 = Version.parse(v1);
        Version ver2 = Version.parse(v2);

        if (ver1 == null && ver2 == null)
            return 0;
        if (ver1 == null)
            return -1;
        if (ver2 == null)
            return 1;

        return ver1.compareTo(ver2);
    }

    private static boolean matchesRequirement(Version version, String requirement) {
        // 공백으로 분리된 여러 조건 처리 (예: ">=1.0.0 <2.0.0")
        if (requirement.contains(" ")) {
            String[] parts = requirement.split("\\s+");
            for (String part : parts) {
                if (!matchesSingleRequirement(version, part.trim())) {
                    return false;
                }
            }
            return true;
        }

        return matchesSingleRequirement(version, requirement);
    }

    private static boolean matchesSingleRequirement(Version version, String req) {
        if (req.isEmpty() || "*".equals(req)) {
            return true;
        }

        // 틸드 범위: ~1.2.3 → >=1.2.3 <1.3.0
        if (req.startsWith("~")) {
            Version reqVer = Version.parse(req.substring(1));
            if (reqVer == null)
                return false;

            // 하한: >=reqVer
            if (version.compareTo(reqVer) < 0)
                return false;

            // 상한: <next minor
            Version upperBound = new Version(reqVer.major, reqVer.minor + 1, 0);
            return version.compareTo(upperBound) < 0;
        }

        // 캐럿 범위: ^1.2.3 → >=1.2.3 <2.0.0
        if (req.startsWith("^")) {
            Version reqVer = Version.parse(req.substring(1));
            if (reqVer == null)
                return false;

            // 하한: >=reqVer
            if (version.compareTo(reqVer) < 0)
                return false;

            // 상한: <next major (단, 0.x는 0.(x+1).0)
            Version upperBound;
            if (reqVer.major == 0) {
                upperBound = new Version(0, reqVer.minor + 1, 0);
            } else {
                upperBound = new Version(reqVer.major + 1, 0, 0);
            }
            return version.compareTo(upperBound) < 0;
        }

        // 비교 연산자
        if (req.startsWith(">=")) {
            Version reqVer = Version.parse(req.substring(2));
            return reqVer != null && version.compareTo(reqVer) >= 0;
        }
        if (req.startsWith("<=")) {
            Version reqVer = Version.parse(req.substring(2));
            return reqVer != null && version.compareTo(reqVer) <= 0;
        }
        if (req.startsWith(">")) {
            Version reqVer = Version.parse(req.substring(1));
            return reqVer != null && version.compareTo(reqVer) > 0;
        }
        if (req.startsWith("<")) {
            Version reqVer = Version.parse(req.substring(1));
            return reqVer != null && version.compareTo(reqVer) < 0;
        }
        if (req.startsWith("=")) {
            Version reqVer = Version.parse(req.substring(1));
            return reqVer != null && version.compareTo(reqVer) == 0;
        }

        // 연산자 없음 = 정확히 일치
        Version reqVer = Version.parse(req);
        return reqVer != null && version.compareTo(reqVer) == 0;
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 버전 파싱 시도.
     */
    public static Version parse(String version) {
        return Version.parse(version);
    }

    /**
     * 유효한 버전 문자열인지 확인.
     */
    public static boolean isValid(String version) {
        return Version.parse(version) != null;
    }

    /**
     * 테스트용 메인 메서드.
     */
    public static void main(String[] args) {
        System.out.println("=== VersionComparator Tests ===");

        // 파싱 테스트
        System.out.println("\n[Parsing]");
        System.out.println("1.0.0 → " + Version.parse("1.0.0"));
        System.out.println("1.2.3-alpha → " + Version.parse("1.2.3-alpha"));
        System.out.println("v2.0.0-beta.1+build.123 → " + Version.parse("v2.0.0-beta.1+build.123"));

        // 비교 테스트
        System.out.println("\n[Comparison]");
        System.out.println("1.0.0 vs 1.0.1: " + compare("1.0.0", "1.0.1"));
        System.out.println("1.1.0 vs 1.0.9: " + compare("1.1.0", "1.0.9"));
        System.out.println("2.0.0-alpha vs 2.0.0: " + compare("2.0.0-alpha", "2.0.0"));

        // 매칭 테스트
        System.out.println("\n[Matching]");
        System.out.println("1.2.3 matches >=1.0.0: " + matches("1.2.3", ">=1.0.0"));
        System.out.println("1.2.3 matches <2.0.0: " + matches("1.2.3", "<2.0.0"));
        System.out.println("1.2.3 matches ~1.2.0: " + matches("1.2.3", "~1.2.0"));
        System.out.println("1.3.0 matches ~1.2.0: " + matches("1.3.0", "~1.2.0"));
        System.out.println("1.9.9 matches ^1.2.3: " + matches("1.9.9", "^1.2.3"));
        System.out.println("2.0.0 matches ^1.2.3: " + matches("2.0.0", "^1.2.3"));
        System.out.println("1.5.0 matches >=1.0.0 <2.0.0: " + matches("1.5.0", ">=1.0.0 <2.0.0"));

        System.out.println("\n=== All Tests Completed ===");
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\mod\VersionComparator.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\GameNetworkBridge.java =====

package com.pulse.network;

import com.pulse.PulseEnvironment;
import com.pulse.access.AccessWidener;
import com.pulse.api.GameAccess;

import java.lang.reflect.Method;
import java.nio.ByteBuffer;

/**
 * 게임 네트워크 시스템 브릿지.
 * Project Zomboid의 네트워크 시스템에 연결하여 실제 패킷 전송을 수행.
 * 
 * 게임 네트워크 클래스:
 * - zombie.network.GameClient: 클라이언트 측 네트워킹
 * - zombie.network.GameServer: 서버 측 네트워킹
 * - zombie.core.network.ByteBufferWriter: 바이트 버퍼 쓰기
 */
public class GameNetworkBridge {

    private static final GameNetworkBridge INSTANCE = new GameNetworkBridge();

    // 게임 네트워크 클래스 캐시
    private Class<?> gameClientClass;
    private Class<?> gameServerClass;
    private Class<?> byteBufferWriterClass;
    private Class<?> udpConnectionClass;

    // Pulse 커스텀 패킷 채널 ID
    private static final short Pulse_PACKET_ID = (short) 0x4D55; // "MU" in hex

    private boolean initialized = false;
    private boolean debugMode = false;

    private GameNetworkBridge() {
    }

    public static GameNetworkBridge getInstance() {
        return INSTANCE;
    }

    /**
     * 네트워크 브릿지 초기화.
     * 게임 클래스 로더가 활성화된 후에 호출되어야 함.
     */
    public void initialize() {
        if (initialized)
            return;

        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null) {
                loader = ClassLoader.getSystemClassLoader();
            }

            // 게임 클래스 로드 시도
            try {
                gameClientClass = loader.loadClass("zombie.network.GameClient");
                System.out.println("[Pulse/Network] GameClient class loaded");
            } catch (ClassNotFoundException e) {
                System.out.println("[Pulse/Network] GameClient class not found (may be server-only)");
            }

            try {
                gameServerClass = loader.loadClass("zombie.network.GameServer");
                System.out.println("[Pulse/Network] GameServer class loaded");
            } catch (ClassNotFoundException e) {
                System.out.println("[Pulse/Network] GameServer class not found (may be client-only)");
            }

            try {
                byteBufferWriterClass = loader.loadClass("zombie.core.network.ByteBufferWriter");
                System.out.println("[Pulse/Network] ByteBufferWriter class loaded");
            } catch (ClassNotFoundException e) {
                System.out.println("[Pulse/Network] ByteBufferWriter class not found");
            }

            try {
                udpConnectionClass = loader.loadClass("zombie.network.UdpConnection");
                System.out.println("[Pulse/Network] UdpConnection class loaded");
            } catch (ClassNotFoundException e) {
                System.out.println("[Pulse/Network] UdpConnection class not found");
            }

            initialized = true;
            System.out.println("[Pulse/Network] Network bridge initialized");

        } catch (Exception e) {
            System.err.println("[Pulse/Network] Failed to initialize network bridge: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * 서버로 패킷 전송 (클라이언트에서 호출)
     */
    public boolean sendToServer(byte[] data) {
        if (!initialized) {
            initialize();
        }

        if (gameClientClass == null) {
            if (debugMode) {
                System.err.println("[Pulse/Network] Cannot send to server: GameClient not available");
            }
            return false;
        }

        try {
            // 방법 1: GameClient의 sendData 메서드 사용 시도
            // zombie.network.GameClient.sendData(ByteBufferWriter)

            // ByteBufferWriter 생성
            Object writer = createByteBufferWriter();
            if (writer == null) {
                return sendRawPacket(data, null);
            }

            // Pulse 패킷 ID 쓰기
            writeShort(writer, Pulse_PACKET_ID);

            // 데이터 길이 쓰기
            writeInt(writer, data.length);

            // 데이터 쓰기
            writeBytes(writer, data);

            // 전송
            Method sendMethod = findSendMethod(gameClientClass);
            if (sendMethod != null) {
                sendMethod.invoke(null, writer);
                if (debugMode) {
                    System.out.println("[Pulse/Network] Sent " + data.length + " bytes to server");
                }
                recordSent(data.length);
                return true;
            }

            return sendRawPacket(data, null);

        } catch (Exception e) {
            System.err.println("[Pulse/Network] Error sending to server: " + e.getMessage());
            if (debugMode) {
                e.printStackTrace();
            }
            return false;
        }
    }

    /**
     * 특정 클라이언트로 패킷 전송 (서버에서 호출)
     */
    public boolean sendToClient(Object connection, byte[] data) {
        if (!initialized) {
            initialize();
        }

        if (gameServerClass == null) {
            if (debugMode) {
                System.err.println("[Pulse/Network] Cannot send to client: GameServer not available");
            }
            return false;
        }

        try {
            Object writer = createByteBufferWriter();
            if (writer == null) {
                return sendRawPacket(data, connection);
            }

            // Pulse 패킷 ID 쓰기
            writeShort(writer, Pulse_PACKET_ID);

            // 데이터 길이 쓰기
            writeInt(writer, data.length);

            // 데이터 쓰기
            writeBytes(writer, data);

            // UdpConnection을 통해 전송
            if (connection != null && udpConnectionClass != null &&
                    udpConnectionClass.isInstance(connection)) {
                Method sendMethod = findUdpSendMethod();
                if (sendMethod != null) {
                    sendMethod.invoke(connection, writer);
                    if (debugMode) {
                        System.out.println("[Pulse/Network] Sent " + data.length + " bytes to client");
                    }
                    return true;
                }
            }

            return sendRawPacket(data, connection);

        } catch (Exception e) {
            System.err.println("[Pulse/Network] Error sending to client: " + e.getMessage());
            if (debugMode) {
                e.printStackTrace();
            }
            return false;
        }
    }

    /**
     * 모든 클라이언트로 패킷 전송 (서버에서 호출)
     */
    public boolean sendToAll(byte[] data) {
        if (!initialized) {
            initialize();
        }

        if (gameServerClass == null) {
            if (debugMode) {
                System.err.println("[Pulse/Network] Cannot send to all: GameServer not available");
            }
            return false;
        }

        try {
            // 모든 연결된 클라이언트 가져오기
            Object connections = AccessWidener.getStaticField(gameServerClass, "udpEngine");
            if (connections == null) {
                connections = AccessWidener.getStaticField(gameServerClass, "connections");
            }

            if (connections == null) {
                if (debugMode) {
                    System.out.println("[Pulse/Network] No connections found, cannot broadcast");
                }
                return false;
            }

            // connections가 iterable인 경우 순회
            if (connections instanceof Iterable<?>) {
                int sent = 0;
                for (Object connection : (Iterable<?>) connections) {
                    if (sendToClient(connection, data)) {
                        sent++;
                    }
                }
                if (debugMode) {
                    System.out.println("[Pulse/Network] Broadcast to " + sent + " clients");
                }
                return sent > 0;
            }

            return false;

        } catch (Exception e) {
            System.err.println("[Pulse/Network] Error broadcasting: " + e.getMessage());
            if (debugMode) {
                e.printStackTrace();
            }
            return false;
        }
    }

    /**
     * 수신된 패킷 처리.
     * 게임의 패킷 핸들러에서 호출되어야 함.
     */
    public void handleReceived(ByteBuffer buffer, Object sender) {
        try {
            // Pulse 패킷 ID 확인
            short packetId = buffer.getShort();
            if (packetId != Pulse_PACKET_ID) {
                // Pulse 패킷이 아님 - 무시
                return;
            }

            // 데이터 길이 읽기
            int length = buffer.getInt();

            // 데이터 읽기
            byte[] data = new byte[length];
            buffer.get(data);

            // NetworkManager에 전달
            NetworkManager.getInstance().handleReceived(data, sender);

            if (debugMode) {
                System.out.println("[Pulse/Network] Received " + length + " bytes");
            }
            recordReceived(length);

        } catch (Exception e) {
            System.err.println("[Pulse/Network] Error handling received packet: " + e.getMessage());
            if (debugMode) {
                e.printStackTrace();
            }
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 헬퍼 메서드
    // ─────────────────────────────────────────────────────────────

    private Object createByteBufferWriter() {
        if (byteBufferWriterClass == null) {
            return null;
        }
        return AccessWidener.newInstance(byteBufferWriterClass);
    }

    private void writeShort(Object writer, short value) {
        AccessWidener.invoke(writer, "putShort", value);
    }

    private void writeInt(Object writer, int value) {
        AccessWidener.invoke(writer, "putInt", value);
    }

    private void writeBytes(Object writer, byte[] data) {
        AccessWidener.invoke(writer, "putBytes", data);
    }

    private Method findSendMethod(Class<?> clazz) {
        try {
            // 일반적인 send 메서드 패턴 찾기
            for (Method method : clazz.getDeclaredMethods()) {
                String name = method.getName().toLowerCase();
                if ((name.contains("send") || name.contains("write")) &&
                        method.getParameterCount() == 1 &&
                        byteBufferWriterClass != null &&
                        byteBufferWriterClass.isAssignableFrom(method.getParameterTypes()[0])) {
                    method.setAccessible(true);
                    return method;
                }
            }
        } catch (Exception e) {
            // 무시
        }
        return null;
    }

    private Method findUdpSendMethod() {
        if (udpConnectionClass == null)
            return null;
        try {
            for (Method method : udpConnectionClass.getDeclaredMethods()) {
                String name = method.getName().toLowerCase();
                if (name.contains("send") && method.getParameterCount() == 1) {
                    method.setAccessible(true);
                    return method;
                }
            }
        } catch (Exception e) {
            // 무시
        }
        return null;
    }

    /**
     * 폴백: 원시 바이트 배열 직접 전송 시도
     */
    private boolean sendRawPacket(byte[] data, Object target) {
        // 게임 네트워크 API를 직접 찾을 수 없는 경우
        // 이 메서드는 게임별 커스터마이징이 필요함
        if (debugMode) {
            System.out.println("[Pulse/Network] Raw packet send not implemented (" +
                    data.length + " bytes)");
        }
        return false;
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    public boolean isClient() {
        return gameClientClass != null && GameAccess.isSinglePlayer() == false;
    }

    public boolean isServer() {
        return gameServerClass != null && !GameAccess.isSinglePlayer();
    }

    public boolean isInitialized() {
        return initialized;
    }

    public void setDebugMode(boolean debug) {
        this.debugMode = debug;
    }

    /**
     * Pulse 패킷 ID 반환 (Mixin에서 패킷 타입 확인용)
     */
    public static short getPulsePacketId() {
        return Pulse_PACKET_ID;
    }

    // ─────────────────────────────────────────────────────────────
    // 패킷 통계 (평가 개선사항)
    // ─────────────────────────────────────────────────────────────

    private volatile int sentPacketCount = 0;
    private volatile int receivedPacketCount = 0;
    private volatile long totalBytesSent = 0;
    private volatile long totalBytesReceived = 0;

    /**
     * 전송된 패킷 수
     */
    public int getSentPacketCount() {
        return sentPacketCount;
    }

    /**
     * 수신된 패킷 수
     */
    public int getReceivedPacketCount() {
        return receivedPacketCount;
    }

    /**
     * 총 전송 바이트 수
     */
    public long getTotalBytesSent() {
        return totalBytesSent;
    }

    /**
     * 총 수신 바이트 수
     */
    public long getTotalBytesReceived() {
        return totalBytesReceived;
    }

    /**
     * 연결 상태 확인
     */
    public boolean isConnected() {
        if (!initialized) {
            initialize();
        }

        // 클라이언트 또는 서버 클래스가 로드되어 있으면 연결 가능 상태
        return gameClientClass != null || gameServerClass != null;
    }

    /**
     * 네트워크 재초기화 시도
     */
    public void reconnect() {
        initialized = false;
        gameClientClass = null;
        gameServerClass = null;
        byteBufferWriterClass = null;
        udpConnectionClass = null;

        initialize();

        System.out.println("[Pulse/Network] Reconnect attempted");
    }

    /**
     * 통계 기록 (전송)
     */
    private void recordSent(int bytes) {
        sentPacketCount++;
        totalBytesSent += bytes;
    }

    /**
     * 통계 기록 (수신)
     */
    private void recordReceived(int bytes) {
        receivedPacketCount++;
        totalBytesReceived += bytes;
    }

    /**
     * 통계 초기화
     */
    public void resetStatistics() {
        sentPacketCount = 0;
        receivedPacketCount = 0;
        totalBytesSent = 0;
        totalBytesReceived = 0;
    }

    /**
     * 네트워크 통계 문자열
     */
    public String getStatisticsReport() {
        return String.format(
                "[Pulse/Network] Stats: sent=%d packets (%d bytes), received=%d packets (%d bytes)",
                sentPacketCount, totalBytesSent, receivedPacketCount, totalBytesReceived);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\GameNetworkBridge.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\HandshakeHandler.java =====

package com.pulse.network;

import com.pulse.mod.ModLoader;
import com.pulse.mod.ModContainer;

import java.util.*;

/**
 * 핸드셰이크 핸들러.
 * 서버-클라이언트 모드 호환성 검증.
 */
public class HandshakeHandler {

    private static final HandshakeHandler INSTANCE = new HandshakeHandler();

    // 필수 모드 목록 (이 모드들은 클라이언트와 서버 모두에 있어야 함)
    private final Set<String> requiredMods = new HashSet<>();

    // 검증 모드
    private ValidationMode validationMode = ValidationMode.STRICT;

    private HandshakeHandler() {
    }

    public static HandshakeHandler getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 검증
    // ─────────────────────────────────────────────────────────────

    /**
     * 클라이언트 모드 목록 검증 (서버 측).
     * 
     * @param clientMods 클라이언트의 modId -> version 맵
     * @return 검증 결과
     */
    public static HandshakeResult validate(Map<String, String> clientMods) {
        return INSTANCE.validateInternal(clientMods);
    }

    private HandshakeResult validateInternal(Map<String, String> clientMods) {
        List<String> missingOnClient = new ArrayList<>();
        List<String> missingOnServer = new ArrayList<>();
        List<String> versionMismatch = new ArrayList<>();

        ModLoader loader = ModLoader.getInstance();
        Map<String, String> serverMods = new HashMap<>();

        for (String modId : loader.getLoadedModIds()) {
            ModContainer container = loader.getMod(modId);
            if (container != null) {
                serverMods.put(modId, container.getMetadata().getVersion());
            }
        }

        // 1. 서버 모드가 클라이언트에 있는지 확인
        for (var entry : serverMods.entrySet()) {
            String modId = entry.getKey();
            String serverVersion = entry.getValue();

            if (!clientMods.containsKey(modId)) {
                if (isRequired(modId)) {
                    missingOnClient.add(modId);
                }
            } else {
                String clientVersion = clientMods.get(modId);
                if (!serverVersion.equals(clientVersion)) {
                    versionMismatch.add(modId + " (server: " + serverVersion +
                            ", client: " + clientVersion + ")");
                }
            }
        }

        // 2. 클라이언트 모드가 서버에 있는지 확인
        for (String modId : clientMods.keySet()) {
            if (!serverMods.containsKey(modId) && isRequired(modId)) {
                missingOnServer.add(modId);
            }
        }

        // 결과 생성
        if (missingOnClient.isEmpty() && missingOnServer.isEmpty() &&
                (versionMismatch.isEmpty() || validationMode == ValidationMode.LENIENT)) {
            return HandshakeResult.success();
        }

        StringBuilder reason = new StringBuilder();
        if (!missingOnClient.isEmpty()) {
            reason.append("Missing on client: ").append(missingOnClient).append(". ");
        }
        if (!missingOnServer.isEmpty()) {
            reason.append("Missing on server: ").append(missingOnServer).append(". ");
        }
        if (!versionMismatch.isEmpty() && validationMode == ValidationMode.STRICT) {
            reason.append("Version mismatch: ").append(versionMismatch);
        }

        return HandshakeResult.failure(reason.toString().trim());
    }

    private boolean isRequired(String modId) {
        // pulse_ 로 시작하는 것은 필수 (핵심 모드)
        if (modId.startsWith("pulse_") || modId.equals("pulse")) {
            return true;
        }
        return requiredMods.contains(modId);
    }

    // ─────────────────────────────────────────────────────────────
    // 설정
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드를 필수로 지정.
     */
    public static void markRequired(String modId) {
        INSTANCE.requiredMods.add(modId);
    }

    /**
     * 검증 모드 설정.
     */
    public static void setValidationMode(ValidationMode mode) {
        INSTANCE.validationMode = mode;
    }

    // ─────────────────────────────────────────────────────────────
    // 패킷 핸들러 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 핸드셰이크 시스템 초기화.
     */
    public static void initialize() {
        // 패킷 등록
        NetworkManager.registerPacket(
                HandshakePacket.class,
                HandshakePacket::new,
                NetworkSide.BOTH);

        // 핸들러 등록
        NetworkManager.registerHandler(HandshakePacket.class, INSTANCE::handlePacket);

        System.out.println("[Pulse/Handshake] Initialized");
    }

    private void handlePacket(HandshakePacket packet, Object sender) {
        switch (packet.getPhase()) {
            case REQUEST:
                // 클라이언트 요청 처리 (서버 측)
                handleClientRequest(packet, sender);
                break;
            case RESPONSE:
                // 서버 응답 처리 (클라이언트 측)
                handleServerResponse(packet);
                break;
            case ACCEPT:
                System.out.println("[Pulse/Handshake] Handshake accepted");
                break;
            case REJECT:
                System.err.println("[Pulse/Handshake] Handshake rejected");
                break;
        }
    }

    private void handleClientRequest(HandshakePacket clientPacket, Object connection) {
        HandshakeResult result = validate(clientPacket.getModVersions());

        if (result.isSuccess()) {
            System.out.println("[Pulse/Handshake] Client validated successfully");
            HandshakePacket response = HandshakePacket.create(HandshakePacket.HandshakePhase.ACCEPT);
            NetworkManager.sendToClient(connection, response);
        } else {
            System.err.println("[Pulse/Handshake] Client validation failed: " + result.getReason());
            HandshakePacket response = HandshakePacket.create(HandshakePacket.HandshakePhase.REJECT);
            NetworkManager.sendToClient(connection, response);

            // 연결 종료
            disconnectClient(connection, result.getReason());
        }
    }

    private void handleServerResponse(HandshakePacket serverPacket) {
        // 클라이언트 측에서 서버 모드 확인
        HandshakeResult result = validate(serverPacket.getModVersions());

        if (!result.isSuccess()) {
            System.err.println("[Pulse/Handshake] Server mod mismatch: " + result.getReason());

            // 경고 표시 및 연결 종료
            showModMismatchWarning(result.getReason());
            disconnectFromServer(result.getReason());
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 연결 관리
    // ─────────────────────────────────────────────────────────────

    /**
     * 클라이언트 연결 종료 (서버 측).
     */
    private void disconnectClient(Object connection, String reason) {
        try {
            // GameServer.kick 또는 유사한 메서드 호출
            Class<?> gameServerClass = Class.forName("zombie.network.GameServer");

            // connection에서 플레이어/연결 정보 추출 시도
            if (connection != null) {
                java.lang.reflect.Method disconnectMethod = gameServerClass.getMethod("disconnect", Object.class,
                        String.class);
                disconnectMethod.invoke(null, connection, "Mod mismatch: " + reason);
                System.out.println("[Pulse/Handshake] Client disconnected: " + reason);
            }
        } catch (ClassNotFoundException e) {
            // GameServer 클래스 없음 - 싱글플레이어이거나 다른 환경
            System.out.println("[Pulse/Handshake] Cannot disconnect client (not a server environment)");
        } catch (Exception e) {
            System.err.println("[Pulse/Handshake] Failed to disconnect client: " + e.getMessage());
        }
    }

    /**
     * 서버 연결 종료 (클라이언트 측).
     */
    private void disconnectFromServer(String reason) {
        try {
            Class<?> gameClientClass = Class.forName("zombie.network.GameClient");
            java.lang.reflect.Method disconnectMethod = gameClientClass.getMethod("disconnect");
            disconnectMethod.invoke(null);
            System.out.println("[Pulse/Handshake] Disconnected from server: " + reason);
        } catch (ClassNotFoundException e) {
            System.out.println("[Pulse/Handshake] Cannot disconnect (not a client environment)");
        } catch (Exception e) {
            System.err.println("[Pulse/Handshake] Failed to disconnect from server: " + e.getMessage());
        }
    }

    /**
     * 모드 불일치 경고 표시.
     */
    private void showModMismatchWarning(String reason) {
        // 콘솔에 경고 출력
        System.err.println("══════════════════════════════════════════════════════════");
        System.err.println("  [Pulse] MOD MISMATCH WARNING");
        System.err.println("══════════════════════════════════════════════════════════");
        System.err.println("  " + reason);
        System.err.println("══════════════════════════════════════════════════════════");

        // UI 모달 표시 시도 (게임 UI 사용 가능한 경우)
        try {
            Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");
            java.lang.reflect.Method runLuaMethod = luaManagerClass.getMethod("RunLua", String.class);
            String luaCode = String.format(
                    "getCore():doPopup('[Pulse] Mod Mismatch', '%s')",
                    reason.replace("'", "\\'"));
            runLuaMethod.invoke(null, luaCode);
        } catch (Exception e) {
            // UI 팝업 실패 - 콘솔 경고만 표시됨
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 결과 클래스
    // ─────────────────────────────────────────────────────────────

    public static class HandshakeResult {
        private final boolean success;
        private final String reason;

        private HandshakeResult(boolean success, String reason) {
            this.success = success;
            this.reason = reason;
        }

        public static HandshakeResult success() {
            return new HandshakeResult(true, null);
        }

        public static HandshakeResult failure(String reason) {
            return new HandshakeResult(false, reason);
        }

        public boolean isSuccess() {
            return success;
        }

        public String getReason() {
            return reason;
        }
    }

    public enum ValidationMode {
        STRICT, // 버전까지 일치 필요
        LENIENT // 모드 존재만 확인
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\HandshakeHandler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\HandshakePacket.java =====

package com.pulse.network;

import com.pulse.api.Pulse;
import com.pulse.mod.ModLoader;
import com.pulse.registry.Identifier;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * 서버-클라이언트 핸드셰이크 패킷.
 * 연결 시 모드 목록과 버전을 교환하여 호환성 검증.
 */
public class HandshakePacket implements Packet {

    private static final Identifier ID = Identifier.of("pulse", "handshake");

    private String loaderVersion;
    private Map<String, String> modVersions; // modId -> version
    private HandshakePhase phase;

    public HandshakePacket() {
        this.modVersions = new LinkedHashMap<>();
        this.phase = HandshakePhase.REQUEST;
    }

    public HandshakePacket(HandshakePhase phase) {
        this();
        this.phase = phase;
    }

    /**
     * 현재 로드된 모드 정보로 패킷 생성.
     */
    public static HandshakePacket create(HandshakePhase phase) {
        HandshakePacket packet = new HandshakePacket(phase);
        packet.loaderVersion = Pulse.VERSION;

        // 로드된 모드 정보 수집
        ModLoader loader = ModLoader.getInstance();
        for (String modId : loader.getLoadedModIds()) {
            var container = loader.getMod(modId);
            if (container != null) {
                packet.modVersions.put(modId, container.getMetadata().getVersion());
            }
        }

        return packet;
    }

    @Override
    public Identifier getId() {
        return ID;
    }

    @Override
    public void write(PacketBuffer buf) {
        buf.writeByte(phase.ordinal());
        buf.writeString(loaderVersion);
        buf.writeInt(modVersions.size());
        for (var entry : modVersions.entrySet()) {
            buf.writeString(entry.getKey());
            buf.writeString(entry.getValue());
        }
    }

    @Override
    public void read(PacketBuffer buf) {
        phase = HandshakePhase.values()[buf.readByte()];
        loaderVersion = buf.readString();
        int count = buf.readInt();
        modVersions = new LinkedHashMap<>();
        for (int i = 0; i < count; i++) {
            String modId = buf.readString();
            String version = buf.readString();
            modVersions.put(modId, version);
        }
    }

    public String getLoaderVersion() {
        return loaderVersion;
    }

    public Map<String, String> getModVersions() {
        return modVersions;
    }

    public HandshakePhase getPhase() {
        return phase;
    }

    public enum HandshakePhase {
        REQUEST, // 클라이언트 → 서버 (모드 목록 요청 또는 전송)
        RESPONSE, // 서버 → 클라이언트 (서버 모드 목록)
        ACCEPT, // 핸드셰이크 성공
        REJECT // 핸드셰이크 실패
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\HandshakePacket.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\NetworkManager.java =====

package com.pulse.network;

import com.pulse.registry.Identifier;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 네트워크 매니저.
 * 패킷 등록, 전송, 수신을 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 패킷 등록
 * NetworkManager.registerPacket(MyPacket.class, MyPacket::new, NetworkSide.SERVER);
 * 
 * // 패킷 핸들러 등록
 * NetworkManager.registerHandler(MyPacket.class, (packet, sender) -> {
 *     System.out.println("Received: " + packet.getMessage());
 * });
 * 
 * // 패킷 송신
 * NetworkManager.sendToServer(new MyPacket("Hello!"));
 * </pre>
 */
public class NetworkManager {

    private static final NetworkManager INSTANCE = new NetworkManager();

    // 등록된 패킷 타입
    private final Map<Identifier, PacketRegistration<?>> packetsByType = new ConcurrentHashMap<>();
    private final Map<Class<?>, PacketRegistration<?>> packetsByClass = new ConcurrentHashMap<>();

    private NetworkManager() {
    }

    public static NetworkManager getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 패킷 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 패킷 타입 등록
     */
    public static <T extends Packet> void registerPacket(
            Class<T> packetClass,
            Supplier<T> factory,
            NetworkSide side) {
        INSTANCE.register(packetClass, factory, side);
    }

    /**
     * 패킷 핸들러 등록
     */
    public static <T extends Packet> void registerHandler(
            Class<T> packetClass,
            PacketHandler<T> handler) {
        INSTANCE.addHandler(packetClass, handler);
    }

    private <T extends Packet> void register(
            Class<T> packetClass,
            Supplier<T> factory,
            NetworkSide side) {

        // 임시 인스턴스로 ID 확인
        T temp = factory.get();
        Identifier id = temp.getId();

        PacketRegistration<T> registration = new PacketRegistration<>(
                id, packetClass, factory, side);

        packetsByType.put(id, registration);
        packetsByClass.put(packetClass, registration);

        System.out.println("[Pulse/Network] Registered packet: " + id +
                " (" + side + ")");
    }

    @SuppressWarnings("unchecked")
    private <T extends Packet> void addHandler(Class<T> packetClass, PacketHandler<T> handler) {
        PacketRegistration<T> reg = (PacketRegistration<T>) packetsByClass.get(packetClass);
        if (reg != null) {
            reg.addHandler(handler);
        } else {
            System.err.println("[Pulse/Network] Cannot add handler: packet not registered");
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 패킷 송신 (GameNetworkBridge를 통해 게임 네트워크에 연결)
    // ─────────────────────────────────────────────────────────────

    /**
     * 서버로 패킷 전송 (클라이언트에서 호출)
     */
    public static void sendToServer(Packet packet) {
        byte[] data = INSTANCE.serialize(packet);
        boolean sent = GameNetworkBridge.getInstance().sendToServer(data);

        if (!sent) {
            System.out.println("[Pulse/Network] Queued for server: " +
                    packet.getId() + " (" + data.length + " bytes)");
        }
    }

    /**
     * 클라이언트로 패킷 전송 (서버에서 호출)
     * 
     * @param connection 클라이언트 연결 객체 (UdpConnection)
     * @param packet     전송할 패킷
     */
    public static void sendToClient(Object connection, Packet packet) {
        byte[] data = INSTANCE.serialize(packet);
        boolean sent = GameNetworkBridge.getInstance().sendToClient(connection, data);

        if (!sent) {
            System.out.println("[Pulse/Network] Queued for client: " +
                    packet.getId() + " (" + data.length + " bytes)");
        }
    }

    /**
     * 모든 클라이언트로 패킷 전송
     */
    public static void sendToAll(Packet packet) {
        byte[] data = INSTANCE.serialize(packet);
        boolean sent = GameNetworkBridge.getInstance().sendToAll(data);

        if (!sent) {
            System.out.println("[Pulse/Network] Queued for broadcast: " +
                    packet.getId() + " (" + data.length + " bytes)");
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 직렬화/역직렬화
    // ─────────────────────────────────────────────────────────────

    /**
     * 패킷 직렬화
     */
    public byte[] serialize(Packet packet) {
        PacketBuffer buf = new PacketBuffer();

        // 패킷 ID 쓰기
        buf.writeString(packet.getId().toString());

        // 패킷 데이터 쓰기
        packet.write(buf);

        return buf.toByteArray();
    }

    /**
     * 패킷 역직렬화
     */
    @SuppressWarnings("unchecked")
    public <T extends Packet> T deserialize(byte[] data) {
        PacketBuffer buf = new PacketBuffer(data);

        // 패킷 ID 읽기
        String idStr = buf.readString();
        Identifier id = Identifier.parse(idStr);

        // 패킷 타입 찾기
        PacketRegistration<T> reg = (PacketRegistration<T>) packetsByType.get(id);
        if (reg == null) {
            System.err.println("[Pulse/Network] Unknown packet: " + id);
            return null;
        }

        // 패킷 인스턴스 생성 및 데이터 읽기
        T packet = reg.create();
        packet.read(buf);

        return packet;
    }

    /**
     * 수신된 패킷 처리
     */
    @SuppressWarnings("unchecked")
    public void handleReceived(byte[] data, Object sender) {
        PacketBuffer buf = new PacketBuffer(data);

        String idStr = buf.readString();
        Identifier id = Identifier.parse(idStr);

        PacketRegistration<?> reg = packetsByType.get(id);
        if (reg == null) {
            System.err.println("[Pulse/Network] Unknown packet: " + id);
            return;
        }

        Packet packet = reg.create();
        packet.read(buf);

        // 핸들러 호출
        ((PacketRegistration<Packet>) reg).handlePacket(packet, sender);
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface PacketHandler<T extends Packet> {
        void handle(T packet, Object sender);
    }

    @SuppressWarnings("unused") // Public API for future game integration
    private static class PacketRegistration<T extends Packet> {
        final Identifier id;
        final Class<T> packetClass;
        final Supplier<T> factory;
        final NetworkSide side;
        final List<PacketHandler<T>> handlers = new ArrayList<>();

        PacketRegistration(Identifier id, Class<T> packetClass,
                Supplier<T> factory, NetworkSide side) {
            this.id = id;
            this.packetClass = packetClass;
            this.factory = factory;
            this.side = side;
        }

        T create() {
            return factory.get();
        }

        Class<T> getPacketClass() {
            return packetClass;
        }

        NetworkSide getSide() {
            return side;
        }

        void addHandler(PacketHandler<T> handler) {
            handlers.add(handler);
        }

        void handlePacket(T packet, Object sender) {
            for (PacketHandler<T> handler : handlers) {
                try {
                    handler.handle(packet, sender);
                } catch (Exception e) {
                    System.err.println("[Pulse/Network] Handler error for " + id);
                    e.printStackTrace();
                }
            }
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\NetworkManager.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\NetworkSide.java =====

package com.pulse.network;

/**
 * 네트워크 사이드.
 * 패킷이 어느 방향으로 전송되는지 정의.
 */
public enum NetworkSide {
    /**
     * 클라이언트 → 서버
     */
    SERVER,

    /**
     * 서버 → 클라이언트
     */
    CLIENT,

    /**
     * 양방향
     */
    BOTH
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\NetworkSide.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\Packet.java =====

package com.pulse.network;

import com.pulse.registry.Identifier;

/**
 * 패킷 인터페이스.
 * 모든 네트워크 패킷은 이 인터페이스를 구현해야 함.
 * 
 * 사용 예:
 * 
 * <pre>
 * public class MyPacket implements Packet {
 *     private String message;
 *     
 *     public MyPacket() {} // 역직렬화용
 *     
 *     public MyPacket(String message) {
 *         this.message = message;
 *     }
 *     
 *     {@literal @}Override
 *     public void write(PacketBuffer buf) {
 *         buf.writeString(message);
 *     }
 *     
 *     {@literal @}Override
 *     public void read(PacketBuffer buf) {
 *         message = buf.readString();
 *     }
 *     
 *     {@literal @}Override
 *     public Identifier getId() {
 *         return Identifier.of("mymod", "my_packet");
 *     }
 * }
 * </pre>
 */
public interface Packet {

    /**
     * 패킷 ID
     */
    Identifier getId();

    /**
     * 패킷 데이터를 버퍼에 쓰기
     */
    void write(PacketBuffer buf);

    /**
     * 버퍼에서 패킷 데이터 읽기
     */
    void read(PacketBuffer buf);
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\Packet.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\PacketBuffer.java =====

package com.pulse.network;

import java.io.*;
import java.nio.charset.StandardCharsets;

/**
 * 패킷 버퍼.
 * 패킷 데이터의 직렬화/역직렬화를 담당.
 */
public class PacketBuffer {

    private final ByteArrayOutputStream outputStream;
    private final DataOutputStream out;
    private final DataInputStream in;
    private byte[] data;

    /**
     * 쓰기용 버퍼 생성
     */
    public PacketBuffer() {
        this.outputStream = new ByteArrayOutputStream();
        this.out = new DataOutputStream(outputStream);
        this.in = null;
        this.data = null;
    }

    /**
     * 읽기용 버퍼 생성
     */
    public PacketBuffer(byte[] data) {
        this.data = data;
        this.outputStream = null;
        this.out = null;
        this.in = new DataInputStream(new ByteArrayInputStream(data));
    }

    // ─────────────────────────────────────────────────────────────
    // 쓰기 메서드
    // ─────────────────────────────────────────────────────────────

    public void writeByte(int value) {
        try {
            out.writeByte(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeShort(int value) {
        try {
            out.writeShort(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeInt(int value) {
        try {
            out.writeInt(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeLong(long value) {
        try {
            out.writeLong(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeFloat(float value) {
        try {
            out.writeFloat(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeDouble(double value) {
        try {
            out.writeDouble(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeBoolean(boolean value) {
        try {
            out.writeBoolean(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeString(String value) {
        try {
            byte[] bytes = value.getBytes(StandardCharsets.UTF_8);
            out.writeInt(bytes.length);
            out.write(bytes);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeBytes(byte[] bytes) {
        try {
            out.writeInt(bytes.length);
            out.write(bytes);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 읽기 메서드
    // ─────────────────────────────────────────────────────────────

    public byte readByte() {
        try {
            return in.readByte();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public short readShort() {
        try {
            return in.readShort();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public int readInt() {
        try {
            return in.readInt();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public long readLong() {
        try {
            return in.readLong();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public float readFloat() {
        try {
            return in.readFloat();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public double readDouble() {
        try {
            return in.readDouble();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public boolean readBoolean() {
        try {
            return in.readBoolean();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public String readString() {
        try {
            int length = in.readInt();
            byte[] bytes = new byte[length];
            in.readFully(bytes);
            return new String(bytes, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public byte[] readBytes() {
        try {
            int length = in.readInt();
            byte[] bytes = new byte[length];
            in.readFully(bytes);
            return bytes;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 버퍼 데이터를 바이트 배열로 변환
     */
    public byte[] toByteArray() {
        if (outputStream != null) {
            return outputStream.toByteArray();
        }
        return data;
    }

    /**
     * 남은 바이트 수
     */
    public int remaining() {
        if (in != null) {
            try {
                return in.available();
            } catch (IOException e) {
                return 0;
            }
        }
        return 0;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\PacketBuffer.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\Synced.java =====

package com.pulse.network;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 자동 동기화 필드 마커.
 * 이 어노테이션이 붙은 필드는 자동으로 서버-클라이언트 간 동기화됨.
 * 
 * 사용 예:
 * 
 * <pre>
 * public class MyEntity {
 *     &#64;Synced
 *     private int health;
 * 
 *     @Synced(direction = SyncDirection.SERVER_TO_CLIENT)
 *     private String name;
 * }
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Synced {

    /**
     * 동기화 방향.
     */
    SyncDirection direction() default SyncDirection.BIDIRECTIONAL;

    /**
     * 동기화 우선순위 (낮을수록 먼저).
     */
    int priority() default 100;

    /**
     * 변경 시에만 동기화할지 여부.
     */
    boolean onlyOnChange() default true;

    public enum SyncDirection {
        SERVER_TO_CLIENT, // 서버 → 클라이언트
        CLIENT_TO_SERVER, // 클라이언트 → 서버
        BIDIRECTIONAL // 양방향
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\network\Synced.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\PulseAgent.java =====

package com.pulse;

import com.pulse.transformer.PulseClassTransformer;
import org.spongepowered.asm.launch.MixinBootstrap;
import org.spongepowered.asm.mixin.MixinEnvironment;
import org.spongepowered.asm.mixin.Mixins;
import org.spongepowered.asm.mixin.transformer.IMixinTransformer;

import java.lang.instrument.Instrumentation;

/**
 * Pulse Java Agent Entry Point.
 * 
 * JVM 시작 시 -javaagent:Pulse.jar 옵션으로 로드됨.
 * 
 * 초기화 순서:
 * 1. Instrumentation 저장
 * 2. 시스템 프로퍼티 설정
 * 3. Mixin 부트스트랩
 * 4. Mixin config 등록
 * 5. Class transformer 등록
 */
public class PulseAgent {

    private static Instrumentation instrumentation;
    private static PulseClassTransformer classTransformer;

    public static void premain(String agentArgs, Instrumentation inst) {
        instrumentation = inst;
        PulseEnvironment.setInstrumentation(inst);

        System.out.println();
        System.out.println("╔══════════════════════════════════════════════════════════════╗");
        System.out.println("║              Pulse MOD LOADER v1.0.0                       ║");
        System.out.println("║          Project Zomboid Modding Platform                    ║");
        System.out.println("╚══════════════════════════════════════════════════════════════╝");
        System.out.println();

        try {
            initializePulse(inst);
        } catch (Throwable t) {
            System.err.println("[Pulse] ════════════════════════════════════════");
            System.err.println("[Pulse] CRITICAL INITIALIZATION ERROR");
            System.err.println("[Pulse] ════════════════════════════════════════");
            t.printStackTrace();
        }
    }

    private static void initializePulse(Instrumentation inst) {
        // ─────────────────────────────────────────────────────────────
        // STEP 1: 시스템 프로퍼티 설정 (Mixin 부트스트랩 전에!)
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 1: Configuring system properties...");

        // Mixin 디버그 활성화
        System.setProperty("mixin.debug", "true");
        System.setProperty("mixin.debug.verbose", "true");
        System.setProperty("mixin.debug.export", "true");
        System.setProperty("mixin.debug.export.decompile", "false");
        System.setProperty("mixin.dumpTargetOnFailure", "true");
        System.setProperty("mixin.checks", "true");
        System.setProperty("mixin.hotSwap", "true");

        // Mixin 서비스 지정 (선택사항 - ServiceLoader가 자동 발견함)
        // System.setProperty("mixin.service",
        // "com.pulse.service.PulseMixinService");

        System.out.println("[Pulse] Step 1: Complete");

        // ─────────────────────────────────────────────────────────────
        // STEP 2: Mixin 부트스트랩
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 2: Bootstrapping Mixin subsystem...");

        MixinBootstrap.init();

        // 부트스트랩 직후 phase 확인
        MixinEnvironment env = MixinEnvironment.getDefaultEnvironment();
        System.out.println("[Pulse]   - Default Environment: " + env);
        System.out.println("[Pulse]   - Side: " + env.getSide());
        System.out.println("[Pulse]   - Phase (after init): " + env.getPhase());

        // Phase가 DEFAULT면 config 등록이 안 될 수 있음
        // gotoPhase로 PREINIT 상태로 되돌리기 시도
        try {
            var currentPhase = env.getPhase();
            System.out.println("[Pulse]   - Current phase: " + currentPhase);
            System.out.println("[Pulse]   - Attempting to check/set phase for config registration...");

            // MixinEnvironment.Phase.PREINIT 또는 INIT에서만 config 등록 가능
            // Reflection으로 phase 상태 확인
            var phaseField = MixinEnvironment.class.getDeclaredField("currentPhase");
            phaseField.setAccessible(true);
            System.out.println("[Pulse]   - Internal currentPhase: " + phaseField.get(null));
        } catch (Exception e) {
            System.out.println("[Pulse]   - Could not inspect phase field: " + e.getMessage());
        }

        System.out.println("[Pulse] Step 2: Complete");

        // ─────────────────────────────────────────────────────────────
        // STEP 2.5: Mixin 내부 상태 확인
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 2.5: Checking Mixin internal state...");
        try {
            // MixinEnvironment 상태
            var mixinEnv = MixinEnvironment.getDefaultEnvironment();
            System.out.println("[Pulse]   - Environment: " + mixinEnv);
            System.out.println("[Pulse]   - Phase: " + mixinEnv.getPhase());
            System.out.println("[Pulse]   - Side: " + mixinEnv.getSide());

            // Mixin Service 확인
            var service = org.spongepowered.asm.service.MixinService.getService();
            System.out.println("[Pulse]   - Active Service: " + service.getName());
            System.out.println("[Pulse]   - Service Class: " + service.getClass().getName());

            // 리소스 로딩 테스트
            var testStream = service.getResourceAsStream("mixins.pulse.json");
            System.out
                    .println("[Pulse]   - Service.getResourceAsStream(): " + (testStream != null ? "OK" : "FAILED"));
            if (testStream != null) {
                // 내용 읽어보기
                byte[] bytes = testStream.readAllBytes();
                System.out.println("[Pulse]   - Config file size: " + bytes.length + " bytes");
                System.out.println(
                        "[Pulse]   - Config content preview: " + new String(bytes, 0, Math.min(200, bytes.length)));
                testStream.close();
            }
        } catch (Throwable t) {
            System.err.println("[Pulse]   - Error checking state: " + t.getMessage());
            t.printStackTrace();
        }

        // ─────────────────────────────────────────────────────────────
        // STEP 3: Mixin Config 등록
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 3: Registering Mixin configurations...");

        // Config 파일 존재 확인
        try {
            var configStream = PulseAgent.class.getClassLoader().getResourceAsStream("mixins.pulse.json");
            if (configStream != null) {
                System.out.println("[Pulse]   - Found: mixins.pulse.json");
                configStream.close();
            } else {
                System.err.println("[Pulse]   - WARNING: mixins.pulse.json not found in classpath!");
            }
        } catch (Exception e) {
            System.err.println("[Pulse]   - Error checking config file: " + e.getMessage());
        }

        try {
            System.out.println("[Pulse]   - Calling Mixins.addConfiguration()...");

            // 먼저 현재 등록된 config 수 확인
            int beforeCount = Mixins.getConfigs().size();
            System.out.println("[Pulse]   - Configs before: " + beforeCount);

            Mixins.addConfiguration("mixins.pulse.json");

            int afterCount = Mixins.getConfigs().size();
            System.out.println("[Pulse]   - Configs after: " + afterCount);

            if (afterCount == beforeCount) {
                System.err.println("[Pulse]   - WARNING: Config was not added! Trying alternative method...");

                // 대안: MixinConfig.create()를 직접 호출 시도
                try {
                    Class<?> mixinConfigClass = Class.forName("org.spongepowered.asm.mixin.transformer.MixinConfig");
                    var createMethod = mixinConfigClass.getDeclaredMethod("create", String.class,
                            MixinEnvironment.class);
                    createMethod.setAccessible(true);

                    var config = createMethod.invoke(null, "mixins.pulse.json",
                            MixinEnvironment.getDefaultEnvironment());
                    System.out.println("[Pulse]   - Direct MixinConfig.create() result: " + config);

                    if (config != null) {
                        // MixinProcessor나 관련 클래스에 직접 등록 시도
                        System.out.println("[Pulse]   - Config created successfully: " + config);
                    }
                } catch (Exception ex) {
                    System.err.println("[Pulse]   - Alternative method failed: " + ex.getMessage());
                    ex.printStackTrace();
                }
            }

            System.out.println("[Pulse]   - addConfiguration() completed");
        } catch (Throwable t) {
            System.err.println("[Pulse]   - ERROR in addConfiguration(): " + t.getClass().getName());
            System.err.println("[Pulse]   - Message: " + t.getMessage());
            t.printStackTrace();
        }

        // 등록된 config 수 확인
        try {
            System.out.println("[Pulse]   - Calling Mixins.getConfigs()...");
            var configs = Mixins.getConfigs();
            System.out.println("[Pulse]   - Registered configs: " + (configs != null ? configs.size() : "null"));

            if (configs != null) {
                for (var config : configs) {
                    System.out.println("[Pulse]   - Config: " + config);
                }
            }
        } catch (Throwable t) {
            System.err.println("[Pulse]   - ERROR in getConfigs(): " + t.getClass().getName());
            System.err.println("[Pulse]   - Message: " + t.getMessage());
            t.printStackTrace();
        }

        System.out.println("[Pulse] Step 3: Complete");

        // ─────────────────────────────────────────────────────────────
        // STEP 4: Mixin Transformer 획득 대기
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 4: Waiting for Mixin transformer...");

        // PulseMixinService.offer()가 호출되면 transformer가 설정됨
        // 짧은 대기 후 확인
        IMixinTransformer mixinTransformer = null;

        for (int i = 0; i < 10; i++) {
            mixinTransformer = PulseEnvironment.getMixinTransformer();
            if (mixinTransformer != null) {
                break;
            }
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                break;
            }
        }

        if (mixinTransformer != null) {
            System.out.println("[Pulse]   - Mixin Transformer acquired: " +
                    mixinTransformer.getClass().getName());
        } else {
            System.err.println("[Pulse]   - WARNING: Mixin Transformer not available!");
            System.err.println("[Pulse]   - Mixins may not be applied correctly.");
        }

        System.out.println("[Pulse] Step 4: Complete");

        // ─────────────────────────────────────────────────────────────
        // STEP 5: Class Transformer 등록
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 5: Registering class transformer...");

        classTransformer = new PulseClassTransformer();

        // Mixin transformer 연결
        if (mixinTransformer != null) {
            classTransformer.connectMixinTransformer(mixinTransformer);
        }

        // Instrumentation에 등록 (canRetransform=true)
        inst.addTransformer(classTransformer, true);

        System.out.println("[Pulse]   - Transformer registered with Instrumentation");
        System.out.println("[Pulse] Step 5: Complete");

        // ─────────────────────────────────────────────────────────────
        // STEP 6: 초기화 완료
        // ─────────────────────────────────────────────────────────────
        PulseEnvironment.markInitialized();

        // ─────────────────────────────────────────────────────────────
        // STEP 6.5: Optimization Extensions 초기화 (v1.0.1)
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 6.5: Initializing optimization extensions...");
        try {
            // CapabilityFlags 초기화
            com.pulse.api.CapabilityFlags.initialize();

            // OptimizationPointRegistry 초기화
            com.pulse.api.optimization.OptimizationPointRegistry.initialize();

            // SafeGameAccess 메인 스레드 설정
            com.pulse.api.SafeGameAccess.setMainThread(Thread.currentThread());

            System.out.println("[Pulse] Step 6.5: Complete");
        } catch (Throwable t) {
            System.err.println("[Pulse] Step 6.5: Optimization extensions init error (non-fatal)");
            t.printStackTrace();
        }

        System.out.println();
        System.out.println("[Pulse] ════════════════════════════════════════════════════");
        System.out.println("[Pulse] CORE INITIALIZATION COMPLETE");
        System.out.println("[Pulse] ════════════════════════════════════════════════════");
        System.out.println();

        // ─────────────────────────────────────────────────────────────
        // STEP 7: 모드 로더 초기화
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 7: Initializing mod loader...");

        try {
            com.pulse.mod.ModLoader modLoader = com.pulse.mod.ModLoader.getInstance();

            // 모드 발견
            modLoader.discoverMods();

            // 의존성 해결
            modLoader.resolveDependencies();

            // 모드 Mixin 등록
            modLoader.registerMixins();

            System.out.println("[Pulse] Step 7: Complete");
        } catch (Throwable t) {
            System.err.println("[Pulse] Step 7: Mod loader error (non-fatal)");
            t.printStackTrace();
        }

        System.out.println();
        System.out.println("[Pulse] ════════════════════════════════════════════════════");
        System.out.println("[Pulse] Pulse FULLY INITIALIZED");
        System.out.println("[Pulse] Waiting for zombie.* classes to load...");
        System.out.println("[Pulse] ════════════════════════════════════════════════════");
        System.out.println();

        // 환경 상태 출력
        PulseEnvironment.printStatus();

        // 디버그: 지연 체크
        startDebugMonitor();
    }

    /**
     * 디버그용 모니터링 스레드
     * 첫 zombie 클래스 로딩과 mixin 적용을 확인
     */
    private static void startDebugMonitor() {
        new Thread(() -> {
            System.out.println("[Pulse/Debug] Monitor thread started");

            // 게임 클래스 로더가 등록될 때까지 대기
            int waitCount = 0;
            while (PulseEnvironment.getGameClassLoader() == null && waitCount < 300) {
                try {
                    Thread.sleep(100);
                    waitCount++;
                } catch (InterruptedException e) {
                    break;
                }
            }

            if (PulseEnvironment.getGameClassLoader() != null) {
                System.out.println("[Pulse/Debug] Game ClassLoader detected after " +
                        (waitCount * 100) + "ms");
                System.out.println("[Pulse/Debug] ClassLoader: " +
                        PulseEnvironment.getGameClassLoader());

                // 모드 초기화 (게임 클래스 로더 감지 후)
                try {
                    System.out.println("[Pulse/Debug] Initializing mods...");
                    com.pulse.mod.ModLoader.getInstance().initializeMods();
                } catch (Throwable t) {
                    System.err.println("[Pulse/Debug] Mod initialization error:");
                    t.printStackTrace();
                }
            } else {
                System.err.println("[Pulse/Debug] WARNING: Game ClassLoader not detected after 30s");
            }

            // Mixin 적용 상태 확인
            if (classTransformer != null) {
                try {
                    Thread.sleep(5000); // 5초 더 대기
                    var transformed = classTransformer.getTransformedClasses();
                    System.out.println("[Pulse/Debug] Transformed classes: " + transformed.size());
                    for (String cls : transformed) {
                        System.out.println("[Pulse/Debug]   - " + cls);
                    }
                } catch (InterruptedException e) {
                    // ignore
                }
            }
        }, "Pulse-Debug-Monitor").start();
    }

    public static Instrumentation getInstrumentation() {
        return instrumentation;
    }

    public static PulseClassTransformer getClassTransformer() {
        return classTransformer;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\PulseAgent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\PulseEnvironment.java =====

package com.pulse;

import org.spongepowered.asm.mixin.transformer.IMixinTransformer;

/**
 * Pulse 전역 환경 상태 관리.
 * 
 * 다양한 컴포넌트 간에 공유되는 상태를 보관:
 * - Game ClassLoader
 * - Mixin Transformer
 * - Instrumentation 인스턴스
 * - 기타 환경 설정
 */
public class PulseEnvironment {

    private static ClassLoader gameClassLoader;
    private static IMixinTransformer mixinTransformer;
    private static java.lang.instrument.Instrumentation instrumentation;
    
    private static boolean initialized = false;
    private static boolean mixinReady = false;

    // ================= Game ClassLoader =================

    public static void setGameClassLoader(ClassLoader cl) {
        if (gameClassLoader == null && cl != null) {
            gameClassLoader = cl;
            System.out.println("[Pulse/Env] Game ClassLoader registered: " + cl);
            System.out.println("[Pulse/Env] ClassLoader class: " + cl.getClass().getName());
        }
    }

    public static ClassLoader getGameClassLoader() {
        return gameClassLoader;
    }

    // ================= Mixin Transformer =================

    public static void setMixinTransformer(IMixinTransformer transformer) {
        if (mixinTransformer == null && transformer != null) {
            mixinTransformer = transformer;
            mixinReady = true;
            System.out.println("[Pulse/Env] Mixin Transformer registered: " + 
                transformer.getClass().getName());
        }
    }

    public static IMixinTransformer getMixinTransformer() {
        return mixinTransformer;
    }

    public static boolean isMixinReady() {
        return mixinReady;
    }

    // ================= Instrumentation =================

    public static void setInstrumentation(java.lang.instrument.Instrumentation inst) {
        instrumentation = inst;
        System.out.println("[Pulse/Env] Instrumentation registered");
    }

    public static java.lang.instrument.Instrumentation getInstrumentation() {
        return instrumentation;
    }

    // ================= Lifecycle =================

    public static void markInitialized() {
        initialized = true;
        System.out.println("[Pulse/Env] Environment marked as initialized");
    }

    public static boolean isInitialized() {
        return initialized;
    }

    // ================= Debug Info =================

    public static void printStatus() {
        System.out.println("==================================================");
        System.out.println("[Pulse/Env] STATUS REPORT");
        System.out.println("  Initialized: " + initialized);
        System.out.println("  Game ClassLoader: " + (gameClassLoader != null ? gameClassLoader : "NOT SET"));
        System.out.println("  Mixin Ready: " + mixinReady);
        System.out.println("  Mixin Transformer: " + (mixinTransformer != null ? "SET" : "NOT SET"));
        System.out.println("  Instrumentation: " + (instrumentation != null ? "SET" : "NOT SET"));
        System.out.println("==================================================");
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\PulseEnvironment.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\registry\DeferredRegister.java =====

package com.pulse.registry;

import java.util.*;
import java.util.function.Supplier;

/**
 * 지연 등록 헬퍼.
 * NeoForge의 DeferredRegister와 유사한 개념.
 * 모드 초기화 시점에 등록을 수집하고, 나중에 실제 레지스트리에 커밋.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 모드 클래스에서
 * public static final DeferredRegister<MyItem> ITEMS = DeferredRegister.create("mymod", MyRegistries.ITEMS);
 * 
 * public static final RegistryEntry<MyItem> COOL_ITEM = ITEMS.register("cool_item", MyCoolItem::new);
 * 
 * // 초기화 시
 * ITEMS.registerAll();
 * </pre>
 * 
 * @param <T> 등록할 객체 타입
 */
public class DeferredRegister<T> {

    private final String modId;
    private final Registry<T> registry;
    private final List<PendingEntry<T>> pendingEntries = new ArrayList<>();
    private boolean committed = false;

    private DeferredRegister(String modId, Registry<T> registry) {
        this.modId = modId;
        this.registry = registry;
    }

    /**
     * DeferredRegister 생성
     */
    public static <T> DeferredRegister<T> create(String modId, Registry<T> registry) {
        return new DeferredRegister<>(modId, registry);
    }

    /**
     * 레지스트리 ID로 DeferredRegister 생성
     */
    public static <T> DeferredRegister<T> create(String modId, Identifier registryId) {
        Registry<T> registry = Registry.getRegistry(registryId);
        if (registry == null) {
            throw new IllegalArgumentException("Registry not found: " + registryId);
        }
        return new DeferredRegister<>(modId, registry);
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 객체 등록 (지연)
     */
    public RegistryEntry<T> register(String name, Supplier<T> supplier) {
        if (committed) {
            throw new IllegalStateException("DeferredRegister already committed");
        }

        Identifier id = Identifier.of(modId, name);
        RegistryEntry<T> entry = new RegistryEntry<>(id, registry);
        pendingEntries.add(new PendingEntry<>(id, supplier, entry));

        return entry;
    }

    /**
     * 이미 생성된 객체 등록
     */
    public RegistryEntry<T> register(String name, T value) {
        return register(name, () -> value);
    }

    // ─────────────────────────────────────────────────────────────
    // 커밋
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 대기 중인 등록을 레지스트리에 커밋
     */
    public void registerAll() {
        if (committed) {
            return;
        }

        for (PendingEntry<T> pending : pendingEntries) {
            T value = pending.supplier.get();
            registry.register(pending.id, value);
            pending.entry.setValue(value);
        }

        committed = true;
        System.out.println("[Pulse/Registry] Committed " + pendingEntries.size() +
                " entries from " + modId + " to " + registry.getRegistryId());
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    public String getModId() {
        return modId;
    }

    public Registry<T> getRegistry() {
        return registry;
    }

    public int getPendingCount() {
        return pendingEntries.size();
    }

    public boolean isCommitted() {
        return committed;
    }

    /**
     * 등록된 모든 엔트리 가져오기
     */
    public List<RegistryEntry<T>> getEntries() {
        List<RegistryEntry<T>> entries = new ArrayList<>();
        for (PendingEntry<T> pending : pendingEntries) {
            entries.add(pending.entry);
        }
        return entries;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    private static class PendingEntry<T> {
        final Identifier id;
        final Supplier<T> supplier;
        final RegistryEntry<T> entry;

        PendingEntry(Identifier id, Supplier<T> supplier, RegistryEntry<T> entry) {
            this.id = id;
            this.supplier = supplier;
            this.entry = entry;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\registry\DeferredRegister.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\registry\Identifier.java =====

package com.pulse.registry;

import java.util.Objects;

/**
 * 리소스 식별자.
 * 네임스페이스:경로 형식 (예: "mymod:my_item")
 * Minecraft의 ResourceLocation과 동일한 개념.
 */
public final class Identifier {

    public static final String DEFAULT_NAMESPACE = "Pulse";
    public static final char SEPARATOR = ':';

    private final String namespace;
    private final String path;

    private Identifier(String namespace, String path) {
        this.namespace = namespace;
        this.path = path;
    }

    /**
     * 식별자 생성
     */
    public static Identifier of(String namespace, String path) {
        validateNamespace(namespace);
        validatePath(path);
        return new Identifier(namespace, path);
    }

    /**
     * 문자열에서 파싱
     * "namespace:path" 또는 "path" (기본 네임스페이스 사용)
     */
    public static Identifier parse(String id) {
        if (id == null || id.isEmpty()) {
            throw new IllegalArgumentException("Identifier cannot be null or empty");
        }

        int colonIndex = id.indexOf(SEPARATOR);
        if (colonIndex < 0) {
            // 네임스페이스 없음 - 기본 사용
            return of(DEFAULT_NAMESPACE, id);
        }

        String namespace = id.substring(0, colonIndex);
        String path = id.substring(colonIndex + 1);
        return of(namespace, path);
    }

    /**
     * 모드 ID로 네임스페이스 지정하여 생성
     */
    public static Identifier mod(String modId, String path) {
        return of(modId, path);
    }

    // ─────────────────────────────────────────────────────────────
    // 유효성 검사
    // ─────────────────────────────────────────────────────────────

    private static void validateNamespace(String namespace) {
        if (namespace == null || namespace.isEmpty()) {
            throw new IllegalArgumentException("Namespace cannot be null or empty");
        }
        if (!isValidNamespace(namespace)) {
            throw new IllegalArgumentException("Invalid namespace: " + namespace);
        }
    }

    private static void validatePath(String path) {
        if (path == null || path.isEmpty()) {
            throw new IllegalArgumentException("Path cannot be null or empty");
        }
        if (!isValidPath(path)) {
            throw new IllegalArgumentException("Invalid path: " + path);
        }
    }

    /**
     * 네임스페이스 유효성 (a-z, 0-9, _, -)
     */
    public static boolean isValidNamespace(String namespace) {
        for (char c : namespace.toCharArray()) {
            if (!(c >= 'a' && c <= 'z') &&
                    !(c >= '0' && c <= '9') &&
                    c != '_' && c != '-') {
                return false;
            }
        }
        return true;
    }

    /**
     * 경로 유효성 (a-z, 0-9, _, -, ., /)
     */
    public static boolean isValidPath(String path) {
        for (char c : path.toCharArray()) {
            if (!(c >= 'a' && c <= 'z') &&
                    !(c >= '0' && c <= '9') &&
                    c != '_' && c != '-' && c != '.' && c != '/') {
                return false;
            }
        }
        return true;
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public String getNamespace() {
        return namespace;
    }

    public String getPath() {
        return path;
    }

    /**
     * 전체 문자열 (namespace:path)
     */
    @Override
    public String toString() {
        return namespace + SEPARATOR + path;
    }

    /**
     * 파일 경로 형식 (namespace/path)
     */
    public String toFilePath() {
        return namespace + "/" + path;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Identifier that = (Identifier) o;
        return namespace.equals(that.namespace) && path.equals(that.path);
    }

    @Override
    public int hashCode() {
        return Objects.hash(namespace, path);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\registry\Identifier.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\registry\Registry.java =====

package com.pulse.registry;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 범용 레지스트리.
 * 특정 타입의 객체를 식별자로 등록하고 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 레지스트리 생성
 * Registry<MyItem> ITEMS = Registry.create(Identifier.of("mymod", "items"));
 * 
 * // 등록
 * ITEMS.register(Identifier.of("mymod", "cool_item"), new MyCoolItem());
 * 
 * // 조회
 * MyItem item = ITEMS.get(Identifier.of("mymod", "cool_item"));
 * </pre>
 * 
 * @param <T> 레지스트리에 저장할 객체 타입
 */
public class Registry<T> {

    private final Identifier registryId;
    private final Map<Identifier, T> entries = new ConcurrentHashMap<>();
    private final Map<Identifier, Supplier<T>> deferredEntries = new ConcurrentHashMap<>();
    private boolean frozen = false;

    // 글로벌 레지스트리 목록
    private static final Map<Identifier, Registry<?>> REGISTRIES = new ConcurrentHashMap<>();

    private Registry(Identifier registryId) {
        this.registryId = registryId;
    }

    /**
     * 새 레지스트리 생성
     */
    public static <T> Registry<T> create(Identifier registryId) {
        if (REGISTRIES.containsKey(registryId)) {
            throw new IllegalStateException("Registry already exists: " + registryId);
        }

        Registry<T> registry = new Registry<>(registryId);
        REGISTRIES.put(registryId, registry);

        System.out.println("[Pulse/Registry] Created registry: " + registryId);
        return registry;
    }

    /**
     * 기존 레지스트리 가져오기
     */
    @SuppressWarnings("unchecked")
    public static <T> Registry<T> getRegistry(Identifier registryId) {
        return (Registry<T>) REGISTRIES.get(registryId);
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 객체 등록
     */
    public T register(Identifier id, T value) {
        if (frozen) {
            throw new IllegalStateException("Registry is frozen: " + registryId);
        }
        if (entries.containsKey(id)) {
            throw new IllegalArgumentException("Duplicate entry: " + id);
        }

        entries.put(id, value);
        System.out.println("[Pulse/Registry] Registered " + registryId + " -> " + id);
        return value;
    }

    /**
     * 문자열 ID로 등록
     */
    public T register(String id, T value) {
        return register(Identifier.parse(id), value);
    }

    /**
     * 지연 등록 (Supplier 사용)
     * 실제 객체는 freeze 시점에 생성됨
     */
    public void registerDeferred(Identifier id, Supplier<T> supplier) {
        if (frozen) {
            throw new IllegalStateException("Registry is frozen: " + registryId);
        }
        deferredEntries.put(id, supplier);
    }

    // ─────────────────────────────────────────────────────────────
    // 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * ID로 객체 가져오기
     */
    public T get(Identifier id) {
        return entries.get(id);
    }

    /**
     * 문자열 ID로 가져오기
     */
    public T get(String id) {
        return get(Identifier.parse(id));
    }

    /**
     * ID로 Optional 가져오기
     */
    public Optional<T> getOptional(Identifier id) {
        return Optional.ofNullable(entries.get(id));
    }

    /**
     * ID 존재 여부 확인
     */
    public boolean contains(Identifier id) {
        return entries.containsKey(id);
    }

    /**
     * 객체의 ID 가져오기 (역방향 조회)
     */
    public Optional<Identifier> getId(T value) {
        for (Map.Entry<Identifier, T> entry : entries.entrySet()) {
            if (entry.getValue().equals(value)) {
                return Optional.of(entry.getKey());
            }
        }
        return Optional.empty();
    }

    // ─────────────────────────────────────────────────────────────
    // 반복
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 ID
     */
    public Set<Identifier> getIds() {
        return Collections.unmodifiableSet(entries.keySet());
    }

    /**
     * 모든 값
     */
    public Collection<T> getValues() {
        return Collections.unmodifiableCollection(entries.values());
    }

    /**
     * 모든 엔트리
     */
    public Set<Map.Entry<Identifier, T>> getEntries() {
        return Collections.unmodifiableSet(entries.entrySet());
    }

    /**
     * 등록된 항목 수
     */
    public int size() {
        return entries.size();
    }

    public boolean isEmpty() {
        return entries.isEmpty();
    }

    // ─────────────────────────────────────────────────────────────
    // 레지스트리 잠금
    // ─────────────────────────────────────────────────────────────

    /**
     * 레지스트리 잠금 (더 이상 등록 불가)
     * 지연 등록된 항목들이 이 시점에 생성됨
     */
    public void freeze() {
        if (frozen)
            return;

        // 지연 등록 처리
        for (Map.Entry<Identifier, Supplier<T>> entry : deferredEntries.entrySet()) {
            T value = entry.getValue().get();
            entries.put(entry.getKey(), value);
        }
        deferredEntries.clear();

        frozen = true;
        System.out.println("[Pulse/Registry] Frozen " + registryId + " with " + entries.size() + " entries");
    }

    public boolean isFrozen() {
        return frozen;
    }

    public Identifier getRegistryId() {
        return registryId;
    }

    /**
     * 모든 레지스트리 잠금
     */
    public static void freezeAll() {
        for (Registry<?> registry : REGISTRIES.values()) {
            registry.freeze();
        }
    }

    /**
     * 모든 레지스트리 가져오기
     */
    public static Collection<Registry<?>> getAllRegistries() {
        return Collections.unmodifiableCollection(REGISTRIES.values());
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\registry\Registry.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\registry\RegistryEntry.java =====

package com.pulse.registry;

/**
 * 레지스트리 엔트리 참조.
 * DeferredRegister에서 반환되어 나중에 실제 값에 접근할 수 있게 함.
 * 
 * @param <T> 등록된 객체 타입
 */
public class RegistryEntry<T> {

    private final Identifier id;
    private final Registry<T> registry;
    private T value;
    private boolean resolved = false;

    RegistryEntry(Identifier id, Registry<T> registry) {
        this.id = id;
        this.registry = registry;
    }

    /**
     * 등록된 값 가져오기
     */
    public T get() {
        if (!resolved) {
            // 아직 커밋되지 않은 경우 레지스트리에서 조회 시도
            T fromRegistry = registry.get(id);
            if (fromRegistry != null) {
                this.value = fromRegistry;
                this.resolved = true;
            }
        }

        if (value == null && !resolved) {
            throw new IllegalStateException("Registry entry not yet available: " + id);
        }

        return value;
    }

    /**
     * 값이 이미 해결되었는지 확인
     */
    public boolean isResolved() {
        return resolved || registry.contains(id);
    }

    /**
     * 식별자 가져오기
     */
    public Identifier getId() {
        return id;
    }

    /**
     * 레지스트리 가져오기
     */
    public Registry<T> getRegistry() {
        return registry;
    }

    // 내부 사용
    void setValue(T value) {
        this.value = value;
        this.resolved = true;
    }

    @Override
    public String toString() {
        return "RegistryEntry[" + id + "]";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\registry\RegistryEntry.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\resource\I18n.java =====

package com.pulse.resource;

import com.pulse.registry.Identifier;

import java.util.*;

/**
 * 번역/다국어 지원.
 * 모드의 번역 문자열을 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 번역 로드
 * I18n.loadLanguage("mymod", "ko_kr");
 * 
 * // 번역 사용
 * String text = I18n.translate("mymod.item.cool_item.name");
 * String formatted = I18n.translate("mymod.message.welcome", playerName);
 * </pre>
 */
public class I18n {

    private static final I18n INSTANCE = new I18n();

    // 현재 언어
    private String currentLanguage = "en_us";

    // 로드된 번역 (modId -> key -> translation)
    private final Map<String, Map<String, String>> translations = new HashMap<>();

    // 폴백 번역 (영어)
    private final Map<String, Map<String, String>> fallback = new HashMap<>();

    private I18n() {
    }

    public static I18n getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 언어 설정
    // ─────────────────────────────────────────────────────────────

    /**
     * 현재 언어 설정
     */
    public static void setLanguage(String language) {
        INSTANCE.currentLanguage = language.toLowerCase();
        INSTANCE.reloadAllTranslations();
    }

    /**
     * 현재 언어 가져오기
     */
    public static String getLanguage() {
        return INSTANCE.currentLanguage;
    }

    // ─────────────────────────────────────────────────────────────
    // 번역 로드
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드의 번역 파일 로드
     */
    public static void loadLanguage(String modId, String language) {
        INSTANCE.loadTranslations(modId, language, false);
    }

    /**
     * 모드의 현재 언어 번역 로드
     */
    public static void loadLanguage(String modId) {
        INSTANCE.loadTranslations(modId, INSTANCE.currentLanguage, false);
        // 폴백으로 영어도 로드
        if (!INSTANCE.currentLanguage.equals("en_us")) {
            INSTANCE.loadTranslations(modId, "en_us", true);
        }
    }

    private void loadTranslations(String modId, String language, boolean isFallback) {
        Identifier langId = Identifier.of(modId, "lang/" + language + ".json");
        String json = ResourceLoader.loadString(langId);

        if (json == null) {
            // .properties 파일도 시도
            langId = Identifier.of(modId, "lang/" + language + ".properties");
            Properties props = ResourceLoader.loadProperties(langId);
            if (props != null) {
                Map<String, String> map = new HashMap<>();
                for (String key : props.stringPropertyNames()) {
                    map.put(key, props.getProperty(key));
                }
                if (isFallback) {
                    fallback.put(modId, map);
                } else {
                    translations.put(modId, map);
                }
                return;
            }
            return;
        }

        // JSON 파싱 (간단한 구현)
        Map<String, String> map = parseSimpleJson(json);
        if (isFallback) {
            fallback.put(modId, map);
        } else {
            translations.put(modId, map);
        }
    }

    private Map<String, String> parseSimpleJson(String json) {
        Map<String, String> result = new HashMap<>();
        // 간단한 JSON 파싱 ({"key": "value"} 형식)
        json = json.trim();
        if (json.startsWith("{") && json.endsWith("}")) {
            json = json.substring(1, json.length() - 1);
            String[] pairs = json.split(",");
            for (String pair : pairs) {
                int colonIdx = pair.indexOf(':');
                if (colonIdx > 0) {
                    String key = pair.substring(0, colonIdx).trim();
                    String value = pair.substring(colonIdx + 1).trim();
                    // 따옴표 제거
                    key = stripQuotes(key);
                    value = stripQuotes(value);
                    result.put(key, value);
                }
            }
        }
        return result;
    }

    private String stripQuotes(String s) {
        if ((s.startsWith("\"") && s.endsWith("\"")) ||
                (s.startsWith("'") && s.endsWith("'"))) {
            return s.substring(1, s.length() - 1);
        }
        return s;
    }

    private void reloadAllTranslations() {
        Set<String> modIds = new HashSet<>(translations.keySet());
        translations.clear();
        for (String modId : modIds) {
            loadLanguage(modId);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 번역 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * 키를 번역
     */
    public static String translate(String key) {
        return INSTANCE.getTranslation(key);
    }

    /**
     * 키를 번역하고 포맷팅
     */
    public static String translate(String key, Object... args) {
        String translation = INSTANCE.getTranslation(key);
        if (args.length > 0) {
            try {
                return String.format(translation, args);
            } catch (Exception e) {
                return translation;
            }
        }
        return translation;
    }

    /**
     * 번역이 존재하는지 확인
     */
    public static boolean hasTranslation(String key) {
        return INSTANCE.translationExists(key);
    }

    private String getTranslation(String key) {
        // modId 추출 시도
        String modId = extractModId(key);

        // 현재 언어에서 찾기
        Map<String, String> modTranslations = translations.get(modId);
        if (modTranslations != null && modTranslations.containsKey(key)) {
            return modTranslations.get(key);
        }

        // 폴백에서 찾기
        Map<String, String> modFallback = fallback.get(modId);
        if (modFallback != null && modFallback.containsKey(key)) {
            return modFallback.get(key);
        }

        // 번역 없음 - 키 반환
        return key;
    }

    private boolean translationExists(String key) {
        String modId = extractModId(key);
        Map<String, String> modTranslations = translations.get(modId);
        if (modTranslations != null && modTranslations.containsKey(key)) {
            return true;
        }
        Map<String, String> modFallback = fallback.get(modId);
        return modFallback != null && modFallback.containsKey(key);
    }

    private String extractModId(String key) {
        int dotIdx = key.indexOf('.');
        if (dotIdx > 0) {
            return key.substring(0, dotIdx);
        }
        return "Pulse";
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\resource\I18n.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\resource\ResourceLoader.java =====

package com.pulse.resource;

import com.pulse.registry.Identifier;

import java.io.*;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

/**
 * 리소스 로더.
 * 모드 JAR 및 리소스 팩에서 리소스를 로드.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 텍스처 로드
 * InputStream tex = ResourceLoader.getResource(
 *         Identifier.of("mymod", "textures/item/cool_item.png"));
 * 
 * // JSON 데이터 로드
 * String json = ResourceLoader.loadString(
 *         Identifier.of("mymod", "data/items.json"));
 * 
 * // 번역 파일 로드
 * Properties lang = ResourceLoader.loadProperties(
 *         Identifier.of("mymod", "lang/ko_kr.properties"));
 * </pre>
 */
public class ResourceLoader {

    private static final ResourceLoader INSTANCE = new ResourceLoader();

    // 등록된 리소스 소스
    private final List<ResourceSource> sources = new ArrayList<>();

    // 리소스 캐시
    private final Map<Identifier, byte[]> cache = new ConcurrentHashMap<>();
    private boolean cacheEnabled = true;

    private ResourceLoader() {
    }

    public static ResourceLoader getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 리소스 소스 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * JAR 파일을 리소스 소스로 추가
     */
    public static void addJarSource(Path jarPath) {
        INSTANCE.registerJarSource(jarPath);
    }

    /**
     * 디렉토리를 리소스 소스로 추가
     */
    public static void addDirectorySource(Path directory) {
        INSTANCE.registerDirectorySource(directory);
    }

    /**
     * 클래스로더를 리소스 소스로 추가
     */
    public static void addClassLoaderSource(ClassLoader classLoader, String namespace) {
        INSTANCE.registerClassLoaderSource(classLoader, namespace);
    }

    private void registerJarSource(Path jarPath) {
        sources.add(new JarResourceSource(jarPath));
        System.out.println("[Pulse/Resource] Added JAR source: " + jarPath.getFileName());
    }

    private void registerDirectorySource(Path directory) {
        sources.add(new DirectoryResourceSource(directory));
        System.out.println("[Pulse/Resource] Added directory source: " + directory);
    }

    private void registerClassLoaderSource(ClassLoader classLoader, String namespace) {
        sources.add(new ClassLoaderResourceSource(classLoader, namespace));
        System.out.println("[Pulse/Resource] Added classloader source for: " + namespace);
    }

    // ─────────────────────────────────────────────────────────────
    // 리소스 로드
    // ─────────────────────────────────────────────────────────────

    /**
     * 리소스를 InputStream으로 가져오기
     */
    public static InputStream getResource(Identifier id) {
        return INSTANCE.loadResource(id);
    }

    /**
     * 리소스를 문자열로 로드
     */
    public static String loadString(Identifier id) {
        byte[] data = INSTANCE.loadBytesInternal(id);
        if (data == null)
            return null;
        return new String(data, StandardCharsets.UTF_8);
    }

    /**
     * 리소스를 바이트 배열로 로드
     */
    public static byte[] loadBytes(Identifier id) {
        return INSTANCE.loadBytesInternal(id);
    }

    /**
     * Properties 파일 로드
     */
    public static Properties loadProperties(Identifier id) {
        try (InputStream is = getResource(id)) {
            if (is == null)
                return null;
            Properties props = new Properties();
            props.load(is);
            return props;
        } catch (IOException e) {
            System.err.println("[Pulse/Resource] Failed to load properties: " + id);
            return null;
        }
    }

    /**
     * 리소스 존재 여부 확인
     */
    public static boolean exists(Identifier id) {
        return INSTANCE.resourceExists(id);
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 구현
    // ─────────────────────────────────────────────────────────────

    private InputStream loadResource(Identifier id) {
        byte[] data = loadBytesInternal(id);
        if (data == null)
            return null;
        return new ByteArrayInputStream(data);
    }

    private byte[] loadBytesInternal(Identifier id) {
        // 캐시 확인
        if (cacheEnabled && cache.containsKey(id)) {
            return cache.get(id);
        }

        // 소스에서 로드
        for (ResourceSource source : sources) {
            byte[] data = source.load(id);
            if (data != null) {
                if (cacheEnabled) {
                    cache.put(id, data);
                }
                return data;
            }
        }

        return null;
    }

    private boolean resourceExists(Identifier id) {
        if (cacheEnabled && cache.containsKey(id)) {
            return true;
        }
        for (ResourceSource source : sources) {
            if (source.exists(id)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 캐시 비우기
     */
    public static void clearCache() {
        INSTANCE.cache.clear();
    }

    public static void setCacheEnabled(boolean enabled) {
        INSTANCE.cacheEnabled = enabled;
    }

    // ─────────────────────────────────────────────────────────────
    // 리소스 소스 인터페이스 및 구현
    // ─────────────────────────────────────────────────────────────

    interface ResourceSource {
        byte[] load(Identifier id);

        boolean exists(Identifier id);
    }

    static class JarResourceSource implements ResourceSource {
        private final Path jarPath;

        JarResourceSource(Path jarPath) {
            this.jarPath = jarPath;
        }

        @Override
        public byte[] load(Identifier id) {
            String path = "assets/" + id.getNamespace() + "/" + id.getPath();
            try (JarFile jar = new JarFile(jarPath.toFile())) {
                JarEntry entry = jar.getJarEntry(path);
                if (entry != null) {
                    try (InputStream is = jar.getInputStream(entry)) {
                        return is.readAllBytes();
                    }
                }
            } catch (IOException e) {
                // Ignore
            }
            return null;
        }

        @Override
        public boolean exists(Identifier id) {
            String path = "assets/" + id.getNamespace() + "/" + id.getPath();
            try (JarFile jar = new JarFile(jarPath.toFile())) {
                return jar.getJarEntry(path) != null;
            } catch (IOException e) {
                return false;
            }
        }
    }

    static class DirectoryResourceSource implements ResourceSource {
        private final Path baseDir;

        DirectoryResourceSource(Path baseDir) {
            this.baseDir = baseDir;
        }

        @Override
        public byte[] load(Identifier id) {
            Path file = baseDir.resolve("assets")
                    .resolve(id.getNamespace())
                    .resolve(id.getPath());
            if (Files.exists(file)) {
                try {
                    return Files.readAllBytes(file);
                } catch (IOException e) {
                    return null;
                }
            }
            return null;
        }

        @Override
        public boolean exists(Identifier id) {
            Path file = baseDir.resolve("assets")
                    .resolve(id.getNamespace())
                    .resolve(id.getPath());
            return Files.exists(file);
        }
    }

    static class ClassLoaderResourceSource implements ResourceSource {
        private final ClassLoader classLoader;
        private final String namespace;

        ClassLoaderResourceSource(ClassLoader classLoader, String namespace) {
            this.classLoader = classLoader;
            this.namespace = namespace;
        }

        @Override
        public byte[] load(Identifier id) {
            if (!id.getNamespace().equals(namespace)) {
                return null;
            }
            String path = "assets/" + id.getNamespace() + "/" + id.getPath();
            try (InputStream is = classLoader.getResourceAsStream(path)) {
                if (is != null) {
                    return is.readAllBytes();
                }
            } catch (IOException e) {
                // Ignore
            }
            return null;
        }

        @Override
        public boolean exists(Identifier id) {
            if (!id.getNamespace().equals(namespace)) {
                return false;
            }
            String path = "assets/" + id.getNamespace() + "/" + id.getPath();
            URL url = classLoader.getResource(path);
            return url != null;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\resource\ResourceLoader.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\scheduler\PulseScheduler.java =====

package com.pulse.scheduler;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Pulse 태스크 스케줄러.
 * 
 * 게임 틱 기반 태스크 스케줄링을 제공.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 60틱(약 3초) 후 1회 실행
 * TaskHandle handle = PulseScheduler.runLater(() -> {
 *     System.out.println("Hello!");
 * }, 60);
 * 
 * // 20틱마다 반복 실행
 * TaskHandle timer = PulseScheduler.runTimer(() -> {
 *     System.out.println("Tick!");
 * }, 20, 0);
 * 
 * // 취소
 * timer.cancel();
 * 
 * // 비동기 실행
 * PulseScheduler.runAsync(() -> {
 *     // 무거운 작업
 * });
 * </pre>
 */
public class PulseScheduler {

    private static final PulseScheduler INSTANCE = new PulseScheduler();

    // 현재 게임 틱
    private volatile long currentTick = 0;

    // 태스크 ID 생성기
    private final AtomicLong taskIdGenerator = new AtomicLong(0);

    // 스케줄된 태스크 목록
    private final List<ScheduledTask> tasks = new CopyOnWriteArrayList<>();

    // 메인 스레드에서 실행할 태스크 큐
    private final ConcurrentLinkedQueue<Runnable> syncQueue = new ConcurrentLinkedQueue<>();

    // 비동기 실행용 스레드 풀
    private final ExecutorService asyncExecutor = Executors.newCachedThreadPool(r -> {
        Thread t = new Thread(r, "Pulse-Async-" + taskIdGenerator.incrementAndGet());
        t.setDaemon(true);
        return t;
    });

    // 디버그 모드
    private boolean debug = false;

    private PulseScheduler() {
    }

    public static PulseScheduler getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 편의 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 지정된 틱 수 후에 1회 실행
     * 
     * @param task       실행할 태스크
     * @param delayTicks 지연 틱 수 (20틱 ≈ 1초)
     * @return 태스크 핸들
     */
    public static TaskHandle runLater(Runnable task, long delayTicks) {
        return INSTANCE.scheduleOnce(task, delayTicks, null);
    }

    /**
     * 지정된 틱 수 후에 1회 실행 (이름 지정)
     */
    public static TaskHandle runLater(Runnable task, long delayTicks, String name) {
        return INSTANCE.scheduleOnce(task, delayTicks, name);
    }

    /**
     * 지정된 간격으로 반복 실행
     * 
     * @param task        실행할 태스크
     * @param periodTicks 반복 간격 (틱)
     * @param delayTicks  첫 실행 전 지연 (틱)
     * @return 태스크 핸들
     */
    public static TaskHandle runTimer(Runnable task, long periodTicks, long delayTicks) {
        return INSTANCE.scheduleRepeating(task, periodTicks, delayTicks, null);
    }

    /**
     * 지정된 간격으로 반복 실행 (이름 지정)
     */
    public static TaskHandle runTimer(Runnable task, long periodTicks, long delayTicks, String name) {
        return INSTANCE.scheduleRepeating(task, periodTicks, delayTicks, name);
    }

    /**
     * 비동기로 즉시 실행 (별도 스레드)
     * 
     * @param task 실행할 태스크
     * @return 태스크 핸들
     */
    public static TaskHandle runAsync(Runnable task) {
        return INSTANCE.executeAsync(task, null);
    }

    /**
     * 비동기로 즉시 실행 (이름 지정)
     */
    public static TaskHandle runAsync(Runnable task, String name) {
        return INSTANCE.executeAsync(task, name);
    }

    /**
     * 메인 스레드(게임 스레드)에서 실행
     * 다음 틱에 실행됨
     * 
     * @param task 실행할 태스크
     */
    public static void runSync(Runnable task) {
        INSTANCE.syncQueue.offer(task);
    }

    /**
     * 현재 게임 틱 가져오기
     */
    public static long getCurrentTick() {
        return INSTANCE.currentTick;
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드 (내부)
    // ─────────────────────────────────────────────────────────────

    private TaskHandle scheduleOnce(Runnable task, long delayTicks, String name) {
        long id = taskIdGenerator.incrementAndGet();
        String taskName = name != null ? name : "task-" + id;
        TaskHandle handle = new TaskHandle(id, taskName);

        ScheduledTask scheduled = new ScheduledTask(
                handle, task, ScheduledTask.TaskType.ONCE,
                delayTicks, 0, currentTick);

        tasks.add(scheduled);

        if (debug) {
            System.out.println("[Pulse/Scheduler] Scheduled once: " + taskName +
                    " (delay=" + delayTicks + " ticks)");
        }

        return handle;
    }

    private TaskHandle scheduleRepeating(Runnable task, long periodTicks, long delayTicks, String name) {
        long id = taskIdGenerator.incrementAndGet();
        String taskName = name != null ? name : "timer-" + id;
        TaskHandle handle = new TaskHandle(id, taskName);

        ScheduledTask scheduled = new ScheduledTask(
                handle, task, ScheduledTask.TaskType.REPEATING,
                delayTicks, periodTicks, currentTick);

        tasks.add(scheduled);

        if (debug) {
            System.out.println("[Pulse/Scheduler] Scheduled repeating: " + taskName +
                    " (period=" + periodTicks + ", delay=" + delayTicks + " ticks)");
        }

        return handle;
    }

    private TaskHandle executeAsync(Runnable task, String name) {
        long id = taskIdGenerator.incrementAndGet();
        String taskName = name != null ? name : "async-" + id;
        TaskHandle handle = new TaskHandle(id, taskName);

        asyncExecutor.submit(() -> {
            try {
                task.run();
                handle.incrementExecutionCount();
                handle.markCompleted();
            } catch (Exception e) {
                System.err.println("[Pulse/Scheduler] Async task error: " + taskName);
                e.printStackTrace();
            }
        });

        if (debug) {
            System.out.println("[Pulse/Scheduler] Submitted async: " + taskName);
        }

        return handle;
    }

    // ─────────────────────────────────────────────────────────────
    // 틱 핸들러 (게임 루프에서 호출되어야 함)
    // ─────────────────────────────────────────────────────────────

    /**
     * 틱 처리.
     * 게임의 메인 루프에서 매 틱마다 호출되어야 함.
     * (Mixin으로 GameTime.tick()에 연결)
     */
    public void tick() {
        currentTick++;

        // 동기 큐 처리
        processSyncQueue();

        // 스케줄된 태스크 처리
        processScheduledTasks();
    }

    private void processSyncQueue() {
        Runnable task;
        int processed = 0;
        int maxPerTick = 100; // 한 틱당 최대 처리량

        while ((task = syncQueue.poll()) != null && processed < maxPerTick) {
            try {
                task.run();
                processed++;
            } catch (Exception e) {
                System.err.println("[Pulse/Scheduler] Sync task error");
                e.printStackTrace();
            }
        }
    }

    private void processScheduledTasks() {
        List<ScheduledTask> toRemove = new ArrayList<>();

        for (ScheduledTask task : tasks) {
            if (task.handle.isCancelled()) {
                toRemove.add(task);
                continue;
            }

            if (task.isReadyToExecute(currentTick)) {
                task.execute();

                if (!task.shouldContinue()) {
                    toRemove.add(task);
                }
            }
        }

        tasks.removeAll(toRemove);
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 태스크 취소
     */
    public void cancelAll() {
        for (ScheduledTask task : tasks) {
            task.handle.cancel();
        }
        tasks.clear();
        syncQueue.clear();
    }

    /**
     * 활성 태스크 수
     */
    public int getActiveTaskCount() {
        return tasks.size();
    }

    /**
     * 팬딩 동기 태스크 수
     */
    public int getPendingSyncTaskCount() {
        return syncQueue.size();
    }

    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    /**
     * 스케줄러 종료 (게임 종료 시)
     */
    public void shutdown() {
        cancelAll();
        asyncExecutor.shutdown();
        try {
            if (!asyncExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                asyncExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            asyncExecutor.shutdownNow();
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\scheduler\PulseScheduler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\scheduler\ScheduledTask.java =====

package com.pulse.scheduler;

/**
 * 내부 태스크 래퍼.
 * 스케줄러 내부에서 사용.
 */
class ScheduledTask {

    enum TaskType {
        ONCE, // 1회 실행
        REPEATING, // 반복 실행
        ASYNC // 비동기 실행
    }

    final TaskHandle handle;
    final Runnable task;
    final TaskType type;
    final long delayTicks;
    final long periodTicks;

    long nextExecutionTick;

    ScheduledTask(TaskHandle handle, Runnable task, TaskType type,
            long delayTicks, long periodTicks, long currentTick) {
        this.handle = handle;
        this.task = task;
        this.type = type;
        this.delayTicks = delayTicks;
        this.periodTicks = periodTicks;
        this.nextExecutionTick = currentTick + delayTicks;
    }

    /**
     * 실행 시점인지 확인
     */
    boolean isReadyToExecute(long currentTick) {
        return currentTick >= nextExecutionTick && !handle.isCancelled();
    }

    /**
     * 태스크 실행
     */
    void execute() {
        if (handle.isCancelled())
            return;

        try {
            task.run();
            handle.incrementExecutionCount();

            if (type == TaskType.ONCE) {
                handle.markCompleted();
            } else if (type == TaskType.REPEATING) {
                // 다음 실행 시점 계산
                nextExecutionTick += periodTicks;
            }
        } catch (Exception e) {
            System.err.println("[Pulse/Scheduler] Task execution error: " + handle.getName());
            e.printStackTrace();
        }
    }

    /**
     * 반복 태스크인지 확인
     */
    boolean shouldContinue() {
        return type == TaskType.REPEATING && !handle.isCancelled();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\scheduler\ScheduledTask.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\scheduler\Scheduler.java =====

package com.pulse.scheduler;

/**
 * Scheduler API 편의 클래스.
 * 
 * PulseScheduler의 정적 메서드를 re-export하여
 * 더 짧은 이름으로 사용 가능하게 함.
 * 
 * 사용 예:
 * 
 * <pre>
 * import static com.pulse.scheduler.Scheduler.*;
 * 
 * // 3초 후 실행
 * runLater(() -> System.out.println("Hello!"), 60);
 * 
 * // 1초마다 반복
 * TaskHandle timer = runTimer(() -> System.out.println("Tick"), 20, 0);
 * timer.cancel();
 * </pre>
 */
public final class Scheduler {

    private Scheduler() {
    }

    /**
     * 지정된 틱 수 후에 1회 실행
     * 
     * @param task       실행할 태스크
     * @param delayTicks 지연 틱 수 (20틱 ≈ 1초)
     * @return 태스크 핸들
     */
    public static TaskHandle runLater(Runnable task, long delayTicks) {
        return PulseScheduler.runLater(task, delayTicks);
    }

    /**
     * 지정된 틱 수 후에 1회 실행 (이름 지정)
     */
    public static TaskHandle runLater(Runnable task, long delayTicks, String name) {
        return PulseScheduler.runLater(task, delayTicks, name);
    }

    /**
     * 지정된 간격으로 반복 실행
     * 
     * @param task        실행할 태스크
     * @param periodTicks 반복 간격 (틱)
     * @param delayTicks  첫 실행 전 지연 (틱)
     * @return 태스크 핸들
     */
    public static TaskHandle runTimer(Runnable task, long periodTicks, long delayTicks) {
        return PulseScheduler.runTimer(task, periodTicks, delayTicks);
    }

    /**
     * 지정된 간격으로 반복 실행 (이름 지정)
     */
    public static TaskHandle runTimer(Runnable task, long periodTicks, long delayTicks, String name) {
        return PulseScheduler.runTimer(task, periodTicks, delayTicks, name);
    }

    /**
     * 비동기로 즉시 실행 (별도 스레드)
     */
    public static TaskHandle runAsync(Runnable task) {
        return PulseScheduler.runAsync(task);
    }

    /**
     * 비동기로 즉시 실행 (이름 지정)
     */
    public static TaskHandle runAsync(Runnable task, String name) {
        return PulseScheduler.runAsync(task, name);
    }

    /**
     * 메인 스레드(게임 스레드)에서 실행
     */
    public static void runSync(Runnable task) {
        PulseScheduler.runSync(task);
    }

    /**
     * 현재 게임 틱 가져오기
     */
    public static long currentTick() {
        return PulseScheduler.getCurrentTick();
    }

    /**
     * 틱을 초로 변환 (약 20틱 = 1초)
     */
    public static long ticksToSeconds(long ticks) {
        return ticks / 20;
    }

    /**
     * 초를 틱으로 변환
     */
    public static long secondsToTicks(double seconds) {
        return (long) (seconds * 20);
    }

    /**
     * 밀리초를 틱으로 변환
     */
    public static long millisToTicks(long millis) {
        return millis / 50;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\scheduler\Scheduler.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\scheduler\TaskHandle.java =====

package com.pulse.scheduler;

/**
 * 스케줄된 태스크 핸들.
 * 태스크 취소 및 상태 확인에 사용.
 */
public class TaskHandle {

    private final long taskId;
    private final String name;
    private volatile boolean cancelled = false;
    private volatile boolean completed = false;
    private volatile int executionCount = 0;

    public TaskHandle(long taskId, String name) {
        this.taskId = taskId;
        this.name = name;
    }

    /**
     * 태스크 취소
     */
    public void cancel() {
        this.cancelled = true;
    }

    /**
     * 취소 여부
     */
    public boolean isCancelled() {
        return cancelled;
    }

    /**
     * 완료 여부
     */
    public boolean isCompleted() {
        return completed;
    }

    /**
     * 실행 중 여부
     */
    public boolean isActive() {
        return !cancelled && !completed;
    }

    /**
     * 실행 횟수
     */
    public int getExecutionCount() {
        return executionCount;
    }

    // 내부 사용
    void markCompleted() {
        this.completed = true;
    }

    void incrementExecutionCount() {
        this.executionCount++;
    }

    public long getTaskId() {
        return taskId;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        String status = cancelled ? "CANCELLED" : (completed ? "COMPLETED" : "ACTIVE");
        return String.format("TaskHandle[id=%d, name=%s, status=%s, executions=%d]",
                taskId, name, status, executionCount);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\scheduler\TaskHandle.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\security\ModSignature.java =====

package com.pulse.security;

/**
 * 모드 서명 및 검증.
 * 모드 JAR의 무결성 확인.
 */
public class ModSignature {

    private final String modId;
    private final String algorithm;
    private final byte[] signature;
    private final String publicKeyId;
    private boolean verified = false;

    public ModSignature(String modId, String algorithm, byte[] signature, String publicKeyId) {
        this.modId = modId;
        this.algorithm = algorithm;
        this.signature = signature;
        this.publicKeyId = publicKeyId;
    }

    // ─────────────────────────────────────────────────────────────
    // 서명 검증
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 JAR 서명 검증.
     */
    public boolean verify(byte[] jarData) {
        try {
            java.security.Signature sig = java.security.Signature.getInstance(algorithm);

            // 공개 키 로드 (신뢰 저장소에서)
            java.security.PublicKey publicKey = TrustStore.getPublicKey(publicKeyId);
            if (publicKey == null) {
                System.err.println("[Pulse/Security] Unknown public key: " + publicKeyId);
                return false;
            }

            sig.initVerify(publicKey);
            sig.update(jarData);
            verified = sig.verify(signature);

            if (verified) {
                System.out.println("[Pulse/Security] Signature verified: " + modId);
            } else {
                System.err.println("[Pulse/Security] Signature verification failed: " + modId);
            }

            return verified;
        } catch (Exception e) {
            System.err.println("[Pulse/Security] Signature error: " + e.getMessage());
            return false;
        }
    }

    /**
     * 파일에서 서명 검증.
     */
    public boolean verifyFile(java.io.File jarFile) {
        try {
            byte[] data = java.nio.file.Files.readAllBytes(jarFile.toPath());
            return verify(data);
        } catch (java.io.IOException e) {
            return false;
        }
    }

    // Getters
    public String getModId() {
        return modId;
    }

    public String getAlgorithm() {
        return algorithm;
    }

    public byte[] getSignature() {
        return signature.clone();
    }

    public String getPublicKeyId() {
        return publicKeyId;
    }

    public boolean isVerified() {
        return verified;
    }

    // ─────────────────────────────────────────────────────────────
    // 서명 생성 (개발용)
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 JAR 서명 생성.
     */
    public static ModSignature sign(String modId, byte[] jarData,
            java.security.PrivateKey privateKey, String publicKeyId) {
        try {
            java.security.Signature sig = java.security.Signature.getInstance("SHA256withRSA");
            sig.initSign(privateKey);
            sig.update(jarData);
            byte[] signature = sig.sign();

            return new ModSignature(modId, "SHA256withRSA", signature, publicKeyId);
        } catch (Exception e) {
            System.err.println("[Pulse/Security] Failed to sign: " + e.getMessage());
            return null;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 신뢰 저장소
    // ─────────────────────────────────────────────────────────────

    public static class TrustStore {
        private static final java.util.Map<String, java.security.PublicKey> keys = new java.util.concurrent.ConcurrentHashMap<>();

        /**
         * 공개 키 등록.
         */
        public static void registerPublicKey(String keyId, java.security.PublicKey key) {
            keys.put(keyId, key);
        }

        /**
         * 공개 키 조회.
         */
        public static java.security.PublicKey getPublicKey(String keyId) {
            return keys.get(keyId);
        }

        /**
         * 파일에서 공개 키 로드.
         */
        public static void loadFromFile(String keyId, java.io.File keyFile) {
            try {
                byte[] keyBytes = java.nio.file.Files.readAllBytes(keyFile.toPath());
                java.security.spec.X509EncodedKeySpec spec = new java.security.spec.X509EncodedKeySpec(keyBytes);
                java.security.KeyFactory kf = java.security.KeyFactory.getInstance("RSA");
                java.security.PublicKey key = kf.generatePublic(spec);
                registerPublicKey(keyId, key);
            } catch (Exception e) {
                System.err.println("[Pulse/Security] Failed to load key: " + e.getMessage());
            }
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\security\ModSignature.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\security\PermissionManager.java =====

package com.pulse.security;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 모드 권한 관리자.
 * 모드별 권한을 검증하고 관리.
 */
public class PermissionManager {

    private static final PermissionManager INSTANCE = new PermissionManager();

    // modId -> 허용된 권한 세트
    private final Map<String, Set<Permission>> grantedPermissions = new ConcurrentHashMap<>();

    // 권한별 기본 정책
    private final Map<Permission, PermissionPolicy> defaultPolicies = new EnumMap<>(Permission.class);

    private PermissionManager() {
        // 기본 정책 설정
        for (Permission p : Permission.values()) {
            defaultPolicies.put(p, p.getDefaultPolicy());
        }
    }

    public static PermissionManager getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 권한 검사
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드가 특정 권한을 가지고 있는지 확인.
     */
    public static boolean hasPermission(String modId, Permission permission) {
        return INSTANCE.checkPermission(modId, permission);
    }

    private boolean checkPermission(String modId, Permission permission) {
        // 명시적으로 부여된 권한
        Set<Permission> perms = grantedPermissions.get(modId);
        if (perms != null && perms.contains(permission)) {
            return true;
        }

        // 기본 정책 확인
        PermissionPolicy policy = defaultPolicies.get(permission);
        return policy == PermissionPolicy.ALLOW_ALL;
    }

    /**
     * 권한 검사 및 예외 발생.
     */
    public static void require(String modId, Permission permission) throws SecurityException {
        if (!hasPermission(modId, permission)) {
            throw new SecurityException("Mod '" + modId + "' lacks permission: " + permission);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 권한 부여
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드에 권한 부여.
     */
    public static void grant(String modId, Permission permission) {
        INSTANCE.grantedPermissions
                .computeIfAbsent(modId, k -> ConcurrentHashMap.newKeySet())
                .add(permission);
        System.out.println("[Pulse/Security] Granted " + permission + " to " + modId);
    }

    /**
     * 모드에서 권한 제거.
     */
    public static void revoke(String modId, Permission permission) {
        Set<Permission> perms = INSTANCE.grantedPermissions.get(modId);
        if (perms != null) {
            perms.remove(permission);
        }
    }

    /**
     * 모드의 모든 권한 제거.
     */
    public static void revokeAll(String modId) {
        INSTANCE.grantedPermissions.remove(modId);
    }

    /**
     * pulse.mod.json의 permissions 필드에서 권한 로드.
     */
    public static void loadFromMetadata(String modId, List<String> permissionNames) {
        for (String name : permissionNames) {
            try {
                Permission perm = Permission.valueOf(name.toUpperCase().replace(".", "_"));
                grant(modId, perm);
            } catch (IllegalArgumentException e) {
                System.err.println("[Pulse/Security] Unknown permission: " + name);
            }
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 권한 열거형
    // ─────────────────────────────────────────────────────────────

    public enum Permission {
        // 파일 시스템
        FILE_READ(PermissionPolicy.ALLOW_ALL),
        FILE_WRITE(PermissionPolicy.ASK),
        FILE_DELETE(PermissionPolicy.DENY),

        // 네트워크
        NETWORK_CLIENT(PermissionPolicy.ALLOW_ALL),
        NETWORK_SERVER(PermissionPolicy.ASK),
        NETWORK_EXTERNAL(PermissionPolicy.DENY),

        // 시스템
        SYSTEM_EXEC(PermissionPolicy.DENY),
        SYSTEM_CLASSLOADER(PermissionPolicy.DENY),
        SYSTEM_REFLECTION(PermissionPolicy.ASK),

        // 게임
        GAME_WORLD_MODIFY(PermissionPolicy.ALLOW_ALL),
        GAME_PLAYER_DATA(PermissionPolicy.ALLOW_ALL),
        GAME_ADMIN_COMMANDS(PermissionPolicy.ASK),

        // 콘솔 (멀티플레이 보안)
        CONSOLE_ACCESS(PermissionPolicy.ALLOW_ALL), // 기본 콘솔 접근
        CONSOLE_LUA_EXEC(PermissionPolicy.DENY), // Lua 코드 실행 (위험)
        CONSOLE_MOD_MANAGE(PermissionPolicy.DENY), // 모드 reload/disable/enable

        // 모드 간
        MOD_IMC(PermissionPolicy.ALLOW_ALL),
        MOD_ACCESS_INTERNAL(PermissionPolicy.DENY);

        private final PermissionPolicy defaultPolicy;

        Permission(PermissionPolicy defaultPolicy) {
            this.defaultPolicy = defaultPolicy;
        }

        public PermissionPolicy getDefaultPolicy() {
            return defaultPolicy;
        }
    }

    public enum PermissionPolicy {
        ALLOW_ALL, // 항상 허용
        ASK, // 사용자 확인 필요
        DENY // 항상 거부 (명시적 부여 필요)
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\security\PermissionManager.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\security\SideValidator.java =====

package com.pulse.security;

import com.pulse.mod.ModContainer;
import com.pulse.mod.ModMetadata;

/**
 * 모드 사이드 검증.
 * 서버 전용/클라이언트 전용 모드 구분.
 */
public class SideValidator {

    /**
     * 현재 실행 환경.
     */
    public enum Side {
        CLIENT, // 클라이언트 (싱글 포함)
        SERVER, // 전용 서버
        BOTH // 양쪽 모두
    }

    private static Side currentSide = Side.CLIENT;

    /**
     * 현재 사이드 설정.
     */
    public static void setCurrentSide(Side side) {
        currentSide = side;
        System.out.println("[Pulse/Side] Running on: " + side);
    }

    /**
     * 현재 사이드 조회.
     */
    public static Side getCurrentSide() {
        return currentSide;
    }

    public static boolean isClient() {
        return currentSide == Side.CLIENT;
    }

    public static boolean isServer() {
        return currentSide == Side.SERVER;
    }

    /**
     * 모드가 현재 사이드에서 로드 가능한지 확인.
     */
    public static boolean canLoad(ModContainer mod) {
        ModMetadata meta = mod.getMetadata();
        ModSide modSide = getModSide(meta);

        switch (modSide) {
            case CLIENT_ONLY:
                return currentSide == Side.CLIENT;
            case SERVER_ONLY:
                return currentSide == Side.SERVER;
            case BOTH:
            default:
                return true;
        }
    }

    /**
     * 모드 메타데이터에서 사이드 정보 추출.
     */
    private static ModSide getModSide(ModMetadata meta) {
        // 권한 목록에서 사이드 힌트 확인
        for (String perm : meta.getPermissions()) {
            if ("client_only".equalsIgnoreCase(perm)) {
                return ModSide.CLIENT_ONLY;
            }
            if ("server_only".equalsIgnoreCase(perm)) {
                return ModSide.SERVER_ONLY;
            }
        }
        return ModSide.BOTH;
    }

    /**
     * 모드가 잘못된 사이드에서 실행 시 경고.
     */
    public static void warnIfWrongSide(String modId, ModSide requiredSide) {
        boolean valid = true;

        switch (requiredSide) {
            case CLIENT_ONLY:
                valid = currentSide == Side.CLIENT;
                break;
            case SERVER_ONLY:
                valid = currentSide == Side.SERVER;
                break;
            default:
                break;
        }

        if (!valid) {
            System.err.println("[Pulse/Side] WARNING: Mod '" + modId +
                    "' requires " + requiredSide + " but running on " + currentSide);
        }
    }

    public enum ModSide {
        CLIENT_ONLY,
        SERVER_ONLY,
        BOTH
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\security\SideValidator.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseClassTracker.java =====

package com.pulse.service;

import org.spongepowered.asm.service.IClassTracker;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * 클래스 로딩 상태를 추적하는 서비스.
 */
public class PulseClassTracker implements IClassTracker {

    private final Set<String> loadedClasses = Collections.synchronizedSet(new HashSet<>());
    private final Set<String> invalidClasses = Collections.synchronizedSet(new HashSet<>());

    // IClassTracker 메서드들 - @Override 없이 구현
    
    public void registerClass(String name) {
        loadedClasses.add(name);
    }

    public boolean isClassLoaded(String name) {
        return loadedClasses.contains(name);
    }

    public String getClassRestrictions(String className) {
        if (loadedClasses.contains(className)) {
            return "already loaded";
        }
        if (invalidClasses.contains(className)) {
            return "invalid class";
        }
        return "";
    }

    public void registerInvalidClass(String name) {
        invalidClasses.add(name);
    }

    // Pulse 내부용 메서드
    
    public Set<String> getLoadedClasses() {
        return Collections.unmodifiableSet(loadedClasses);
    }

    public int countLoadedWithPrefix(String prefix) {
        return (int) loadedClasses.stream()
            .filter(n -> n.startsWith(prefix))
            .count();
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseClassTracker.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseDefineClassTransformer.java =====

package com.pulse.service;

import com.pulse.PulseEnvironment;

import java.lang.instrument.ClassFileTransformer;
import java.security.ProtectionDomain;

public class PulseDefineClassTransformer implements ClassFileTransformer {

    @Override
    public byte[] transform(
            Module module,
            ClassLoader loader,
            String className,
            Class<?> classBeingRedefined,
            ProtectionDomain protectionDomain,
            byte[] classfileBuffer
    ) {

        // defineClass가 호출될 때 className은 null일 수 있다.
        if (className == null || loader == null) return null;

        // convert name style: "zombie/characters/IsoZombie"
        if (className.startsWith("zombie/")) {

            System.out.println("[Pulse] ClassLoader has loaded zombie class: " + className);
            System.out.println("[Pulse] Registering Game ClassLoader: " + loader);

            PulseEnvironment.setGameClassLoader(loader);

            // Once captured, we do NOT want to override or modify class bytes
            return null;
        }

        return null;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseDefineClassTransformer.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseGameClassTracker.java =====

package com.pulse.service;

import com.pulse.PulseEnvironment;

import java.lang.instrument.ClassFileTransformer;
import java.security.ProtectionDomain;

public class PulseGameClassTracker implements ClassFileTransformer {

    @Override
    public byte[] transform(
            Module module,
            ClassLoader loader,
            String className,
            Class<?> classBeingRedefined,
            ProtectionDomain protectionDomain,
            byte[] classfileBuffer
    ) {
        // 예: className = "zombie/characters/IsoZombie"
        if (className != null && loader != null && className.startsWith("zombie/")) {
            System.out.println("[Pulse/TRACKER] Detected zombie class: " + className);
            System.out.println("[Pulse/TRACKER] Loader: " + loader);

            // 실제 게임 클래스 로더 등록
            PulseEnvironment.setGameClassLoader(loader);
        }

        // 클래스 바이트코드는 건드리지 않는다
        return null;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseGameClassTracker.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseGlobalPropertyService.java =====

package com.pulse.service;

import org.spongepowered.asm.service.IGlobalPropertyService;
import org.spongepowered.asm.service.IPropertyKey;

import java.util.HashMap;
import java.util.Map;

/**
 * Mixin 전역 프로퍼티 서비스.
 * Mixin 시스템 전체에서 공유되는 설정값을 관리.
 */
public class PulseGlobalPropertyService implements IGlobalPropertyService {

    private final Map<String, Object> properties = new HashMap<>();

    public PulseGlobalPropertyService() {
        // 기본 프로퍼티 설정
        properties.put("mixin.debug", true);
        properties.put("mixin.env.disableRefMap", true);
    }

    @Override
    public IPropertyKey resolveKey(String name) {
        return new StringPropertyKey(name);
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> T getProperty(IPropertyKey key) {
        return (T) properties.get(key.toString());
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> T getProperty(IPropertyKey key, T defaultValue) {
        Object value = properties.get(key.toString());
        return value != null ? (T) value : defaultValue;
    }

    @Override
    public void setProperty(IPropertyKey key, Object value) {
        properties.put(key.toString(), value);
    }

    @Override
    public String getPropertyString(IPropertyKey key, String defaultValue) {
        Object value = properties.get(key.toString());
        return value != null ? value.toString() : defaultValue;
    }

    // 내부 키 구현
    private static class StringPropertyKey implements IPropertyKey {
        private final String key;

        StringPropertyKey(String key) {
            this.key = key;
        }

        @Override
        public String toString() {
            return key;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            return key.equals(((StringPropertyKey) o).key);
        }

        @Override
        public int hashCode() {
            return key.hashCode();
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseGlobalPropertyService.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseLogger.java =====

package com.pulse.service;

import org.spongepowered.asm.logging.ILogger;
import org.spongepowered.asm.logging.Level;

/**
 * Pulse용 Mixin 로거 구현.
 */
public class PulseLogger implements ILogger {
    private final String name;

    public PulseLogger(String name) {
        this.name = name;
    }

    @Override
    public String getId() {
        return this.name;
    }

    @Override
    public String getType() {
        return "Pulse";
    }

    public String getName() {
        return this.name;
    }

    private String format(String level, String message, Object... params) {
        String formatted = message;
        if (params != null && params.length > 0) {
            // 간단한 {} 치환
            for (Object param : params) {
                int idx = formatted.indexOf("{}");
                if (idx >= 0) {
                    formatted = formatted.substring(0, idx) + param + formatted.substring(idx + 2);
                }
            }
        }
        return String.format("[Pulse/%s] [%s] %s", level, name, formatted);
    }

    @Override
    public void debug(String message, Object... params) {
        System.out.println(format("DEBUG", message, params));
    }

    @Override
    public void debug(String message, Throwable t) {
        System.out.println(format("DEBUG", message));
        t.printStackTrace(System.out);
    }

    @Override
    public void trace(String message, Object... params) {
        // Trace 레벨은 더 상세한 디버깅용
        System.out.println(format("TRACE", message, params));
    }

    @Override
    public void trace(String message, Throwable t) {
        System.out.println(format("TRACE", message));
        t.printStackTrace(System.out);
    }

    @Override
    public void info(String message, Object... params) {
        System.out.println(format("INFO", message, params));
    }

    @Override
    public void info(String message, Throwable t) {
        System.out.println(format("INFO", message));
        t.printStackTrace(System.out);
    }

    @Override
    public void warn(String message, Object... params) {
        System.out.println(format("WARN", message, params));
    }

    @Override
    public void warn(String message, Throwable t) {
        System.out.println(format("WARN", message));
        t.printStackTrace(System.out);
    }

    @Override
    public void error(String message, Object... params) {
        System.err.println(format("ERROR", message, params));
    }

    @Override
    public void error(String message, Throwable t) {
        System.err.println(format("ERROR", message));
        t.printStackTrace(System.err);
    }

    @Override
    public void fatal(String message, Object... params) {
        System.err.println(format("FATAL", message, params));
    }

    @Override
    public void fatal(String message, Throwable t) {
        System.err.println(format("FATAL", message));
        t.printStackTrace(System.err);
    }

    @Override
    public void log(Level level, String message, Object... params) {
        switch (level) {
            case DEBUG: debug(message, params); break;
            case TRACE: trace(message, params); break;
            case INFO: info(message, params); break;
            case WARN: warn(message, params); break;
            case ERROR: error(message, params); break;
            case FATAL: fatal(message, params); break;
            default: info(message, params);
        }
    }

    @Override
    public void log(Level level, String message, Throwable t) {
        switch (level) {
            case DEBUG: debug(message, t); break;
            case TRACE: trace(message, t); break;
            case INFO: info(message, t); break;
            case WARN: warn(message, t); break;
            case ERROR: error(message, t); break;
            case FATAL: fatal(message, t); break;
            default: info(message, t);
        }
    }

    @Override
    public <T extends Throwable> T throwing(T t) {
        error("Throwing", t);
        return t;
    }

    @Override
    public void catching(Throwable t) {
        catching(Level.ERROR, t);
    }

    @Override
    public void catching(Level level, Throwable t) {
        log(level, "Catching exception: " + t.getClass().getName(), t);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseLogger.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseMixinService.java =====

package com.pulse.service;

import com.pulse.PulseEnvironment;
import org.spongepowered.asm.launch.platform.container.ContainerHandleVirtual;
import org.spongepowered.asm.launch.platform.container.IContainerHandle;
import org.spongepowered.asm.logging.ILogger;
import org.spongepowered.asm.mixin.MixinEnvironment.CompatibilityLevel;
import org.spongepowered.asm.mixin.MixinEnvironment.Phase;
import org.spongepowered.asm.mixin.transformer.IMixinTransformer;
import org.spongepowered.asm.mixin.transformer.IMixinTransformerFactory;
import org.spongepowered.asm.service.*;
import org.spongepowered.asm.util.ReEntranceLock;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Collection;
import java.util.Collections;

/**
 * Pulse의 핵심 Mixin 서비스 구현.
 * 
 * Sponge Mixin이 필요로 하는 모든 인터페이스를 구현:
 * - IMixinService: 메인 서비스 인터페이스
 * - IClassProvider: 클래스 로딩
 * - IClassBytecodeProvider: 바이트코드 접근
 */
public class PulseMixinService implements IMixinService, IClassProvider, IClassBytecodeProvider {

    private final ReEntranceLock lock = new ReEntranceLock(1);
    private final PulseTransformerProvider transformerProvider = new PulseTransformerProvider();
    private final PulseClassTracker classTracker = new PulseClassTracker();

    // Mixin이 생성한 transformer (offer()를 통해 전달됨)
    private IMixinTransformer mixinTransformer;
    private IMixinTransformerFactory transformerFactory;

    // Primary container (이 JAR 자체)
    private IContainerHandle primaryContainer;

    public PulseMixinService() {
        System.out.println("[Pulse/Service] PulseMixinService instantiated");
    }

    // ================= ClassLoader 관리 =================

    private ClassLoader getEffectiveClassLoader() {
        // 1순위: 게임 클래스 로더
        ClassLoader gameLoader = PulseEnvironment.getGameClassLoader();
        if (gameLoader != null) {
            return gameLoader;
        }

        // 2순위: 현재 컨텍스트 클래스 로더
        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
        if (contextLoader != null) {
            return contextLoader;
        }

        // 3순위: 시스템 클래스 로더
        return ClassLoader.getSystemClassLoader();
    }

    // ================= IMixinService 구현 =================

    @Override
    public String getName() {
        return "Pulse";
    }

    @Override
    public boolean isValid() {
        return true;
    }

    @Override
    public void prepare() {
        System.out.println("[Pulse/Service] prepare() called");
    }

    @Override
    public Phase getInitialPhase() {
        return Phase.PREINIT;
    }

    @Override
    public void offer(IMixinInternal internal) {
        System.out.println("[Pulse/Service] offer() called with: " +
                (internal != null ? internal.getClass().getName() : "null"));

        if (internal instanceof IMixinTransformerFactory) {
            this.transformerFactory = (IMixinTransformerFactory) internal;
            System.out.println("[Pulse/Service] Received IMixinTransformerFactory");

            // Transformer 생성
            try {
                this.mixinTransformer = transformerFactory.createTransformer();
                System.out.println("[Pulse/Service] Created IMixinTransformer: " +
                        (mixinTransformer != null ? mixinTransformer.getClass().getName() : "null"));

                // PulseEnvironment에 저장하여 외부에서 접근 가능하게 함
                PulseEnvironment.setMixinTransformer(mixinTransformer);

            } catch (Exception e) {
                System.err.println("[Pulse/Service] Failed to create transformer");
                e.printStackTrace();
            }
        }
    }

    @Override
    public void init() {
        System.out.println("[Pulse/Service] init() called");
    }

    @Override
    public void beginPhase() {
        System.out.println("[Pulse/Service] beginPhase() called");
    }

    @Override
    public void checkEnv(Object bootSource) {
        System.out.println("[Pulse/Service] checkEnv() called");
    }

    @Override
    public ReEntranceLock getReEntranceLock() {
        return this.lock;
    }

    @Override
    public IClassProvider getClassProvider() {
        return this;
    }

    @Override
    public IClassBytecodeProvider getBytecodeProvider() {
        return this;
    }

    @Override
    public ITransformerProvider getTransformerProvider() {
        return this.transformerProvider;
    }

    @Override
    public IClassTracker getClassTracker() {
        return this.classTracker;
    }

    @Override
    public IMixinAuditTrail getAuditTrail() {
        // 감사 추적은 선택사항
        return null;
    }

    @Override
    public Collection<String> getPlatformAgents() {
        // Platform agent 클래스 이름들
        // 필요시 PulsePlatformAgent 구현 가능
        return Collections.singletonList("com.pulse.service.PulsePlatformAgent");
    }

    @Override
    public String getSideName() {
        return "CLIENT";
    }

    @Override
    public IContainerHandle getPrimaryContainer() {
        if (primaryContainer == null) {
            try {
                // 이 클래스가 포함된 JAR/폴더의 위치
                URL location = getClass().getProtectionDomain().getCodeSource().getLocation();
                primaryContainer = new ContainerHandleVirtual(getName());
                System.out.println("[Pulse/Service] Primary container location: " + location);
            } catch (Exception e) {
                primaryContainer = new ContainerHandleVirtual(getName());
            }
        }
        return primaryContainer;
    }

    @Override
    public Collection<IContainerHandle> getMixinContainers() {
        // Mixin config를 포함하는 컨테이너들
        // 현재는 primary container만 반환
        return Collections.singletonList(getPrimaryContainer());
    }

    @Override
    public InputStream getResourceAsStream(String name) {
        System.out.println("[Pulse/Service] getResourceAsStream() called for: " + name);

        ClassLoader cl = getEffectiveClassLoader();
        System.out.println("[Pulse/Service]   - Using ClassLoader: " + cl.getClass().getName());

        // 여러 경로 시도
        InputStream is = cl.getResourceAsStream(name);
        System.out.println("[Pulse/Service]   - Try 1 (direct): " + (is != null ? "FOUND" : "not found"));

        if (is == null) {
            // 슬래시로 시작하는 경로 시도
            is = cl.getResourceAsStream("/" + name);
            System.out.println("[Pulse/Service]   - Try 2 (with /): " + (is != null ? "FOUND" : "not found"));
        }

        if (is == null) {
            // 이 클래스의 클래스로더에서 시도
            is = getClass().getClassLoader().getResourceAsStream(name);
            System.out.println(
                    "[Pulse/Service]   - Try 3 (service classloader): " + (is != null ? "FOUND" : "not found"));
        }

        if (is == null) {
            // 시스템 클래스로더에서 시도
            is = ClassLoader.getSystemClassLoader().getResourceAsStream(name);
            System.out.println(
                    "[Pulse/Service]   - Try 4 (system classloader): " + (is != null ? "FOUND" : "not found"));
        }

        if (is == null) {
            System.err.println("[Pulse/Service]   - FAILED to find resource: " + name);
        } else {
            System.out.println("[Pulse/Service]   - SUCCESS: Found resource: " + name);
        }

        return is;
    }

    @Override
    public CompatibilityLevel getMinCompatibilityLevel() {
        return CompatibilityLevel.JAVA_8;
    }

    @Override
    public CompatibilityLevel getMaxCompatibilityLevel() {
        return CompatibilityLevel.JAVA_17;
    }

    @Override
    public ILogger getLogger(String name) {
        return new PulseLogger(name);
    }

    // ================= IClassProvider 구현 =================

    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {
        return findClass(name, true);
    }

    @Override
    public Class<?> findClass(String name, boolean initialize) throws ClassNotFoundException {
        classTracker.registerClass(name);
        return Class.forName(name, initialize, getEffectiveClassLoader());
    }

    @Override
    public Class<?> findAgentClass(String name, boolean initialize) throws ClassNotFoundException {
        // Agent 클래스는 시스템 클래스로더에서 로드
        return Class.forName(name, initialize, ClassLoader.getSystemClassLoader());
    }

    @Override
    public URL[] getClassPath() {
        // 클래스패스 URL 배열 반환
        // Java 9+에서는 모듈 시스템 때문에 복잡해질 수 있음
        return new URL[0];
    }

    // ================= IClassBytecodeProvider 구현 =================

    @Override
    public ClassNode getClassNode(String name) throws ClassNotFoundException, IOException {
        return getClassNode(name, true);
    }

    @Override
    public ClassNode getClassNode(String name, boolean runTransformers)
            throws ClassNotFoundException, IOException {

        String resourceName = name.replace('.', '/') + ".class";
        InputStream is = getResourceAsStream(resourceName);

        if (is == null) {
            throw new ClassNotFoundException("Cannot find class bytecode: " + name +
                    " (resource: " + resourceName + ")");
        }

        try {
            ClassReader reader = new ClassReader(is);
            ClassNode node = new ClassNode();
            reader.accept(node, ClassReader.EXPAND_FRAMES);
            return node;
        } finally {
            is.close();
        }
    }

    // ================= Pulse 전용 메서드 =================

    /**
     * Mixin transformer 반환 (PulseClassTransformer에서 사용)
     */
    public IMixinTransformer getMixinTransformer() {
        return this.mixinTransformer;
    }

    /**
     * ClassTracker 반환 (디버깅/모니터링용)
     */
    public PulseClassTracker getClassTrackerInstance() {
        return this.classTracker;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseMixinService.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseMixinServiceBootstrap.java =====

package com.pulse.service;

import org.spongepowered.asm.service.IMixinServiceBootstrap;

/**
 * Mixin 서비스 부트스트랩.
 * Sponge Mixin이 서비스를 초기화할 때 가장 먼저 호출됨.
 * 
 * ServiceLoader를 통해 자동 발견됨:
 * META-INF/services/org.spongepowered.asm.service.IMixinServiceBootstrap
 */
public class PulseMixinServiceBootstrap implements IMixinServiceBootstrap {

    @Override
    public String getName() {
        return "Pulse";
    }

    @Override
    public String getServiceClassName() {
        return "com.pulse.service.PulseMixinService";
    }

    @Override
    public void bootstrap() {
        System.out.println("[Pulse/Bootstrap] Mixin service bootstrap initiated");
        
        // 환경 준비 작업
        // 예: 시스템 프로퍼티 설정, 초기 상태 구성 등
        
        System.out.println("[Pulse/Bootstrap] Bootstrap complete");
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseMixinServiceBootstrap.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulsePlatformAgent.java =====

package com.pulse.service;

import org.spongepowered.asm.launch.platform.MixinPlatformAgentAbstract;
import org.spongepowered.asm.launch.platform.container.IContainerHandle;

/**
 * Mixin Platform Agent.
 */
public class PulsePlatformAgent extends MixinPlatformAgentAbstract {

    public AcceptResult accept(IContainerHandle root, String className) {
        if (className != null && className.startsWith("com.pulse.")) {
            return AcceptResult.ACCEPTED;
        }
        return AcceptResult.REJECTED;
    }

    public String getPhaseProvider() {
        return null;
    }

    public void prepare() {
        System.out.println("[Pulse/PlatformAgent] prepare()");
    }

    public void initPrimaryContainer() {
        System.out.println("[Pulse/PlatformAgent] initPrimaryContainer()");
    }

    public void inject() {
        System.out.println("[Pulse/PlatformAgent] inject()");
    }

    public String getLaunchTarget() {
        return null;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulsePlatformAgent.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseTransformerProvider.java =====

package com.pulse.service;

import org.spongepowered.asm.service.ITransformer;
import org.spongepowered.asm.service.ITransformerProvider;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * Mixin에게 transformer 정보를 제공하는 서비스.
 * 
 * Sponge Mixin은 이 provider를 통해:
 * 1. 기존 transformer들의 존재를 인식
 * 2. transformer 제외 규칙을 관리
 * 3. delegated transformer를 통한 체이닝 지원
 */
public class PulseTransformerProvider implements ITransformerProvider {

    private final List<ITransformer> transformers = new ArrayList<>();
    private final List<ITransformer> delegatedTransformers = new ArrayList<>();
    private final List<String> exclusions = new ArrayList<>();

    public PulseTransformerProvider() {
        // 기본 제외 패턴
        exclusions.add("java.");
        exclusions.add("javax.");
        exclusions.add("sun.");
        exclusions.add("com.pulse.mixin.");  // Mixin 클래스 자체는 제외
    }

    @Override
    public Collection<ITransformer> getTransformers() {
        return Collections.unmodifiableList(transformers);
    }

    @Override
    public Collection<ITransformer> getDelegatedTransformers() {
        return Collections.unmodifiableList(delegatedTransformers);
    }

    @Override
    public void addTransformerExclusion(String name) {
        if (name != null && !name.isEmpty()) {
            exclusions.add(name);
            System.out.println("[Pulse/TransformerProvider] Added exclusion: " + name);
        }
    }

    /**
     * transformer 등록 (Pulse 내부용)
     */
    public void registerTransformer(ITransformer transformer) {
        if (transformer != null) {
            transformers.add(transformer);
            System.out.println("[Pulse/TransformerProvider] Registered transformer: " + 
                transformer.getClass().getName());
        }
    }

    /**
     * 클래스가 제외 대상인지 확인
     */
    public boolean isExcluded(String className) {
        for (String exclusion : exclusions) {
            if (className.startsWith(exclusion)) {
                return true;
            }
        }
        return false;
    }

    public List<String> getExclusions() {
        return Collections.unmodifiableList(exclusions);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\service\PulseTransformerProvider.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\test\Assertions.java =====

package com.pulse.test;

/**
 * 테스트 어설션.
 */
public class Assertions {

    public static void assertTrue(boolean condition) {
        if (!condition) {
            throw new AssertionError("Expected true but was false");
        }
    }

    public static void assertTrue(boolean condition, String message) {
        if (!condition) {
            throw new AssertionError(message);
        }
    }

    public static void assertFalse(boolean condition) {
        if (condition) {
            throw new AssertionError("Expected false but was true");
        }
    }

    public static void assertFalse(boolean condition, String message) {
        if (condition) {
            throw new AssertionError(message);
        }
    }

    public static void assertEquals(Object expected, Object actual) {
        if (!java.util.Objects.equals(expected, actual)) {
            throw new AssertionError("Expected: " + expected + " but was: " + actual);
        }
    }

    public static void assertEquals(Object expected, Object actual, String message) {
        if (!java.util.Objects.equals(expected, actual)) {
            throw new AssertionError(message + " - Expected: " + expected + " but was: " + actual);
        }
    }

    public static void assertNotEquals(Object unexpected, Object actual) {
        if (java.util.Objects.equals(unexpected, actual)) {
            throw new AssertionError("Expected not equal to: " + unexpected);
        }
    }

    public static void assertNull(Object obj) {
        if (obj != null) {
            throw new AssertionError("Expected null but was: " + obj);
        }
    }

    public static void assertNotNull(Object obj) {
        if (obj == null) {
            throw new AssertionError("Expected not null");
        }
    }

    public static void assertNotNull(Object obj, String message) {
        if (obj == null) {
            throw new AssertionError(message);
        }
    }

    public static <T extends Throwable> T assertThrows(Class<T> expectedType, Runnable executable) {
        try {
            executable.run();
            throw new AssertionError("Expected " + expectedType.getSimpleName() + " to be thrown");
        } catch (Throwable t) {
            if (expectedType.isInstance(t)) {
                return expectedType.cast(t);
            }
            throw new AssertionError("Expected " + expectedType.getSimpleName() +
                    " but was " + t.getClass().getSimpleName());
        }
    }

    public static void fail() {
        throw new AssertionError("Test failed");
    }

    public static void fail(String message) {
        throw new AssertionError(message);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\test\Assertions.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\test\TestRunner.java =====

package com.pulse.test;

import java.lang.reflect.*;
import java.util.*;

/**
 * 헤드리스 테스트 러너.
 * 게임 없이 모드 코드 테스트.
 */
public class TestRunner {

    private static final TestRunner INSTANCE = new TestRunner();

    private final List<TestResult> results = new ArrayList<>();
    private int passed = 0;
    private int failed = 0;

    private TestRunner() {
    }

    public static TestRunner getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 테스트 실행
    // ─────────────────────────────────────────────────────────────

    /**
     * 테스트 클래스 실행.
     */
    public static void run(Class<?> testClass) {
        INSTANCE.runClass(testClass);
    }

    private void runClass(Class<?> testClass) {
        System.out.println("\n═══════════════════════════════════════");
        System.out.println("  Running: " + testClass.getSimpleName());
        System.out.println("═══════════════════════════════════════");

        Object instance = null;
        try {
            instance = testClass.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            System.err.println("Failed to instantiate test class: " + e.getMessage());
            return;
        }

        // @BeforeAll
        invokeAnnotatedMethods(testClass, instance, BeforeAll.class, true);

        // 테스트 메서드 실행
        for (Method method : testClass.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Test.class)) {
                // @BeforeEach
                invokeAnnotatedMethods(testClass, instance, BeforeEach.class, false);

                runTest(instance, method);

                // @AfterEach
                invokeAnnotatedMethods(testClass, instance, AfterEach.class, false);
            }
        }

        // @AfterAll
        invokeAnnotatedMethods(testClass, instance, AfterAll.class, true);

        printSummary();
    }

    private void runTest(Object instance, Method method) {
        String testName = method.getDeclaringClass().getSimpleName() + "." + method.getName();
        long startTime = System.nanoTime();

        try {
            method.setAccessible(true);
            method.invoke(instance);

            long duration = (System.nanoTime() - startTime) / 1_000_000;
            passed++;
            results.add(new TestResult(testName, true, duration, null));
            System.out.println("  ✓ " + method.getName() + " (" + duration + "ms)");

        } catch (InvocationTargetException e) {
            long duration = (System.nanoTime() - startTime) / 1_000_000;
            Throwable cause = e.getCause();
            failed++;
            results.add(new TestResult(testName, false, duration, cause));
            System.out.println("  ✗ " + method.getName() + " - " + cause.getMessage());
        } catch (Exception e) {
            failed++;
            results.add(new TestResult(testName, false, 0, e));
            System.out.println("  ✗ " + method.getName() + " - " + e.getMessage());
        }
    }

    private void invokeAnnotatedMethods(Class<?> clazz, Object instance,
            Class<? extends java.lang.annotation.Annotation> annotation, boolean isStatic) {
        for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(annotation)) {
                try {
                    method.setAccessible(true);
                    method.invoke(isStatic && Modifier.isStatic(method.getModifiers()) ? null : instance);
                } catch (Exception e) {
                    System.err.println("Setup/Teardown failed: " + e.getMessage());
                }
            }
        }
    }

    private void printSummary() {
        System.out.println("───────────────────────────────────────");
        System.out.printf("  Results: %d passed, %d failed%n", passed, failed);
        System.out.println("═══════════════════════════════════════\n");
    }

    /**
     * 모든 테스트 결과 초기화.
     */
    public static void reset() {
        INSTANCE.results.clear();
        INSTANCE.passed = 0;
        INSTANCE.failed = 0;
    }

    /**
     * 테스트 결과 조회.
     */
    public static List<TestResult> getResults() {
        return new ArrayList<>(INSTANCE.results);
    }

    // ─────────────────────────────────────────────────────────────
    // 테스트 결과
    // ─────────────────────────────────────────────────────────────

    public static class TestResult {
        public final String testName;
        public final boolean passed;
        public final long durationMs;
        public final Throwable error;

        TestResult(String testName, boolean passed, long durationMs, Throwable error) {
            this.testName = testName;
            this.passed = passed;
            this.durationMs = durationMs;
            this.error = error;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 어노테이션
    // ─────────────────────────────────────────────────────────────

    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
    @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD)
    public @interface Test {
    }

    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
    @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD)
    public @interface BeforeEach {
    }

    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
    @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD)
    public @interface AfterEach {
    }

    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
    @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD)
    public @interface BeforeAll {
    }

    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
    @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD)
    public @interface AfterAll {
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\test\TestRunner.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\transformer\PulseClassTransformer.java =====

package com.pulse.transformer;

import com.pulse.PulseEnvironment;
import com.pulse.mixin.MixinDiagnostics;
import org.spongepowered.asm.mixin.MixinEnvironment;
import org.spongepowered.asm.mixin.transformer.IMixinTransformer;

import java.lang.instrument.ClassFileTransformer;
import java.security.ProtectionDomain;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Pulse의 핵심 클래스 트랜스포머.
 * Java Instrumentation API와 Sponge Mixin을 연결한다.
 *
 * 역할:
 * 1. zombie.* 클래스 로딩을 감지
 * 2. Mixin 변환을 적용
 * 3. 향후 추가될 다른 transformer들과 체이닝
 */
public class PulseClassTransformer implements ClassFileTransformer {

    private final Set<String> transformedClasses = ConcurrentHashMap.newKeySet();
    private final Set<String> excludedPrefixes = ConcurrentHashMap.newKeySet();

    private IMixinTransformer mixinTransformer;
    private boolean mixinReady = false;

    public PulseClassTransformer() {
        // Mixin 적용 제외 패키지
        excludedPrefixes.add("java/");
        excludedPrefixes.add("javax/");
        excludedPrefixes.add("sun/");
        excludedPrefixes.add("jdk/");
        excludedPrefixes.add("com.pulse/");
        excludedPrefixes.add("org/spongepowered/");
        excludedPrefixes.add("org/objectweb/asm/");
    }

    /**
     * Mixin Transformer를 연결한다.
     * MixinBootstrap.init() 이후에 호출되어야 함.
     */
    public void connectMixinTransformer(IMixinTransformer transformer) {
        this.mixinTransformer = transformer;
        this.mixinReady = (transformer != null);

        if (mixinReady) {
            System.out.println("[Pulse/Transformer] Mixin transformer connected successfully");
        } else {
            System.err.println("[Pulse/Transformer] WARNING: Mixin transformer is null!");
        }
    }

    @Override
    public byte[] transform(
            ClassLoader loader,
            String className,
            Class<?> classBeingRedefined,
            ProtectionDomain protectionDomain,
            byte[] classfileBuffer) {
        if (className == null || classfileBuffer == null) {
            return null;
        }

        // 제외 패키지 체크
        for (String prefix : excludedPrefixes) {
            if (className.startsWith(prefix)) {
                return null;
            }
        }

        // Game ClassLoader 등록 (최초 zombie 클래스 발견 시)
        if (className.startsWith("zombie/") && loader != null) {
            if (PulseEnvironment.getGameClassLoader() == null) {
                PulseEnvironment.setGameClassLoader(loader);
            }
        }

        // Mixin 변환 적용
        byte[] transformed = applyMixinTransform(className, classfileBuffer);

        return transformed;
    }

    // Java 9+ module-aware 버전
    @Override
    public byte[] transform(
            Module module,
            ClassLoader loader,
            String className,
            Class<?> classBeingRedefined,
            ProtectionDomain protectionDomain,
            byte[] classfileBuffer) {
        return transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);
    }

    private byte[] applyMixinTransform(String className, byte[] classfileBuffer) {
        if (!mixinReady || mixinTransformer == null) {
            return null;
        }

        // zombie 패키지만 Mixin 대상
        if (!className.startsWith("zombie/")) {
            return null;
        }

        String dotName = className.replace('/', '.');

        try {
            // Mixin 환경 가져오기
            MixinEnvironment env = MixinEnvironment.getDefaultEnvironment();

            // 변환 수행
            byte[] result = mixinTransformer.transformClass(env, dotName, classfileBuffer);

            if (result != null && result != classfileBuffer) {
                transformedClasses.add(dotName);

                // MixinDiagnostics 연동
                MixinDiagnostics.getInstance().recordMixinApplied(
                        dotName, "PulseTransformer", "pulse", 1000);

                System.out.println("[Pulse/Transformer] ✓ Mixin applied to: " + dotName);
                return result;
            }

        } catch (Throwable t) {
            // 실패 추적
            MixinDiagnostics.getInstance().recordMixinFailed(
                    "Unknown", "pulse", dotName, t.getMessage());

            System.err.println("[Pulse/Transformer] Error transforming: " + dotName);
            t.printStackTrace();
        }

        return null;
    }

    public Set<String> getTransformedClasses() {
        return new java.util.HashSet<>(transformedClasses);
    }

    public boolean isMixinReady() {
        return mixinReady;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\transformer\PulseClassTransformer.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\Button.java =====

package com.pulse.ui;

import java.util.function.Consumer;

/**
 * 버튼 위젯.
 */
public class Button extends Widget {

    private String text;
    private Consumer<Button> onClick;
    private boolean hovered = false;
    private boolean pressed = false;

    // 색상
    private int backgroundColor = 0x404040;
    private int hoverColor = 0x505050;
    private int pressedColor = 0x303030;
    private int textColor = 0xFFFFFF;
    private int borderColor = 0x606060;

    public Button(int x, int y, int width, int height, String text) {
        super(x, y, width, height);
        this.text = text;
    }

    public Button(int x, int y, int width, int height, String text, Consumer<Button> onClick) {
        this(x, y, width, height, text);
        this.onClick = onClick;
    }

    @Override
    public void render(UIRenderContext ctx) {
        if (!visible)
            return;

        int absX = getAbsoluteX();
        int absY = getAbsoluteY();

        // 배경
        int bgColor = pressed ? pressedColor : (hovered ? hoverColor : backgroundColor);
        ctx.fillRect(absX, absY, width, height, bgColor);

        // 테두리
        ctx.drawRect(absX, absY, width, height, borderColor);

        // 텍스트 (가운데 정렬)
        int textWidth = ctx.getTextWidth(text);
        int textHeight = ctx.getTextHeight();
        int textX = absX + (width - textWidth) / 2;
        int textY = absY + (height - textHeight) / 2;
        ctx.drawText(text, textX, textY, enabled ? textColor : 0x808080);
    }

    @Override
    public void onMouseMove(int mouseX, int mouseY) {
        hovered = isMouseOver(mouseX, mouseY);
    }

    @Override
    public boolean onMouseClick(int mouseX, int mouseY, int button) {
        if (!visible || !enabled)
            return false;

        if (button == 0 && isMouseOver(mouseX, mouseY)) {
            pressed = true;
            if (onClick != null) {
                onClick.accept(this);
            }
            return true;
        }
        return false;
    }

    // Getters/Setters
    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public void setOnClick(Consumer<Button> onClick) {
        this.onClick = onClick;
    }

    public void setBackgroundColor(int color) {
        this.backgroundColor = color;
    }

    public void setHoverColor(int color) {
        this.hoverColor = color;
    }

    public void setTextColor(int color) {
        this.textColor = color;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\Button.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\HUDOverlay.java =====

package com.pulse.ui;

import java.util.*;

/**
 * HUD 오버레이 매니저.
 * 게임 화면 위에 표시되는 UI 레이어.
 */
public class HUDOverlay {

    private static final HUDOverlay INSTANCE = new HUDOverlay();

    private final Map<String, HUDLayer> layers = new LinkedHashMap<>();
    private boolean visible = true;

    private HUDOverlay() {
    }

    public static HUDOverlay getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 레이어 관리
    // ─────────────────────────────────────────────────────────────

    /**
     * HUD 레이어 등록.
     * 
     * @param id       레이어 식별자
     * @param layer    레이어
     * @param priority 우선순위 (낮을수록 먼저 렌더링)
     */
    public static void registerLayer(String id, HUDLayer layer, int priority) {
        layer.id = id;
        layer.priority = priority;
        INSTANCE.layers.put(id, layer);
        INSTANCE.sortLayers();
        System.out.println("[Pulse/HUD] Registered layer: " + id);
    }

    /**
     * HUD 레이어 등록 해제.
     */
    public static void unregisterLayer(String id) {
        INSTANCE.layers.remove(id);
    }

    /**
     * 레이어 가져오기.
     */
    public static HUDLayer getLayer(String id) {
        return INSTANCE.layers.get(id);
    }

    private void sortLayers() {
        List<Map.Entry<String, HUDLayer>> entries = new ArrayList<>(layers.entrySet());
        entries.sort(Comparator.comparingInt(e -> e.getValue().priority));

        layers.clear();
        for (var entry : entries) {
            layers.put(entry.getKey(), entry.getValue());
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 렌더링
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 HUD 레이어 렌더링.
     */
    public static void render(UIRenderContext ctx) {
        if (!INSTANCE.visible)
            return;

        for (HUDLayer layer : INSTANCE.layers.values()) {
            if (layer.isVisible()) {
                try {
                    layer.render(ctx);
                } catch (Exception e) {
                    System.err.println("[Pulse/HUD] Error rendering layer: " + layer.id);
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * 모든 HUD 레이어 업데이트.
     */
    public static void update(float deltaTime) {
        for (HUDLayer layer : INSTANCE.layers.values()) {
            if (layer.isVisible()) {
                layer.update(deltaTime);
            }
        }
    }

    // Getters/Setters
    public static boolean isVisible() {
        return INSTANCE.visible;
    }

    public static void setVisible(boolean visible) {
        INSTANCE.visible = visible;
    }

    public static Collection<HUDLayer> getLayers() {
        return Collections.unmodifiableCollection(INSTANCE.layers.values());
    }

    // ─────────────────────────────────────────────────────────────
    // HUD 레이어 추상 클래스
    // ─────────────────────────────────────────────────────────────

    public static abstract class HUDLayer {
        String id;
        int priority;
        private boolean visible = true;

        /**
         * 레이어 렌더링.
         */
        public abstract void render(UIRenderContext ctx);

        /**
         * 레이어 업데이트.
         */
        public void update(float deltaTime) {
            // 선택적 오버라이드
        }

        public String getId() {
            return id;
        }

        public int getPriority() {
            return priority;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\HUDOverlay.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\Label.java =====

package com.pulse.ui;

/**
 * 텍스트 라벨 위젯.
 */
public class Label extends Widget {

    private String text;
    private int textColor = 0xFFFFFF;
    private Alignment alignment = Alignment.LEFT;

    public Label(int x, int y, String text) {
        super(x, y, 0, 16); // 너비는 텍스트에 맞춰 자동 조정
        this.text = text;
    }

    public Label(int x, int y, int width, int height, String text) {
        super(x, y, width, height);
        this.text = text;
    }

    @Override
    public void render(UIRenderContext ctx) {
        if (!visible || text == null)
            return;

        int absX = getAbsoluteX();
        int absY = getAbsoluteY();

        int textWidth = ctx.getTextWidth(text);
        int textX;

        switch (alignment) {
            case CENTER:
                textX = absX + (width - textWidth) / 2;
                break;
            case RIGHT:
                textX = absX + width - textWidth;
                break;
            default:
                textX = absX;
        }

        ctx.drawText(text, textX, absY, textColor);
    }

    // Getters/Setters
    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public int getTextColor() {
        return textColor;
    }

    public void setTextColor(int color) {
        this.textColor = color;
    }

    public Alignment getAlignment() {
        return alignment;
    }

    public void setAlignment(Alignment alignment) {
        this.alignment = alignment;
    }

    public enum Alignment {
        LEFT, CENTER, RIGHT
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\Label.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\Panel.java =====

package com.pulse.ui;

import java.util.ArrayList;
import java.util.List;

/**
 * 컨테이너 패널 위젯.
 * 다른 위젯들을 포함.
 */
public class Panel extends Widget {

    private final List<Widget> children = new ArrayList<>();
    private int backgroundColor = 0x303030;
    private int borderColor = 0x505050;
    private boolean drawBackground = true;
    private boolean drawBorder = true;
    private int padding = 4;

    public Panel(int x, int y, int width, int height) {
        super(x, y, width, height);
    }

    @Override
    public void render(UIRenderContext ctx) {
        if (!visible)
            return;

        int absX = getAbsoluteX();
        int absY = getAbsoluteY();

        // 배경
        if (drawBackground) {
            ctx.fillRect(absX, absY, width, height, backgroundColor);
        }

        // 테두리
        if (drawBorder) {
            ctx.drawRect(absX, absY, width, height, borderColor);
        }

        // 자식 위젯 렌더링
        for (Widget child : children) {
            if (child.isVisible()) {
                child.preRender(ctx);
                child.render(ctx);
                child.postRender(ctx);
            }
        }
    }

    @Override
    public boolean onMouseClick(int mouseX, int mouseY, int button) {
        if (!visible || !enabled)
            return false;

        // 역순으로 검사 (위에 있는 것이 먼저)
        for (int i = children.size() - 1; i >= 0; i--) {
            Widget child = children.get(i);
            if (child.isVisible() && child.isEnabled()) {
                if (child.onMouseClick(mouseX, mouseY, button)) {
                    return true;
                }
            }
        }
        return isMouseOver(mouseX, mouseY);
    }

    @Override
    public void onMouseMove(int mouseX, int mouseY) {
        for (Widget child : children) {
            if (child.isVisible()) {
                child.onMouseMove(mouseX, mouseY);
            }
        }
    }

    @Override
    public boolean onKeyPress(int keyCode, char character) {
        for (Widget child : children) {
            if (child.isVisible() && child.isEnabled()) {
                if (child.onKeyPress(keyCode, character)) {
                    return true;
                }
            }
        }
        return false;
    }

    // ─────────────────────────────────────────────────────────────
    // 자식 관리
    // ─────────────────────────────────────────────────────────────

    public void add(Widget widget) {
        widget.setParent(this);
        children.add(widget);
    }

    public void remove(Widget widget) {
        widget.setParent(null);
        children.remove(widget);
    }

    public void clear() {
        for (Widget child : children) {
            child.setParent(null);
        }
        children.clear();
    }

    public List<Widget> getChildren() {
        return new ArrayList<>(children);
    }

    public Widget findById(String id) {
        for (Widget child : children) {
            if (id.equals(child.getId())) {
                return child;
            }
            if (child instanceof Panel) {
                Widget found = ((Panel) child).findById(id);
                if (found != null)
                    return found;
            }
        }
        return null;
    }

    // Getters/Setters
    public int getBackgroundColor() {
        return backgroundColor;
    }

    public void setBackgroundColor(int color) {
        this.backgroundColor = color;
    }

    public int getBorderColor() {
        return borderColor;
    }

    public void setBorderColor(int color) {
        this.borderColor = color;
    }

    public boolean isDrawBackground() {
        return drawBackground;
    }

    public void setDrawBackground(boolean draw) {
        this.drawBackground = draw;
    }

    public boolean isDrawBorder() {
        return drawBorder;
    }

    public void setDrawBorder(boolean draw) {
        this.drawBorder = draw;
    }

    public int getPadding() {
        return padding;
    }

    public void setPadding(int padding) {
        this.padding = padding;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\Panel.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\TextField.java =====

package com.pulse.ui;

import java.util.function.Consumer;

/**
 * 텍스트 입력 필드 위젯.
 */
public class TextField extends Widget {

    private StringBuilder text = new StringBuilder();
    private String placeholder = "";
    private int maxLength = 256;
    private int cursorPosition = 0;
    private boolean focused = false;

    // 콜백
    private Consumer<String> onTextChanged;
    private Consumer<String> onSubmit;

    // 색상
    private int backgroundColor = 0x202020;
    private int textColor = 0xFFFFFF;
    private int placeholderColor = 0x808080;
    private int borderColor = 0x404040;
    private int focusBorderColor = 0x6060FF;

    public TextField(int x, int y, int width, int height) {
        super(x, y, width, height);
    }

    public TextField(int x, int y, int width, int height, String placeholder) {
        this(x, y, width, height);
        this.placeholder = placeholder;
    }

    @Override
    public void render(UIRenderContext ctx) {
        if (!visible)
            return;

        int absX = getAbsoluteX();
        int absY = getAbsoluteY();

        // 배경
        ctx.fillRect(absX, absY, width, height, backgroundColor);

        // 테두리
        ctx.drawRect(absX, absY, width, height, focused ? focusBorderColor : borderColor);

        // 텍스트 또는 플레이스홀더
        String displayText = text.length() > 0 ? text.toString() : placeholder;
        int color = text.length() > 0 ? textColor : placeholderColor;

        int padding = 4;
        int textY = absY + (height - ctx.getTextHeight()) / 2;
        ctx.drawText(displayText, absX + padding, textY, color);

        // 커서 (포커스 시)
        if (focused && System.currentTimeMillis() % 1000 < 500) {
            String beforeCursor = text.substring(0, Math.min(cursorPosition, text.length()));
            int cursorX = absX + padding + ctx.getTextWidth(beforeCursor);
            ctx.fillRect(cursorX, absY + 2, 1, height - 4, textColor);
        }
    }

    @Override
    public boolean onMouseClick(int mouseX, int mouseY, int button) {
        boolean wasMouseOver = isMouseOver(mouseX, mouseY);
        focused = wasMouseOver && enabled;
        return wasMouseOver;
    }

    @Override
    public boolean onKeyPress(int keyCode, char character) {
        if (!focused || !enabled)
            return false;

        // 백스페이스
        if (keyCode == 14 && cursorPosition > 0) {
            text.deleteCharAt(cursorPosition - 1);
            cursorPosition--;
            notifyTextChanged();
            return true;
        }

        // Delete
        if (keyCode == 211 && cursorPosition < text.length()) {
            text.deleteCharAt(cursorPosition);
            notifyTextChanged();
            return true;
        }

        // Enter
        if (keyCode == 28) {
            if (onSubmit != null) {
                onSubmit.accept(text.toString());
            }
            return true;
        }

        // 좌/우 화살표
        if (keyCode == 203 && cursorPosition > 0) {
            cursorPosition--;
            return true;
        }
        if (keyCode == 205 && cursorPosition < text.length()) {
            cursorPosition++;
            return true;
        }

        // 일반 문자 입력
        if (character >= 32 && character < 127 && text.length() < maxLength) {
            text.insert(cursorPosition, character);
            cursorPosition++;
            notifyTextChanged();
            return true;
        }

        return false;
    }

    private void notifyTextChanged() {
        if (onTextChanged != null) {
            onTextChanged.accept(text.toString());
        }
    }

    // Getters/Setters
    public String getText() {
        return text.toString();
    }

    public void setText(String text) {
        this.text = new StringBuilder(text);
        this.cursorPosition = text.length();
    }

    public String getPlaceholder() {
        return placeholder;
    }

    public void setPlaceholder(String placeholder) {
        this.placeholder = placeholder;
    }

    public int getMaxLength() {
        return maxLength;
    }

    public void setMaxLength(int maxLength) {
        this.maxLength = maxLength;
    }

    public boolean isFocused() {
        return focused;
    }

    public void setFocused(boolean focused) {
        this.focused = focused;
    }

    public void setOnTextChanged(Consumer<String> callback) {
        this.onTextChanged = callback;
    }

    public void setOnSubmit(Consumer<String> callback) {
        this.onSubmit = callback;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\TextField.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\UIRenderContext.java =====

package com.pulse.ui;

/**
 * UI 렌더링 컨텍스트.
 * 위젯 렌더링에 필요한 그래픽 API 래퍼.
 */
public class UIRenderContext {

    private Object graphics; // PZ의 UIGraphics 또는 Graphics2D
    private float deltaTime;
    private int screenWidth;
    private int screenHeight;

    public UIRenderContext(Object graphics, float deltaTime, int screenWidth, int screenHeight) {
        this.graphics = graphics;
        this.deltaTime = deltaTime;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
    }

    // ─────────────────────────────────────────────────────────────
    // 기본 그리기
    // ─────────────────────────────────────────────────────────────

    /**
     * 사각형 그리기.
     */
    public void drawRect(int x, int y, int width, int height, int color) {
        drawRect(x, y, width, height, color, 1.0f);
    }

    public void drawRect(int x, int y, int width, int height, int color, float alpha) {
        try {
            // PZ UIGraphics 사용 시도
            if (graphics != null) {
                java.lang.reflect.Method drawMethod = graphics.getClass().getMethod(
                        "DrawRect", int.class, int.class, int.class, int.class,
                        float.class, float.class, float.class, float.class);

                float r = ((color >> 16) & 0xFF) / 255.0f;
                float g = ((color >> 8) & 0xFF) / 255.0f;
                float b = (color & 0xFF) / 255.0f;

                drawMethod.invoke(graphics, x, y, width, height, r, g, b, alpha);
            }
        } catch (Exception e) {
            // 폴백: 콘솔 로그
        }
    }

    /**
     * 채워진 사각형 그리기.
     */
    public void fillRect(int x, int y, int width, int height, int color) {
        fillRect(x, y, width, height, color, 1.0f);
    }

    public void fillRect(int x, int y, int width, int height, int color, float alpha) {
        try {
            if (graphics != null) {
                java.lang.reflect.Method fillMethod = graphics.getClass().getMethod(
                        "DrawRectFilled", int.class, int.class, int.class, int.class,
                        float.class, float.class, float.class, float.class);

                float r = ((color >> 16) & 0xFF) / 255.0f;
                float g = ((color >> 8) & 0xFF) / 255.0f;
                float b = (color & 0xFF) / 255.0f;

                fillMethod.invoke(graphics, x, y, width, height, r, g, b, alpha);
            }
        } catch (Exception e) {
            // 폴백
        }
    }

    /**
     * 텍스트 그리기.
     */
    public void drawText(String text, int x, int y, int color) {
        try {
            if (graphics != null) {
                java.lang.reflect.Method textMethod = graphics.getClass().getMethod(
                        "DrawText", String.class, int.class, int.class,
                        float.class, float.class, float.class, float.class);

                float r = ((color >> 16) & 0xFF) / 255.0f;
                float g = ((color >> 8) & 0xFF) / 255.0f;
                float b = (color & 0xFF) / 255.0f;

                textMethod.invoke(graphics, text, x, y, r, g, b, 1.0f);
            }
        } catch (Exception e) {
            // 폴백
        }
    }

    /**
     * 텍스트 너비 계산.
     */
    public int getTextWidth(String text) {
        try {
            if (graphics != null) {
                java.lang.reflect.Method widthMethod = graphics.getClass().getMethod(
                        "getTextWidth", String.class);
                return (int) widthMethod.invoke(graphics, text);
            }
        } catch (Exception e) {
            // 폴백: 글자당 8픽셀
        }
        return text.length() * 8;
    }

    /**
     * 텍스트 높이.
     */
    public int getTextHeight() {
        return 16; // 기본 폰트 높이
    }

    // Getters
    public Object getGraphics() {
        return graphics;
    }

    public float getDeltaTime() {
        return deltaTime;
    }

    public int getScreenWidth() {
        return screenWidth;
    }

    public int getScreenHeight() {
        return screenHeight;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\UIRenderContext.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\UIScreen.java =====

package com.pulse.ui;

import java.util.Stack;

/**
 * UI 스크린 매니저.
 * 게임 UI 스크린 관리 및 전환.
 */
public class UIScreen extends Panel {

    private static final Stack<UIScreen> screenStack = new Stack<>();
    private static UIScreen currentScreen = null;

    private String title;
    private boolean pauseGame = false;

    public UIScreen(String title) {
        super(0, 0, 800, 600); // 기본 크기 (런타임에 조정)
        this.title = title;
        setDrawBackground(true);
        setBackgroundColor(0x000000);
    }

    // ─────────────────────────────────────────────────────────────
    // 스크린 라이프사이클
    // ─────────────────────────────────────────────────────────────

    /**
     * 스크린이 열릴 때 호출.
     */
    public void onOpen() {
        System.out.println("[Pulse/UI] Screen opened: " + title);
    }

    /**
     * 스크린이 닫힐 때 호출.
     */
    public void onClose() {
        System.out.println("[Pulse/UI] Screen closed: " + title);
    }

    /**
     * 매 프레임 업데이트.
     */
    public void update(float deltaTime) {
        // 하위 클래스에서 오버라이드
    }

    // ─────────────────────────────────────────────────────────────
    // 스크린 관리 (정적 메서드)
    // ─────────────────────────────────────────────────────────────

    /**
     * 스크린 열기.
     */
    public static void open(UIScreen screen) {
        if (currentScreen != null) {
            screenStack.push(currentScreen);
        }
        currentScreen = screen;
        screen.onOpen();
    }

    /**
     * 현재 스크린 닫기.
     */
    public static void close() {
        if (currentScreen != null) {
            currentScreen.onClose();
            currentScreen = screenStack.isEmpty() ? null : screenStack.pop();
        }
    }

    /**
     * 모든 스크린 닫기.
     */
    public static void closeAll() {
        while (currentScreen != null) {
            close();
        }
    }

    /**
     * 현재 스크린 가져오기.
     */
    public static UIScreen getCurrent() {
        return currentScreen;
    }

    /**
     * 스크린이 열려 있는지 확인.
     */
    public static boolean isOpen() {
        return currentScreen != null;
    }

    /**
     * 현재 스크린 렌더링.
     */
    public static void renderCurrent(UIRenderContext ctx) {
        if (currentScreen != null && currentScreen.isVisible()) {
            currentScreen.preRender(ctx);
            currentScreen.render(ctx);
            currentScreen.postRender(ctx);
        }
    }

    /**
     * 현재 스크린 업데이트.
     */
    public static void updateCurrent(float deltaTime) {
        if (currentScreen != null) {
            currentScreen.update(deltaTime);
        }
    }

    // Getters/Setters
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public boolean isPauseGame() {
        return pauseGame;
    }

    public void setPauseGame(boolean pause) {
        this.pauseGame = pause;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\UIScreen.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\Widget.java =====

package com.pulse.ui;

/**
 * UI 위젯 기본 클래스.
 * 모든 UI 요소의 상위 클래스.
 */
public abstract class Widget {

    protected int x, y;
    protected int width, height;
    protected boolean visible = true;
    protected boolean enabled = true;
    protected Widget parent;
    protected String id;

    public Widget(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    // ─────────────────────────────────────────────────────────────
    // 렌더링
    // ─────────────────────────────────────────────────────────────

    /**
     * 위젯 렌더링 (하위 클래스에서 구현).
     */
    public abstract void render(UIRenderContext ctx);

    /**
     * 렌더링 전 처리.
     */
    public void preRender(UIRenderContext ctx) {
        // 선택적 오버라이드
    }

    /**
     * 렌더링 후 처리.
     */
    public void postRender(UIRenderContext ctx) {
        // 선택적 오버라이드
    }

    // ─────────────────────────────────────────────────────────────
    // 입력 처리
    // ─────────────────────────────────────────────────────────────

    /**
     * 마우스 클릭 처리.
     * 
     * @return 이벤트 소비 여부
     */
    public boolean onMouseClick(int mouseX, int mouseY, int button) {
        return false;
    }

    /**
     * 마우스 이동 처리.
     */
    public void onMouseMove(int mouseX, int mouseY) {
        // 선택적 오버라이드
    }

    /**
     * 키 입력 처리.
     * 
     * @return 이벤트 소비 여부
     */
    public boolean onKeyPress(int keyCode, char character) {
        return false;
    }

    /**
     * 마우스가 위젯 위에 있는지 확인.
     */
    public boolean isMouseOver(int mouseX, int mouseY) {
        int absX = getAbsoluteX();
        int absY = getAbsoluteY();
        return mouseX >= absX && mouseX < absX + width &&
                mouseY >= absY && mouseY < absY + height;
    }

    // ─────────────────────────────────────────────────────────────
    // 위치/크기
    // ─────────────────────────────────────────────────────────────

    public int getAbsoluteX() {
        return parent != null ? parent.getAbsoluteX() + x : x;
    }

    public int getAbsoluteY() {
        return parent != null ? parent.getAbsoluteY() + y : y;
    }

    public void setPosition(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void setSize(int width, int height) {
        this.width = width;
        this.height = height;
    }

    public void setBounds(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    // Getters/Setters
    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public boolean isVisible() {
        return visible;
    }

    public void setVisible(boolean visible) {
        this.visible = visible;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    public Widget getParent() {
        return parent;
    }

    public void setParent(Widget parent) {
        this.parent = parent;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\java\com\pulse\ui\Widget.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\src\main\resources\mixins.pulse.json =====

{
  "required": true,
  "minVersion": "0.8",
  "package": "com.pulse.mixin",
  "mixins": [
    "MainScreenStateMixin",
    "GameClientMixin",
    "GameWindowMixin",
    "IsoWorldMixin",
    "IsoPlayerMixin"
  ],
  "client": [],
  "server": [],
  "injectors": {
    "defaultRequire": 0
  },
  "verbose": true
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\src\main\resources\mixins.pulse.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-a\build.gradle =====

plugins {
    id 'java'
}

group = 'com.pulse.test'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // Pulse API - 컴파일 타임에만 필요
    compileOnly files('../../build/libs/Pulse.jar')
}

jar {
    archiveBaseName.set('test-mod-a')
    
    from('src/main/resources') {
        include 'pulse.mod.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Test Mod A',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-a\build.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-a\src\main\java\com\mutagen\test\a\TestModA.java =====

package com.pulse.test.a;

import com.pulse.api.Pulse;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.mod.PulseMod;

/**
 * Test Mod A - Phase 1 검증용 단순 로그/이벤트 테스트 모드
 * 
 * 테스트 항목:
 * - PulseMod 인터페이스 작동
 * - onInitialize() 호출
 * - EventBus 구독/이벤트 처리
 */
public class TestModA implements PulseMod {

    private static final String MOD_ID = "test_mod_a";
    private int tickCount = 0;

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "═══════════════════════════════════════");
        Pulse.log(MOD_ID, "Test Mod A - onInitialize() called!");
        Pulse.log(MOD_ID, "═══════════════════════════════════════");

        // 이벤트 리스너 등록
        registerEventListeners();

        Pulse.log(MOD_ID, "Test Mod A initialized successfully!");
    }

    private void registerEventListeners() {
        Pulse.log(MOD_ID, "Registering event listeners...");

        // 게임 틱 이벤트 구독
        EventBus.subscribe(GameTickEvent.class, this::onGameTick);

        Pulse.log(MOD_ID, "Event listeners registered!");
    }

    private void onGameTick(GameTickEvent event) {
        tickCount++;

        // 매 1000틱마다 로그 출력 (약 50초)
        if (tickCount % 1000 == 0) {
            Pulse.log(MOD_ID, "Tick count: " + tickCount + " (Event handling works!)");
        }
    }

    @Override
    public void onWorldLoad() {
        Pulse.log(MOD_ID, "World loaded! Test Mod A is active.");
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Test Mod A unloading...");
        Pulse.log(MOD_ID, "Total ticks processed: " + tickCount);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-a\src\main\java\com\mutagen\test\a\TestModA.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-a\src\main\resources\pulse.mod.json =====

{
    "id": "test_mod_a",
    "name": "Test Mod A",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Simple logging and event test mod for Phase 1 verification",
    "entrypoint": "com.pulse.test.a.TestModA",
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-a\src\main\resources\pulse.mod.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-b\build.gradle =====

plugins {
    id 'java'
}

group = 'com.pulse.test'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven/' }
}

dependencies {
    // Pulse API - 컴파일 타임에만 필요
    compileOnly files('../../build/libs/Pulse.jar')
    
    // Mixin (annotation processing용)
    compileOnly 'org.spongepowered:mixin:0.8.5'
}

jar {
    archiveBaseName.set('test-mod-b')
    
    from('src/main/resources') {
        include 'pulse.mod.json'
        include 'mixins.testmodb.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Test Mod B',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-b\build.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-b\src\main\java\com\mutagen\test\b\mixin\TestMixin.java =====

package com.pulse.test.b.mixin;

import com.pulse.test.b.TestModB;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * Test Mixin - Phase 1 검증용 간단한 Mixin
 * 
 * 이 Mixin은 Object 클래스의 toString()을 타겟으로 합니다.
 * 실제 게임에서는 zombie.* 클래스를 타겟으로 해야 합니다.
 * 
 * 이 예제는 Mixin 시스템 동작 확인용입니다.
 */
@Mixin(Object.class)
public class TestMixin {

    /**
     * 정적 초기화 블록에서 Mixin 적용 알림
     * Mixin 클래스가 로드되면 실행됨
     */
    static {
        try {
            TestModB.onMixinApplied("java.lang.Object");
        } catch (Throwable t) {
            // TestModB가 아직 로드되지 않았을 수 있음
            System.out.println("[TestMixin] Mixin class loaded (TestModB not ready yet)");
        }
    }

    // Note: 실제로 Object.toString()에 Inject하면 성능 영향이 있으므로
    // 이 예제에서는 static 블록으로 로딩만 확인합니다.
    // 실제 모드에서는 게임 클래스를 타겟으로 해야 합니다.
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-b\src\main\java\com\mutagen\test\b\mixin\TestMixin.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-b\src\main\java\com\mutagen\test\b\TestModB.java =====

package com.pulse.test.b;

import com.pulse.api.Pulse;
import com.pulse.mod.PulseMod;

/**
 * Test Mod B - Phase 1 검증용 Mixin 테스트 모드
 * 
 * 테스트 항목:
 * - PulseMod 인터페이스 작동
 * - 외부 Mixin 설정 로딩
 * - Mixin 적용 확인
 */
public class TestModB implements PulseMod {

    private static final String MOD_ID = "test_mod_b";
    private static boolean mixinApplied = false;

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "═══════════════════════════════════════");
        Pulse.log(MOD_ID, "Test Mod B - onInitialize() called!");
        Pulse.log(MOD_ID, "═══════════════════════════════════════");

        // Mixin 적용 확인
        if (mixinApplied) {
            Pulse.log(MOD_ID, "✓ Mixin was applied successfully!");
        } else {
            Pulse.log(MOD_ID, "⚠ Mixin not yet applied (might be applied after class loads)");
        }

        Pulse.log(MOD_ID, "Test Mod B initialized successfully!");
    }

    /**
     * Mixin에서 호출하는 콜백 메서드
     */
    public static void onMixinApplied(String targetClass) {
        mixinApplied = true;
        Pulse.log("test_mod_b", "Mixin successfully applied to: " + targetClass);
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Test Mod B unloading...");
        Pulse.log(MOD_ID, "Mixin was applied: " + mixinApplied);
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-b\src\main\java\com\mutagen\test\b\TestModB.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-b\src\main\resources\mixins.testmodb.json =====

{
    "required": true,
    "package": "com.pulse.test.b.mixin",
    "compatibilityLevel": "JAVA_17",
    "mixins": [
        "TestMixin"
    ],
    "injectors": {
        "defaultRequire": 1
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-b\src\main\resources\mixins.testmodb.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-b\src\main\resources\pulse.mod.json =====

{
    "id": "test_mod_b",
    "name": "Test Mod B",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Mixin test mod for Phase 1 verification",
    "entrypoint": "com.pulse.test.b.TestModB",
    "mixins": [
        "mixins.testmodb.json"
    ],
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-mods\test-mod-b\src\main\resources\pulse.mod.json =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-output\testmod\build.gradle =====

plugins {
    id 'java'
}

group = 'com.example.testmod'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // Pulse API - compile time only
    compileOnly files('path/to/Pulse.jar')
}

jar {
    from('src/main/resources') {
        include 'pulse.mod.json'
    }
    
    manifest {
        attributes(
            'Implementation-Title': 'Test Mod',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-output\testmod\build.gradle =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-output\testmod\src\main\java\com\example\testmod\TestmodMod.java =====

package com.example.testmod;

import com.pulse.api.Pulse;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameInitEvent;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.mod.PulseMod;

/**
 * Test Mod - Main mod class
 */
public class TestmodMod implements PulseMod {

    private static final String MOD_ID = "testmod";

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "Test Mod initializing...");
        
        // Register event listeners
        EventBus.subscribe(GameInitEvent.class, this::onGameInit, MOD_ID);
        EventBus.subscribe(GameTickEvent.class, this::onGameTick, MOD_ID);
        
        Pulse.log(MOD_ID, "Test Mod initialized!");
    }
    
    private void onGameInit(GameInitEvent event) {
        Pulse.log(MOD_ID, "Game initialization complete!");
    }
    
    private void onGameTick(GameTickEvent event) {
        // Called every game tick
        // Add your tick logic here
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Test Mod unloading...");
    }
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-output\testmod\src\main\java\com\example\testmod\TestmodMod.java =====


===== FILE START: C:\Users\MW\Downloads\coding\Pulse\test-output\testmod\src\main\resources\pulse.mod.json =====

{
  "id": "testmod",
  "name": "Test Mod",
  "version": "1.0.0",
  "author": "Developer",
  "description": "A Pulse mod for Project Zomboid",
  "entrypoint": "com.example.testmod.testmodMod",
  "dependencies": [
    {
      "id": "Pulse",
      "version": ">=1.0.0"
    }
  ]
}

===== FILE END: C:\Users\MW\Downloads\coding\Pulse\test-output\testmod\src\main\resources\pulse.mod.json =====

