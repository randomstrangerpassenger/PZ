

===== FILE: C:\Users\MW\Downloads\coding\PZ\.vscode\settings.json =====

{
<<<<<<< HEAD
    "java.compile.nullAnalysis.mode": "automatic",
=======
>>>>>>> echo-history/main
    "java.configuration.updateBuildConfiguration": "interactive"
}


===== FILE: C:\Users\MW\Downloads\coding\PZ\build.gradle =====

// PZ Root Project - Common Build Configuration
// Applies common settings to all subprojects

plugins {
    id 'base'
}

// ═══════════════════════════════════════════════════════════════
// Version Catalog - Centralized dependency versions
// ═══════════════════════════════════════════════════════════════
ext {
    versions = [
        mixin: '0.8.5',
        asm: '9.6',
        gson: '2.10.1',
        junit: '5.10.0',
        mockito: '5.6.0'
    ]
    
    // ═══════════════════════════════════════════════════════════════
    // Project Zomboid Auto-Detection
    // Automatically finds the game installation by reading Steam's
    // library configuration file (libraryfolders.vdf)
    // ═══════════════════════════════════════════════════════════════
    
    findProjectZomboid = {
        // 1. Manual override via gradle.properties or environment variable
        def manualPath = System.getenv('PZ_HOME') ?: findProperty('pzHome')
        if (manualPath) {
            def manualDir = file(manualPath)
            if (manualDir.exists()) {
                logger.lifecycle("[PZ] Using manual path: ${manualPath}")
                return manualPath
            } else {
                logger.warn("[PZ] Manual path not found: ${manualPath}")
            }
        }
        
        // 2. Find Steam installation
        def steamPaths = []
        
        // Windows default Steam locations
        if (System.getProperty('os.name').toLowerCase().contains('windows')) {
            steamPaths.addAll([
                'C:/Program Files (x86)/Steam',
                'C:/Program Files/Steam',
                'D:/Program Files (x86)/Steam',
                'D:/Steam'
            ])
            
            // Try to read from Windows Registry
            try {
                def regQuery = 'reg query "HKEY_CURRENT_USER\\Software\\Valve\\Steam" /v SteamPath'.execute()
                def output = regQuery.text
                def match = output =~ /SteamPath\s+REG_SZ\s+(.+)/
                if (match) {
                    steamPaths.add(0, match[0][1].trim().replace('\\', '/'))
                }
            } catch (Exception ignored) {}
        }
        // Linux
        else if (System.getProperty('os.name').toLowerCase().contains('linux')) {
            def home = System.getProperty('user.home')
            steamPaths.addAll([
                "${home}/.steam/steam",
                "${home}/.local/share/Steam"
            ])
        }
        // macOS
        else if (System.getProperty('os.name').toLowerCase().contains('mac')) {
            def home = System.getProperty('user.home')
            steamPaths.add("${home}/Library/Application Support/Steam")
        }
        
        // 3. Find the actual Steam directory
        def steamDir = steamPaths.find { file(it).exists() }
        if (!steamDir) {
            logger.warn("[PZ] Steam installation not found in common locations")
            return null
        }
        logger.lifecycle("[PZ] Found Steam: ${steamDir}")
        
        // 4. Parse libraryfolders.vdf to find all Steam libraries
        def libraryFolders = []
        libraryFolders.add("${steamDir}/steamapps") // Default library
        
        def vdfFile = file("${steamDir}/steamapps/libraryfolders.vdf")
        if (vdfFile.exists()) {
            def vdfContent = vdfFile.text
            // Simple regex to extract paths from VDF
            def pathPattern = /"path"\s+"([^"]+)"/
            (vdfContent =~ pathPattern).each { match ->
                def libPath = match[1].replace('\\\\', '/').replace('\\', '/')
                def steamapps = "${libPath}/steamapps"
                if (!libraryFolders.contains(steamapps) && file(steamapps).exists()) {
                    libraryFolders.add(steamapps)
                }
            }
        }
        
        logger.lifecycle("[PZ] Found ${libraryFolders.size()} Steam library folder(s)")
        
        // 5. Search for ProjectZomboid in all libraries
        for (lib in libraryFolders) {
            def pzPath = "${lib}/common/ProjectZomboid"
            if (file(pzPath).exists()) {
                logger.lifecycle("[PZ] Found Project Zomboid: ${pzPath}")
                return pzPath
            }
        }
        
        logger.warn("[PZ] Project Zomboid not found in any Steam library")
        logger.warn("[PZ] Please set 'pzHome' in gradle.properties or PZ_HOME environment variable")
        return null
    }
    
    // Cache the result
    pzGamePath = findProjectZomboid()
}

// ═══════════════════════════════════════════════════════════════
// Common configuration for all subprojects
// ═══════════════════════════════════════════════════════════════
subprojects {
    afterEvaluate {
        if (plugins.hasPlugin('java')) {
            java {
                sourceCompatibility = JavaVersion.VERSION_17
                targetCompatibility = JavaVersion.VERSION_17
            }
            
            tasks.withType(JavaCompile).configureEach {
                options.encoding = 'UTF-8'
                options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
            }
            
            repositories {
                mavenCentral()
                maven { url 'https://repo.spongepowered.org/maven/' }
            }
            
            // Common test dependencies
            dependencies {
                testImplementation "org.junit.jupiter:junit-jupiter:${rootProject.ext.versions.junit}"
                testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
            }
            
            test {
                useJUnitPlatform()
                testLogging {
                    events 'passed', 'skipped', 'failed'
                }
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════════
// Aggregate Tasks
// ═══════════════════════════════════════════════════════════════

task buildAll {
    description = 'Builds all subprojects'
    group = 'build'
    dependsOn subprojects.collect { it.tasks.matching { it.name == 'build' } }
}

task cleanAll {
    description = 'Cleans all subprojects'
    group = 'build'
    dependsOn subprojects.collect { it.tasks.matching { it.name == 'clean' } }
}

task testAll {
    description = 'Runs tests for all subprojects'
    group = 'verification'
    dependsOn subprojects.collect { it.tasks.matching { it.name == 'test' } }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\.vscode\settings.json =====

{
    "java.configuration.updateBuildConfiguration": "interactive"
}


===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\build.gradle =====

plugins {
    id 'java'
    id 'eclipse'
    id 'idea'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'com.echo'
version = '2.0.0'  // Synced with pulse.mod.json

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven' }
}

dependencies {
    // Pulse API (compile-only, provided at runtime by Pulse.jar)
    // - 로컬 개발 (PZ 루트): project(':pulse-api') 사용
    // - 단독 빌드 (Echo repo만): libs/pulse-api.jar 사용
    if (findProject(':pulse-api') != null) {
        compileOnly project(':pulse-api')
        testImplementation project(':pulse-api')  // v0.9: 테스트에서도 pulse-api 참조 필요
    } else {
        // Echo repo 단독 클론 시 폴백
        compileOnly files('libs/pulse-api.jar')
        testImplementation files('libs/pulse-api.jar')
    }
    
    // Pulse main (compile-only, for HUDOverlay/UIRenderContext - v2.0 Native UI)
    if (findProject(':Pulse') != null) {
        compileOnly project(':Pulse')
        testImplementation project(':Pulse')
    }
    
    // Project Zomboid stubs (compile-only, optional)
    // Use fileTree to gracefully handle missing file
    compileOnly fileTree(dir: 'libs', include: ['pz-stubs.jar'])
    
    // Gson for JSON serialization
    implementation 'com.google.code.gson:gson:2.10.1'
    
    // Test dependencies
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testImplementation 'org.mockito:mockito-core:5.5.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.5.0'
}

test {
    useJUnitPlatform()
}

shadowJar {
    archiveBaseName.set('Echo')
    archiveClassifier.set('')
    archiveVersion.set(version)
    
    // Include resources (pulse.mod.json)
    from sourceSets.main.resources
    
    // Relocate Gson to avoid conflicts
    relocate 'com.google.gson', 'com.echo.shaded.gson'
    
    manifest {
        attributes(
            'Echo-Version': version,
            'Pulse-Mod': 'true',
            'Mod-Id': 'echo',
            'Mod-Name': 'Echo Profiler',
            'Mod-Version': version,
            'Mod-Authors': 'Echo Team',
            'Mod-Description': 'Performance profiling tool for Project Zomboid'
        )
    }
}

tasks.named('jar') {
    enabled = false
}

tasks.named('build') {
    dependsOn shadowJar
}

// Create libs directory task
tasks.register('createLibsDir') {
    doLast {
        mkdir 'libs'
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\gradle\wrapper\gradle-wrapper.properties =====

distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.5-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\media\lua\client\Echo\EchoProfiler.lua =====

-- Echo Profiler (Lua Side)
-- Implements Sampling Profiler using debug.sethook
-- Phase 3

EchoProfiler = {}
EchoProfiler.enabled = false
EchoProfiler.samplingRate = 1000 -- Instructions per hook
EchoProfiler.isSampling = false

-- Use a local reference for speed
local debug_sethook = debug.sethook
local debug_getinfo = debug.getinfo

function EchoProfiler.enableSampling(enable)
    if enable then
        if EchoProfiler.isSampling then return end
        print("[Echo] Lua Sampling Profiler: STARTED")
        debug_sethook(EchoProfiler.onHook, "c", EchoProfiler.samplingRate) -- 'count' hook
        EchoProfiler.isSampling = true
    else
        if not EchoProfiler.isSampling then return end
        print("[Echo] Lua Sampling Profiler: STOPPED")
        debug_sethook() -- Turn off hook
        EchoProfiler.isSampling = false
    end
end

function EchoProfiler.onHook(event)
    -- Sampling: Just capture the top function
    local info = debug_getinfo(2, "nS")
    if info and info.name and info.name ~= "" and info.source then
        -- Send to Java
        -- We perform a static call to Echo's bridge
        -- Assuming Exposed Java Method: com.echo.pulse.LuaBridge.recordSample(name, source)
        -- TODO: Implement bridge binding or native call
        -- For now, simulate or check if we can call static Java
        
        -- To avoid massive JNI overhead on every sample, we might aggregate here in Lua
        -- But for "Sampling", we want to minimize Lua side logic too.
        -- Best practice in PZ: direct call to exposed Java method is relatively fast compared to Lua logic.
    end
end

-- Check Config periodically or via Event
Events.OnTick.Add(function()
    -- This check should be cheap.
    -- Ideally, Java side triggers an event "EchoConfigChanged" to push state.
    -- For now, we rely on a global flag or Java call.
    
    -- Placeholder for config check
    -- local javaEnabled = ...
    -- if javaEnabled ~= EchoProfiler.isSampling then EchoProfiler.enableSampling(javaEnabled) end
end)

return EchoProfiler



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\settings.gradle =====

rootProject.name = 'Echo'



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\aggregate\DataQualityFlag.java =====

package com.echo.aggregate;

/**
 * 데이터 품질 플래그.
 * 
 * 프로파일링 샘플에 영향을 미칠 수 있는 조건을 표시합니다.
 * 통계 계산 시 특정 플래그가 있는 샘플을 제외할 수 있습니다.
 * 
 * @since 1.0.1
 */
public enum DataQualityFlag {

    /**
     * 게임 시작 직후 불안정 구간 (Warmup)
     * 처음 몇 초는 클래스 로딩, JIT 컴파일 등으로 노이즈가 많음
     */
    WARMUP_PERIOD("Session warmup period - data may be noisy"),

    /**
     * 프로파일링 스택 불일치
     * push() 호출 후 pop()이 없거나 순서가 맞지 않음
     */
    PUSH_POP_MISMATCH("Profiling stack push/pop mismatch"),

    /**
     * 잘못된 스레드 접근
     * 메인 스레드가 아닌 곳에서 프로파일링 함수 호출
     */
    WRONG_THREAD_ACCESS("Profiling called from non-main thread"),

    /**
     * 비정상적으로 큰 델타 시간 (>100ms)
     * 틱이 정상 범위를 크게 벗어남
     */
    LARGE_DELTA_TIME("Abnormally large delta time (>100ms)"),

    /**
     * GC 일시정지 기간 중 샘플
     * GC가 발생하면 타이밍 데이터가 왜곡됨
     */
    GC_PAUSE_AFFECTED("Sample affected by GC pause"),

    /**
     * 게임 일시정지 중
     * 일시정지 상태에서는 틱이 멈추므로 데이터가 왜곡될 수 있음
     */
    GAME_PAUSED("Game was paused during sample"),

    /**
     * 세션 시간 부족
     * 충분한 샘플이 수집되지 않음
     */
    INSUFFICIENT_SAMPLES("Insufficient samples for reliable statistics");

    private final String description;

    DataQualityFlag(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return name() + ": " + description;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\aggregate\MemoryTimeSeries.java =====

package com.echo.aggregate;

import java.util.*;

/**
 * 메모리 스냅샷 타임시리즈.
 * 
 * GC/메모리 데이터를 시계열로 기록합니다.
 * 틱 히스토그램과 동일한 주기로 스냅샷을 저장합니다.
 * 
 * @since 1.0.1
 */
public class MemoryTimeSeries {

    private static final MemoryTimeSeries INSTANCE = new MemoryTimeSeries();

    // 기본 버퍼 크기 (5분 * 60fps = 18000, 하지만 메모리 절약을 위해 1초당 1개만)
    private static final int DEFAULT_BUFFER_SIZE = 300; // 5분 worth
    private static final long SAMPLE_INTERVAL_MS = 1000; // 1초

    private final LinkedList<MemorySnapshot> snapshots = new LinkedList<>();
    private int maxSize = DEFAULT_BUFFER_SIZE;
    private long lastSampleTime = 0;

    public static MemoryTimeSeries getInstance() {
        return INSTANCE;
    }

    /**
     * 메모리 스냅샷 기록 (매 틱 호출 가능하지만 실제로는 1초 간격)
     */
    public void record() {
        long now = System.currentTimeMillis();
        if (now - lastSampleTime < SAMPLE_INTERVAL_MS) {
            return;
        }
        lastSampleTime = now;

        MemorySnapshot snapshot = MemorySnapshot.capture();
        synchronized (snapshots) {
            snapshots.addLast(snapshot);
            while (snapshots.size() > maxSize) {
                snapshots.removeFirst();
            }
        }
    }

    /**
     * 지정 시간 범위의 스냅샷 조회
     * 
     * @param durationMs 최근 N 밀리초
     */
    public List<MemorySnapshot> getRecent(long durationMs) {
        long cutoff = System.currentTimeMillis() - durationMs;
        List<MemorySnapshot> result = new ArrayList<>();
        synchronized (snapshots) {
            for (MemorySnapshot s : snapshots) {
                if (s.timestamp >= cutoff) {
                    result.add(s);
                }
            }
        }
        return result;
    }

    /**
     * 전체 스냅샷 조회
     */
    public List<MemorySnapshot> getAll() {
        synchronized (snapshots) {
            return new ArrayList<>(snapshots);
        }
    }

    /**
     * 트렌드 분석 (최근 N초 동안의 메모리 추세)
     */
    public TrendAnalysis analyzeTrend(long durationMs) {
        List<MemorySnapshot> recent = getRecent(durationMs);
        if (recent.size() < 2) {
            return new TrendAnalysis(0, 0, TrendDirection.STABLE);
        }

        MemorySnapshot first = recent.get(0);
        MemorySnapshot last = recent.get(recent.size() - 1);

        long heapDelta = last.heapUsed - first.heapUsed;
        long timeDelta = last.timestamp - first.timestamp;

        double ratePerSecond = timeDelta > 0 ? (heapDelta * 1000.0 / timeDelta) : 0;

        TrendDirection direction;
        if (ratePerSecond > 1024 * 1024) { // 1MB/s 증가
            direction = TrendDirection.INCREASING;
        } else if (ratePerSecond < -1024 * 1024) { // 1MB/s 감소
            direction = TrendDirection.DECREASING;
        } else {
            direction = TrendDirection.STABLE;
        }

        // GC 빈도 계산
        int gcCount = 0;
        long prevGc = first.gcCount;
        for (MemorySnapshot s : recent) {
            if (s.gcCount > prevGc) {
                gcCount++;
                prevGc = s.gcCount;
            }
        }
        double gcFrequency = timeDelta > 0 ? (gcCount * 60000.0 / timeDelta) : 0; // GC per minute

        return new TrendAnalysis(ratePerSecond, gcFrequency, direction);
    }

    /**
     * JSON 출력용 Map
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();

        List<MemorySnapshot> recent = getRecent(60000); // 최근 1분

        map.put("sample_count", recent.size());

        if (!recent.isEmpty()) {
            MemorySnapshot latest = recent.get(recent.size() - 1);
            map.put("latest_heap_mb", latest.heapUsed / (1024 * 1024));
            map.put("latest_gc_count", latest.gcCount);
            map.put("latest_gc_time_ms", latest.gcTimeMs);
        }

        TrendAnalysis trend = analyzeTrend(60000);
        Map<String, Object> trendMap = new LinkedHashMap<>();
        trendMap.put("direction", trend.direction.name());
        trendMap.put("rate_bytes_per_sec", Math.round(trend.ratePerSecond));
        trendMap.put("gc_per_minute", Math.round(trend.gcFrequency * 100) / 100.0);
        map.put("trend", trendMap);

        return map;
    }

    /**
     * 초기화
     */
    public void reset() {
        synchronized (snapshots) {
            snapshots.clear();
        }
        lastSampleTime = 0;
    }

    public void setMaxSize(int size) {
        this.maxSize = size;
    }

    // --- 내부 클래스 ---

    /**
     * 메모리 스냅샷
     */
    public static class MemorySnapshot {
        public final long timestamp;
        public final long heapUsed;
        public final long heapMax;
        public final long gcCount;
        public final long gcTimeMs;
        public final double allocationRateMBps;

        public MemorySnapshot(long timestamp, long heapUsed, long heapMax,
                long gcCount, long gcTimeMs, double allocationRateMBps) {
            this.timestamp = timestamp;
            this.heapUsed = heapUsed;
            this.heapMax = heapMax;
            this.gcCount = gcCount;
            this.gcTimeMs = gcTimeMs;
            this.allocationRateMBps = allocationRateMBps;
        }

        public static MemorySnapshot capture() {
            Runtime rt = Runtime.getRuntime();
            long heapUsed = rt.totalMemory() - rt.freeMemory();
            long heapMax = rt.maxMemory();

            long gcCount = 0;
            long gcTime = 0;
            for (java.lang.management.GarbageCollectorMXBean gc : java.lang.management.ManagementFactory
                    .getGarbageCollectorMXBeans()) {
                if (gc.getCollectionCount() >= 0)
                    gcCount += gc.getCollectionCount();
                if (gc.getCollectionTime() >= 0)
                    gcTime += gc.getCollectionTime();
            }

            return new MemorySnapshot(
                    System.currentTimeMillis(),
                    heapUsed,
                    heapMax,
                    gcCount,
                    gcTime,
                    0 // Allocation rate calculated separately
            );
        }
    }

    /**
     * 트렌드 분석 결과
     */
    public static class TrendAnalysis {
        public final double ratePerSecond;
        public final double gcFrequency;
        public final TrendDirection direction;

        public TrendAnalysis(double ratePerSecond, double gcFrequency, TrendDirection direction) {
            this.ratePerSecond = ratePerSecond;
            this.gcFrequency = gcFrequency;
            this.direction = direction;
        }
    }

    public enum TrendDirection {
        INCREASING,
        DECREASING,
        STABLE
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\aggregate\SpikeLog.java =====

package com.echo.aggregate;

import com.echo.measure.ProfilingPoint;

import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.atomic.AtomicLong;

import com.echo.EchoConstants;

/**
 * 스파이크 로그
 * 
 * 성능 스파이크 이벤트를 기록하고 분석합니다.
 * Phase 4: 스택 캡처 기능 추가
 */
public class SpikeLog {

    private static final int MAX_ENTRIES = EchoConstants.SPIKE_LOG_MAX_ENTRIES;
    private static final int MAX_STACK_DEPTH = EchoConstants.SPIKE_MAX_STACK_DEPTH;

    private final Deque<SpikeEntry> entries = new ConcurrentLinkedDeque<>();
    private volatile double thresholdMs;

    // Phase 4: 스택 캡처 옵션
    private volatile boolean stackCaptureEnabled = false;
    private static final StackWalker STACK_WALKER = StackWalker.getInstance(
            StackWalker.Option.RETAIN_CLASS_REFERENCE);

    // 통계 (스레드 안전)
    private final AtomicLong totalSpikes = new AtomicLong(0);
    private final AtomicLong worstSpikeMicros = new AtomicLong(0);
    private volatile String worstSpikeLabel = "";

    public SpikeLog() {
        this(EchoConstants.DEFAULT_SPIKE_THRESHOLD_MS); // 기본 2프레임 (30fps 기준)
    }

    public SpikeLog(double thresholdMs) {
        this.thresholdMs = thresholdMs;
    }

    /**
     * 스택 캡처 활성화/비활성화
     * 주의: 성능 비용이 크므로 디버깅 시에만 사용
     */
    public void setStackCaptureEnabled(boolean enabled) {
        this.stackCaptureEnabled = enabled;
        System.out.println("[Echo] Spike stack capture: " + (enabled ? "ENABLED" : "DISABLED"));
    }

    public boolean isStackCaptureEnabled() {
        return stackCaptureEnabled;
    }

    /**
     * 스파이크 기록
     */
    public void logSpike(long durationMicros, ProfilingPoint point, String label) {
        logSpike(durationMicros, point, label, null);
    }

    /**
     * 포인트별 스파이크 카운트
     */
    public Map<ProfilingPoint, Long> getSpikesByPoint() {
        Map<ProfilingPoint, Long> result = new EnumMap<>(ProfilingPoint.class);
        for (SpikeEntry entry : entries) {
            result.merge(entry.point, 1L, Long::sum);
        }
        return result;
    }

    /**
     * 스택 트레이스 캡처 (Phase 4)
     * 비용이 크므로 옵션으로만 사용
     */
    private String captureStackTrace() {
        StringBuilder sb = new StringBuilder();
        STACK_WALKER.walk(frames -> {
            frames.limit(MAX_STACK_DEPTH)
                    .skip(3) // logSpike 호출 스택 스킵
                    .forEach(frame -> {
                        sb.append(frame.getClassName())
                                .append(".")
                                .append(frame.getMethodName())
                                .append(":")
                                .append(frame.getLineNumber())
                                .append("\n");
                    });
            return null;
        });
        return sb.toString().trim();
    }

    /**
     * 간편 스파이크 로깅 (Tick용)
     */
    public void logTickSpike(long durationMicros) {
        logSpike(durationMicros, ProfilingPoint.TICK, null);
    }

    /**
     * 최근 스파이크 목록 조회
     */
    public List<SpikeEntry> getRecentSpikes(int count) {
        List<SpikeEntry> result = new ArrayList<>();
        Iterator<SpikeEntry> iter = entries.descendingIterator();
        while (iter.hasNext() && result.size() < count) {
            result.add(iter.next());
        }
        return result;
    }

    /**
     * 모든 스파이크 조회
     */
    public List<SpikeEntry> getAllSpikes() {
        return new ArrayList<>(entries);
    }

    /**
     * 총 스파이크 수
     */
    public long getTotalSpikes() {
        return totalSpikes.get();
    }

    /**
     * 최악 스파이크 시간 (밀리초)
     */
    public double getWorstSpikeMs() {
        return worstSpikeMicros.get() / 1000.0;
    }

    /**
     * 최악 스파이크 라벨
     */
    public String getWorstSpikeLabel() {
        return worstSpikeLabel;
    }

    /**
     * 임계값 (밀리초)
     */
    public double getThresholdMs() {
        return thresholdMs;
    }

    /**
     * 임계값 설정
     * 
     * @param thresholdMs 새 임계값 (밀리초)
     */
    public void setThresholdMs(double thresholdMs) {
        this.thresholdMs = thresholdMs;
        System.out.println("[Echo] Spike threshold set to: " + thresholdMs + " ms");
    }

    // Phase 2: Context Provider (Snapshots)
    private java.util.function.Supplier<Map<String, Object>> contextProvider;

    /**
     * Set the context provider for capturing game state during spikes.
     */
    public void setContextProvider(java.util.function.Supplier<Map<String, Object>> provider) {
        this.contextProvider = provider;
    }

    /**
     * 스파이크 기록 (스택 경로 포함)
     */
    public void logSpike(long durationMicros, ProfilingPoint point, String label, String stackPath) {
        double durationMs = durationMicros / 1000.0;
        if (durationMs < thresholdMs)
            return;

        // Phase 4: 스택 캡처 (옵션)
        String capturedStack = stackPath;
        if (stackCaptureEnabled && capturedStack == null) {
            capturedStack = captureStackTrace();
        }

        // Phase 2: Context Snapshot
        Map<String, Object> context = null;
        if (contextProvider != null) {
            try {
                context = contextProvider.get();
            } catch (Exception e) {
                // Prevent crash during logging
                System.err.println("[Echo] Failed to capture spike context: " + e.getMessage());
            }
        }

        SpikeEntry entry = new SpikeEntry(
                Instant.now(),
                durationMicros,
                point,
                label,
                capturedStack,
                context);

        entries.addLast(entry);
        totalSpikes.incrementAndGet();

        // 최악 스파이크 갱신 (CAS 패턴)
        long current;
        do {
            current = worstSpikeMicros.get();
            if (durationMicros <= current)
                break;
        } while (!worstSpikeMicros.compareAndSet(current, durationMicros));

        if (durationMicros > current) {
            worstSpikeLabel = (label != null ? label : point.name());
        }

        // 최대 엔트리 수 유지
        while (entries.size() > MAX_ENTRIES) {
            entries.pollFirst();
        }
    }

    /**
     * JSON 출력용 Map
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("threshold_ms", thresholdMs);
        map.put("total_spikes", totalSpikes.get());
        map.put("worst_spike_ms", Math.round(getWorstSpikeMs() * 100) / 100.0);
        map.put("worst_spike_source", worstSpikeLabel);

        List<Map<String, Object>> recent = new ArrayList<>();
        for (SpikeEntry entry : getRecentSpikes(10)) {
            recent.add(entry.toMap());
        }
        map.put("recent_spikes", recent);

        return map;
    }

    /**
     * 초기화
     */
    public void reset() {
        entries.clear();
        totalSpikes.set(0);
        worstSpikeMicros.set(0);
        worstSpikeLabel = "";
    }

    // --- 스파이크 엔트리 ---

    public static class SpikeEntry {
        private final Instant timestamp;
        private final long durationMicros;
        private final ProfilingPoint point;
        private final String label;
        private final String stackPath;
        private final Map<String, Object> context; // Phase 2

        public SpikeEntry(Instant timestamp, long durationMicros,
                ProfilingPoint point, String label) {
            this(timestamp, durationMicros, point, label, null, null);
        }

        public SpikeEntry(Instant timestamp, long durationMicros,
                ProfilingPoint point, String label, String stackPath) {
            this(timestamp, durationMicros, point, label, stackPath, null);
        }

        public SpikeEntry(Instant timestamp, long durationMicros,
                ProfilingPoint point, String label, String stackPath, Map<String, Object> context) {
            this.timestamp = timestamp;
            this.durationMicros = durationMicros;
            this.point = point;
            this.label = label;
            this.stackPath = stackPath;
            this.context = context;
        }

        public Instant getTimestamp() {
            return timestamp;
        }

        public long getDurationMicros() {
            return durationMicros;
        }

        public double getDurationMs() {
            return durationMicros / 1000.0;
        }

        public ProfilingPoint getPoint() {
            return point;
        }

        public String getLabel() {
            return label;
        }

        public String getStackPath() {
            return stackPath;
        }

        public Map<String, Object> getContext() {
            return context;
        }

        public Map<String, Object> toMap() {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("timestamp", DateTimeFormatter.ISO_INSTANT.format(timestamp));
            map.put("duration_ms", Math.round(getDurationMs() * 100) / 100.0);
            map.put("point", point.name());
            map.put("label", label != null ? label : point.getDisplayName());
            if (stackPath != null) {
                map.put("stack_path", stackPath);
            }
            if (context != null) {
                map.put("context", context);
            }
            return map;
        }

        @Override
        public String toString() {
            return String.format("[%s] %.2fms - %s (%s)",
                    DateTimeFormatter.ISO_LOCAL_TIME.format(
                            timestamp.atZone(java.time.ZoneId.systemDefault())),
                    getDurationMs(),
                    point.getDisplayName(),
                    label != null ? label : "");
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\aggregate\TickHistogram.java =====

package com.echo.aggregate;

import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.atomic.LongAdder;

import com.echo.EchoConstants;

/**
 * 틱 히스토그램
 * 
 * 틱 시간 분포를 버킷별로 집계합니다.
 * 성능 분석 및 시각화에 사용됩니다.
 */
public class TickHistogram {

    // 기본 버킷 경계 (밀리초)
    private static final double[] DEFAULT_BUCKETS = EchoConstants.DEFAULT_HISTOGRAM_BUCKETS;

    private final double[] buckets;
    private final LongAdder[] counts;
    private final LongAdder totalSamples = new LongAdder();

    // 통계
    private final LongAdder sumMicros = new LongAdder();
    private final LongAdder sumSquaresMicros = new LongAdder(); // v0.9: 표준편차 계산용

    // Jank 카운터 (Phase 4)
    private final LongAdder jankCount60 = new LongAdder(); // >16.67ms (60fps 기준)
    private final LongAdder jankCount30 = new LongAdder(); // >33.33ms (30fps 기준)
    private final LongAdder jankCount100 = new LongAdder(); // >100ms (Major Stutter)
    private final LongAdder warmupCount = new LongAdder(); // Warmup 기간 틱 수 (Echo 0.9.0)

    // v0.9: 틱 간 편차 추적
    private long lastSampleMicros = -1;
    private final LongAdder varianceSum = new LongAdder(); // abs(current - prev) 누적
    private final LongAdder varianceCount = new LongAdder();

    // Jank 임계값 (마이크로초)
    private static final long JANK_THRESHOLD_60_MICROS = 16_667; // 16.67ms
    private static final long JANK_THRESHOLD_30_MICROS = 33_333; // 33.33ms
    private static final long JANK_THRESHOLD_100_MICROS = 100_000; // 100ms

    // 정확한 백분위수 계산을 위한 최근 샘플 추적
    private final long[] recentSamples = new long[EchoConstants.HISTOGRAM_SAMPLE_BUFFER];
    private int sampleIndex = 0;
    private final Object sampleLock = new Object();

    public TickHistogram() {
        this(DEFAULT_BUCKETS);
    }

    public TickHistogram(double[] bucketsMs) {
        this.buckets = Arrays.copyOf(bucketsMs, bucketsMs.length);
        this.counts = new LongAdder[buckets.length];
        for (int i = 0; i < counts.length; i++) {
            counts[i] = new LongAdder();
        }
    }

    /**
     * 샘플 추가
     * 
     * @param durationMicros 소요 시간 (마이크로초)
     */
    public void addSample(long durationMicros) {
        double durationMs = durationMicros / 1000.0;

        // 해당하는 버킷 찾기
        int bucketIndex = findBucket(durationMs);
        counts[bucketIndex].increment();
        totalSamples.increment();
        sumMicros.add(durationMicros);

        // Jank 카운터 업데이트
        if (durationMicros > JANK_THRESHOLD_60_MICROS) {
            jankCount60.increment();
        }
        if (durationMicros > JANK_THRESHOLD_30_MICROS) {
            jankCount30.increment();
        }
        if (durationMicros > JANK_THRESHOLD_100_MICROS) {
            jankCount100.increment();
        }

        // v0.9: 표준편차 계산용 제곱합
        sumSquaresMicros.add(durationMicros * durationMicros / 1000); // overflow 방지: micros^2 / 1000

        // v0.9: 틱 간 편차 추적
        if (lastSampleMicros >= 0) {
            long variance = Math.abs(durationMicros - lastSampleMicros);
            varianceSum.add(variance);
            varianceCount.increment();
        }
        lastSampleMicros = durationMicros;

        // 최근 샘플 저장 (정확한 백분위수용)
        synchronized (sampleLock) {
            recentSamples[sampleIndex] = durationMicros;
            sampleIndex = (sampleIndex + 1) % recentSamples.length;
        }
    }

    // ... (Skipping methods)

    /**
     * 100ms 초과 Major Stutter 비율
     */
    public double getJankPercent100() {
        long total = totalSamples.sum();
        if (total == 0)
            return 0;
        return (jankCount100.sum() * 100.0) / total;
    }

    public long getJankCount100() {
        return jankCount100.sum();
    }

    /**
     * JSON 출력용 Map 생성
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();

        // 버킷 라벨 생성
        String[] labels = new String[buckets.length];
        for (int i = 0; i < buckets.length; i++) {
            if (i == buckets.length - 1) {
                labels[i] = String.format(">=%.1fms", buckets[i]);
            } else {
                labels[i] = String.format("%.1f-%.1fms", buckets[i], buckets[i + 1]);
            }
        }

        map.put("buckets_ms", buckets);
        map.put("labels", labels);
        map.put("counts", getCounts());
        map.put("total_samples", getTotalSamples());
        map.put("average_ms", Math.round(getAverageMs() * 100) / 100.0);
        map.put("p50_ms", Math.round(getP50() * 100) / 100.0);
        map.put("p95_ms", Math.round(getP95() * 100) / 100.0);
        map.put("p99_ms", Math.round(getP99() * 100) / 100.0);
        map.put("jank_percent_60fps", Math.round(getJankPercent60() * 100) / 100.0);
        map.put("jank_percent_30fps", Math.round(getJankPercent30() * 100) / 100.0);
        map.put("jank_percent_100ms", Math.round(getJankPercent100() * 100) / 100.0);
        map.put("warmup_ticks", warmupCount.sum());

        // v0.9: 품질 측정 지표
        map.put("std_deviation_ms", Math.round(getStandardDeviationMs() * 100) / 100.0);
        map.put("p99_spike_count", getP99SpikeCount());
        map.put("variance_rate_ms", Math.round(getVarianceRateMs() * 100) / 100.0);
        map.put("quality_score", getQualityScore());

        return map;
    }

    /**
     * Warmup 샘플 추가 (통계 제외, 카운트만)
     */
    public void addWarmupSample(long durationMicros) {
        warmupCount.increment();
        // Warmup 데이터는 메인 통계(P50 등)에 포함하지 않음
        // 필요시 나중에 별도 분석용으로 저장 가능
    }

    private int findBucket(double durationMs) {
        for (int i = buckets.length - 1; i >= 0; i--) {
            if (durationMs >= buckets[i]) {
                return i;
            }
        }
        return 0;
    }

    /**
     * 버킷별 카운트 조회
     */
    public long[] getCounts() {
        long[] result = new long[counts.length];
        for (int i = 0; i < counts.length; i++) {
            result[i] = counts[i].sum();
        }
        return result;
    }

    /**
     * 버킷 경계값 조회
     */
    public double[] getBuckets() {
        return Arrays.copyOf(buckets, buckets.length);
    }

    /**
     * 총 샘플 수
     */
    public long getTotalSamples() {
        return totalSamples.sum();
    }

    /**
     * 백분위수 계산 (개선된 버전)
     * 
     * @param percentile 0-100 사이 값
     */
    public double getPercentile(double percentile) {
        long total = totalSamples.sum();
        if (total == 0)
            return 0;

        // 최근 샘플 기반 정확한 계산 시도
        synchronized (sampleLock) {
            int validSamples = (int) Math.min(total, recentSamples.length);
            if (validSamples >= 10) {
                long[] sorted = new long[validSamples];
                System.arraycopy(recentSamples, 0, sorted, 0, validSamples);
                java.util.Arrays.sort(sorted);
                int index = (int) Math.ceil(percentile / 100.0 * validSamples) - 1;
                index = Math.max(0, Math.min(index, validSamples - 1));
                return sorted[index] / 1000.0; // 마이크로초 -> 밀리초
            }
        }

        // 폴백: 버킷 기반 추정
        long target = (long) (total * percentile / 100.0);
        long cumulative = 0;

        for (int i = 0; i < counts.length; i++) {
            cumulative += counts[i].sum();
            if (cumulative >= target) {
                if (i == counts.length - 1) {
                    // 마지막 버킷: 경계값 + 50% 추정 대신 실제 버킷 시작값 사용
                    return buckets[i];
                }
                // 선형 보간
                double bucketStart = buckets[i];
                double bucketEnd = buckets[i + 1];
                long bucketCount = counts[i].sum();
                long prevCumulative = cumulative - bucketCount;
                double fraction = bucketCount > 0
                        ? (double) (target - prevCumulative) / bucketCount
                        : 0.5;
                return bucketStart + fraction * (bucketEnd - bucketStart);
            }
        }

        return buckets[buckets.length - 1];
    }

    /**
     * P50 (중앙값)
     */
    public double getP50() {
        return getPercentile(50);
    }

    /**
     * P95
     */
    public double getP95() {
        return getPercentile(95);
    }

    /**
     * P99
     */
    public double getP99() {
        return getPercentile(99);
    }

    /**
     * 평균값 (밀리초)
     */
    public double getAverageMs() {
        long total = totalSamples.sum();
        if (total == 0)
            return 0;
        return (sumMicros.sum() / 1000.0) / total;
    }

    // --- Jank 통계 (Phase 4) ---

    /**
     * 60fps 기준 Jank 비율 (>16.67ms)
     * 
     * @return Jank 비율 (0-100%)
     */
    public double getJankPercent60() {
        long total = totalSamples.sum();
        if (total == 0)
            return 0;
        return (jankCount60.sum() * 100.0) / total;
    }

    /**
     * 30fps 기준 Jank 비율 (>33.33ms)
     * 
     * @return Jank 비율 (0-100%)
     */
    public double getJankPercent30() {
        long total = totalSamples.sum();
        if (total == 0)
            return 0;
        return (jankCount30.sum() * 100.0) / total;
    }

    /**
     * 60fps 기준 Jank 카운트
     */
    public long getJankCount60() {
        return jankCount60.sum();
    }

    /**
     * 30fps 기준 Jank 카운트
     */
    public long getJankCount30() {
        return jankCount30.sum();
    }

    // --- v0.9: Histogram 품질 측정 (Fuse/Nerve 지원) ---

    /**
     * 표준편차 (밀리초)
     * 틱 시간의 분포 폭을 측정합니다.
     */
    public double getStandardDeviationMs() {
        long n = totalSamples.sum();
        if (n < 2)
            return 0;

        double mean = (sumMicros.sum() / 1000.0) / n; // ms
        double sumSq = sumSquaresMicros.sum(); // micros^2 / 1000 단위

        // Variance = E[X^2] - (E[X])^2
        // sumSq는 micros^2/1000 단위이므로 변환 필요
        double meanSq = mean * mean;
        double varMs = (sumSq / n / 1000.0) - meanSq; // 근사치

        return varMs > 0 ? Math.sqrt(varMs) : 0;
    }

    /**
     * 상위 1% 스파이크 수 (P99 초과 샘플 수)
     */
    public long getP99SpikeCount() {
        long total = totalSamples.sum();
        if (total == 0)
            return 0;

        // 상위 1% = P99 초과
        return (long) Math.ceil(total * 0.01);
    }

    /**
     * 틱 간 편차 변화율 (밀리초)
     * 연속된 틱 사이의 평균 시간 차이를 측정합니다.
     * 낮을수록 일관성 있는 프레임 타이밍.
     */
    public double getVarianceRateMs() {
        long count = varianceCount.sum();
        if (count == 0)
            return 0;
        return (varianceSum.sum() / 1000.0) / count;
    }

    /**
     * 품질 점수 (0-100)
     * P99/P50 비율과 표준편차를 기반으로 버퍼 안정성을 평가합니다.
     */
    public int getQualityScore() {
        long samples = totalSamples.sum();
        if (samples < 60)
            return 0; // 최소 60 샘플 (1초) 필요

        double p50 = getP50();
        double p99 = getP99();
        double stdDev = getStandardDeviationMs();

        if (p50 <= 0)
            return 0;

        // P99/P50 ratio: 1.0 = 완벽, 2.0+ = 불안정
        double ratio = p99 / p50;
        int ratioScore = (int) Math.max(0, 100 - (ratio - 1) * 30);

        // StdDev: 0 = 완벽, 10ms+ = 불안정
        int stdDevScore = (int) Math.max(0, 100 - stdDev * 5);

        // Jank 60fps: 0% = 완벽, 10%+ = 불안정
        int jankScore = (int) Math.max(0, 100 - getJankPercent60() * 5);

        return (ratioScore + stdDevScore + jankScore) / 3;
    }

    /**
     * 콘솔 출력용 문자열
     */
    public String toAsciiChart() {
        StringBuilder sb = new StringBuilder();
        long[] countArray = getCounts();
        long maxCount = Arrays.stream(countArray).max().orElse(1);

        sb.append("Tick Time Distribution:\n");
        sb.append("────────────────────────────────────────────────\n");

        for (int i = 0; i < buckets.length; i++) {
            String label;
            if (i == buckets.length - 1) {
                label = String.format(">=%5.1fms", buckets[i]);
            } else {
                label = String.format("%5.1f-%5.1fms", buckets[i], buckets[i + 1]);
            }

            int barLength = (int) ((countArray[i] * 30) / Math.max(maxCount, 1));
            String bar = "█".repeat(barLength);

            double percentage = getTotalSamples() > 0
                    ? (countArray[i] * 100.0 / getTotalSamples())
                    : 0;

            sb.append(String.format("  %s │ %s %d (%.1f%%)\n",
                    label, bar, countArray[i], percentage));
        }

        sb.append("────────────────────────────────────────────────\n");
        sb.append(String.format("  Total: %,d samples | P50: %.1fms | P95: %.1fms | P99: %.1fms\n",
                getTotalSamples(), getP50(), getP95(), getP99()));

        return sb.toString();
    }

    /**
     * 초기화
     */
    public void reset() {
        for (LongAdder count : counts) {
            count.reset();
        }
        totalSamples.reset();
        sumMicros.reset();
        sumSquaresMicros.reset();
        jankCount60.reset();
        jankCount30.reset();
        warmupCount.reset();
        varianceSum.reset();
        varianceCount.reset();
        lastSampleMicros = -1;
        synchronized (sampleLock) {
            java.util.Arrays.fill(recentSamples, 0);
            sampleIndex = 0;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\aggregate\TimeSeriesStore.java =====

package com.echo.aggregate;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 시계열 데이터 저장소.
 * 
 * Phase 4.2: 다양한 메트릭의 시계열 데이터를 저장하고 트렌드를 분석합니다.
 * 
 * @since 1.0.1
 */
public class TimeSeriesStore {

    private static final TimeSeriesStore INSTANCE = new TimeSeriesStore();

    // 메트릭별 시계열 데이터
    private final Map<String, TimeSeries> seriesMap = new ConcurrentHashMap<>();

    // 기본 설정
    private static final int DEFAULT_MAX_SAMPLES = 3600; // 1시간 (1초당 1개)

    public static TimeSeriesStore getInstance() {
        return INSTANCE;
    }

    /**
     * 데이터 포인트 기록
     */
    public void record(String metric, double value) {
        record(metric, System.currentTimeMillis(), value);
    }

    /**
     * 타임스탬프 지정하여 기록
     */
    public void record(String metric, long timestamp, double value) {
        seriesMap.computeIfAbsent(metric, k -> new TimeSeries(DEFAULT_MAX_SAMPLES))
                .add(timestamp, value);
    }

    /**
     * 시간 범위로 조회
     */
    public TimeSeries query(String metric, TimeRange range) {
        TimeSeries series = seriesMap.get(metric);
        if (series == null)
            return new TimeSeries(0);
        return series.slice(range.startMs, range.endMs);
    }

    /**
     * 최근 N밀리초 조회
     */
    public TimeSeries queryRecent(String metric, long durationMs) {
        long now = System.currentTimeMillis();
        return query(metric, new TimeRange(now - durationMs, now));
    }

    /**
     * 트렌드 분석
     */
    public TrendAnalysis analyzeTrend(String metric, TimeRange range) {
        TimeSeries series = query(metric, range);
        return series.analyzeTrend();
    }

    /**
     * 등록된 모든 메트릭 이름
     */
    public Set<String> getMetricNames() {
        return new HashSet<>(seriesMap.keySet());
    }

    /**
     * 특정 메트릭 삭제
     */
    public void clear(String metric) {
        seriesMap.remove(metric);
    }

    /**
     * 전체 초기화
     */
    public void reset() {
        seriesMap.clear();
    }

    /**
     * JSON 출력용 요약
     */
    public Map<String, Object> toSummary() {
        Map<String, Object> summary = new LinkedHashMap<>();
        summary.put("metric_count", seriesMap.size());

        List<Map<String, Object>> metrics = new ArrayList<>();
        for (Map.Entry<String, TimeSeries> entry : seriesMap.entrySet()) {
            Map<String, Object> m = new LinkedHashMap<>();
            m.put("name", entry.getKey());
            m.put("sample_count", entry.getValue().size());

            TrendAnalysis trend = entry.getValue().analyzeTrend();
            m.put("trend", trend.direction.name());
            m.put("avg", Math.round(trend.average * 100) / 100.0);
            m.put("min", trend.min);
            m.put("max", trend.max);

            metrics.add(m);
        }
        summary.put("metrics", metrics);

        return summary;
    }

    // --- 내부 클래스 ---

    /**
     * 시계열 데이터
     */
    public static class TimeSeries {
        private final LinkedList<DataPoint> points = new LinkedList<>();
        private final int maxSize;

        public TimeSeries(int maxSize) {
            this.maxSize = maxSize;
        }

        public synchronized void add(long timestamp, double value) {
            points.addLast(new DataPoint(timestamp, value));
            while (points.size() > maxSize && maxSize > 0) {
                points.removeFirst();
            }
        }

        public synchronized int size() {
            return points.size();
        }

        public synchronized TimeSeries slice(long startMs, long endMs) {
            TimeSeries sliced = new TimeSeries(maxSize);
            for (DataPoint p : points) {
                if (p.timestamp >= startMs && p.timestamp <= endMs) {
                    sliced.add(p.timestamp, p.value);
                }
            }
            return sliced;
        }

        public synchronized List<DataPoint> getPoints() {
            return new ArrayList<>(points);
        }

        public synchronized TrendAnalysis analyzeTrend() {
            if (points.isEmpty()) {
                return new TrendAnalysis(0, 0, 0, 0, TrendDirection.STABLE);
            }

            double sum = 0, min = Double.MAX_VALUE, max = Double.MIN_VALUE;
            for (DataPoint p : points) {
                sum += p.value;
                min = Math.min(min, p.value);
                max = Math.max(max, p.value);
            }
            double avg = sum / points.size();

            // 트렌드 방향 결정 (간단한 선형 회귀)
            TrendDirection direction = TrendDirection.STABLE;
            if (points.size() >= 2) {
                DataPoint first = points.getFirst();
                DataPoint last = points.getLast();
                double slope = (last.value - first.value) / (last.timestamp - first.timestamp);

                if (slope > 0.001)
                    direction = TrendDirection.INCREASING;
                else if (slope < -0.001)
                    direction = TrendDirection.DECREASING;
            }

            return new TrendAnalysis(avg, min, max, sum, direction);
        }
    }

    /**
     * 데이터 포인트
     */
    public static class DataPoint {
        public final long timestamp;
        public final double value;

        public DataPoint(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }
    }

    /**
     * 시간 범위
     */
    public static class TimeRange {
        public final long startMs;
        public final long endMs;

        public TimeRange(long startMs, long endMs) {
            this.startMs = startMs;
            this.endMs = endMs;
        }

        public static TimeRange last(long durationMs) {
            long now = System.currentTimeMillis();
            return new TimeRange(now - durationMs, now);
        }
    }

    /**
     * 트렌드 분석 결과
     */
    public static class TrendAnalysis {
        public final double average;
        public final double min;
        public final double max;
        public final double sum;
        public final TrendDirection direction;

        public TrendAnalysis(double average, double min, double max, double sum, TrendDirection direction) {
            this.average = average;
            this.min = min;
            this.max = max;
            this.sum = sum;
            this.direction = direction;
        }
    }

    public enum TrendDirection {
        INCREASING,
        DECREASING,
        STABLE
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\aggregate\TimingData.java =====

package com.echo.aggregate;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

/**
 * 타이밍 데이터 누적 및 통계 계산
 * 
 * 기능:
 * - 1초/5초/60초 단위 통계
 * - 평균/최대값/표준편차 계산
 * - 호출 빈도 추적
 * - Heavy Function Top N 랭킹
 */
public class TimingData {

    private final String name;

    // 원자적 카운터
    private final LongAdder callCount = new LongAdder();
    private final LongAdder totalTime = new LongAdder();
    private final AtomicLong maxTime = new AtomicLong(0);
    private final AtomicLong minTime = new AtomicLong(Long.MAX_VALUE);

    // 최근 샘플 (스파이크 감지용)
    private final long[] recentSamples = new long[100];
    private int sampleIndex = 0;
    private final Object sampleLock = new Object();

    // 시간대별 통계 (밀리초 단위)
    private final RollingStats stats1s = new RollingStats(1_000);
    private final RollingStats stats5s = new RollingStats(5_000);
    private final RollingStats stats60s = new RollingStats(60_000);

    // 라벨별 세부 통계 (예: 개별 Lua 함수)
    private final Map<String, SubTimingData> labelStats = new ConcurrentHashMap<>();

    public TimingData(String name) {
        this.name = name;
    }

    // --- 샘플 추가 ---

    /**
     * 새 샘플 추가
     * 
     * @param elapsedNanos 소요 시간 (나노초)
     */
    public void addSample(long elapsedNanos) {
        addSample(elapsedNanos, null);
    }

    /**
     * 새 샘플 추가 (라벨 포함)
     * 
     * @param elapsedNanos 소요 시간 (나노초)
     * @param label        세부 라벨 (null 가능)
     */
    public void addSample(long elapsedNanos, String label) {
        long elapsedMicros = elapsedNanos / 1000;

        // 기본 통계 업데이트
        callCount.increment();
        totalTime.add(elapsedMicros);

        // 최대/최소 업데이트 (CAS)
        updateMax(elapsedMicros);
        updateMin(elapsedMicros);

        // 최근 샘플 저장
        synchronized (sampleLock) {
            recentSamples[sampleIndex] = elapsedMicros;
            sampleIndex = (sampleIndex + 1) % recentSamples.length;
        }

        // 롤링 통계 업데이트
        long now = System.currentTimeMillis();
        stats1s.addSample(elapsedMicros, now);
        stats5s.addSample(elapsedMicros, now);
        stats60s.addSample(elapsedMicros, now);

        // 라벨별 통계
        if (label != null && !label.isEmpty()) {
            labelStats.computeIfAbsent(label, SubTimingData::new)
                    .addSample(elapsedMicros);
        }
    }

    private void updateMax(long value) {
        long current;
        do {
            current = maxTime.get();
            if (value <= current)
                return;
        } while (!maxTime.compareAndSet(current, value));
    }

    private void updateMin(long value) {
        long current;
        do {
            current = minTime.get();
            if (value >= current)
                return;
        } while (!minTime.compareAndSet(current, value));
    }

    // --- 통계 조회 ---

    public String getName() {
        return name;
    }

    public long getCallCount() {
        return callCount.sum();
    }

    /** 평균 시간 (마이크로초) */
    public double getAverageMicros() {
        long count = callCount.sum();
        return count == 0 ? 0 : (double) totalTime.sum() / count;
    }

    /** 최대 시간 (마이크로초) */
    public long getMaxMicros() {
        return maxTime.get();
    }

    /** 최소 시간 (마이크로초) */
    public long getMinMicros() {
        long min = minTime.get();
        return min == Long.MAX_VALUE ? 0 : min;
    }

    /** 총 누적 시간 (마이크로초) */
    public long getTotalMicros() {
        return totalTime.sum();
    }

    // 시간대별 통계
    public RollingStats getStats1s() {
        return stats1s;
    }

    public RollingStats getStats5s() {
        return stats5s;
    }

    public RollingStats getStats60s() {
        return stats60s;
    }

    /**
     * Top N Heavy 라벨 (총 시간 기준)
     */
    public List<SubTimingData> getTopNByTotalTime(int n) {
        return labelStats.values().stream()
                .sorted((a, b) -> Long.compare(b.getTotalMicros(), a.getTotalMicros()))
                .limit(n)
                .toList();
    }

    /**
     * Top N Heavy 라벨 (최대 시간 기준 - 스파이크 감지)
     */
    public List<SubTimingData> getTopNByMaxTime(int n) {
        return labelStats.values().stream()
                .sorted((a, b) -> Long.compare(b.getMaxMicros(), a.getMaxMicros()))
                .limit(n)
                .toList();
    }

    /**
     * Top N Heavy 라벨 (호출 빈도 기준)
     */
    public List<SubTimingData> getTopNByCallCount(int n) {
        return labelStats.values().stream()
                .sorted((a, b) -> Long.compare(b.getCallCount(), a.getCallCount()))
                .limit(n)
                .toList();
    }

    /**
     * 모든 라벨 통계 조회
     */
    public Map<String, SubTimingData> getLabelStats() {
        return Collections.unmodifiableMap(labelStats);
    }

    /**
     * 초기화
     */
    public void reset() {
        callCount.reset();
        totalTime.reset();
        maxTime.set(0);
        minTime.set(Long.MAX_VALUE);

        synchronized (sampleLock) {
            Arrays.fill(recentSamples, 0);
            sampleIndex = 0;
        }

        stats1s.reset();
        stats5s.reset();
        stats60s.reset();

        labelStats.clear();
    }

    // --- 내부 클래스: 롤링 통계 ---

    /**
     * 시간 윈도우 기반 롤링 통계 (Zero-Allocation Ring Buffer)
     * 
     * Phase 1 Update:
     * - Added Standard Deviation / Variance calculation
     * - Replaced hardcoded FPS regarding TickContract
     */
    public static class RollingStats {
        // 상수: TickContract 기준 (기본 60 FPS)
        public static final int SAMPLES_PER_SECOND = com.pulse.api.TickContract.TARGET_TICK_RATE;
        public static final int WINDOW_1S = SAMPLES_PER_SECOND;
        public static final int WINDOW_5S = SAMPLES_PER_SECOND * 5;
        public static final int WINDOW_60S = SAMPLES_PER_SECOND * 60;

        private final int capacity;
        private final long[] values;
        private int head = 0; // 다음 쓸 위치
        private int size = 0; // 현재 샘플 수

        // Running statistics (O(1) 조회)
        private long runningSum = 0;
        private long runningSumSq = 0; // Variance 계산용
        private long runningMax = 0;

        // 호환성을 위한 windowMs (deprecated, 표시용)
        @Deprecated
        private final long windowMs;

        public RollingStats(long windowMs) {
            // 기존 API 호환: windowMs → 샘플 수 변환
            this.windowMs = windowMs;
            if (windowMs <= 1_000) {
                this.capacity = WINDOW_1S;
            } else if (windowMs <= 5_000) {
                this.capacity = WINDOW_5S;
            } else {
                this.capacity = WINDOW_60S;
            }
            this.values = new long[capacity];
        }

        /**
         * 새 샘플 추가 (O(1), Zero-Allocation)
         * 
         * @param value     측정값 (마이크로초)
         * @param timestamp 무시됨 (호환성용)
         */
        public void addSample(long value, long timestamp) {
            addSample(value);
        }

        /**
         * 새 샘플 추가 (O(1), Zero-Allocation)
         */
        public synchronized void addSample(long value) {
            // Ring Buffer가 가득 찬 경우 가장 오래된 값 제거
            if (size == capacity) {
                long oldValue = values[head];
                runningSum -= oldValue;
                runningSumSq -= (oldValue * oldValue);
            }

            // 새 값 저장
            values[head] = value;
            runningSum += value;
            runningSumSq += (value * value);

            // Max 갱신 (제거되는 값이 max였을 수 있으므로 재계산 필요)
            // 버그 수정: head가 다음 쓸 위치이므로, 현재 head 위치의 값이 덮어써질 값
            if (size == capacity && values[head] == runningMax) {
                recalculateMax();
            } else if (value > runningMax) {
                runningMax = value;
            }

            // 포인터 이동
            head = (head + 1) % capacity;
            size = Math.min(size + 1, capacity);
        }

        /**
         * 평균값 조회 (O(1))
         */
        public long getAverage() {
            return size == 0 ? 0 : runningSum / size;
        }

        /**
         * 분산 조회 (O(1))
         * Variance = E[X^2] - (E[X])^2
         */
        public double getVariance() {
            if (size == 0)
                return 0.0;
            double mean = (double) runningSum / size;
            double meanSq = (double) runningSumSq / size;
            return Math.max(0, meanSq - (mean * mean));
        }

        /**
         * 표준편차 조회 (O(1))
         */
        public double getStdDev() {
            return Math.sqrt(getVariance());
        }

        /**
         * 최대값 조회 (O(1) 평균, 드물게 O(n))
         */
        public long getMax() {
            return size == 0 ? 0 : runningMax;
        }

        /**
         * 현재 샘플 수
         */
        public int getSampleCount() {
            return size;
        }

        /**
         * 버퍼 용량
         */
        public int getCapacity() {
            return capacity;
        }

        /**
         * 윈도우 시간 (deprecated - 호환성용)
         */
        @Deprecated
        public long getWindowMs() {
            return windowMs;
        }

        /**
         * 통계적 신뢰도 (0.0 ~ 1.0)
         * Event-driven Points에서 낮은 호출 빈도 감지용
         */
        public double getConfidence() {
            return (double) size / capacity;
        }

        /**
         * 통계적으로 의미 있는 데이터인지 (50% 이상 채워짐)
         */
        public boolean isStatisticallyMeaningful() {
            return size >= capacity / 2;
        }

        /**
         * 초기화
         */
        public void reset() {
            Arrays.fill(values, 0);
            head = 0;
            size = 0;
            runningSum = 0;
            runningSumSq = 0;
            runningMax = 0;
        }

        /**
         * 오래된 샘플 정리 (호환성용 - 샘플 기반이므로 NOP)
         */
        public void performCleanup() {
            // 샘플 기반 Ring Buffer에서는 자동으로 관리되므로 불필요
        }

        /**
         * 최대값 재계산 (O(n) - 드물게 호출)
         */
        private void recalculateMax() {
            runningMax = 0;
            for (int i = 0; i < size; i++) {
                if (values[i] > runningMax) {
                    runningMax = values[i];
                }
            }
        }
    }

    // --- 내부 클래스: 라벨별 세부 통계 ---

    /**
     * 개별 라벨(함수)에 대한 세부 통계
     */
    public static class SubTimingData {
        private final String label;
        private final LongAdder callCount = new LongAdder();
        private final LongAdder totalTime = new LongAdder();
        private final AtomicLong maxTime = new AtomicLong(0);

        public SubTimingData(String label) {
            this.label = label;
        }

        public void addSample(long elapsedMicros) {
            callCount.increment();
            totalTime.add(elapsedMicros);

            long current;
            do {
                current = maxTime.get();
                if (elapsedMicros <= current)
                    return;
            } while (!maxTime.compareAndSet(current, elapsedMicros));
        }

        public String getLabel() {
            return label;
        }

        public long getCallCount() {
            return callCount.sum();
        }

        public long getTotalMicros() {
            return totalTime.sum();
        }

        public long getMaxMicros() {
            return maxTime.get();
        }

        public double getAverageMicros() {
            long count = callCount.sum();
            return count == 0 ? 0 : (double) totalTime.sum() / count;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\analysis\BottleneckDetector.java =====

package com.echo.analysis;

import com.echo.aggregate.TimingData;
import com.echo.measure.*;
import com.echo.fuse.*;
import com.pulse.api.service.echo.IBottleneckDetector;
import com.pulse.api.service.echo.OptimizationPriority;

import java.util.*;

/**
 * 자동 병목 식별기.
 * 
 * 성능 병목을 자동으로 식별하고 Fuse/Nerve 최적화 타겟을 제안합니다.
 * 
 * @since 1.0.1
 */
public class BottleneckDetector implements IBottleneckDetector {

    private static final BottleneckDetector INSTANCE = new BottleneckDetector();

    // 임계값
    private static final double TICK_THRESHOLD_MS = 16.67;
    private static final double CRITICAL_RATIO = 0.3; // 전체의 30% 이상이면 병목

    public static BottleneckDetector getInstance() {
        return INSTANCE;
    }

    /**
     * 상위 N개 병목 식별
     */
    public List<Bottleneck> identifyTopN(int n) {
        List<Bottleneck> bottlenecks = new ArrayList<>();

        EchoProfiler profiler = EchoProfiler.getInstance();
        TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);
        if (tickData == null || tickData.getCallCount() == 0) {
            return bottlenecks;
        }

        double totalTickMs = tickData.getAverageMicros() / 1000.0;

        // 각 서브시스템 분석
        for (ProfilingPoint point : ProfilingPoint.values()) {
            if (point.getCategory() != ProfilingPoint.Category.SUBSYSTEM)
                continue;

            TimingData data = profiler.getTimingData(point);
            if (data == null || data.getCallCount() == 0)
                continue;

            double avgMs = data.getAverageMicros() / 1000.0;
            double ratio = totalTickMs > 0 ? avgMs / totalTickMs : 0;

            if (ratio >= 0.1) { // 10% 이상이면 병목 후보
                BottleneckType type = classifyBottleneck(point, ratio);
                OptimizationModule module = suggestModule(point);
                int priority = calculatePriority(point, ratio, avgMs);

                // CRITICAL_RATIO 이상이면 우선순위 가산
                if (ratio >= CRITICAL_RATIO) {
                    priority = Math.min(100, priority + 20);
                }

                bottlenecks.add(new Bottleneck(
                        point.name(),
                        point.getDisplayName(),
                        avgMs,
                        ratio,
                        type,
                        module,
                        priority));
            }
        }

        // Deep Analysis 병목 추가
        addDeepAnalysisBottlenecks(bottlenecks, totalTickMs);

        // 우선순위로 정렬
        bottlenecks.sort((a, b) -> Integer.compare(b.priority, a.priority));

        return bottlenecks.size() > n ? bottlenecks.subList(0, n) : bottlenecks;
    }

    private void addDeepAnalysisBottlenecks(List<Bottleneck> bottlenecks, double totalTickMs) {
        // 패스파인딩
        PathfindingProfiler pf = PathfindingProfiler.getInstance();
        double pfMs = pf.getTotalTimeMs();
        if (pfMs > 1.0) {
            double ratio = pfMs / totalTickMs;
            bottlenecks.add(new Bottleneck(
                    "PATHFINDING_DEEP",
                    "Pathfinding (Detailed)",
                    pfMs,
                    ratio,
                    BottleneckType.CPU_BOUND,
                    OptimizationModule.FUSE,
                    calculatePriority(null, ratio, pfMs)));
        }

        // 좀비 AI
        ZombieProfiler zp = ZombieProfiler.getInstance();
        int zombieCount = (int) zp.getZombieCount();
        if (zombieCount > 100) {
            // 좀비당 추정 시간
            double estimatedMs = zombieCount * 0.05; // 0.05ms per zombie
            double ratio = estimatedMs / totalTickMs;
            if (ratio > 0.1) {
                bottlenecks.add(new Bottleneck(
                        "ZOMBIE_PROCESSING",
                        "Zombie Processing (" + zombieCount + " zombies)",
                        estimatedMs,
                        ratio,
                        BottleneckType.CPU_BOUND,
                        OptimizationModule.FUSE,
                        (int) (ratio * 100)));
            }
        }
    }

    /**
     * Fuse 타겟 제안
     */
    @Override
    public OptimizationPriority suggestFuseTarget() {
        List<Bottleneck> bottlenecks = identifyTopN(5);

        for (Bottleneck b : bottlenecks) {
            if (b.suggestedModule == OptimizationModule.FUSE) {
                return new OptimizationPriority(
                        b.name,
                        b.displayName,
                        b.priority,
                        generateFuseRecommendation(b));
            }
        }

        return new OptimizationPriority("NONE", "No Fuse target identified", 0,
                "Current performance is acceptable or bottlenecks are not Fuse-optimizable.");
    }

    /**
     * Nerve 타겟 제안
     */
    @Override
    public OptimizationPriority suggestNerveTarget() {
        List<Bottleneck> bottlenecks = identifyTopN(5);

        for (Bottleneck b : bottlenecks) {
            if (b.suggestedModule == OptimizationModule.NERVE) {
                return new OptimizationPriority(
                        b.name,
                        b.displayName,
                        b.priority,
                        generateNerveRecommendation(b));
            }
        }

        return new OptimizationPriority("NONE", "No Nerve target identified", 0,
                "Current load is manageable or requires code-level optimization.");
    }

    /**
     * 이상 탐지
     */
    public AnomalyReport detectAnomalies() {
        AnomalyReport report = new AnomalyReport();

        EchoProfiler profiler = EchoProfiler.getInstance();
        TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);

        if (tickData == null)
            return report;

        // 틱 시간 이상
        double avgMs = tickData.getAverageMicros() / 1000.0;
        double maxMs = tickData.getMaxMicros() / 1000.0;

        if (avgMs > TICK_THRESHOLD_MS * 2) {
            report.addAnomaly(AnomalySeverity.CRITICAL, "TICK_OVERLOAD",
                    String.format("Average tick time (%.2fms) is 2x over target", avgMs));
        } else if (avgMs > TICK_THRESHOLD_MS) {
            report.addAnomaly(AnomalySeverity.WARNING, "TICK_SLOW",
                    String.format("Average tick time (%.2fms) exceeds target", avgMs));
        }

        // 스파이크 이상
        if (maxMs > avgMs * 5) {
            report.addAnomaly(AnomalySeverity.WARNING, "SPIKE_DETECTED",
                    String.format("Max spike (%.2fms) is 5x average", maxMs));
        }

        // 메모리 이상
        double memUsage = MemoryProfiler.getHeapUsagePercent();
        if (memUsage > 90) {
            report.addAnomaly(AnomalySeverity.CRITICAL, "MEMORY_CRITICAL",
                    String.format("Heap usage at %.1f%%", memUsage));
        } else if (memUsage > 75) {
            report.addAnomaly(AnomalySeverity.WARNING, "MEMORY_HIGH",
                    String.format("Heap usage at %.1f%%", memUsage));
        }

        return report;
    }

    /**
     * JSON 출력
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();

        // Top 5 병목
        List<Map<String, Object>> bottleneckList = new ArrayList<>();
        for (Bottleneck b : identifyTopN(5)) {
            Map<String, Object> bMap = new LinkedHashMap<>();
            bMap.put("name", b.name);
            bMap.put("display_name", b.displayName);
            bMap.put("avg_ms", Math.round(b.avgMs * 100) / 100.0);
            bMap.put("ratio_percent", Math.round(b.ratio * 10000) / 100.0);
            bMap.put("type", b.type.name());
            bMap.put("suggested_module", b.suggestedModule.name());
            bMap.put("priority", b.priority);
            bottleneckList.add(bMap);
        }
        map.put("top_bottlenecks", bottleneckList);

        // 최적화 제안
        Map<String, Object> suggestions = new LinkedHashMap<>();
        OptimizationPriority fuse = suggestFuseTarget();
        suggestions.put("fuse_target", fuse.toMap());
        OptimizationPriority nerve = suggestNerveTarget();
        suggestions.put("nerve_target", nerve.toMap());
        map.put("optimization_suggestions", suggestions);

        // 이상 탐지
        map.put("anomalies", detectAnomalies().toMap());

        return map;
    }

    // --- 헬퍼 메서드 ---

    private BottleneckType classifyBottleneck(ProfilingPoint point, double ratio) {
        return switch (point) {
            case RENDER, RENDER_WORLD, RENDER_UI -> BottleneckType.GPU_BOUND;
            case NETWORK -> BottleneckType.IO_BOUND;
            case CHUNK_IO -> BottleneckType.IO_BOUND;
            default -> BottleneckType.CPU_BOUND;
        };
    }

    private OptimizationModule suggestModule(ProfilingPoint point) {
        return switch (point) {
            case ZOMBIE_AI, SIMULATION, PHYSICS -> OptimizationModule.FUSE;
            case RENDER, RENDER_WORLD -> OptimizationModule.NERVE;
            case NETWORK -> OptimizationModule.NERVE;
            default -> OptimizationModule.FUSE;
        };
    }

    private int calculatePriority(ProfilingPoint point, double ratio, double avgMs) {
        int base = (int) (ratio * 100);
        if (avgMs > TICK_THRESHOLD_MS)
            base += 20;
        if (avgMs > TICK_THRESHOLD_MS * 2)
            base += 30;
        return Math.min(100, base);
    }

    private String generateFuseRecommendation(Bottleneck b) {
        return switch (b.name) {
            case "ZOMBIE_AI" -> "Consider zombie AI pooling and LOD-based update frequency";
            case "SIMULATION" -> "Review high-frequency simulation updates for batching opportunities";
            case "PHYSICS" -> "Implement physics LOD or reduce collision check frequency";
            case "PATHFINDING_DEEP" -> "Cache pathfinding results and implement hierarchical pathfinding";
            default -> "Profile detailed call stacks to identify hot paths";
        };
    }

    private String generateNerveRecommendation(Bottleneck b) {
        return switch (b.name) {
            case "RENDER" -> "Implement occlusion culling and batch similar draw calls";
            case "RENDER_WORLD" -> "Consider LOD for distant objects and frustum culling";
            case "NETWORK" -> "Batch network packets and implement delta compression";
            default -> "Monitor I/O patterns for optimization opportunities";
        };
    }

    // --- 내부 클래스 ---

    public static class Bottleneck {
        public final String name;
        public final String displayName;
        public final double avgMs;
        public final double ratio;
        public final BottleneckType type;
        public final OptimizationModule suggestedModule;
        public final int priority;

        public Bottleneck(String name, String displayName, double avgMs, double ratio,
                BottleneckType type, OptimizationModule suggestedModule, int priority) {
            this.name = name;
            this.displayName = displayName;
            this.avgMs = avgMs;
            this.ratio = ratio;
            this.type = type;
            this.suggestedModule = suggestedModule;
            this.priority = priority;
        }
    }

    public enum BottleneckType {
        CPU_BOUND, GPU_BOUND, IO_BOUND, MEMORY_BOUND
    }

    public enum OptimizationModule {
        FUSE, NERVE, EITHER
    }

    public static class AnomalyReport {
        private final List<Anomaly> anomalies = new ArrayList<>();

        public void addAnomaly(AnomalySeverity severity, String type, String message) {
            anomalies.add(new Anomaly(severity, type, message));
        }

        public boolean hasAnomalies() {
            return !anomalies.isEmpty();
        }

        public boolean hasCritical() {
            return anomalies.stream().anyMatch(a -> a.severity == AnomalySeverity.CRITICAL);
        }

        public Map<String, Object> toMap() {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("count", anomalies.size());
            map.put("has_critical", hasCritical());

            List<Map<String, String>> list = new ArrayList<>();
            for (Anomaly a : anomalies) {
                Map<String, String> aMap = new LinkedHashMap<>();
                aMap.put("severity", a.severity.name());
                aMap.put("type", a.type);
                aMap.put("message", a.message);
                list.add(aMap);
            }
            map.put("items", list);

            return map;
        }
    }

    public static class Anomaly {
        public final AnomalySeverity severity;
        public final String type;
        public final String message;

        public Anomaly(AnomalySeverity severity, String type, String message) {
            this.severity = severity;
            this.type = type;
            this.message = message;
        }
    }

    public enum AnomalySeverity {
        INFO, WARNING, CRITICAL
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\analysis\CorrelationAnalyzer.java =====

package com.echo.analysis;

import com.echo.history.MetricHistory;

import java.util.Arrays;

/**
 * 상관관계 분석기
 * Pearson Correlation Coefficient(PCC)를 사용하여 두 메트릭 간의 상관관계를 분석합니다.
 */
public class CorrelationAnalyzer {

    /**
     * 두 히스토리 데이터의 상관계수를 계산합니다.
     * 
     * @return -1.0 ~ 1.0 사이의 값. 데이터가 부족하거나 분산이 0이면 0.0 반환.
     */
    public static double calculateCorrelation(MetricHistory h1, MetricHistory h2) {
        if (h1 == null || h2 == null)
            return 0.0;

        double[] d1 = h1.toArray();
        double[] d2 = h2.toArray();

        // 1. 데이터 길이 맞추기 (뒤에서부터, 즉 최신 데이터 기준으로 매칭)
        int len = Math.min(d1.length, d2.length);
        if (len < 5) {
            // 데이터가 너무 적으면 의미 없음 (적어도 5개 샘플은 필요)
            return 0.0;
        }

        // 최신 N개 추출
        double[] x = Arrays.copyOfRange(d1, d1.length - len, d1.length);
        double[] y = Arrays.copyOfRange(d2, d2.length - len, d2.length);

        return computePearson(x, y);
    }

    private static double computePearson(double[] x, double[] y) {
        if (x.length != y.length)
            return 0.0;
        int n = x.length;

        double sumX = 0.0;
        double sumY = 0.0;
        double sumXY = 0.0;
        double sumX2 = 0.0;
        double sumY2 = 0.0;

        for (int i = 0; i < n; i++) {
            sumX += x[i];
            sumY += y[i];
            sumXY += x[i] * y[i];
            sumX2 += x[i] * x[i];
            sumY2 += y[i] * y[i];
        }

        double numerator = n * sumXY - sumX * sumY;
        double denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

        if (denominator == 0)
            return 0.0; // 분모가 0이면(표준편차가 0이면) 상관관계 정의 불가

        return numerator / denominator;
    }

    /**
     * 상관관계 해석 (디버그용/리포트용)
     */
    public static String interpret(double correlation) {
        double abs = Math.abs(correlation);
        String direction = correlation > 0 ? "Positive" : "Negative";

        if (abs > 0.7)
            return "Strong " + direction;
        if (abs > 0.3)
            return "Moderate " + direction;
        return "Weak/None";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\analysis\ExtendedCorrelationAnalyzer.java =====

package com.echo.analysis;

import com.echo.aggregate.*;
import com.echo.measure.*;
import com.echo.fuse.*;

import java.util.*;

/**
 * 확장 상관관계 분석기.
 * 
 * 다양한 메트릭 간의 상관관계를 분석합니다.
 * 기존 CorrelationAnalyzer를 확장합니다.
 * 
 * @since 1.0.1
 */
public class ExtendedCorrelationAnalyzer {

    private static final ExtendedCorrelationAnalyzer INSTANCE = new ExtendedCorrelationAnalyzer();
    private static final int BUFFER_SIZE = 100;

    // 상관관계 버퍼들
    private final CorrelationBuffer chunkVsFrameTime = new CorrelationBuffer(BUFFER_SIZE);
    private final CorrelationBuffer entityVsSimulation = new CorrelationBuffer(BUFFER_SIZE);
    private final CorrelationBuffer memoryVsGcFreq = new CorrelationBuffer(BUFFER_SIZE);
    private final CorrelationBuffer pathfindingVsTick = new CorrelationBuffer(BUFFER_SIZE);
    private final CorrelationBuffer zombieVsTick = new CorrelationBuffer(BUFFER_SIZE);
    private final CorrelationBuffer vehicleVsTick = new CorrelationBuffer(BUFFER_SIZE);

    // 캐시된 값들
    private long lastGcCount = 0;
    private long lastTickTime = System.currentTimeMillis();

    public static ExtendedCorrelationAnalyzer getInstance() {
        return INSTANCE;
    }

    /**
     * 틱마다 호출하여 데이터 수집
     */
    public void onTick() {
        TimingData tickData = EchoProfiler.getInstance().getTimingData(ProfilingPoint.TICK);
        if (tickData == null)
            return;

        double tickMs = tickData.getStats1s().getAverage() / 1000.0;
        long now = System.currentTimeMillis();

        // 1. 좀비 vs 틱
        int zombieCount = (int) ZombieProfiler.getInstance().getZombieCount();
        zombieVsTick.addSample(zombieCount, tickMs);

        // 2. 청크 vs 프레임
        try {
            Class<?> gameAccess = Class.forName("com.pulse.api.GameAccess");
            java.lang.reflect.Method getChunks = gameAccess.getMethod("getLoadedCellCount");
            int chunkCount = ((Number) getChunks.invoke(null)).intValue();

            TimingData frameData = EchoProfiler.getInstance().getTimingData(ProfilingPoint.FRAME);
            if (frameData != null) {
                chunkVsFrameTime.addSample(chunkCount, frameData.getStats1s().getAverage() / 1000.0);
            }

            // 3. 총 엔티티 vs 시뮬레이션
            java.lang.reflect.Method getEntities = gameAccess.getMethod("getTotalEntityCount");
            int entityCount = ((Number) getEntities.invoke(null)).intValue();

            TimingData simData = EchoProfiler.getInstance().getTimingData(ProfilingPoint.SIMULATION);
            if (simData != null) {
                entityVsSimulation.addSample(entityCount, simData.getStats1s().getAverage() / 1000.0);
            }

            // 4. 차량 vs 틱
            java.lang.reflect.Method getVehicles = gameAccess.getMethod("getVehicleCount");
            int vehicleCount = ((Number) getVehicles.invoke(null)).intValue();
            vehicleVsTick.addSample(vehicleCount, tickMs);

        } catch (Exception e) {
            // Pulse 없이 실행 중
        }

        // 5. 메모리 vs GC 빈도
        long currentGcCount = MemoryProfiler.getTotalGcCount();
        double gcDelta = currentGcCount - lastGcCount;
        double timeDelta = (now - lastTickTime) / 1000.0;
        double gcFreq = timeDelta > 0 ? gcDelta / timeDelta : 0;

        double memoryUsage = MemoryProfiler.getHeapUsagePercent();
        memoryVsGcFreq.addSample(memoryUsage, gcFreq);

        lastGcCount = currentGcCount;
        lastTickTime = now;

        // 6. 패스파인딩 호출 vs 틱 (총 요청 수 사용)
        long pathfindingCalls = PathfindingProfiler.getInstance().getTotalRequests();
        pathfindingVsTick.addSample(pathfindingCalls, tickMs);
    }

    /**
     * 모든 상관관계 분석 결과
     */
    public Map<String, Object> analyze() {
        Map<String, Object> results = new LinkedHashMap<>();

        results.put("zombie_vs_tick", createCorrelationEntry(zombieVsTick, "좀비 수 vs 틱 시간"));
        results.put("chunk_vs_frame", createCorrelationEntry(chunkVsFrameTime, "청크 수 vs 프레임 시간"));
        results.put("entity_vs_simulation", createCorrelationEntry(entityVsSimulation, "엔티티 수 vs 시뮬레이션"));
        results.put("memory_vs_gc", createCorrelationEntry(memoryVsGcFreq, "메모리 사용률 vs GC 빈도"));
        results.put("pathfinding_vs_tick", createCorrelationEntry(pathfindingVsTick, "패스파인딩 호출 vs 틱"));
        results.put("vehicle_vs_tick", createCorrelationEntry(vehicleVsTick, "차량 수 vs 틱 시간"));

        // 요약
        Map<String, Object> summary = new LinkedHashMap<>();
        double strongestCorr = 0;
        String strongestName = "none";

        for (Map.Entry<String, Object> entry : results.entrySet()) {
            @SuppressWarnings("unchecked")
            Map<String, Object> data = (Map<String, Object>) entry.getValue();
            double corr = Math.abs((Double) data.get("correlation"));
            if (corr > Math.abs(strongestCorr)) {
                strongestCorr = corr;
                strongestName = entry.getKey();
            }
        }

        summary.put("strongest_correlation", strongestName);
        summary.put("strongest_value", Math.round(strongestCorr * 100) / 100.0);
        results.put("summary", summary);

        return results;
    }

    private Map<String, Object> createCorrelationEntry(CorrelationBuffer buffer, String description) {
        Map<String, Object> entry = new LinkedHashMap<>();
        double corr = buffer.calculateCorrelation();
        entry.put("correlation", Math.round(corr * 1000) / 1000.0);
        entry.put("samples", buffer.getCount());
        entry.put("description", description);
        entry.put("strength", getCorrelationStrength(corr));
        return entry;
    }

    private String getCorrelationStrength(double corr) {
        double abs = Math.abs(corr);
        if (abs >= 0.8)
            return "VERY_STRONG";
        if (abs >= 0.6)
            return "STRONG";
        if (abs >= 0.4)
            return "MODERATE";
        if (abs >= 0.2)
            return "WEAK";
        return "NONE";
    }

    /**
     * 초기화
     */
    public void reset() {
        chunkVsFrameTime.reset();
        entityVsSimulation.reset();
        memoryVsGcFreq.reset();
        pathfindingVsTick.reset();
        zombieVsTick.reset();
        vehicleVsTick.reset();
        lastGcCount = 0;
        lastTickTime = System.currentTimeMillis();
    }

    // --- 내부 클래스 ---

    private static class CorrelationBuffer {
        private final double[] xBuffer;
        private final double[] yBuffer;
        private final int size;
        private int count = 0;
        private int head = 0;

        CorrelationBuffer(int size) {
            this.size = size;
            this.xBuffer = new double[size];
            this.yBuffer = new double[size];
        }

        void addSample(double x, double y) {
            xBuffer[head] = x;
            yBuffer[head] = y;
            head = (head + 1) % size;
            if (count < size)
                count++;
        }

        int getCount() {
            return count;
        }

        void reset() {
            count = 0;
            head = 0;
        }

        double calculateCorrelation() {
            if (count < 2)
                return 0;

            double sumX = 0, sumY = 0, sumXY = 0;
            double sumX2 = 0, sumY2 = 0;

            for (int i = 0; i < count; i++) {
                double x = xBuffer[i];
                double y = yBuffer[i];
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumX2 += x * x;
                sumY2 += y * y;
            }

            double n = count;
            double numerator = n * sumXY - sumX * sumY;
            double denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

            return denominator == 0 ? 0 : numerator / denominator;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\command\EchoCommands.java =====

package com.echo.command;

import com.echo.command.impl.*;
import com.echo.measure.EchoProfiler;
import com.pulse.command.CommandContext;
import com.pulse.command.CommandRegistry;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;

/**
 * Echo 콘솔 명령어
 * 
 * 사용 가능한 명령어:
 * - /echo help - 도움말
 * - /echo enable - 프로파일링 시작
 * - /echo disable - 프로파일링 중지
 * - /echo status - 현재 상태 출력
 * - /echo report - 리포트 생성
 * - /echo reset - 통계 초기화
 * - /echo lua on/off - Lua 프로파일링 토글
 * - /echo config threshold <ms> - 스파이크 임계값 설정
 * - /echo memory - 메모리 상태 출력
 */
public class EchoCommands {

    private static final Map<String, Consumer<String[]>> commands = new HashMap<>();
    private static boolean registered = false;

    /**
     * 명령어 등록 (Pulse CommandRegistry 통합)
     */
    public static void register() {
        if (registered)
            return;

        // Register internal command map for dispatch
        commands.put("help", EchoCommands::cmdHelp);
        commands.put("enable", EchoCommands::cmdEnable);
        commands.put("disable", EchoCommands::cmdDisable);

        // Delegated Commands
        commands.put("status", EchoStatusCmd::execute);
        commands.put("report", EchoReportCmd::execute);
        commands.put("config", EchoConfigCmd::execute);
        commands.put("lua", EchoLuaCmd::execute);
        commands.put("test", EchoTestCmd::execute);
        commands.put("overhead", EchoOverheadCmd::execute);
        commands.put("memory", EchoMonitoringCmd::executeMemory);
        commands.put("stack", EchoMonitoringCmd::executeStack);
        commands.put("monitor", EchoMonitoringCmd::executeMonitor);

        commands.put("reset", EchoCommands::cmdReset);

        // Register with Pulse CommandRegistry (if available)
        try {
            CommandRegistry.register("echo", "Echo Profiler 명령어", EchoCommands::handleEchoCommand);
            System.out.println("[Echo] Commands registered via Pulse CommandRegistry");
        } catch (NoClassDefFoundError e) {
            // Pulse not available, fallback to direct invocation
            System.out.println("[Echo] Commands registered (standalone mode)");
        }

        registered = true;
    }

    /**
     * Pulse CommandContext 기반 핸들러
     */
    private static void handleEchoCommand(CommandContext ctx) {
        String[] args = ctx.getRawArgs();
        if (args.length == 0) {
            cmdHelp(new String[0]);
            return;
        }

        String subCommand = args[0].toLowerCase();
        Consumer<String[]> handler = commands.get(subCommand);

        if (handler != null) {
            handler.accept(args);
        } else {
            ctx.reply("[Echo] Unknown command: " + subCommand);
            ctx.reply("[Echo] Use '/echo help' for available commands");
        }
    }

    /**
     * 명령어 실행
     * 
     * @param args 명령어 인자 (첫 번째는 서브커맨드)
     * @return 처리 여부
     */
    public static boolean execute(String[] args) {
        if (args == null || args.length == 0) {
            cmdHelp(args);
            return true;
        }

        String subCommand = args[0].toLowerCase();
        Consumer<String[]> handler = commands.get(subCommand);

        if (handler != null) {
            handler.accept(args);
            return true;
        } else {
            System.out.println("[Echo] Unknown command: " + subCommand);
            System.out.println("[Echo] Use '/echo help' for available commands");
            return false;
        }
    }

    // --- Command Handlers ---

    private static void cmdHelp(String[] args) {
        System.out.println();
        System.out.println("╔═══════════════════════════════════════════════╗");
        System.out.println("║           Echo Profiler Commands              ║");
        System.out.println("╠═══════════════════════════════════════════════╣");
        System.out.println("║  Basic Commands:                              ║");
        System.out.println("║  /echo help        - Show this help           ║");
        System.out.println("║  /echo enable      - Start profiling          ║");
        System.out.println("║  /echo disable     - Stop profiling           ║");
        System.out.println("║  /echo status      - Show current status      ║");
        System.out.println("║  /echo report      - Generate report          ║");
        System.out.println("║  /echo report json - Save JSON report         ║");
        System.out.println("║  /echo reset       - Reset all statistics     ║");
        System.out.println("╠═══════════════════════════════════════════════╣");
        System.out.println("║  Lua Profiling:                               ║");
        System.out.println("║  /echo lua on      - Enable Lua profiling     ║");
        System.out.println("║  /echo lua off     - Disable Lua profiling    ║");
        System.out.println("╠═══════════════════════════════════════════════╣");
        System.out.println("║  Configuration:                               ║");
        System.out.println("║  /echo config      - Show current config      ║");
        System.out.println("║  /echo config set threshold <ms>              ║");
        System.out.println("║  /echo memory      - Show memory status       ║");
        System.out.println("╠═══════════════════════════════════════════════╣");
        System.out.println("║  Advanced (Phase 4):                          ║");
        System.out.println("║  /echo stack on    - Enable spike stack trace ║");
        System.out.println("║  /echo overhead    - Measure profiler cost    ║");
        System.out.println("║  /echo monitor start [port] - Start HTTP API  ║");
        System.out.println("║  /echo test        - Run quick test           ║");
        System.out.println("╚═══════════════════════════════════════════════╝");
        System.out.println();
    }

    private static void cmdEnable(String[] args) {
        EchoProfiler.getInstance().enable();
    }

    private static void cmdDisable(String[] args) {
        EchoProfiler.getInstance().disable();
    }

    private static void cmdReset(String[] args) {
        EchoProfiler.getInstance().reset();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\command\impl\EchoConfigCmd.java =====

package com.echo.command.impl;

import com.echo.aggregate.SpikeLog;
import com.echo.measure.EchoProfiler;

public class EchoConfigCmd {
    public static void execute(String[] args) {
        EchoProfiler profiler = EchoProfiler.getInstance();
        SpikeLog spikeLog = profiler.getSpikeLog();

        // /echo config (no args) - show current config
        if (args.length < 2) {
            System.out.println();
            System.out.println("╔═══════════════════════════════════════════════╗");
            System.out.println("║           Echo Configuration                  ║");
            System.out.println("╠═══════════════════════════════════════════════╣");
            System.out.printf("║  Spike Threshold: %.2f ms                    ║%n", spikeLog.getThresholdMs());
            System.out.printf("║  Lua Profiling:   %s                      ║%n",
                    profiler.isLuaProfilingEnabled() ? "ON " : "OFF");
            System.out.println("╠═══════════════════════════════════════════════╣");
            System.out.println("║  Usage:                                       ║");
            System.out.println("║    /echo config get              - Show all   ║");
            System.out.println("║    /echo config set threshold <ms>            ║");
            System.out.println("╚═══════════════════════════════════════════════╝");
            System.out.println();
            return;
        }

        String action = args[1].toLowerCase();

        // /echo config get
        if ("get".equals(action)) {
            System.out.println("[Echo] Current Configuration:");
            System.out.printf("  spike.threshold = %.2f ms%n", spikeLog.getThresholdMs());
            System.out.printf("  lua.enabled = %s%n", profiler.isLuaProfilingEnabled());
            System.out.printf("  profiler.enabled = %s%n", profiler.isEnabled());
            return;
        }

        // /echo config set <key> <value>
        if ("set".equals(action)) {
            if (args.length < 4) {
                System.out.println("[Echo] Usage: /echo config set <key> <value>");
                System.out.println("[Echo]   Available keys: threshold");
                return;
            }

            String key = args[2].toLowerCase();
            String value = args[3];

            if ("threshold".equals(key)) {
                try {
                    double thresholdMs = Double.parseDouble(value);
                    if (thresholdMs <= 0) {
                        System.out.println("[Echo] Threshold must be positive");
                        return;
                    }
                    spikeLog.setThresholdMs(thresholdMs);
                    System.out.printf("[Echo] Spike threshold set to %.2f ms%n", thresholdMs);
                } catch (NumberFormatException e) {
                    System.out.println("[Echo] Invalid number: " + value);
                }
            } else {
                System.out.println("[Echo] Unknown config key: " + key);
                System.out.println("[Echo] Available keys: threshold");
            }
            return;
        }

        // Legacy: /echo config threshold <value> (backward compatibility)
        if ("threshold".equals(action)) {
            if (args.length < 3) {
                System.out.printf("[Echo] Current threshold: %.2f ms%n", spikeLog.getThresholdMs());
                return;
            }
            try {
                double thresholdMs = Double.parseDouble(args[2]);
                if (thresholdMs <= 0) {
                    System.out.println("[Echo] Threshold must be positive");
                    return;
                }
                spikeLog.setThresholdMs(thresholdMs);
            } catch (NumberFormatException e) {
                System.out.println("[Echo] Invalid number: " + args[2]);
            }
            return;
        }

        System.out.println("[Echo] Unknown config action: " + action);
        System.out.println("[Echo] Usage: /echo config [get|set <key> <value>]");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\command\impl\EchoLuaCmd.java =====

package com.echo.command.impl;

import com.echo.measure.EchoProfiler;

public class EchoLuaCmd {
    public static void execute(String[] args) {
        if (args.length < 2) {
            System.out.println("[Echo] Usage: /echo lua <on|off>");
            return;
        }

        String toggle = args[1].toLowerCase();
        EchoProfiler profiler = EchoProfiler.getInstance();

        if ("on".equals(toggle)) {
            profiler.enableLuaProfiling();
        } else if ("off".equals(toggle)) {
            profiler.disableLuaProfiling();
        } else {
            System.out.println("[Echo] Usage: /echo lua <on|off>");
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\command\impl\EchoMonitoringCmd.java =====

package com.echo.command.impl;

import com.echo.aggregate.SpikeLog;
import com.echo.measure.EchoProfiler;
import com.echo.measure.MemoryProfiler;
import com.echo.monitor.EchoMonitorServer;

public class EchoMonitoringCmd {

    public static void executeMonitor(String[] args) {
        EchoMonitorServer server = EchoMonitorServer.getInstance();

        if (args.length < 2) {
            System.out.println("[Echo] Monitor server: " + (server.isRunning() ? "RUNNING" : "STOPPED"));
            System.out.println("[Echo] Usage: /echo monitor <start|stop>");
            return;
        }

        String action = args[1].toLowerCase();
        switch (action) {
            case "start":
                if (args.length > 2) {
                    try {
                        int port = Integer.parseInt(args[2]);
                        server.start(port);
                    } catch (NumberFormatException e) {
                        System.out.println("[Echo] Invalid port: " + args[2]);
                    }
                } else {
                    server.start();
                }
                break;
            case "stop":
                server.stop();
                break;
            default:
                System.out.println("[Echo] Usage: /echo monitor <start|stop>");
        }
    }

    public static void executeMemory(String[] args) {
        MemoryProfiler.printStatus();
    }

    public static void executeStack(String[] args) {
        SpikeLog spikeLog = EchoProfiler.getInstance().getSpikeLog();

        if (args.length < 2) {
            System.out.println("[Echo] Stack capture: " +
                    (spikeLog.isStackCaptureEnabled() ? "ENABLED" : "DISABLED"));
            System.out.println("[Echo] Usage: /echo stack <on|off>");
            System.out.println("[Echo] ⚠️ Warning: Stack capture has significant performance cost!");
            return;
        }

        String toggle = args[1].toLowerCase();
        if ("on".equals(toggle)) {
            spikeLog.setStackCaptureEnabled(true);
        } else if ("off".equals(toggle)) {
            spikeLog.setStackCaptureEnabled(false);
        } else {
            System.out.println("[Echo] Usage: /echo stack <on|off>");
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\command\impl\EchoOverheadCmd.java =====

package com.echo.command.impl;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;

public class EchoOverheadCmd {
    public static void execute(String[] args) {
        System.out.println("[Echo] Measuring profiler overhead...");

        EchoProfiler profiler = EchoProfiler.getInstance();
        boolean wasEnabled = profiler.isEnabled();

        if (!wasEnabled) {
            profiler.enable(false);
        }

        int iterations = 10000;

        // 오버헤드 없이 측정
        long baselineStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            // 빈 루프
        }
        long baselineTime = System.nanoTime() - baselineStart;

        // 프로파일링 오버헤드 측정
        long profiledStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            long start = profiler.startRaw(ProfilingPoint.ECHO_OVERHEAD);
            profiler.endRaw(ProfilingPoint.ECHO_OVERHEAD, start);
        }
        long profiledTime = System.nanoTime() - profiledStart;

        // scope() API 오버헤드 측정
        long scopeStart = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            try (var scope = profiler.scope(ProfilingPoint.ECHO_OVERHEAD)) {
                // 빈 루프
            }
        }
        long scopeTime = System.nanoTime() - scopeStart;

        if (!wasEnabled) {
            profiler.disable();
        }

        // 결과 출력
        double rawOverheadNs = (profiledTime - baselineTime) / (double) iterations;
        double scopeOverheadNs = (scopeTime - baselineTime) / (double) iterations;

        System.out.println();
        System.out.println("╔═══════════════════════════════════════════════╗");
        System.out.println("║         Echo Profiler Overhead Report         ║");
        System.out.println("╠═══════════════════════════════════════════════╣");
        System.out.printf("║  Iterations:        %,d                   ║%n", iterations);
        System.out.printf("║  Raw API overhead:  %.2f ns/call           ║%n", rawOverheadNs);
        System.out.printf("║  Scope API overhead: %.2f ns/call          ║%n", scopeOverheadNs);
        System.out.println("╠═══════════════════════════════════════════════╣");
        System.out.println("║  💡 Lower is better. <100ns is excellent.     ║");
        System.out.println("╚═══════════════════════════════════════════════╝");
        System.out.println();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\command\impl\EchoReportCmd.java =====

package com.echo.command.impl;

import com.echo.config.EchoConfig;
import com.echo.measure.EchoProfiler;
import com.echo.report.EchoReport;

public class EchoReportCmd {
    public static void execute(String[] args) {
        EchoProfiler profiler = EchoProfiler.getInstance();
        EchoReport report = new EchoReport(profiler);
        String reportDir = EchoConfig.getInstance().getReportDirectory();

        if (args.length > 1) {
            String format = args[1].toLowerCase();
            try {
                switch (format) {
                    case "json":
                        String jsonPath = report.saveWithTimestamp(reportDir);
                        System.out.println("[Echo] JSON report saved: " + jsonPath);
                        break;
                    case "csv":
                        String csvPath = report.saveCsv(reportDir);
                        System.out.println("[Echo] CSV report saved: " + csvPath);
                        break;
                    case "html":
                        String htmlPath = report.saveHtml(reportDir);
                        System.out.println("[Echo] HTML report saved: " + htmlPath);
                        break;
                    default:
                        System.out.println("[Echo] Unknown format: " + format);
                        System.out.println("[Echo] Usage: /echo report [json|csv|html]");
                }
            } catch (Exception e) {
                System.err.println("[Echo] Failed to save report: " + e.getMessage());
            }
        } else {
            report.printToConsole();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\command\impl\EchoStatusCmd.java =====

package com.echo.command.impl;

import com.echo.measure.EchoProfiler;
import com.echo.pulse.PulseEventAdapter;
import com.echo.pulse.TickProfiler;
import com.echo.pulse.RenderProfiler;

public class EchoStatusCmd {
    public static void execute(String[] args) {
        EchoProfiler profiler = EchoProfiler.getInstance();
        profiler.printStatus();

        // Enhanced Phase 3: 추가 상태 정보
        System.out.println("⚙️ CONFIGURATION");
        System.out.println("───────────────────────────────────────────────────────");
        System.out.printf("  Lua Profiling:   %s%n",
                profiler.isLuaProfilingEnabled() ? "✅ ENABLED" : "❌ DISABLED");
        System.out.printf("  Spike Threshold: %.2f ms%n",
                profiler.getSpikeLog().getThresholdMs());
        System.out.printf("  Stack Depth:     %d (current thread)%n",
                profiler.getCurrentStackDepth());
        System.out.printf("  Session Time:    %d seconds%n",
                profiler.getSessionDurationSeconds());
        System.out.println();

        // Pulse integration status
        if (PulseEventAdapter.isRegistered()) {
            TickProfiler tickProfiler = PulseEventAdapter.getTickProfiler();
            RenderProfiler renderProfiler = PulseEventAdapter.getRenderProfiler();

            System.out.println("📡 PULSE INTEGRATION");
            System.out.println("───────────────────────────────────────────────────────");
            if (tickProfiler != null) {
                System.out.printf("  Tick Count:     %,d%n", tickProfiler.getTickCount());
                System.out.printf("  Last Tick:      %.2f ms%n", tickProfiler.getLastTickDurationMs());
                System.out.printf("  Spike Threshold: %.2f ms%n", tickProfiler.getSpikeThresholdMs());
            }
            if (renderProfiler != null) {
                System.out.printf("  Frame Count:    %,d%n", renderProfiler.getFrameCount());
                System.out.printf("  Current FPS:    %.1f%n", renderProfiler.getCurrentFps());
                System.out.printf("  Last Frame:     %.2f ms%n", renderProfiler.getLastFrameDurationMs());
            }
            System.out.println();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\command\impl\EchoTestCmd.java =====

package com.echo.command.impl;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;

import java.io.File;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class EchoTestCmd {
    public static void execute(String[] args) {
        System.out.println("[Echo] Running quick profiling test...");

        EchoProfiler profiler = EchoProfiler.getInstance();
        boolean wasEnabled = profiler.isEnabled();
        long testStartTime = System.currentTimeMillis();

        if (!wasEnabled) {
            profiler.enable();
        }

        int testIterations = 100;
        int successCount = 0;

        // Simulate some profiling
        for (int i = 0; i < testIterations; i++) {
            try (var scope = profiler.scope(ProfilingPoint.TICK)) {
                // Simulate tick work
                Thread.sleep(1);

                try (var aiScope = profiler.scope(ProfilingPoint.ZOMBIE_AI, "pathfinding")) {
                    Thread.sleep(0, 500000); // 0.5ms
                }

                try (var renderScope = profiler.scope(ProfilingPoint.RENDER)) {
                    Thread.sleep(0, 300000); // 0.3ms
                }
                successCount++;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }

        long testDuration = System.currentTimeMillis() - testStartTime;

        System.out.println("[Echo] Test complete! " + successCount + "/" + testIterations + " ticks recorded.");
        profiler.printStatus();

        // Phase 3: 결과 파일 저장
        saveTestResult(profiler, testIterations, successCount, testDuration);

        if (!wasEnabled) {
            profiler.disable();
        }
    }

    private static void saveTestResult(EchoProfiler profiler, int iterations, int success, long durationMs) {
        try {
            File dir = new File("./echo_tests");
            if (!dir.exists()) {
                dir.mkdirs();
            }

            String timestamp = LocalDateTime.now()
                    .format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            File file = new File(dir, "smoke_test_" + timestamp + ".txt");

            try (PrintWriter writer = new PrintWriter(file)) {
                writer.println("═══════════════════════════════════════════════════════");
                writer.println("  Echo Profiler Smoke Test Report");
                writer.println("  " + LocalDateTime.now());
                writer.println("═══════════════════════════════════════════════════════");
                writer.println();
                writer.println("TEST SUMMARY");
                writer.println("───────────────────────────────────────────────────────");
                writer.println("  Iterations:    " + iterations);
                writer.println("  Success:       " + success);
                writer.println("  Duration:      " + durationMs + " ms");
                writer.println("  Result:        " + (success == iterations ? "✅ PASS" : "❌ FAIL"));
                writer.println();
                writer.println("PROFILER METRICS");
                writer.println("───────────────────────────────────────────────────────");

                for (ProfilingPoint point : ProfilingPoint.values()) {
                    var data = profiler.getTimingData(point);
                    if (data != null && data.getCallCount() > 0) {
                        writer.printf("  %-15s | calls: %,8d | avg: %6.2f ms | max: %6.2f ms%n",
                                point.getDisplayName(),
                                data.getCallCount(),
                                data.getAverageMicros() / 1000.0,
                                data.getMaxMicros() / 1000.0);
                    }
                }

                writer.println();
                writer.println("CONFIGURATION");
                writer.println("───────────────────────────────────────────────────────");
                writer.println("  Spike Threshold: " + profiler.getSpikeLog().getThresholdMs() + " ms");
                writer.println("  Lua Profiling:   " + profiler.isLuaProfilingEnabled());
                writer.println();
                writer.println("═══════════════════════════════════════════════════════");
            }

            System.out.println("[Echo] Test result saved: " + file.getAbsolutePath());
        } catch (Exception e) {
            System.err.println("[Echo] Failed to save test result: " + e.getMessage());
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\config\EchoConfig.java =====

package com.echo.config;

import com.echo.EchoConstants;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Echo 설정 관리
 * 
 * JSON 기반 설정 파일 로드/저장
 */
public class EchoConfig {

    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    // 사용자 홈 디렉토리 기반 설정 경로 (권한 문제 방지)
    private static final String CONFIG_DIR = System.getProperty("user.home") + "/Zomboid/Echo";
    private static final String CONFIG_FILE = "echo.json";

    private static EchoConfig instance;

    // --- Config Fields ---

    /** 설정 버전 (마이그레이션용) */
    private int configVersion = 1;

    /** 스파이크 임계값 (ms) */
    private double spikeThresholdMs = EchoConstants.DEFAULT_SPIKE_THRESHOLD_MS;

    /** 핵심 프로파일링 활성화 (기본 ON) */
    private boolean coreProfilingEnabled = true;

    /** 심층 분석 활성화 (SubTiming, Fuse, TickPhase 등) */
    private boolean deepAnalysisEnabled = true; // 기본 활성화 (tick_phase, heavy_functions 등)

    /** Lua 프로파일링 활성화 (기본 ON) */
    private boolean luaProfilingEnabled = true;

    /** Lua Sampling Profiler 활성화 (sethook) */
    private boolean luaSamplingEnabled = false;

    /** Pathfinding 상세 분석 (LOS 등) */
    private boolean enablePathfindingDetails = false;

    /** Zombie 상세 분석 (Behavior/Motion 분리) */
    private boolean enableZombieDetails = false;

    /** IsoGrid 상세 분석 (Lighting/Recalc) */
    private boolean enableIsoGridDetails = false;

    // --- Other Settings ---

    /** 게임 시작 시 자동으로 프로파일링 시작 */
    private boolean autoStartProfiling = true;

    /** 리포트 자동 저장 */
    private boolean autoSaveReports = true;

    /** 리포트 저장 경로 */
    private String reportDirectory = EchoConstants.DEFAULT_REPORT_DIR;

    /** 스택 캡처 활성화 (디버그용) */
    private boolean stackCaptureEnabled = false;

    /** 디버그 모드 */
    private boolean debugMode = false;

    /** Top N 함수 표시 수 */
    private int topNFunctions = EchoConstants.DEFAULT_TOP_N;

    // --- Zero-Risk Engine (v0.9.0) ---

    /**
     * Fallback tick 허용 (디버그 전용, 기본 OFF)
     * 
     * @see com.pulse.api.TickContract
     */
    private boolean allowFallbackTicks = true;

    /**
     * Fallback tick 간격 (ms)
     * 기준: TickContract.DEFAULT_FALLBACK_INTERVAL_MS (200ms)
     * 
     * @see com.pulse.api.TickContract#DEFAULT_FALLBACK_INTERVAL_MS
     */
    private long fallbackTickIntervalMs = 200;

    /** 저장 최소 품질 임계값 (기본 0 = 모두 저장) */
    private int minQualityToSave = 0;

    /** Baseline 품질 임계값 (기본 30, 이상이면 baseline 폴더에 저장) */
    private int baselineQualityThreshold = 30;

    /** 사용자가 명시적으로 Lua OFF를 지정했는지 */
    private boolean userExplicitLuaOff = false;

    /** fallback tick이 사용되었는지 (런타임 상태) */
    private transient boolean usedFallbackTicks = false;

    // --- Singleton ---

    public EchoConfig() {
    }

    public static EchoConfig getInstance() {
        // 1. Try ServiceLocator (Hybrid DI)
        try {
            com.pulse.di.PulseServiceLocator locator = com.pulse.di.PulseServiceLocator.getInstance();
            EchoConfig service = locator.getService(EchoConfig.class);
            if (service != null) {
                return service;
            }
        } catch (NoClassDefFoundError | Exception ignored) {
            // Pulse might not be fully loaded or in standalone test mode
        }

        // 2. Fallback to Singleton
        if (instance == null) {
            instance = new EchoConfig();
            instance.load();

            // Register to ServiceLocator if available
            try {
                com.pulse.di.PulseServiceLocator.getInstance().registerService(EchoConfig.class, instance);
            } catch (NoClassDefFoundError | Exception ignored) {
                // Ignore
            }
        }
        return instance;
    }

    // --- Load/Save ---

    /**
     * 설정 파일 로드
     */
    public void load() {
        Path configPath = Paths.get(CONFIG_DIR, CONFIG_FILE);

        if (!Files.exists(configPath)) {
            System.out.println("[Echo] Config file not found, using defaults");
            save(); // 기본값으로 생성
            return;
        }

        try (Reader reader = new FileReader(configPath.toFile())) {
            EchoConfig loaded = GSON.fromJson(reader, EchoConfig.class);
            if (loaded != null) {
                // Config Version Check
                if (loaded.configVersion < this.configVersion) {
                    System.out.println("[Echo] Config version mismatch (Found: " + loaded.configVersion + ", Current: "
                            + this.configVersion + "). Migrating defaults where necessary.");
                    // 마이그레이션 로직이 필요하면 여기에 추가
                }

                // Migrate if needed
                this.spikeThresholdMs = loaded.spikeThresholdMs;
                this.coreProfilingEnabled = loaded.coreProfilingEnabled;
                this.deepAnalysisEnabled = loaded.deepAnalysisEnabled;
                this.luaProfilingEnabled = loaded.luaProfilingEnabled;
                this.luaSamplingEnabled = loaded.luaSamplingEnabled;
                this.enablePathfindingDetails = loaded.enablePathfindingDetails;
                this.enableZombieDetails = loaded.enableZombieDetails;
                this.enableIsoGridDetails = loaded.enableIsoGridDetails;

                this.autoStartProfiling = loaded.autoStartProfiling;
                this.autoSaveReports = loaded.autoSaveReports;
                this.reportDirectory = loaded.reportDirectory;
                this.stackCaptureEnabled = loaded.stackCaptureEnabled;
                this.debugMode = loaded.debugMode;
                this.topNFunctions = loaded.topNFunctions;
            }
            System.out.println("[Echo] Config loaded from: " + configPath);
        } catch (Exception e) {
            System.err.println("[Echo] Failed to load config: " + e.getMessage());
        }
    }

    /**
     * 설정 파일 저장
     */
    public void save() {
        Path configDir = Paths.get(CONFIG_DIR);
        Path configPath = configDir.resolve(CONFIG_FILE);

        try {
            if (!Files.exists(configDir)) {
                Files.createDirectories(configDir);
            }

            try (Writer writer = new FileWriter(configPath.toFile())) {
                GSON.toJson(this, writer);
            }
            System.out.println("[Echo] Config saved to: " + configPath);
        } catch (Exception e) {
            System.err.println("[Echo] Failed to save config: " + e.getMessage());
        }
    }

    /**
     * 설정 리셋
     */
    public void reset() {
        this.spikeThresholdMs = EchoConstants.DEFAULT_SPIKE_THRESHOLD_MS;
        this.coreProfilingEnabled = true;
        this.deepAnalysisEnabled = true; // 기본 활성화
        this.luaProfilingEnabled = false;
        this.luaSamplingEnabled = false;
        this.enablePathfindingDetails = false;
        this.enableZombieDetails = false;
        this.enableIsoGridDetails = false;

        this.autoStartProfiling = true;
        this.autoSaveReports = true;
        this.reportDirectory = EchoConstants.DEFAULT_REPORT_DIR;
        this.stackCaptureEnabled = false;
        this.debugMode = false;
        this.topNFunctions = EchoConstants.DEFAULT_TOP_N;
        this.allowFallbackTicks = true;
        this.minQualityToSave = 0;
        this.userExplicitLuaOff = false;
        save();
        System.out.println("[Echo] Config reset to defaults");
    }

    /**
     * 설정 검증 및 자동 수정 (Echo 0.9.0 Zero-Risk)
     * enable() 전에 호출하여 잘못된 설정 자동 보정
     * 
     * @return 수정된 항목 수
     */
    public int sanitize() {
        int fixCount = 0;
        StringBuilder log = new StringBuilder();

        // 1. spikeThresholdMs < 0 → 기본값
        if (spikeThresholdMs < 0) {
            spikeThresholdMs = EchoConstants.DEFAULT_SPIKE_THRESHOLD_MS;
            log.append("  - spikeThresholdMs was negative → set to ").append(spikeThresholdMs).append("ms\n");
            fixCount++;
        }

        // 2. deepAnalysisEnabled=true인데 모든 detail 옵션이 false → Wave 1 자동 활성화
        if (deepAnalysisEnabled && !enablePathfindingDetails && !enableZombieDetails && !enableIsoGridDetails) {
            // Wave 1 기본 옵션을 켜줌 (최소한의 deep analysis)
            log.append("  - DeepAnalysis ON but all detail options OFF → enabling basic Wave 1\n");
            // Wave 1은 SubProfiler의 기본 라벨들로 deepAnalysisEnabled만 있으면 동작함
            // 추가 조치 없음 (Wave 1은 deepAnalysisEnabled가 true면 자동 활성화)
            fixCount++;
        }

        // 3. topNFunctions가 너무 작거나 큰 경우
        if (topNFunctions < 1) {
            topNFunctions = 1;
            log.append("  - topNFunctions was < 1 → set to 1\n");
            fixCount++;
        } else if (topNFunctions > 100) {
            topNFunctions = 100;
            log.append("  - topNFunctions was > 100 → set to 100\n");
            fixCount++;
        }

        // 4. minQualityToSave 범위 체크
        if (minQualityToSave < 0) {
            minQualityToSave = 0;
            log.append("  - minQualityToSave was < 0 → set to 0\n");
            fixCount++;
        } else if (minQualityToSave > 100) {
            minQualityToSave = 100;
            log.append("  - minQualityToSave was > 100 → set to 100\n");
            fixCount++;
        }

        if (fixCount > 0) {
            System.out.println("[Echo] Config.sanitize() auto-fixed " + fixCount + " issue(s):");
            System.out.print(log);
            save();
        }

        return fixCount;
    }

    // --- Getters/Setters ---

    public int getConfigVersion() {
        return configVersion;
    }

    public double getSpikeThresholdMs() {
        return spikeThresholdMs;
    }

    public void setSpikeThresholdMs(double spikeThresholdMs) {
        this.spikeThresholdMs = spikeThresholdMs;
    }

    public boolean isCoreProfilingEnabled() {
        return coreProfilingEnabled;
    }

    public void setCoreProfilingEnabled(boolean enabled) {
        this.coreProfilingEnabled = enabled;
    }

    public boolean isDeepAnalysisEnabled() {
        return deepAnalysisEnabled;
    }

    public void setDeepAnalysisEnabled(boolean enabled) {
        this.deepAnalysisEnabled = enabled;
    }

    public boolean isLuaProfilingEnabled() {
        return luaProfilingEnabled;
    }

    public void setLuaProfilingEnabled(boolean enabled) {
        this.luaProfilingEnabled = enabled;
    }

    public boolean isLuaSamplingEnabled() {
        return luaSamplingEnabled;
    }

    public void setLuaSamplingEnabled(boolean enabled) {
        this.luaSamplingEnabled = enabled;
    }

    public boolean isEnablePathfindingDetails() {
        return enablePathfindingDetails;
    }

    public void setEnablePathfindingDetails(boolean enablePathfindingDetails) {
        this.enablePathfindingDetails = enablePathfindingDetails;
    }

    public boolean isEnableZombieDetails() {
        return enableZombieDetails;
    }

    public void setEnableZombieDetails(boolean enableZombieDetails) {
        this.enableZombieDetails = enableZombieDetails;
    }

    public boolean isEnableIsoGridDetails() {
        return enableIsoGridDetails;
    }

    public void setEnableIsoGridDetails(boolean enableIsoGridDetails) {
        this.enableIsoGridDetails = enableIsoGridDetails;
    }

    public boolean isAutoStartProfiling() {
        return autoStartProfiling;
    }

    public void setAutoStartProfiling(boolean autoStartProfiling) {
        this.autoStartProfiling = autoStartProfiling;
    }

    public boolean isAutoSaveReports() {
        return autoSaveReports;
    }

    public void setAutoSaveReports(boolean autoSaveReports) {
        this.autoSaveReports = autoSaveReports;
    }

    public String getReportDirectory() {
        return reportDirectory;
    }

    public void setReportDirectory(String reportDirectory) {
        this.reportDirectory = reportDirectory;
    }

    public boolean isStackCaptureEnabled() {
        return stackCaptureEnabled;
    }

    public void setStackCaptureEnabled(boolean stackCaptureEnabled) {
        this.stackCaptureEnabled = stackCaptureEnabled;
    }

    public boolean isDebugMode() {
        return debugMode;
    }

    public void setDebugMode(boolean debugMode) {
        this.debugMode = debugMode;
    }

    public int getTopNFunctions() {
        return topNFunctions;
    }

    public void setTopNFunctions(int topNFunctions) {
        this.topNFunctions = topNFunctions;
    }

    // --- Zero-Risk Engine Getters/Setters ---

    public boolean isAllowFallbackTicks() {
        return allowFallbackTicks;
    }

    public void setAllowFallbackTicks(boolean allowFallbackTicks) {
        this.allowFallbackTicks = allowFallbackTicks;
    }

    public int getMinQualityToSave() {
        return minQualityToSave;
    }

    public void setMinQualityToSave(int minQualityToSave) {
        this.minQualityToSave = minQualityToSave;
    }

    public int getBaselineQualityThreshold() {
        return baselineQualityThreshold;
    }

    public void setBaselineQualityThreshold(int threshold) {
        this.baselineQualityThreshold = Math.max(0, Math.min(100, threshold));
    }

    public boolean isUserExplicitLuaOff() {
        return userExplicitLuaOff;
    }

    public void setUserExplicitLuaOff(boolean userExplicitLuaOff) {
        this.userExplicitLuaOff = userExplicitLuaOff;
    }

    public boolean isUsedFallbackTicks() {
        return usedFallbackTicks;
    }

    public void setUsedFallbackTicks(boolean usedFallbackTicks) {
        this.usedFallbackTicks = usedFallbackTicks;
    }

    public long getFallbackTickIntervalMs() {
        return fallbackTickIntervalMs;
    }

    public void setFallbackTickIntervalMs(long fallbackTickIntervalMs) {
        this.fallbackTickIntervalMs = Math.max(50, Math.min(1000, fallbackTickIntervalMs)); // 50-1000ms range
    }

    /**
     * 콘솔 출력
     */
    public void printConfig() {
        System.out.println("\n[Echo] Current Configuration (v" + configVersion + "):");
        System.out.println("───────────────────────────────────────────────────────");
        System.out.printf("  spike.threshold     = %.2f ms%n", spikeThresholdMs);
        System.out.printf("  core.profiling      = %s%n", coreProfilingEnabled);
        System.out.printf("  deep.analysis       = %s%n", deepAnalysisEnabled);
        System.out.printf("  lua.profiling       = %s%n", luaProfilingEnabled);
        System.out.printf("    - pathfinding     = %s%n", enablePathfindingDetails);
        System.out.printf("    - zombie          = %s%n", enableZombieDetails);
        System.out.printf("    - isogrid         = %s%n", enableIsoGridDetails);
        System.out.printf("  auto.start          = %s%n", autoStartProfiling);
        System.out.printf("  report.auto_save    = %s%n", autoSaveReports);
        System.out.printf("  report.directory    = %s%n", reportDirectory);
        System.out.printf("  stack.capture       = %s%n", stackCaptureEnabled);
        System.out.printf("  debug.mode          = %s%n", debugMode);
        System.out.printf("  top_n               = %d%n", topNFunctions);
        System.out.println("  --- Zero-Risk Engine (v0.9.0) ---");
        System.out.printf("  fallback.ticks      = %s%n", allowFallbackTicks);
        System.out.printf("  min.quality.save    = %d%n", minQualityToSave);
        System.out.println();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\debug\DebugOverlayData.java =====

package com.echo.debug;

import com.echo.aggregate.TickHistogram;
import com.echo.config.EchoConfig;
import com.echo.measure.EchoProfiler;
import com.echo.measure.TickPhaseProfiler;
import com.echo.measure.TickPhaseProfiler.TickPhase;
import com.echo.validation.PulseContractVerifier;

import java.util.*;

/**
 * 통합 DebugOverlay 데이터 제공자
 * 
 * Fuse/Nerve에서 사용할 수 있는 디버그 정보를 수집하고 제공합니다.
 * 실제 UI 렌더링은 Fuse/Nerve에서 담당하고, 이 클래스는 데이터만 제공합니다.
 * 
 * @since Echo 0.9 (Phase 4 DX)
 */
public final class DebugOverlayData {

    private static final DebugOverlayData INSTANCE = new DebugOverlayData();

    private DebugOverlayData() {
    }

    public static DebugOverlayData getInstance() {
        return INSTANCE;
    }

    // --- Pulse 틱 상태 ---

    /**
     * Pulse 계약 상태 반환
     */
    public String getPulseContractStatus() {
        return PulseContractVerifier.getInstance().getStatusForDisplay();
    }

    /**
     * 총 위반 횟수
     */
    public long getViolationCount() {
        return PulseContractVerifier.getInstance().getTotalViolationCount();
    }

    /**
     * 마지막 위반 메시지
     */
    public String getLastViolation() {
        String msg = PulseContractVerifier.getInstance().getLastViolation();
        return msg != null ? msg : "";
    }

    // --- 페이즈 CPU 사용량 상위 3개 ---

    /**
     * CPU 사용량 상위 3개 페이즈 반환
     * 
     * @return [{phase: "World Update", percent: 45.2}, ...]
     */
    public List<Map<String, Object>> getTopPhases() {
        List<Map<String, Object>> result = new ArrayList<>();

        TickPhaseProfiler profiler = TickPhaseProfiler.getInstance();
        Map<TickPhase, Double> percentages = profiler.getPhasePercentages();

        // 비율 기준으로 정렬
        List<Map.Entry<TickPhase, Double>> sorted = new ArrayList<>(percentages.entrySet());
        sorted.sort((a, b) -> Double.compare(b.getValue(), a.getValue()));

        // 상위 3개
        int count = 0;
        for (Map.Entry<TickPhase, Double> entry : sorted) {
            if (count >= 3)
                break;
            if (entry.getValue() <= 0)
                continue;

            Map<String, Object> item = new LinkedHashMap<>();
            item.put("phase", entry.getKey().getDisplayName());
            item.put("percent", Math.round(entry.getValue() * 10) / 10.0);
            item.put("color", entry.getKey().getColor());
            result.add(item);
            count++;
        }

        return result;
    }

    // --- Echo 품질 점수 ---

    /**
     * Echo Histogram 품질 점수 (0-100)
     */
    public int getQualityScore() {
        TickHistogram histogram = EchoProfiler.getInstance().getTickHistogram();
        return histogram != null ? histogram.getQualityScore() : 0;
    }

    /**
     * 품질 등급 반환
     */
    public String getQualityGrade() {
        int score = getQualityScore();
        if (score >= 90)
            return "A";
        if (score >= 80)
            return "B";
        if (score >= 70)
            return "C";
        if (score >= 60)
            return "D";
        return "F";
    }

    /**
     * P50/P95/P99 반환
     */
    public Map<String, Double> getPercentiles() {
        Map<String, Double> result = new LinkedHashMap<>();
        TickHistogram histogram = EchoProfiler.getInstance().getTickHistogram();

        if (histogram != null) {
            result.put("p50", Math.round(histogram.getP50() * 100) / 100.0);
            result.put("p95", Math.round(histogram.getP95() * 100) / 100.0);
            result.put("p99", Math.round(histogram.getP99() * 100) / 100.0);
        }

        return result;
    }

    // --- FallbackTickEmitter 상태 ---

    /**
     * FallbackTickEmitter 사용 여부
     */
    public boolean isFallbackTickActive() {
        return EchoConfig.getInstance().isUsedFallbackTicks();
    }

    /**
     * FallbackTick 간격 (ms)
     */
    public long getFallbackTickIntervalMs() {
        return EchoConfig.getInstance().getFallbackTickIntervalMs();
    }

    // --- 통합 요약 ---

    /**
     * Fuse/Nerve 디버그 화면에 표시할 전체 상태 Map
     */
    public Map<String, Object> getSummary() {
        Map<String, Object> summary = new LinkedHashMap<>();

        // Pulse Contract
        summary.put("pulse_status", getPulseContractStatus());
        summary.put("violations", getViolationCount());

        // Echo Quality
        summary.put("quality_score", getQualityScore());
        summary.put("quality_grade", getQualityGrade());
        summary.put("percentiles", getPercentiles());

        // Top Phases
        summary.put("top_phases", getTopPhases());

        // Fallback
        summary.put("fallback_active", isFallbackTickActive());
        if (isFallbackTickActive()) {
            summary.put("fallback_interval_ms", getFallbackTickIntervalMs());
        }

        return summary;
    }

    /**
     * 콘솔 출력용 한 줄 요약
     */
    public String getOneLiner() {
        return String.format("Pulse:%s | Quality:%s(%d) | Top:%s | Fallback:%s",
                getPulseContractStatus(),
                getQualityGrade(),
                getQualityScore(),
                getTopPhases().isEmpty() ? "N/A" : getTopPhases().get(0).get("phase"),
                isFallbackTickActive() ? "ON" : "OFF");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\EchoConstants.java =====

package com.echo;

/**
 * Echo Profiler 전역 상수
 * 
 * @since 0.8.0
 * @since 0.9.0 - Validation, Session, FreezeDetector 상수 추가
 */
public final class EchoConstants {

    private EchoConstants() {
    }

    // ═══════════════════════════════════════════════════════════════
    // Version
    // ═══════════════════════════════════════════════════════════════

    /** 현재 Echo 버전 */
    public static final String VERSION = "0.9.0";

    // ═══════════════════════════════════════════════════════════════
    // Spike Detection
    // ═══════════════════════════════════════════════════════════════

    /** 기본 스파이크 임계값 (ms) - 30fps 기준 2프레임 */
    public static final double DEFAULT_SPIKE_THRESHOLD_MS = 33.33;

    /** 스파이크 로그 최대 엔트리 수 */
    public static final int SPIKE_LOG_MAX_ENTRIES = 100;

    /** 스파이크 스택 캡처 최대 깊이 */
    public static final int SPIKE_MAX_STACK_DEPTH = 10;

    // ═══════════════════════════════════════════════════════════════
    // Histogram
    // ═══════════════════════════════════════════════════════════════

    /** 히스토그램 최근 샘플 버퍼 크기 */
    public static final int HISTOGRAM_SAMPLE_BUFFER = 1000;

    /** 기본 히스토그램 버킷 경계 (ms) */
    public static final double[] DEFAULT_HISTOGRAM_BUCKETS = {
            0, 5, 10, 16.67, 20, 33.33, 50, 100, 200
    };

    // ═══════════════════════════════════════════════════════════════
    // Rolling Stats
    // ═══════════════════════════════════════════════════════════════

    /** 초당 예상 샘플 수 (60 FPS 기준) */
    public static final int SAMPLES_PER_SECOND = 60;

    /** 1초 윈도우 샘플 수 */
    public static final int ROLLING_WINDOW_1S = SAMPLES_PER_SECOND;

    /** 5초 윈도우 샘플 수 */
    public static final int ROLLING_WINDOW_5S = SAMPLES_PER_SECOND * 5;

    /** 60초 윈도우 샘플 수 */
    public static final int ROLLING_WINDOW_60S = SAMPLES_PER_SECOND * 60;

    // ═══════════════════════════════════════════════════════════════
    // Object Pool
    // ═══════════════════════════════════════════════════════════════

    /** ProfilingScope 풀 크기 */
    public static final int SCOPE_POOL_SIZE = 16;

    // ═══════════════════════════════════════════════════════════════
    // Report
    // ═══════════════════════════════════════════════════════════════

    /** 기본 Top N 함수 표시 수 */
    public static final int DEFAULT_TOP_N = 10;

    /** 기본 리포트 저장 경로 */
    public static final String DEFAULT_REPORT_DIR = System.getProperty("user.home") + "/Zomboid/echo_reports";

    /** 기본 테스트 결과 저장 경로 */
    public static final String DEFAULT_TEST_DIR = "./echo_tests";

    // ═══════════════════════════════════════════════════════════════
    // Validation (Self-Validation)
    // ═══════════════════════════════════════════════════════════════

    /** 자가검증 지연 시간 (ms) */
    public static final long VALIDATION_DELAY_MS = 10_000;

    /** 워밍업 기간 (ms) */
    public static final long WARMUP_DURATION_MS = 5_000;

    /** Fallback 활성화 대기 시간 (ms) */
    public static final long FALLBACK_ACTIVATION_DELAY_MS = 3_000;

    /** Fallback 재시도 최대 횟수 */
    public static final int FALLBACK_MAX_RETRIES = 3;

    // ═══════════════════════════════════════════════════════════════
    // Session Management
    // ═══════════════════════════════════════════════════════════════

    /** 세션 dirty 판정 최소 틱 수 */
    public static final int MIN_TICKS_FOR_DIRTY = 600;

    /** 메뉴 렌더 세션 종료 프레임 수 */
    public static final int MENU_RENDER_THRESHOLD = 10;

    /** 메뉴 이탈 감지 틱 수 */
    public static final int MENU_EXIT_THRESHOLD = 60;

    // ═══════════════════════════════════════════════════════════════
    // Freeze Detector
    // ═══════════════════════════════════════════════════════════════

    /** 프리즈 감지 임계값 (ms) */
    public static final long FREEZE_THRESHOLD_MS = 500;

    /** Watchdog 체크 주기 (ms) */
    public static final long WATCHDOG_CHECK_INTERVAL_MS = 100;

    /** 프리즈 히스토리 최대 항목 수 */
    public static final int MAX_FREEZE_HISTORY = 10;

    // ═══════════════════════════════════════════════════════════════
    // Timeout & Cache
    // ═══════════════════════════════════════════════════════════════

    /** Lua 통계 캐시 TTL (ms) */
    public static final long LUA_CACHE_TTL_MS = 1000;

    /** 최근 샘플 버퍼 크기 */
    public static final int RECENT_SAMPLES_SIZE = 100;

    // ═══════════════════════════════════════════════════════════════
    // UI Constants
    // ═══════════════════════════════════════════════════════════════

    /** HotspotPanel 업데이트 간격 (ms) */
    public static final long UI_UPDATE_INTERVAL_MS = 1000;

    /** HotspotPanel 폭 */
    public static final int HOTSPOT_PANEL_WIDTH = 280;

    /** HotspotPanel 레이어 우선순위 */
    public static final int HOTSPOT_PANEL_LAYER_PRIORITY = 110;

    // ═══════════════════════════════════════════════════════════════
    // Log Tags (for PulseLogger)
    // ═══════════════════════════════════════════════════════════════

    /** Echo 기본 로그 태그 */
    public static final String LOG = "Echo";

    /** LuaHook 서브모듈 */
    public static final String LOG_LUA_HOOK = "Echo/LuaHook";

    /** FallbackTick 서브모듈 */
    public static final String LOG_FALLBACK_TICK = "Echo/FallbackTick";

    /** SubProfiler 브릿지 */
    public static final String LOG_SUB_PROFILER_BRIDGE = "Echo/SubProfilerBridge";

    /** DetailedWindow 서브모듈 */
    public static final String LOG_DETAILED_WINDOW = "Echo/DetailedWindow";

    /** LuaTracker 서브모듈 */
    public static final String LOG_LUA_TRACKER = "Echo/LuaTracker";

    /** TickPhase 서브모듈 */
    public static final String LOG_TICK_PHASE = "Echo/TickPhase";

    /** Mixin 관련 로그 */
    public static final String LOG_MIXIN = "Echo/Mixin";
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\EchoMod.java =====

package com.echo;

import com.echo.command.EchoCommands;
import com.echo.measure.EchoProfiler;
import com.echo.session.SessionManager;
import com.echo.pulse.PulseEventAdapter;
import com.echo.pulse.SubProfilerBridge;
import com.echo.pulse.PathfindingBridge;
import com.echo.pulse.ZombieBridge;
import com.echo.pulse.IsoGridBridge;
import com.echo.spi.EchoProfilerProvider;
import com.pulse.api.log.PulseLogger;
import com.pulse.mod.PulseMod;

/**
 * Echo Mod 진입점
 * 
 * Pulse 모드 로더에서 로드되는 메인 클래스
 */
public class EchoMod implements PulseMod {

    public static final String MOD_ID = "echo";
    public static final String MOD_NAME = "Echo Profiler";
    public static final String VERSION = EchoConstants.VERSION;

    private static boolean initialized = false;

    public EchoMod() {
        // PulseMod에서 인스턴스 관리
    }

    @Override
    public void onInitialize() {
        init();
    }

    @Override
    public void onUnload() {
        shutdown();
    }

    /** 모드 초기화 */
    public static void init() {
        if (initialized) {
            PulseLogger.debug("Echo", "Already initialized, skipping...");
            return;
        }

        // Phase 0: 서버 환경 감지
        if (isServerEnvironment()) {
            EchoRuntime.enableSilentMode("Server environment detected");
            return;
        }

        // Fail-soft wrapper
        try {
            initInternal();
            initialized = true;

            // v2.1: Shutdown hook - 비정상 종료 시에만 저장 (Alt+F4 등)
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                SessionManager manager = SessionManager.getInstance();
                manager.saveSync(); // 조건부 저장 (미저장 데이터가 있을 때만)
                manager.shutdownExecutor(); // Executor 정리
            }, "Echo-Shutdown-Hook"));

            PulseLogger.info("Echo", "Profiling is now active - session-based saving enabled");
        } catch (Exception e) {
            EchoRuntime.recordError("init", e);
            PulseLogger.error("Echo", "Initialization failed: " + e.getMessage(), e);
        }
    }

    /**
     * 서버 환경 감지
     * GameServer.bServer 또는 Pulse API로 확인
     */
    private static boolean isServerEnvironment() {
        try {
            // Pulse API 우선 체크
            Class<?> pulseSide = Class.forName("com.pulse.api.PulseSide");
            java.lang.reflect.Method isServer = pulseSide.getMethod("isServer");
            Object result = isServer.invoke(null);
            if (Boolean.TRUE.equals(result)) {
                return true;
            }
        } catch (ClassNotFoundException e) {
            // Pulse API unavailable
        } catch (Exception e) {
            PulseLogger.warn("Echo", "Warning: Failed to check Pulse API: " + e.getMessage());
        }

        try {
            // PZ GameServer.bServer 체크
            Class<?> gameServer = Class.forName("zombie.network.GameServer");
            java.lang.reflect.Field bServer = gameServer.getField("bServer");
            Object result = bServer.get(null);
            if (Boolean.TRUE.equals(result)) {
                return true;
            }
        } catch (ClassNotFoundException e) {
            // Dev environment
        } catch (Exception e) {
            PulseLogger.warn("Echo", "Warning: Failed to check GameServer: " + e.getMessage());
        }

        return false;
    }

    /** 내부 초기화 로직 */
    private static void initInternal() {
        System.out.println();
        System.out.println("╔═══════════════════════════════════════════════╗");
        System.out.println("║     Echo Profiler v" + VERSION + " Initialized         ║");
        System.out.println("║     \"Observe, Don't Patch\"                    ║");
        System.out.println("╚═══════════════════════════════════════════════╝");
        System.out.println();

        // Phase 0: Profiler 선 활성화 (다른 컴포넌트들이 상태를 체크하기 전에)
        com.echo.config.EchoConfig config = com.echo.config.EchoConfig.getInstance();
        com.echo.measure.EchoProfiler profiler = com.echo.measure.EchoProfiler.getInstance();

        profiler.enable();

        // Lua 프로파일링 설정 동기화 (EchoConfig → EchoProfiler)
        if (config.isLuaProfilingEnabled()) {
            profiler.enableLuaProfiling();
            PulseLogger.info("Echo", "✓ Lua Profiling PRE-ENABLED (from config)");
        }

        // 명령어 등록
        try {
            EchoCommands.register();
            PulseLogger.info("Echo", "✓ EchoCommands registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ EchoCommands.register() FAILED: " + t.getMessage(), t);
        }

        // Pulse 이벤트 어댑터 등록
        try {
            PulseEventAdapter.register();
            PulseLogger.info("Echo", "✓ PulseEventAdapter registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ PulseEventAdapter.register() FAILED: " + t.getMessage(), t);
        }

        // Echo 1.0: SubProfiler 브릿지 등록 (Pulse Mixin → Echo SubProfiler 연동)
        try {
            SubProfilerBridge.register();
            PulseLogger.info("Echo", "✓ SubProfilerBridge registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ SubProfilerBridge.register() FAILED: " + t.getMessage(), t);
        }

        // Echo 1.0: TickPhase 브릿지 등록 (Pulse Mixin → Echo TickPhaseProfiler 연동)
        try {
            com.echo.pulse.TickPhaseBridge.register();
            PulseLogger.info("Echo", "✓ TickPhaseBridge registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ TickPhaseBridge.register() FAILED: " + t.getMessage(), t);
        }

        // Echo 2.0: Lua Path Hit 프로브 등록 (30초 후 검증 로그)
        try {
            com.echo.lua.LuaPathHitBridge.register();
            PulseLogger.info("Echo", "✓ LuaPathHitBridge registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ LuaPathHitBridge.register() FAILED: " + t.getMessage(), t);
        }

        // Echo 1.0 Phase 4: Fuse Deep Analysis 브릿지 등록
        try {
            PathfindingBridge.register();
            PulseLogger.info("Echo", "✓ PathfindingBridge registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ PathfindingBridge.register() FAILED: " + t.getMessage(), t);
        }

        try {
            ZombieBridge.register();
            PulseLogger.info("Echo", "✓ ZombieBridge registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ ZombieBridge.register() FAILED: " + t.getMessage(), t);
        }

        try {
            IsoGridBridge.register();
            PulseLogger.info("Echo", "✓ IsoGridBridge registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ IsoGridBridge.register() FAILED: " + t.getMessage(), t);
        }

        // Echo 2.0: ProfilerBridge Sink 등록 (Fuse → Pulse → Echo 데이터 경로)
        try {
            com.echo.pulse.EchoProfilerSink.register();
            PulseLogger.info("Echo", "✓ EchoProfilerSink registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ EchoProfilerSink.register() FAILED: " + t.getMessage(), t);
        }

        // 키바인딩 등록
        try {
            com.echo.input.EchoKeyBindings.register();
            PulseLogger.info("Echo", "✓ EchoKeyBindings registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ EchoKeyBindings.register() FAILED: " + t.getMessage(), t);
        }

        // HUD 레이어 등록 (Pulse Native UI)
        try {
            com.echo.ui.EchoHUD.register();
            com.echo.ui.HotspotPanel.register();
            PulseLogger.info("Echo", "✓ EchoHUD, HotspotPanel registered");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ HUD registration FAILED: " + t.getMessage(), t);
        }

        // OptimizationPoint 동기화 (Pulse Registry에서 로드)
        try {
            com.echo.pulse.OptimizationPointSync.syncFromPulse();
            PulseLogger.info("Echo", "✓ OptimizationPointSync completed");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "✗ OptimizationPointSync FAILED: " + t.getMessage(), t);
        }

        // SPI 프로바이더 등록 (Pulse가 있을 때만)
        registerSpiProvider();

        // Phase 5: Service Registration using PulseServiceLocator
        registerServices();

        // 프로파일러 상태 최종 확인 (이미 Phase 0에서 활성화됨)
        System.out.println("╔═══════════════════════════════════════════════╗");
        System.out.println("║  [Echo] ✓ PROFILER ENABLED - Collecting Data  ║");
        System.out.println("╚═══════════════════════════════════════════════╝");

        // 활성화 확인 로그
        if (!profiler.isEnabled()) {
            PulseLogger.error("Echo", "CRITICAL ERROR: Profiler failed to enable!");
            PulseLogger.error("Echo", "Check for initialization errors above.");
        }
    }

    /**
     * Pulse SPI에 EchoProfilerProvider 등록
     */
    private static void registerSpiProvider() {
        try {
            // Pulse API 존재 확인
            Class<?> pulseClass = Class.forName("com.pulse.api.Pulse");
            java.lang.reflect.Method getRegistry = pulseClass.getMethod("getProviderRegistry");
            Object registry = getRegistry.invoke(null);

            if (registry != null) {
                java.lang.reflect.Method registerMethod = registry.getClass()
                        .getMethod("register", Class.forName("com.pulse.api.spi.IProvider"));
                registerMethod.invoke(registry, new EchoProfilerProvider());
                PulseLogger.info("Echo", "Registered as Pulse SPI provider");
            }
        } catch (ClassNotFoundException e) {
            PulseLogger.debug("Echo", "Running in standalone mode");
        } catch (Exception e) {
            PulseLogger.warn("Echo", "Warning: Failed to register SPI provider: " + e.getMessage());
        }
    }

    /**
     * Phase 5: Register Echo services to PulseServiceLocator
     */
    private static void registerServices() {
        try {
            com.pulse.di.PulseServiceLocator locator = com.pulse.di.PulseServiceLocator.getInstance();
            locator.registerService(com.pulse.api.service.echo.INetworkMetrics.class,
                    com.echo.measure.NetworkMetrics.getInstance());
            locator.registerService(com.pulse.api.service.echo.IRenderMetrics.class,
                    com.echo.measure.RenderMetrics.getInstance());
            locator.registerService(com.pulse.api.service.echo.IBottleneckDetector.class,
                    com.echo.analysis.BottleneckDetector.getInstance());
            PulseLogger.info("Echo", "Registered services to PulseServiceLocator");
        } catch (NoClassDefFoundError e) {
            PulseLogger.debug("Echo", "PulseServiceLocator not found");
        } catch (Exception e) {
            PulseLogger.error("Echo", "Failed to register services: " + e.getMessage());
        }
    }

    /** 모드 종료 */
    public static void shutdown() {
        if (!initialized) {
            return;
        }

        EchoProfiler profiler = EchoProfiler.getInstance();
        com.echo.config.EchoConfig config = com.echo.config.EchoConfig.getInstance();

        // 리포트 자동 저장
        if (config.isAutoSaveReports()) {
            try {
                com.echo.report.EchoReport report = new com.echo.report.EchoReport(profiler);
                String reportPath = report.saveWithTimestamp(config.getReportDirectory());

                report.printQualitySummary();

                PulseLogger.info("Echo", "Report saved: " + reportPath);
            } catch (Exception e) {
                PulseLogger.error("Echo", "Failed to save report: " + e.getMessage());
            }
        }

        // 프로파일러 비활성화
        if (profiler.isEnabled()) {
            profiler.disable();
        }

        initialized = false;
    }

    /** 리포트 강제 저장 (종료 없이) */
    public static void flush() {
        if (!initialized)
            return;

        try {
            EchoProfiler profiler = EchoProfiler.getInstance();
            com.echo.config.EchoConfig config = com.echo.config.EchoConfig.getInstance();

            String reportPath = new com.echo.report.EchoReport(profiler)
                    .saveWithTimestamp(config.getReportDirectory());
            PulseLogger.info("Echo", "Report flushed: " + reportPath);
        } catch (Exception e) {
            PulseLogger.error("Echo", "Failed to flush report: " + e.getMessage());
        }
    }

    public static boolean isInitialized() {
        return initialized;
    }

    public static String getVersion() {
        return VERSION;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\EchoRuntime.java =====

package com.echo;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * Echo 런타임 상태 관리
 * 
 * 모든 Echo 진입점에서 통일된 활성화 체크를 제공합니다.
 * Fail-soft: 에러가 많이 발생하면 자동으로 비활성화됩니다.
 */
public final class EchoRuntime {

    private static volatile boolean enabled = true;
    private static volatile boolean silentMode = false;
    private static final AtomicInteger errorCount = new AtomicInteger(0);
    private static volatile long errorWindowStart = System.currentTimeMillis();

    /** 에러 카운터 리셋 윈도우 (1분) */
    private static final long ERROR_WINDOW_MS = 60_000;
    /** 영구 비활성화 임계값 (1분 내 5회) */
    private static final int ERROR_THRESHOLD = 5;

    private EchoRuntime() {
        // Utility class
    }

    /**
     * Echo가 활성화되어 있는지 확인
     * 모든 Echo 진입점에서 이 메서드를 호출해야 합니다.
     * 
     * @return Echo 활성화 여부
     */
    public static boolean isEnabled() {
        return enabled && !silentMode;
    }

    /**
     * Echo가 Silent Mode인지 확인 (서버 환경)
     * 
     * @return Silent Mode 여부
     */
    public static boolean isSilentMode() {
        return silentMode;
    }

    /**
     * Echo 비활성화
     * 
     * @param reason 비활성화 사유
     */
    public static void disable(String reason) {
        if (enabled) {
            enabled = false;
            System.out.println("[Echo] Disabled: " + reason);
        }
    }

    /**
     * Silent Mode 설정 (서버 환경)
     * 
     * @param reason Silent Mode 사유
     */
    public static void enableSilentMode(String reason) {
        if (!silentMode) {
            silentMode = true;
            System.out.println("[Echo] Silent Mode: " + reason);
        }
    }

    /**
     * 에러 기록 및 임계값 초과 시 자동 비활성화
     * 
     * Fail-soft 래퍼에서 예외 발생 시 호출합니다.
     * 1분 내 5회 에러 발생 시 영구 비활성화됩니다.
     * 
     * @param context 에러 발생 컨텍스트 (예: "HUD", "TickHook")
     * @param e       발생한 예외 (null 가능)
     */
    public static void recordError(String context, Exception e) {
        long now = System.currentTimeMillis();

        // 윈도우 리셋
        if (now - errorWindowStart > ERROR_WINDOW_MS) {
            errorCount.set(0);
            errorWindowStart = now;
        }

        int count = errorCount.incrementAndGet();

        // 첫 번째 에러만 상세 로그
        if (count == 1 && e != null) {
            System.err.println("[Echo] Error in " + context + ": " + e.getMessage());
        }

        // 임계값 초과 시 비활성화
        if (count >= ERROR_THRESHOLD) {
            disable("Too many errors (" + count + "/" + ERROR_THRESHOLD + " in " + context + ")");
        }
    }

    /**
     * 런타임 상태 리셋 (테스트용)
     */
    public static void reset() {
        enabled = true;
        silentMode = false;
        errorCount.set(0);
        errorWindowStart = System.currentTimeMillis();
    }

    /**
     * 현재 에러 카운트 조회 (진단용)
     * 
     * @return 현재 윈도우 내 에러 수
     */
    public static int getErrorCount() {
        return errorCount.get();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\event\EchoEventListener.java =====

package com.echo.event;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.measure.ProfilingScope;

/**
 * Echo 이벤트 리스너
 * 
 * Pulse 이벤트 버스와 연동하여 자동으로 프로파일링 포인트를 측정합니다.
 * 
 * 지원 이벤트:
 * - OnTick (게임 틱)
 * - OnRenderTick (렌더링)
 * - OnZombiesUpdate (좀비 AI)
 */
public class EchoEventListener {

    private static final EchoProfiler profiler = EchoProfiler.getInstance();

    // 현재 활성 스코프 (수동 관리용)
    private static ProfilingScope currentTickScope = null;
    private static ProfilingScope currentRenderScope = null;

    /**
     * 게임 틱 시작
     * Pulse OnTick.Pre 이벤트에서 호출
     */
    public static void onTickStart() {
        if (!profiler.isEnabled())
            return;
        currentTickScope = profiler.scope(ProfilingPoint.TICK);
    }

    /**
     * 게임 틱 종료
     * Pulse OnTick.Post 이벤트에서 호출
     */
    public static void onTickEnd() {
        if (currentTickScope != null) {
            currentTickScope.close();
            currentTickScope = null;
        }
    }

    /**
     * 렌더링 시작
     */
    public static void onRenderStart() {
        if (!profiler.isEnabled())
            return;
        currentRenderScope = profiler.scope(ProfilingPoint.RENDER);
    }

    /**
     * 렌더링 종료
     */
    public static void onRenderEnd() {
        if (currentRenderScope != null) {
            currentRenderScope.close();
            currentRenderScope = null;
        }
    }

    /**
     * 좀비 AI 업데이트 래퍼
     * Callable 방식으로 기존 로직을 감싸서 측정
     */
    public static void profileZombieAI(Runnable zombieUpdate) {
        if (!profiler.isEnabled()) {
            zombieUpdate.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.ZOMBIE_AI)) {
            zombieUpdate.run();
        }
    }

    /**
     * 물리 엔진 업데이트 래퍼
     */
    public static void profilePhysics(Runnable physicsUpdate) {
        if (!profiler.isEnabled()) {
            physicsUpdate.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.PHYSICS)) {
            physicsUpdate.run();
        }
    }

    /**
     * 네트워크 처리 래퍼
     */
    public static void profileNetwork(Runnable networkUpdate) {
        if (!profiler.isEnabled()) {
            networkUpdate.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.NETWORK)) {
            networkUpdate.run();
        }
    }

    /**
     * 청크 I/O 래퍼
     */
    public static void profileChunkIO(Runnable chunkIO, String chunkInfo) {
        if (!profiler.isEnabled()) {
            chunkIO.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.CHUNK_IO, chunkInfo)) {
            chunkIO.run();
        }
    }

    /**
     * Lua 이벤트 래퍼 (On-Demand)
     */
    public static void profileLuaEvent(Runnable luaCallback, String eventName) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            luaCallback.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_EVENT, eventName)) {
            luaCallback.run();
        }
    }

    /**
     * Lua 함수 호출 래퍼 (On-Demand)
     */
    public static void profileLuaFunction(Runnable luaFunction, String functionName) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            luaFunction.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_FUNCTION, functionName)) {
            luaFunction.run();
        }
    }

    /**
     * 모드 틱 핸들러 래퍼
     */
    public static void profileModTick(Runnable modTick, String modId) {
        if (!profiler.isEnabled()) {
            modTick.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.MOD_TICK, modId)) {
            modTick.run();
        }
    }

    /**
     * 범용 프로파일링 래퍼
     */
    public static void profile(ProfilingPoint point, Runnable task) {
        if (!profiler.isEnabled()) {
            task.run();
            return;
        }

        try (var scope = profiler.scope(point)) {
            task.run();
        }
    }

    /**
     * 범용 프로파일링 래퍼 (라벨 포함)
     */
    public static void profile(ProfilingPoint point, String label, Runnable task) {
        if (!profiler.isEnabled()) {
            task.run();
            return;
        }

        try (var scope = profiler.scope(point, label)) {
            task.run();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\event\ProfilerResetEvent.java =====

package com.echo.event;

import com.pulse.event.Event;

/**
 * EchoProfiler 리셋 이벤트.
 * 프로파일러가 리셋될 때 발행됩니다.
 * 
 * <p>
 * 이 이벤트를 통해 다른 컴포넌트들이 프로파일러 리셋에 반응할 수 있습니다.
 * </p>
 * 
 * @since 1.1.0
 */
public class ProfilerResetEvent extends Event {

    private final long timestamp;
    private final String reason;
    private final boolean fullReset;

    /**
     * 리셋 이벤트 생성.
     * 
     * @param reason    리셋 사유
     * @param fullReset 전체 리셋 여부
     */
    public ProfilerResetEvent(String reason, boolean fullReset) {
        this.timestamp = System.currentTimeMillis();
        this.reason = reason;
        this.fullReset = fullReset;
    }

    /**
     * 기본 리셋 이벤트 (일반 리셋).
     */
    public ProfilerResetEvent() {
        this("manual", false);
    }

    public long getTimestamp() {
        return timestamp;
    }

    public String getReason() {
        return reason;
    }

    public boolean isFullReset() {
        return fullReset;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\fuse\IsoGridProfiler.java =====

package com.echo.fuse;

import com.echo.config.EchoConfig;
import java.util.EnumMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;

/**
 * IsoGrid Profiler for Fuse Deep Analysis.
 * Tracks detailed timing for IsoGrid updates (Map rendering/update logic).
 * 
 * @since Echo 1.0 Phase 4
 */
public class IsoGridProfiler {

    private static final IsoGridProfiler INSTANCE = new IsoGridProfiler();

    public enum GridStep {
        FLOOR_UPDATE,
        LIGHTING_UPDATE,
        GENERATOR_UPDATE,
        WEATHER_IMPACT,
        ROOM_UPDATE
    }

    private final Map<GridStep, LongAdder> stepTimes = new EnumMap<>(GridStep.class);
    private final Map<GridStep, LongAdder> stepCounts = new EnumMap<>(GridStep.class);

    private IsoGridProfiler() {
        for (GridStep step : GridStep.values()) {
            stepTimes.put(step, new LongAdder());
            stepCounts.put(step, new LongAdder());
        }
    }

    public static IsoGridProfiler getInstance() {
        return INSTANCE;
    }

    public void recordStep(GridStep step, long durationMicros) {
        if (!EchoConfig.getInstance().isDeepAnalysisEnabled())
            return;

        stepTimes.get(step).add(durationMicros);
        stepCounts.get(step).increment();
    }

    public void reset() {
        for (GridStep step : GridStep.values()) {
            stepTimes.get(step).reset();
            stepCounts.get(step).reset();
        }
    }

    public Map<String, Object> toMap() {
        Map<String, Object> map = new ConcurrentHashMap<>();

        Map<String, Object> steps = new ConcurrentHashMap<>();
        for (GridStep step : GridStep.values()) {
            Map<String, Object> stepData = new ConcurrentHashMap<>();
            long time = stepTimes.get(step).sum();
            long count = stepCounts.get(step).sum();

            stepData.put("total_ms", time / 1000.0);
            stepData.put("count", count);
            stepData.put("avg_ms", count == 0 ? 0 : (time / 1000.0) / count);

            steps.put(step.name(), stepData);
        }
        map.put("steps", steps);

        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\fuse\PathfindingProfiler.java =====

package com.echo.fuse;

import com.echo.config.EchoConfig;
import java.util.EnumMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;

/**
 * AI Pathfinding Profiler for Fuse Deep Analysis.
 * Tracks detailed timing for pathfinding operations.
 * 
 * @since Echo 1.0 Phase 4
 */
public class PathfindingProfiler {

    private static final PathfindingProfiler INSTANCE = new PathfindingProfiler();

    public enum PathfindingStep {
        LOS_CALCULATION,
        GRID_SEARCH,
        OBSTACLE_CHECK,
        DOOR_WINDOW_DETECTION,
        BEHAVIOR
    }

    private final Map<PathfindingStep, LongAdder> stepTimes = new EnumMap<>(PathfindingStep.class);
    private final Map<PathfindingStep, LongAdder> stepCounts = new EnumMap<>(PathfindingStep.class);
    private final LongAdder totalPathRequests = new LongAdder();

    private PathfindingProfiler() {
        for (PathfindingStep step : PathfindingStep.values()) {
            stepTimes.put(step, new LongAdder());
            stepCounts.put(step, new LongAdder());
        }
    }

    public static PathfindingProfiler getInstance() {
        return INSTANCE;
    }

    public void recordStep(PathfindingStep step, long durationMicros) {
        if (!EchoConfig.getInstance().isDeepAnalysisEnabled())
            return;

        stepTimes.get(step).add(durationMicros);
        stepCounts.get(step).increment();
    }

    public void incrementPathRequests() {
        if (!EchoConfig.getInstance().isDeepAnalysisEnabled())
            return;
        totalPathRequests.increment();
    }

    public void reset() {
        for (PathfindingStep step : PathfindingStep.values()) {
            stepTimes.get(step).reset();
            stepCounts.get(step).reset();
        }
        totalPathRequests.reset();
    }

    /**
     * 총 패스파인딩 요청 수
     */
    public long getTotalRequests() {
        return totalPathRequests.sum();
    }

    /**
     * 총 패스파인딩 시간 (밀리초)
     */
    public double getTotalTimeMs() {
        double total = 0;
        for (PathfindingStep step : PathfindingStep.values()) {
            total += stepTimes.get(step).sum() / 1000.0;
        }
        return total;
    }

    public Map<String, Object> toMap() {
        Map<String, Object> map = new ConcurrentHashMap<>();
        map.put("total_requests", totalPathRequests.sum());

        Map<String, Object> steps = new ConcurrentHashMap<>();
        for (PathfindingStep step : PathfindingStep.values()) {
            Map<String, Object> stepData = new ConcurrentHashMap<>();
            long time = stepTimes.get(step).sum();
            long count = stepCounts.get(step).sum();

            stepData.put("total_ms", time / 1000.0);
            stepData.put("count", count);
            stepData.put("avg_ms", count == 0 ? 0 : (time / 1000.0) / count);

            steps.put(step.name(), stepData);
        }
        map.put("steps", steps);

        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\fuse\ZombieProfiler.java =====

package com.echo.fuse;

import com.echo.config.EchoConfig;
import java.util.EnumMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;

/**
 * Zombie Profiler for Fuse Deep Analysis.
 * Tracks detailed timing for individual zombie update steps.
 * 
 * @since Echo 1.0 Phase 4
 */
public class ZombieProfiler {

    private static final ZombieProfiler INSTANCE = new ZombieProfiler();

    public enum ZombieStep {
        MOTION_UPDATE,
        SOUND_PERCEPTION,
        TARGET_TRACKING,
        COLLISION,
        BEHAVIOR_TICK,
        // Phase 1 추가: IsoZombie 분석 기반
        PLAYER_DETECTION, // spotted() 메서드
        PATH_RECALC, // pathToCharacter() 경로 재계산
        LOS_CHECK // 시야 확인 (Line of Sight)
    }

    private final Map<ZombieStep, LongAdder> stepTimes = new EnumMap<>(ZombieStep.class);
    private final Map<ZombieStep, LongAdder> stepCounts = new EnumMap<>(ZombieStep.class);
    private final LongAdder totalZombiesUpdated = new LongAdder(); // Total zombie update calls
    private final LongAdder tickZombiesUpdated = new LongAdder(); // Per-tick updates

    private ZombieProfiler() {
        for (ZombieStep step : ZombieStep.values()) {
            stepTimes.put(step, new LongAdder());
            stepCounts.put(step, new LongAdder());
        }
    }

    public static ZombieProfiler getInstance() {
        return INSTANCE;
    }

    public void recordStep(ZombieStep step, long durationMicros) {
        if (!EchoConfig.getInstance().isDeepAnalysisEnabled())
            return;

        stepTimes.get(step).add(durationMicros);
        stepCounts.get(step).increment();
    }

    public void incrementZombieUpdates() {
        if (!EchoConfig.getInstance().isDeepAnalysisEnabled())
            return;
        totalZombiesUpdated.increment();
        tickZombiesUpdated.increment();
    }

    public long getZombieCount() {
        return totalZombiesUpdated.sum();
    }

    public long getTickZombieCount() {
        return tickZombiesUpdated.sum();
    }

    public void endTick() {
        tickZombiesUpdated.reset();
    }

    public void reset() {
        for (ZombieStep step : ZombieStep.values()) {
            stepTimes.get(step).reset();
            stepCounts.get(step).reset();
        }
        totalZombiesUpdated.reset();
    }

    public Map<String, Object> toMap() {
        Map<String, Object> map = new ConcurrentHashMap<>();
        map.put("total_updates", totalZombiesUpdated.sum());

        Map<String, Object> steps = new ConcurrentHashMap<>();
        for (ZombieStep step : ZombieStep.values()) {
            Map<String, Object> stepData = new ConcurrentHashMap<>();
            long time = stepTimes.get(step).sum();
            long count = stepCounts.get(step).sum();

            stepData.put("total_ms", time / 1000.0);
            stepData.put("count", count);
            stepData.put("avg_ms", count == 0 ? 0 : (time / 1000.0) / count);

            steps.put(step.name(), stepData);
        }
        map.put("steps", steps);

        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\history\MetricCollector.java =====

package com.echo.history;

import com.echo.analysis.CorrelationAnalyzer;
import com.echo.fuse.ZombieProfiler;
import com.echo.pulse.RenderProfiler;
import com.echo.pulse.TickProfiler;

import java.util.HashMap;
import java.util.Map;

/**
 * Metric Collector
 * Collects and stores historical data for analysis.
 */
public class MetricCollector {
    private final Map<String, MetricHistory> histories = new HashMap<>();
    private static final int HISTORY_SIZE = 1000;

    public MetricCollector() {
        registerMetric("zombie_count");
        registerMetric("tick_time");
        registerMetric("fps");
    }

    public void registerMetric(String name) {
        histories.put(name, new MetricHistory(name, HISTORY_SIZE));
    }

    // Called at End of Tick
    public void collect(TickProfiler tickProfiler, RenderProfiler renderProfiler) {
        // Collect samples from profilers
        // Zombie Count (Per Tick)
        long zombieCount = ZombieProfiler.getInstance().getTickZombieCount();

        // Tick Duration (Last Tick)
        double tickTime = tickProfiler.getLastTickDurationMs();

        // FPS
        double fps = renderProfiler.getCurrentFps();

        addSample("zombie_count", (double) zombieCount);
        addSample("tick_time", tickTime);
        addSample("fps", fps);
    }

    public void addSample(String name, double value) {
        MetricHistory history = histories.get(name);
        if (history != null) {
            history.add(value);
        }
    }

    public MetricHistory getHistory(String name) {
        return histories.get(name);
    }

    public double getCorrelation(String metric1, String metric2) {
        MetricHistory h1 = getHistory(metric1);
        MetricHistory h2 = getHistory(metric2);
        return CorrelationAnalyzer.calculateCorrelation(h1, h2);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\history\MetricHistory.java =====

package com.echo.history;

import java.util.Arrays;

/**
 * 메트릭 시계열 데이터 저장소 (Ring Buffer)
 */
public class MetricHistory {
    private final double[] buffer;
    private int head = 0;
    private int size = 0;
    private final int capacity;
    private final String name;

    public MetricHistory(String name, int capacity) {
        this.name = name;
        this.capacity = capacity;
        this.buffer = new double[capacity];
    }

    public synchronized void add(double value) {
        buffer[head] = value;
        head = (head + 1) % capacity;
        if (size < capacity) {
            size++;
        }
    }

    public synchronized double[] toArray() {
        if (size < capacity) {
            return Arrays.copyOf(buffer, size);
        }

        double[] result = new double[capacity];
        // head is the index of the *next* write, so the oldest element is at head (if
        // full)
        // We want chronological order: oldest -> newest

        int current = head; // oldest element
        for (int i = 0; i < capacity; i++) {
            result[i] = buffer[current];
            current = (current + 1) % capacity;
        }
        return result;
    }

    public String getName() {
        return name;
    }

    public int getSize() {
        return size;
    }

    public int getCapacity() {
        return capacity;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\input\EchoKeyBindings.java =====

package com.echo.input;

import com.echo.EchoRuntime;
import com.echo.measure.EchoProfiler;
import com.echo.ui.EchoExtendedHUD;

/**
 * Echo 키바인딩 관리
 * 
 * F6: HUD 토글
 * F7: 프로파일링 On/Off
 * F8: HotspotPanel 토글
 * F9: Extended HUD 토글 (메모리/네트워크/병목)
 */
public final class EchoKeyBindings {

    // 키바인딩 상태
    private static boolean hudVisible = true;
    private static boolean panelVisible = false;

    // 키 코드 (PZ/LWJGL 키코드)
    public static final int KEY_F6 = 64; // 0x40 - HUD 토글
    public static final int KEY_F7 = 65; // 0x41 - 프로파일링 토글
    public static final int KEY_F8 = 66; // 0x42 - 패널 토글
    public static final int KEY_F9 = 67; // 0x43 - Extended HUD 토글

    private EchoKeyBindings() {
        // Utility class
    }

    /**
     * 키바인딩 등록
     * EchoMod.init()에서 호출됨
     */
    public static void register() {
        // Pulse KeyBindings API 시도
        if (tryPulseKeyBindings()) {
            System.out.println("[Echo] Key bindings registered via Pulse API");
            return;
        }

        // 폴백: 수동 키 체크 (render 루프에서 호출 필요)
        System.out.println("[Echo] Key bindings: F6=HUD, F7=Profile, F8=Panel, F9=Extended");
        System.out.println("[Echo] Note: Use PulseEventAdapter.checkKeys() in render loop");
    }

    /**
     * Pulse KeyBindings API로 등록 시도
     * 
     * @return 등록 성공 여부
     */
    private static boolean tryPulseKeyBindings() {
        try {
            Class<?> keyBindings = Class.forName("com.pulse.api.KeyBindings");

            // register(String name, int key, Runnable action)
            java.lang.reflect.Method registerMethod = keyBindings.getMethod(
                    "register", String.class, int.class, Runnable.class);

            registerMethod.invoke(null, "echo_hud", KEY_F6, (Runnable) EchoKeyBindings::toggleHud);
            registerMethod.invoke(null, "echo_profile", KEY_F7, (Runnable) EchoKeyBindings::toggleProfiling);
            registerMethod.invoke(null, "echo_panel", KEY_F8, (Runnable) EchoKeyBindings::togglePanel);
            registerMethod.invoke(null, "echo_extended", KEY_F9, (Runnable) EchoKeyBindings::toggleExtendedHud);

            return true;
        } catch (ClassNotFoundException e) {
            return false;
        } catch (Exception e) {
            System.out.println("[Echo] Warning: Failed to register key bindings: " + e.getMessage());
            return false;
        }
    }

    /**
     * 수동 키 체크 (Pulse API 없을 때 렌더 루프에서 호출)
     * 
     * @param keyCode 눌린 키 코드
     */
    public static void onKeyPressed(int keyCode) {
        if (!EchoRuntime.isEnabled())
            return;

        switch (keyCode) {
            case KEY_F6 -> toggleHud();
            case KEY_F7 -> toggleProfiling();
            case KEY_F8 -> togglePanel();
            case KEY_F9 -> toggleExtendedHud();
        }
    }

    /**
     * HUD 토글 (F6)
     */
    public static void toggleHud() {
        if (!EchoRuntime.isEnabled())
            return;
        hudVisible = !hudVisible;
        System.out.println("[Echo] HUD " + (hudVisible ? "ON" : "OFF"));
    }

    /**
     * 프로파일링 토글 (F7)
     */
    public static void toggleProfiling() {
        if (!EchoRuntime.isEnabled())
            return;
        EchoProfiler profiler = EchoProfiler.getInstance();
        if (profiler.isEnabled()) {
            profiler.disable();
            System.out.println("[Echo] Profiling OFF");
        } else {
            profiler.enable();
            System.out.println("[Echo] Profiling ON");
        }
    }

    /**
     * HotspotPanel 토글 (F8)
     */
    public static void togglePanel() {
        if (!EchoRuntime.isEnabled())
            return;
        panelVisible = !panelVisible;
        System.out.println("[Echo] Panel " + (panelVisible ? "ON" : "OFF"));
    }

    /**
     * Extended HUD 토글 (F9)
     */
    public static void toggleExtendedHud() {
        if (!EchoRuntime.isEnabled())
            return;
        EchoExtendedHUD.toggle();
    }

    // Getters
    public static boolean isHudVisible() {
        return hudVisible && EchoRuntime.isEnabled();
    }

    public static boolean isPanelVisible() {
        return panelVisible && EchoRuntime.isEnabled();
    }

    public static boolean isExtendedHudVisible() {
        return EchoExtendedHUD.isShown() && EchoRuntime.isEnabled();
    }

    // Setters (테스트/명령어용)
    public static void setHudVisible(boolean visible) {
        hudVisible = visible;
    }

    public static void setPanelVisible(boolean visible) {
        panelVisible = visible;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\CallStackTracker.java =====

package com.echo.lua;

import java.util.ArrayDeque;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Lua 호출 스택 관리.
 * 
 * <p>
 * LuaCallTracker에서 분리된 스택 전용 클래스입니다.
 * ThreadLocal 스택, 프레임 관리, 틱 경계 처리를 담당합니다.
 * </p>
 * 
 * <h3>핵심 원칙:</h3>
 * <ul>
 * <li>"tracked 프레임만 push" - 추적 조건 만족 시에만 스택에 push</li>
 * <li>빈 스택 = 정상 (Start가 추적 안 됨)</li>
 * </ul>
 * 
 * <h3>Thread Safety:</h3>
 * <ul>
 * <li>ThreadLocal로 스레드별 스택 격리</li>
 * <li>Game Thread에서만 쓰기, 동기화 불필요</li>
 * </ul>
 * 
 * @since Echo 0.9 - Extracted from LuaCallTracker
 */
public class CallStackTracker {

    // ═══════════════════════════════════════════════════════════════
    // Configuration
    // ═══════════════════════════════════════════════════════════════

    private static final int MAX_STACK_DEPTH = 128;
    private static final long FRAME_TTL_NANOS = 5_000_000_000L; // 5초

    // ═══════════════════════════════════════════════════════════════
    // ThreadLocal Stack
    // ═══════════════════════════════════════════════════════════════

    private final ThreadLocal<ArrayDeque<CallFrame>> callStack = ThreadLocal.withInitial(() -> new ArrayDeque<>(32));
    private final AtomicLong currentFrameId = new AtomicLong(0);

    // ═══════════════════════════════════════════════════════════════
    // CallFrame Structure
    // ═══════════════════════════════════════════════════════════════

    /**
     * 호출 프레임 정보.
     */
    public static class CallFrame {
        public final String funcName;
        public final String contextTag;
        public final long startNanos;
        public final long frameId;
        public long childTime = 0; // 하위 호출에 소요된 시간

        public CallFrame(String funcName, String contextTag, long startNanos, long frameId) {
            this.funcName = funcName;
            this.contextTag = contextTag;
            this.startNanos = startNanos;
            this.frameId = frameId;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Call Result DTO
    // ═══════════════════════════════════════════════════════════════

    /**
     * recordEnd 결과를 담는 DTO.
     */
    public static class CallResult {
        public final String funcName;
        public final String contextTag;
        public final long elapsedMicros;
        public final long selfMicros;

        public CallResult(String funcName, String contextTag, long elapsedMicros, long selfMicros) {
            this.funcName = funcName;
            this.contextTag = contextTag;
            this.elapsedMicros = elapsedMicros;
            this.selfMicros = selfMicros;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Core API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 호출 시작 시 스택에 push.
     * 
     * @param funcName   함수 이름
     * @param contextTag 컨텍스트 태그
     * @param startNanos 시작 시간 (nanos)
     * @return push 성공 여부 (스택 오버플로우 시 false)
     */
    public boolean recordStart(String funcName, String contextTag, long startNanos) {
        ArrayDeque<CallFrame> stack = callStack.get();

        // Fail-safe: 스택 깊이 초과 시 정리
        if (stack.size() >= MAX_STACK_DEPTH) {
            cleanupStaleFrames(stack, startNanos);
            if (stack.size() >= MAX_STACK_DEPTH) {
                return false; // 여전히 초과 시 push 실패
            }
        }

        stack.push(new CallFrame(funcName, contextTag, startNanos, currentFrameId.get()));
        return true;
    }

    /**
     * 호출 종료 시 스택에서 pop하고 결과 반환.
     * 
     * @param endNanos 종료 시간 (nanos)
     * @return 결과 (스택이 비어있으면 null - 정상 케이스)
     */
    public CallResult recordEnd(long endNanos) {
        ArrayDeque<CallFrame> stack = callStack.get();

        // 스택이 비어있다 = Start가 추적 안 됨 (정상 케이스)
        if (stack.isEmpty()) {
            return null;
        }

        CallFrame frame = stack.pop();
        long elapsed = endNanos - frame.startNanos;
        long elapsedMicros = elapsed / 1000;

        // Self time 계산 (하위 호출 시간 제외)
        long selfTime = elapsed - frame.childTime;
        long selfMicros = selfTime / 1000;

        // 상위 프레임에 child time 전파
        if (!stack.isEmpty()) {
            stack.peek().childTime += elapsed;
        }

        return new CallResult(frame.funcName, frame.contextTag, elapsedMicros, selfMicros);
    }

    /**
     * 오래된 프레임 정리 (예외 탈출 대응).
     * 
     * @return 정리된 프레임 수
     */
    public int cleanupStaleFrames(long nowNanos) {
        return cleanupStaleFrames(callStack.get(), nowNanos);
    }

    private int cleanupStaleFrames(ArrayDeque<CallFrame> stack, long nowNanos) {
        int cleaned = 0;
        while (!stack.isEmpty()) {
            CallFrame oldest = stack.peekLast();
            if (nowNanos - oldest.startNanos > FRAME_TTL_NANOS) {
                stack.pollLast();
                cleaned++;
            } else {
                break;
            }
        }
        if (cleaned > 0) {
            System.out.println("[Echo/CallStack] Cleaned " + cleaned + " stale frames (likely exception escape)");
        }
        return cleaned;
    }

    /**
     * 스택 강제 리셋.
     * 
     * @return 리셋된 프레임 수
     */
    public int resetStack() {
        ArrayDeque<CallFrame> stack = callStack.get();
        int size = stack.size();
        if (size > 0) {
            stack.clear();
            System.out.println("[Echo/CallStack] Stack reset (had " + size + " frames)");
        }
        return size;
    }

    /**
     * 스택이 비어있는지 확인.
     */
    public boolean isEmpty() {
        return callStack.get().isEmpty();
    }

    /**
     * 현재 스택 깊이.
     */
    public int getStackDepth() {
        return callStack.get().size();
    }

    // ═══════════════════════════════════════════════════════════════
    // Tick Boundary
    // ═══════════════════════════════════════════════════════════════

    /**
     * 틱 경계에서 호출 - 프레임 ID 증가.
     */
    public void onTickBoundary() {
        currentFrameId.incrementAndGet();
    }

    /**
     * 현재 프레임 ID.
     */
    public long getCurrentFrameId() {
        return currentFrameId.get();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\DetailedWindowManager.java =====

package com.echo.lua;

import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Detailed Window 트리거 관리자 (v2.1)
 * 
 * 특정 조건에서 Detailed Lua Profiling Window를 열어
 * 상세 통계를 수집합니다.
 * 
 * P1: 윈도우 통계 추적 지원
 * P2: 컨텍스트 태깅 지원
 */
public class DetailedWindowManager {

    private static DetailedWindowManager INSTANCE;

    private final LuaCallTracker tracker;
    private final AtomicLong lastTriggerTime = new AtomicLong(0);
    private static final long COOLDOWN_MS = 1000; // 1초 쿨다운

    // 트리거 유형
    public enum DetailedTrigger {
        SLOW_TICK, // 틱이 25ms 초과
        CONTEXT_MENU, // OnFillWorldObjectContextMenu 이벤트
        INVENTORY_BURST, // 인벤토리 갱신 폭발
        MANUAL_CAPTURE // 개발자 핫키/명령
    }

    // 트리거별 윈도우 설정 (durationMs, sampleRate, contextTag)
    private static final Map<DetailedTrigger, WindowConfig> CONFIGS = Map.of(
            DetailedTrigger.SLOW_TICK, new WindowConfig(300, 4, "SLOW_TICK"),
            DetailedTrigger.CONTEXT_MENU, new WindowConfig(300, 2, "CONTEXT_MENU"), // P1: 300ms로 증가
            DetailedTrigger.INVENTORY_BURST, new WindowConfig(200, 4, "INVENTORY_BURST"),
            DetailedTrigger.MANUAL_CAPTURE, new WindowConfig(2000, 1, "MANUAL"));

    private record WindowConfig(long durationMs, int sampleRate, String contextTag) {
    }

    private DetailedWindowManager(LuaCallTracker tracker) {
        this.tracker = tracker;
    }

    public static DetailedWindowManager getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new DetailedWindowManager(LuaCallTracker.getInstance());
        }
        return INSTANCE;
    }

    /**
     * Detailed Window 트리거
     * 
     * @param type 트리거 유형
     */
    public void trigger(DetailedTrigger type) {
        long now = System.currentTimeMillis();

        // 쿨다운 체크
        long lastTrigger = lastTriggerTime.get();
        if (now - lastTrigger < COOLDOWN_MS) {
            return;
        }

        // CAS로 동시 호출 방지
        if (!lastTriggerTime.compareAndSet(lastTrigger, now)) {
            return;
        }

        WindowConfig config = CONFIGS.get(type);
        if (config == null) {
            System.err.println("[Echo/DetailedWindow] Unknown trigger type: " + type);
            return;
        }

        // P2: 컨텍스트 태그 전달
        tracker.openDetailedWindow(config.durationMs, config.sampleRate, config.contextTag);
        System.out.println("[Echo/DetailedWindow] Triggered: " + type +
                " (" + config.durationMs + "ms, 1/" + config.sampleRate + " sample, context=" + config.contextTag
                + ")");
    }

    /**
     * Detailed Window가 활성 상태인지 확인
     */
    public boolean isActive() {
        return tracker.isDetailedActive();
    }

    /**
     * 수동 캡처 시작 (콘솔 명령용)
     * 
     * @param durationMs 지속 시간 (밀리초)
     */
    public void startManualCapture(long durationMs) {
        tracker.openDetailedWindow(durationMs, 1, "MANUAL_COMMAND"); // 100% 샘플링
        System.out.println("[Echo/DetailedWindow] Manual capture started: " + durationMs + "ms");
    }

    /**
     * 상태 출력
     */
    public void printStatus() {
        System.out.println("\n[Echo/DetailedWindow] Status:");
        System.out.println("  active = " + isActive());
        System.out.println("  cooldown_ms = " + COOLDOWN_MS);
        System.out.println("  last_trigger = " +
                (System.currentTimeMillis() - lastTriggerTime.get()) + "ms ago");
        System.out.println("  windows_opened = " + tracker.getDetailedWindowsOpened());
        System.out.println("  total_active_ms = " + tracker.getDetailedTotalActiveMs());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\EchoLuaContext.java =====

package com.echo.lua;

/**
 * Manages the current UI/Logic context for Lua profiling.
 * 
 * Used to group Lua function calls by high-level context (e.g., "Inventory",
 * "HealthPanel", "Combat")
 * without the overhead of deep stack inspection.
 */
public class EchoLuaContext {

    private static final ThreadLocal<String> currentContext = ThreadLocal.withInitial(() -> "Unknown");

    /**
     * Set the current context.
     * 
     * @param context Context name (e.g., "Inventory", "HUD")
     */
    public static void setContext(String context) {
        currentContext.set(context != null ? context : "Unknown");
    }

    /**
     * Get the current context.
     * 
     * @return Current context name
     */
    public static String getContext() {
        return currentContext.get();
    }

    /**
     * Clear context (reset to Unknown or Default).
     */
    public static void clearContext() {
        currentContext.set("Unknown");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\EchoLuaSamplingBridge.java =====

package com.echo.lua;

import com.echo.config.EchoConfig;

/**
 * Echo Lua 샘플링 브릿지.
 * 
 * <p>
 * Lua 스크립트에서 Echo와 통신하기 위한 브릿지입니다.
 * 노출된 메서드는 Lua에서 호출됩니다.
 * </p>
 * 
 * <p>
 * v2.0: LuaBridge → EchoLuaSamplingBridge로 이름 변경
 * (Pulse LuaBridge와의 충돌 방지)
 * </p>
 * 
 * @since Echo 0.9
 * @since Echo 1.0 - Renamed from LuaBridge
 */
public class EchoLuaSamplingBridge {

    private EchoLuaSamplingBridge() {
        // Static utility class
    }

    /**
     * 샘플링 프로파일러 활성화 여부 확인.
     * 
     * @return Lua 프로파일링 + 샘플링 모두 활성화되었으면 true
     */
    public static boolean isSamplingEnabled() {
        EchoConfig config = EchoConfig.getInstance();
        return config.isLuaProfilingEnabled() && config.isLuaSamplingEnabled();
    }

    /**
     * Lua에서 샘플 기록.
     * 
     * @param functionName 함수 이름
     * @param source       소스 파일
     */
    public static void recordSample(String functionName, String source) {
        // 1 샘플 = 1 단위의 "무거움"으로 처리
        LuaCallTracker.getInstance().recordFunctionCall(functionName, source, 1);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\FunctionLabeler.java =====

package com.echo.lua;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.util.Map;
import java.util.Collections;
import java.util.WeakHashMap;
import java.util.concurrent.atomic.LongAdder;

/**
 * Lua 함수 라벨러 - 제네릭 라벨을 실제 식별 가능한 함수 ID로 변환
 * 
 * 출력 형태:
 * - LuaClosure: "media/lua/client/ISUI/ISInventoryPage.lua:100 (render)"
 * - JavaFunction: "[Java] pcall"
 * - Unknown: "unknown:type#hash"
 * 
 * 설계 원칙:
 * 1. WeakHashMap 캐시로 메모리 누수 방지
 * 2. 리플렉션 필드는 1회만 조회
 * 3. 3단계 폴백: LuaClosure → JavaFunction → unknown
 */
public class FunctionLabeler {

    // 리플렉션 비용 최소화를 위한 캐시 (WeakHashMap으로 메모리 누수 방지)
    private static final Map<Object, String> labelCache = Collections.synchronizedMap(new WeakHashMap<>());

    // 품질 지표
    private static final LongAdder totalLabeled = new LongAdder();
    private static final LongAdder unknownLabeled = new LongAdder();
    private static final LongAdder cacheHits = new LongAdder();

    // 리플렉션 필드 캐시 (클래스별 1회만 조회)
    private static volatile Field closurePrototypeField;
    private static volatile Field protoFilenameField;
    private static volatile Field protoNameField;
    private static volatile Field protoLinesField;
    private static volatile boolean fieldsInitialized = false;

    /**
     * Function object에서 라벨 추출
     * 
     * @param func Lua 함수 객체 (LuaClosure, JavaFunction 등)
     * @return 식별 가능한 라벨 문자열
     */
    public static String labelOf(Object func) {
        if (func == null) {
            return "<null>";
        }

        // 1. Fast Path: 캐시 확인
        String cached = labelCache.get(func);
        if (cached != null) {
            cacheHits.increment();
            return cached;
        }

        // 2. 라벨 생성
        String label = createLabel(func);

        // 3. 캐싱
        labelCache.put(func, label);

        // 4. 품질 지표 업데이트
        totalLabeled.increment();
        if (label.startsWith("unknown:")) {
            unknownLabeled.increment();
        }

        return label;
    }

    private static String createLabel(Object func) {
        String className = func.getClass().getName();

        try {
            // Case A: LuaClosure (대부분의 Lua 함수)
            if (className.contains("LuaClosure")) {
                return labelLuaClosure(func);
            }

            // Case B: JavaFunction (pcall, print 등 자바 구현 함수)
            if (className.contains("JavaFunction")) {
                return labelJavaFunction(func);
            }

            // Case C: 기타 - String이면 그대로 반환
            if (func instanceof String) {
                return (String) func;
            }

            // Case D: 숫자(argCount) - 기존 방식 호환
            if (func instanceof Number) {
                return "call:" + func;
            }

            // Case E: 기타
            return "unknown:" + func.getClass().getSimpleName() + "#" +
                    Integer.toHexString(System.identityHashCode(func));

        } catch (Exception e) {
            return "unknown:error#" + Integer.toHexString(System.identityHashCode(func));
        }
    }

    /**
     * LuaClosure 라벨링
     * 출력 형태: "media/lua/client/ISUI/ISInventoryPage.lua:100 (render)"
     * "media/lua/client/ISUI/ISInventoryPage.lua:100"
     * "lua:closure#1a2b3c" (fallback)
     */
    private static String labelLuaClosure(Object closure) throws Exception {
        initFieldsIfNeeded(closure);

        if (closurePrototypeField == null) {
            return "lua:closure#" + Integer.toHexString(System.identityHashCode(closure));
        }

        Object prototype = closurePrototypeField.get(closure);
        if (prototype == null) {
            return "lua:closure#" + Integer.toHexString(System.identityHashCode(closure));
        }

        // Filename 추출
        String filename = null;
        if (protoFilenameField != null) {
            filename = (String) protoFilenameField.get(prototype);
        }

        // Name 추출 (함수명, 없을 수 있음)
        String name = null;
        if (protoNameField != null) {
            name = (String) protoNameField.get(prototype);
        }

        // Line Number 추출 (lines 배열의 첫 번째 요소)
        int line = 0;
        if (protoLinesField != null) {
            Object linesArray = protoLinesField.get(prototype);
            if (linesArray != null && Array.getLength(linesArray) > 0) {
                line = Array.getInt(linesArray, 0);
            }
        }

        // 포맷팅
        if (filename != null && !filename.isEmpty()) {
            // 파일명 간소화 (긴 경로에서 media/lua/ 이후만)
            String shortFilename = shortenFilename(filename);
            if (name != null && !name.isEmpty()) {
                return String.format("%s:%d (%s)", shortFilename, line, name);
            } else {
                return String.format("%s:%d", shortFilename, line);
            }
        }

        // Fallback
        return "lua:closure#" + Integer.toHexString(System.identityHashCode(closure));
    }

    /**
     * 파일명 간소화 - 긴 경로에서 핵심 부분만 추출
     */
    private static String shortenFilename(String filename) {
        if (filename == null)
            return "";

        // media/lua/가 포함된 경우 그 이후 부분만
        int idx = filename.indexOf("media/lua/");
        if (idx >= 0) {
            return filename.substring(idx);
        }

        // 그 외의 경우 마지막 3개 경로 컴포넌트만
        String[] parts = filename.split("[/\\\\]");
        if (parts.length <= 3) {
            return filename;
        }
        return parts[parts.length - 3] + "/" + parts[parts.length - 2] + "/" + parts[parts.length - 1];
    }

    /**
     * JavaFunction 라벨링
     * 출력 형태: "[Java] pcall", "[Java] MyMod_OnFillContextMenu"
     */
    private static String labelJavaFunction(Object javaFunc) {
        String str = javaFunc.toString();
        // toString이 유용한 정보를 주면 사용, 아니면 클래스명
        if (str != null && !str.isEmpty() && !str.contains("@")) {
            return "[Java] " + str;
        }
        return "[Java] " + javaFunc.getClass().getSimpleName();
    }

    /**
     * 리플렉션 필드 초기화 (1회만 수행)
     */
    private static synchronized void initFieldsIfNeeded(Object closure) {
        if (fieldsInitialized) {
            return;
        }

        try {
            Class<?> closureClass = closure.getClass();
            closurePrototypeField = closureClass.getField("prototype");

            Object prototype = closurePrototypeField.get(closure);
            if (prototype != null) {
                Class<?> protoClass = prototype.getClass();

                try {
                    protoFilenameField = protoClass.getField("filename");
                } catch (NoSuchFieldException ignored) {
                }

                try {
                    protoNameField = protoClass.getField("name");
                } catch (NoSuchFieldException ignored) {
                }

                try {
                    protoLinesField = protoClass.getField("lines");
                } catch (NoSuchFieldException ignored) {
                }
            }
        } catch (Exception e) {
            // 필드 없으면 null로 유지
            System.err.println("[Echo/FunctionLabeler] Field initialization failed: " + e.getMessage());
        }

        fieldsInitialized = true;
    }

    // ===== 품질 지표 API =====

    public static double getUnknownLabelRatio() {
        long total = totalLabeled.sum();
        if (total == 0)
            return 0.0;
        return (double) unknownLabeled.sum() / total;
    }

    public static double getCacheHitRatio() {
        long total = totalLabeled.sum() + cacheHits.sum();
        if (total == 0)
            return 0.0;
        return (double) cacheHits.sum() / total;
    }

    public static void resetStats() {
        totalLabeled.reset();
        unknownLabeled.reset();
        cacheHits.reset();
    }

    public static Map<String, Object> getStats() {
        return Map.of(
                "total_labeled", totalLabeled.sum(),
                "unknown_labeled", unknownLabeled.sum(),
                "unknown_ratio", Math.round(getUnknownLabelRatio() * 10000) / 100.0,
                "cache_hits", cacheHits.sum(),
                "cache_hit_ratio", Math.round(getCacheHitRatio() * 10000) / 100.0,
                "cache_size", labelCache.size());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\LuaCallTracker.java =====

package com.echo.lua;

import com.echo.measure.EchoProfiler;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Lua 호출 추적기 (v3.0 - Refactored).
 * 
 * <p>
 * v3.0에서 로직을 분리하여 조정자 역할만 담당합니다:
 * </p>
 * <ul>
 * <li>{@link CallStackTracker} - 스택/프레임 관리</li>
 * <li>{@link LuaStatistics} - 통계 수집/조회</li>
 * <li>{@link DetailedWindowManager} - Detailed Window 관리 (기존)</li>
 * </ul>
 * 
 * <h3>핵심 원칙:</h3>
 * <ul>
 * <li>"tracked 프레임만 push" - 추적 조건 만족 시에만 스택에 push</li>
 * <li>빈 스택 = 정상 (Start가 추적 안 됨)</li>
 * </ul>
 * 
 * @since Echo 0.9
 * @since Echo 1.0 - v3.0 Refactored
 */
public class LuaCallTracker {

    private static LuaCallTracker INSTANCE;

    // ═══════════════════════════════════════════════════════════════
    // Delegate Components
    // ═══════════════════════════════════════════════════════════════

    private final CallStackTracker stackTracker = new CallStackTracker();
    private final LuaStatistics statistics = new LuaStatistics();

    // ═══════════════════════════════════════════════════════════════
    // Detailed Window State
    // ═══════════════════════════════════════════════════════════════

    private volatile long detailedUntilNanos = 0;
    private volatile int sampleRate = 1; // 1 = 100%, 4 = 25%
    private final AtomicLong sampleCounter = new AtomicLong(0);
    private volatile long lastWindowOpenTime = 0;
    private volatile String currentContextTag = "Unknown";

    // ═══════════════════════════════════════════════════════════════
    // Function Name Cache
    // ═══════════════════════════════════════════════════════════════

    private final Map<Object, String> functionNameCache = Collections.synchronizedMap(new WeakHashMap<>(256));

    // ═══════════════════════════════════════════════════════════════
    // Dependencies
    // ═══════════════════════════════════════════════════════════════

    private final EchoProfiler profiler;

    // ═══════════════════════════════════════════════════════════════
    // Constructor & Singleton
    // ═══════════════════════════════════════════════════════════════

    public LuaCallTracker(com.echo.config.EchoConfig config, EchoProfiler profiler) {
        // config is accepted for API compatibility but not used internally
        this.profiler = profiler;
    }

    public static LuaCallTracker getInstance() {
        try {
            com.pulse.di.PulseServiceLocator locator = com.pulse.di.PulseServiceLocator.getInstance();
            LuaCallTracker service = locator.getService(LuaCallTracker.class);
            if (service != null) {
                return service;
            }
        } catch (NoClassDefFoundError | Exception ignored) {
        }

        if (INSTANCE == null) {
            INSTANCE = new LuaCallTracker(com.echo.config.EchoConfig.getInstance(), EchoProfiler.getInstance());
        }
        return INSTANCE;
    }

    // ═══════════════════════════════════════════════════════════════
    // Detailed Window Control
    // ═══════════════════════════════════════════════════════════════

    public void openDetailedWindow(long durationMs, int sampleRate, String contextTag) {
        long now = System.nanoTime();

        // 이전 윈도우가 열려있었다면 시간 누적
        if (lastWindowOpenTime > 0 && now < detailedUntilNanos) {
            long activeMs = (now - lastWindowOpenTime) / 1_000_000L;
            statistics.addDetailedActiveMs(activeMs);
        }

        this.detailedUntilNanos = now + durationMs * 1_000_000L;
        this.sampleRate = Math.max(1, sampleRate);
        this.currentContextTag = (contextTag != null) ? contextTag : "Unknown";
        this.lastWindowOpenTime = now;

        statistics.incrementDetailedWindowsOpened();
        System.out.println("[Echo/LuaTracker] Detailed window opened: " + durationMs + "ms, rate=1/" + sampleRate
                + ", context=" + contextTag);
    }

    public void openDetailedWindow(long durationMs, int sampleRate) {
        openDetailedWindow(durationMs, sampleRate, "Manual");
    }

    public boolean isDetailedActive() {
        return System.nanoTime() < detailedUntilNanos;
    }

    public void setContextTag(String tag) {
        this.currentContextTag = (tag != null) ? tag : "Unknown";
    }

    private boolean shouldSample() {
        if (sampleRate == 1)
            return true;
        return sampleCounter.incrementAndGet() % sampleRate == 0;
    }

    // ═══════════════════════════════════════════════════════════════
    // Core Recording API (위임)
    // ═══════════════════════════════════════════════════════════════

    public void recordCallStart(Object func, long startNanos) {
        statistics.incrementTotalCalls();

        // 추적 여부 결정: Detailed Window 활성 && 샘플링 통과
        boolean shouldTrack = isDetailedActive() && shouldSample();

        if (!shouldTrack) {
            statistics.incrementUntrackedCalls();
            return;
        }

        String funcName = extractFunctionName(func);
        boolean pushed = stackTracker.recordStart(funcName, currentContextTag, startNanos);

        if (pushed) {
            statistics.incrementTrackedCalls();
        } else {
            statistics.addDroppedFrames(1);
        }
    }

    public void recordCallEnd(Object func, long endNanos) {
        CallStackTracker.CallResult result = stackTracker.recordEnd(endNanos);

        // 스택이 비어있다 = Start가 추적 안 됨 (정상 케이스)
        if (result == null) {
            return;
        }

        // 통계 기록
        statistics.recordFunction(result.funcName, result.elapsedMicros,
                result.selfMicros, result.contextTag);
    }

    public void resetStack() {
        int resetCount = stackTracker.resetStack();
        if (resetCount > 0) {
            statistics.incrementStackResets();
        }
    }

    public void onTickBoundary() {
        stackTracker.onTickBoundary();

        // 윈도우 종료 감지 및 시간 누적
        if (lastWindowOpenTime > 0 && !isDetailedActive()) {
            long activeMs = (detailedUntilNanos - lastWindowOpenTime) / 1_000_000L;
            statistics.addDetailedActiveMs(Math.max(0, activeMs));
            lastWindowOpenTime = 0;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Legacy API (하위 호환성)
    // ═══════════════════════════════════════════════════════════════

    public void recordFunctionCall(String functionName, long durationMicros) {
        if (!profiler.isLuaProfilingEnabled())
            return;
        statistics.recordFunction(functionName, durationMicros);
        String context = EchoLuaContext.getContext();
        statistics.recordFunction(functionName, durationMicros, 0, context);
    }

    public void recordFunctionCall(String functionName, String sourceFile, long durationMicros) {
        recordFunctionCall(functionName, durationMicros);
        statistics.recordFile(sourceFile, durationMicros);
    }

    public void recordEventCall(String eventName, long durationMicros, int handlerCount) {
        if (!profiler.isLuaProfilingEnabled())
            return;
        statistics.recordEvent(eventName, durationMicros, handlerCount);
    }

    public void recordUIElementCall(LuaUICategory category, String elementName, long durationMicros) {
        if (!profiler.isLuaProfilingEnabled())
            return;
        statistics.recordUIElement(category, elementName, durationMicros);
    }

    public void profileFunction(String functionName, Runnable function) {
        if (!profiler.isLuaProfilingEnabled()) {
            function.run();
            return;
        }
        long start = System.nanoTime();
        try {
            function.run();
        } finally {
            long elapsed = (System.nanoTime() - start) / 1000;
            recordFunctionCall(functionName, elapsed);
        }
    }

    public void profileEvent(String eventName, int handlerCount, Runnable event) {
        if (!profiler.isLuaProfilingEnabled()) {
            event.run();
            return;
        }
        long start = System.nanoTime();
        try {
            event.run();
        } finally {
            long elapsed = (System.nanoTime() - start) / 1000;
            recordEventCall(eventName, elapsed, handlerCount);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Function Name Extraction
    // ═══════════════════════════════════════════════════════════════

    private String extractFunctionName(Object func) {
        if (func == null)
            return "<anonymous>";
        return FunctionLabeler.labelOf(func);
    }

    // ═══════════════════════════════════════════════════════════════
    // Query API (위임)
    // ═══════════════════════════════════════════════════════════════

    public long getTotalCalls() {
        return statistics.getTotalCalls();
    }

    public long getTrackedCalls() {
        return statistics.getTrackedCalls();
    }

    public long getUntrackedCalls() {
        return statistics.getUntrackedCalls();
    }

    public long getSampledCalls() {
        return statistics.getSampledCalls();
    }

    public long getDroppedCalls() {
        return statistics.getDroppedCalls();
    }

    public long getMismatchCount() {
        return statistics.getMismatchCount();
    }

    public long getDroppedFrames() {
        return statistics.getDroppedFrames();
    }

    public long getStackResets() {
        return statistics.getStackResets();
    }

    public long getOrphanedEnds() {
        return statistics.getOrphanedEnds();
    }

    public int getSampleRate() {
        return sampleRate;
    }

    public double getTotalTimeMs() {
        return statistics.getTotalTimeMs();
    }

    public long getDetailedWindowsOpened() {
        return statistics.getDetailedWindowsOpened();
    }

    public long getDetailedTotalActiveMs() {
        return statistics.getDetailedTotalActiveMs();
    }

    public LuaFunctionStats getFunctionStats(String functionName) {
        return statistics.getFunctionStats(functionName);
    }

    public Collection<LuaFunctionStats> getAllFunctionStats() {
        return statistics.getAllFunctionStats();
    }

    public LuaEventStats getEventStats(String eventName) {
        return statistics.getEventStats(eventName);
    }

    public Collection<LuaEventStats> getAllEventStats() {
        return statistics.getAllEventStats();
    }

    public LuaUIElementStats getUIElementStats(LuaUICategory category, String elementName) {
        return statistics.getUIElementStats(category, elementName);
    }

    public Collection<LuaUIElementStats> getAllUIElementStats() {
        return statistics.getAllUIElementStats();
    }

    public List<LuaFunctionStats> getTopFunctionsByTime(int n) {
        return statistics.getTopFunctionsByTime(n);
    }

    public List<LuaFunctionStats> getTopFunctionsByCalls(int n) {
        return statistics.getTopFunctionsByCalls(n);
    }

    // ═══════════════════════════════════════════════════════════════
    // Reset & Print
    // ═══════════════════════════════════════════════════════════════

    public void reset() {
        statistics.reset();
        functionNameCache.clear();
        System.out.println("[Echo] Lua call tracker RESET");
    }

    public void printStats(int topN) {
        statistics.printStats(topN, sampleRate);
    }

    public Map<String, Object> toMap(int topN) {
        Map<String, Object> map = statistics.toMap(topN,
                profiler.isLuaProfilingEnabled(),
                isDetailedActive(),
                sampleRate);

        // FunctionLabeler 통계 추가
        map.put("labeling_stats", FunctionLabeler.getStats());

        // Path hits from Pulse
        long pathHits = getPathHitsFromPulse();
        map.put("path_hits", pathHits);
        map.put("path_verified", pathHits > 0);

        String mode = (getTrackedCalls() > 0) ? "detailed" : "path_verify";
        map.put("mode", mode);

        return map;
    }

    private long getPathHitsFromPulse() {
        try {
            return com.pulse.api.lua.PulseLuaHook.getPathHitCount();
        } catch (NoClassDefFoundError | Exception e) {
            return 0;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Internal Accessors (for advanced use)
    // ═══════════════════════════════════════════════════════════════

    public CallStackTracker getStackTracker() {
        return stackTracker;
    }

    public LuaStatistics getStatistics() {
        return statistics;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\LuaEventStats.java =====

package com.echo.lua;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.atomic.LongAdder;

public class LuaEventStats {
    private final String name;
    private final LongAdder fireCount = new LongAdder();
    private final LongAdder totalHandlers = new LongAdder();
    private final LongAdder totalMicros = new LongAdder();

    public LuaEventStats(String name) {
        this.name = name;
    }

    public void record(long durationMicros, int handlerCount) {
        fireCount.increment();
        totalHandlers.add(handlerCount);
        totalMicros.add(durationMicros);
    }

    public String getName() {
        return name;
    }

    public long getFireCount() {
        return fireCount.sum();
    }

    public long getTotalHandlers() {
        return totalHandlers.sum();
    }

    public double getTotalMs() {
        return totalMicros.sum() / 1000.0;
    }

    public double getAverageHandlersPerFire() {
        long count = fireCount.sum();
        return count == 0 ? 0 : (double) totalHandlers.sum() / count;
    }

    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("name", name);
        map.put("fire_count", getFireCount());
        map.put("total_handlers", getTotalHandlers());
        map.put("avg_handlers_per_fire", Math.round(getAverageHandlersPerFire() * 10) / 10.0);
        map.put("total_time_ms", Math.round(getTotalMs() * 100) / 100.0);
        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\LuaFunctionStats.java =====

package com.echo.lua;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

/**
 * Lua 함수 통계 (v2.1)
 * 
 * 호출 횟수, 총 시간, self-time (자기 시간, 하위 호출 제외)을 추적합니다.
 * P2: context 태깅 지원 추가
 */
public class LuaFunctionStats {
    private final String name;
    private final LongAdder callCount = new LongAdder();
    private final LongAdder totalMicros = new LongAdder();
    private final LongAdder selfTimeMicros = new LongAdder(); // Phase 2: self-time
    private final AtomicLong maxMicros = new AtomicLong(0);

    // P2: Context 태깅
    private volatile String context = "Unknown";

    public LuaFunctionStats(String name) {
        this.name = name;
    }

    /**
     * 호출 기록 (legacy - total time만)
     */
    public void record(long durationMicros) {
        callCount.increment();
        totalMicros.add(durationMicros);
        updateMax(durationMicros);
    }

    /**
     * 호출 기록 (self-time 포함)
     * 
     * @param totalMicros 전체 실행 시간 (하위 호출 포함)
     * @param selfMicros  자기 시간 (하위 호출 제외)
     */
    public void record(long totalMicros, long selfMicros) {
        callCount.increment();
        this.totalMicros.add(totalMicros);
        this.selfTimeMicros.add(selfMicros);
        updateMax(totalMicros);
    }

    private void updateMax(long durationMicros) {
        long current;
        do {
            current = maxMicros.get();
            if (durationMicros <= current)
                return;
        } while (!maxMicros.compareAndSet(current, durationMicros));
    }

    /**
     * Context 설정 (마지막 호출의 컨텍스트로 덮어씀)
     */
    public void setContext(String context) {
        if (context != null && !context.isEmpty()) {
            this.context = context;
        }
    }

    public String getContext() {
        return context;
    }

    public String getName() {
        return name;
    }

    public long getCallCount() {
        return callCount.sum();
    }

    public long getTotalMicros() {
        return totalMicros.sum();
    }

    public long getSelfTimeMicros() {
        return selfTimeMicros.sum();
    }

    public long getMaxMicros() {
        return maxMicros.get();
    }

    public double getTotalMs() {
        return totalMicros.sum() / 1000.0;
    }

    public double getSelfTimeMs() {
        return selfTimeMicros.sum() / 1000.0;
    }

    public double getAverageMs() {
        long count = callCount.sum();
        return count == 0 ? 0 : getTotalMs() / count;
    }

    public Map<String, Object> toMap(int rank) {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("rank", rank);
        map.put("name", name);
        map.put("context", context); // P2: context 포함
        map.put("call_count", getCallCount());
        map.put("total_time_ms", Math.round(getTotalMs() * 100) / 100.0);
        map.put("self_time_ms", Math.round(getSelfTimeMs() * 100) / 100.0);
        map.put("average_time_ms", Math.round(getAverageMs() * 1000) / 1000.0);
        map.put("max_time_ms", Math.round(getMaxMicros() / 1000.0 * 100) / 100.0);
        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\LuaGCProfiler.java =====

package com.echo.lua;

import com.echo.config.EchoConfig;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Tracks Memory/GC pressure during the game loop.
 * 
 * Note: This tracks JVM Heap Delta, which is an *estimation* of general GC
 * pressure,
 * including both Java and Lua (since Kahlua objects are Java objects).
 */
public class LuaGCProfiler {

    private static final LuaGCProfiler INSTANCE = new LuaGCProfiler();

    private long lastTotalMemory = 0;
    private long lastFreeMemory = 0;

    private final java.util.List<java.lang.management.GarbageCollectorMXBean> gcBeans;
    private long lastTotalGcTime = 0;
    private final AtomicLong gcPausePerTick = new AtomicLong(0);
    private final java.util.concurrent.atomic.AtomicLong heapDeltaPerTick = new java.util.concurrent.atomic.AtomicLong(
            0);

    private LuaGCProfiler() {
        gcBeans = java.lang.management.ManagementFactory.getGarbageCollectorMXBeans();
    }

    public static LuaGCProfiler getInstance() {
        return INSTANCE;
    }

    /**
     * Called at the start of a profiling period (e.g., start of Tick).
     */
    public void onTickStart() {
        if (!EchoConfig.getInstance().isLuaProfilingEnabled())
            return;

        Runtime rt = Runtime.getRuntime();
        lastTotalMemory = rt.totalMemory();
        lastFreeMemory = rt.freeMemory();

        // Capture GC time at start
        long totalGc = 0;
        for (java.lang.management.GarbageCollectorMXBean bean : gcBeans) {
            long time = bean.getCollectionTime();
            if (time != -1)
                totalGc += time;
        }
        lastTotalGcTime = totalGc;
    }

    /**
     * Called at the end of a profiling period.
     * Calculates the "Heap Delta" (Allocation - GC).
     * Positive means allocation, Negative/Zero usually means GC happened or static.
     */
    public void onTickEnd() {
        if (!EchoConfig.getInstance().isLuaProfilingEnabled())
            return;

        Runtime rt = Runtime.getRuntime();
        long currentTotal = rt.totalMemory();
        long currentFree = rt.freeMemory();

        long usedBefore = lastTotalMemory - lastFreeMemory;
        long usedNow = currentTotal - currentFree;

        long delta = usedNow - usedBefore;
        heapDeltaPerTick.set(delta);

        // Calculate GC Pause (difference in collection time)
        long totalGc = 0;
        for (java.lang.management.GarbageCollectorMXBean bean : gcBeans) {
            long time = bean.getCollectionTime();
            if (time != -1)
                totalGc += time;
        }

        long pause = totalGc - lastTotalGcTime;
        gcPausePerTick.set(pause > 0 ? pause : 0);
    }

    public long getHeapDelta() {
        return heapDeltaPerTick.get();
    }

    public long getGcPauseTime() {
        return gcPausePerTick.get();
    }

    public long getUsedMemory() {
        Runtime rt = Runtime.getRuntime();
        return rt.totalMemory() - rt.freeMemory();
    }

    public void reset() {
        heapDeltaPerTick.set(0);
        gcPausePerTick.set(0);
        lastTotalMemory = 0;
        lastFreeMemory = 0;
        lastTotalGcTime = 0;
    }

    public java.util.Map<String, Object> toMap() {
        java.util.Map<String, Object> map = new java.util.HashMap<>();
        map.put("heap_delta_bytes", getHeapDelta());
        map.put("used_memory_bytes", getUsedMemory());
        map.put("gc_pause_ms", getGcPauseTime());
        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\LuaPathHitBridge.java =====

package com.echo.lua;

import com.pulse.api.lua.PulseLuaHook;

/**
 * Lua 경로 히트 프로브 브릿지.
 * 
 * Pulse의 PulseLuaHook.getPathHitCount()를 읽어서
 * 게임 시작 ~30초 후 1회 로그 출력.
 * 
 * 설계 원칙:
 * - Pulse: 주입(Mixin) + 카운터
 * - Echo: 읽기 + 리포트
 * 
 * 사용법: EchoMod.init()에서 register() 호출
 * 
 * @since Echo 2.0
 */
public final class LuaPathHitBridge {

    private static LuaPathHitBridge INSTANCE;

    /** 대략 30초 (60fps 기준 1800틱) */
    private static final int TARGET_TICKS = 1800;

    /** 현재 틱 수 */
    private int tickCount = 0;

    /** 이미 출력했는지 */
    private boolean printed = false;

    /** 마지막으로 읽은 pathHitCount */
    private long lastPathHitCount = 0;

    private LuaPathHitBridge() {
    }

    /**
     * 브릿지 등록
     */
    public static void register() {
        if (INSTANCE != null) {
            return;
        }
        INSTANCE = new LuaPathHitBridge();
        System.out.println("[Echo] LuaPathHitBridge registered (30s validation probe)");
    }

    /**
     * 싱글톤 인스턴스
     */
    public static LuaPathHitBridge getInstance() {
        return INSTANCE;
    }

    /**
     * TickPhaseBridge.onTickComplete() 또는 다른 틱 콜백에서 호출
     */
    public void onTick() {
        if (printed) {
            return;
        }

        if (++tickCount >= TARGET_TICKS) {
            printed = true;
            printPathHitSummary();
        }
    }

    /**
     * 경로 히트 검증 결과 출력
     */
    private void printPathHitSummary() {
        try {
            long hits = PulseLuaHook.getPathHitCount();
            lastPathHitCount = hits;

            if (hits > 0) {
                System.out.println("[Echo/LuaHook] ✅ pathHitCount after ~30s = " + hits + " (Lua path is ACTIVE)");
            } else {
                System.out.println("[Echo/LuaHook] ⚠️ pathHitCount = 0 (Lua path NOT active - check Mixin)");
            }
        } catch (NoClassDefFoundError e) {
            System.out.println("[Echo/LuaHook] ⚠️ PulseLuaHook not available (Pulse outdated?)");
        } catch (Throwable t) {
            System.out.println("[Echo/LuaHook] ❌ Failed to read pathHitCount: " + t.getMessage());
        }
    }

    /**
     * 현재 pathHitCount 조회 (리포트용)
     */
    public long getPathHitCount() {
        try {
            return PulseLuaHook.getPathHitCount();
        } catch (Throwable t) {
            return -1;
        }
    }

    /**
     * 마지막으로 읽은 값 반환
     */
    public long getLastPathHitCount() {
        return lastPathHitCount;
    }

    /**
     * 30초 프로브 완료 여부
     */
    public boolean isValidated() {
        return printed;
    }

    /**
     * 리셋
     */
    public void reset() {
        tickCount = 0;
        printed = false;
        lastPathHitCount = 0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\LuaStatistics.java =====

package com.echo.lua;

import com.echo.util.StringUtils;
import com.pulse.api.util.TopNCollector;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;

/**
 * Lua 호출 통계 수집 및 조회.
 * 
 * <p>
 * LuaCallTracker에서 분리된 통계 전용 클래스입니다.
 * 통계 저장, Top N 캐싱, 리셋, 출력 등을 담당합니다.
 * </p>
 * 
 * <h3>Thread Safety:</h3>
 * <ul>
 * <li>ConcurrentHashMap으로 동시성 지원</li>
 * <li>읽기 스레드 (Render/Debug UI)에서 안전하게 조회 가능</li>
 * </ul>
 * 
 * @since Echo 0.9 - Extracted from LuaCallTracker
 */
public class LuaStatistics {

    // ═══════════════════════════════════════════════════════════════
    // Statistics Storage
    // ═══════════════════════════════════════════════════════════════

    private final Map<String, LuaFunctionStats> functionStats = new ConcurrentHashMap<>();
    private final Map<String, LuaEventStats> eventStats = new ConcurrentHashMap<>();
    private final Map<String, LuaUIElementStats> uiElementStats = new ConcurrentHashMap<>();
    private final Map<String, LongAdder> contextStats = new ConcurrentHashMap<>();
    private final Map<String, LongAdder> fileStats = new ConcurrentHashMap<>();

    // ═══════════════════════════════════════════════════════════════
    // Counters
    // ═══════════════════════════════════════════════════════════════

    private final LongAdder totalCalls = new LongAdder();
    private final LongAdder trackedCalls = new LongAdder();
    private final LongAdder untrackedCalls = new LongAdder();
    private final LongAdder totalTimeMicros = new LongAdder();

    // Quality metrics
    private final LongAdder mismatchCount = new LongAdder();
    private final LongAdder droppedFrames = new LongAdder();
    private final LongAdder stackResets = new LongAdder();

    // Detailed window stats
    private final LongAdder detailedWindowsOpened = new LongAdder();
    private final LongAdder detailedTotalActiveMs = new LongAdder();

    // ═══════════════════════════════════════════════════════════════
    // Top N Cache
    // ═══════════════════════════════════════════════════════════════

    private volatile List<LuaFunctionStats> topByTimeCached = new ArrayList<>();
    private volatile List<LuaFunctionStats> topByCallsCached = new ArrayList<>();
    private volatile long lastCacheUpdate = 0;
    private static final long CACHE_TTL_MS = 1000;

    // ═══════════════════════════════════════════════════════════════
    // Recording API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 함수 호출 통계 기록.
     */
    public void recordFunction(String funcName, long elapsedMicros, long selfMicros, String contextTag) {
        LuaFunctionStats stats = functionStats.computeIfAbsent(funcName, LuaFunctionStats::new);
        stats.record(elapsedMicros, selfMicros);
        if (contextTag != null) {
            stats.setContext(contextTag);
        }

        totalTimeMicros.add(elapsedMicros);
        contextStats.computeIfAbsent(contextTag != null ? contextTag : "Unknown",
                k -> new LongAdder()).add(elapsedMicros);
    }

    /**
     * 함수 호출 통계 기록 (Legacy API).
     */
    public void recordFunction(String funcName, long durationMicros) {
        functionStats.computeIfAbsent(funcName, LuaFunctionStats::new).record(durationMicros);
        totalCalls.increment();
        trackedCalls.increment();
        totalTimeMicros.add(durationMicros);
    }

    /**
     * 이벤트 호출 통계 기록.
     */
    public void recordEvent(String eventName, long durationMicros, int handlerCount) {
        eventStats.computeIfAbsent(eventName, LuaEventStats::new)
                .record(durationMicros, handlerCount);
    }

    /**
     * UI 요소 호출 통계 기록.
     */
    public void recordUIElement(LuaUICategory category, String elementName, long durationMicros) {
        String key = category.name() + ":" + elementName;
        uiElementStats.computeIfAbsent(key, k -> new LuaUIElementStats(category, elementName))
                .record(durationMicros);
    }

    /**
     * 파일별 통계 기록.
     */
    public void recordFile(String sourceFile, long durationMicros) {
        if (sourceFile != null && !sourceFile.isEmpty()) {
            fileStats.computeIfAbsent(sourceFile, k -> new LongAdder()).add(durationMicros);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Counter Updates
    // ═══════════════════════════════════════════════════════════════

    public void incrementTotalCalls() {
        totalCalls.increment();
    }

    public void incrementTrackedCalls() {
        trackedCalls.increment();
    }

    public void incrementUntrackedCalls() {
        untrackedCalls.increment();
    }

    public void incrementMismatchCount() {
        mismatchCount.increment();
    }

    public void addDroppedFrames(int count) {
        droppedFrames.add(count);
    }

    public void incrementStackResets() {
        stackResets.increment();
    }

    public void incrementDetailedWindowsOpened() {
        detailedWindowsOpened.increment();
    }

    public void addDetailedActiveMs(long ms) {
        detailedTotalActiveMs.add(ms);
    }

    // ═══════════════════════════════════════════════════════════════
    // Query API
    // ═══════════════════════════════════════════════════════════════

    public long getTotalCalls() {
        return totalCalls.sum();
    }

    public long getTrackedCalls() {
        return trackedCalls.sum();
    }

    public long getUntrackedCalls() {
        return untrackedCalls.sum();
    }

    public long getSampledCalls() {
        return trackedCalls.sum();
    } // Legacy

    public long getDroppedCalls() {
        return untrackedCalls.sum();
    } // Legacy

    public long getMismatchCount() {
        return mismatchCount.sum();
    }

    public long getDroppedFrames() {
        return droppedFrames.sum();
    }

    public long getStackResets() {
        return stackResets.sum();
    }

    public long getOrphanedEnds() {
        return 0;
    } // v2.1: 더 이상 에러 아님

    public double getTotalTimeMs() {
        return totalTimeMicros.sum() / 1000.0;
    }

    public long getDetailedWindowsOpened() {
        return detailedWindowsOpened.sum();
    }

    public long getDetailedTotalActiveMs() {
        return detailedTotalActiveMs.sum();
    }

    public LuaFunctionStats getFunctionStats(String name) {
        return functionStats.get(name);
    }

    public Collection<LuaFunctionStats> getAllFunctionStats() {
        return Collections.unmodifiableCollection(functionStats.values());
    }

    public LuaEventStats getEventStats(String name) {
        return eventStats.get(name);
    }

    public Collection<LuaEventStats> getAllEventStats() {
        return Collections.unmodifiableCollection(eventStats.values());
    }

    public LuaUIElementStats getUIElementStats(LuaUICategory category, String elementName) {
        return uiElementStats.get(category.name() + ":" + elementName);
    }

    public Collection<LuaUIElementStats> getAllUIElementStats() {
        return Collections.unmodifiableCollection(uiElementStats.values());
    }

    // ═══════════════════════════════════════════════════════════════
    // Top N with Caching
    // ═══════════════════════════════════════════════════════════════

    public List<LuaFunctionStats> getTopFunctionsByTime(int n) {
        updateCacheIfNeeded();
        return topByTimeCached.size() <= n ? topByTimeCached : topByTimeCached.subList(0, n);
    }

    public List<LuaFunctionStats> getTopFunctionsByCalls(int n) {
        updateCacheIfNeeded();
        return topByCallsCached.size() <= n ? topByCallsCached : topByCallsCached.subList(0, n);
    }

    private void updateCacheIfNeeded() {
        long now = System.currentTimeMillis();
        if (now - lastCacheUpdate < CACHE_TTL_MS)
            return;

        Collection<LuaFunctionStats> all = functionStats.values();

        // TopNCollector 활용 (Phase 8 개선)
        topByTimeCached = TopNCollector.topNByLong(all, LuaFunctionStats::getTotalMicros, all.size());
        topByCallsCached = TopNCollector.topNByLong(all, LuaFunctionStats::getCallCount, all.size());

        lastCacheUpdate = now;
    }

    // ═══════════════════════════════════════════════════════════════
    // Reset
    // ═══════════════════════════════════════════════════════════════

    public void reset() {
        functionStats.clear();
        eventStats.clear();
        uiElementStats.clear();
        contextStats.clear();
        fileStats.clear();

        totalCalls.reset();
        trackedCalls.reset();
        untrackedCalls.reset();
        totalTimeMicros.reset();
        mismatchCount.reset();
        droppedFrames.reset();
        stackResets.reset();
        detailedWindowsOpened.reset();
        detailedTotalActiveMs.reset();

        topByTimeCached.clear();
        topByCallsCached.clear();
    }

    // ═══════════════════════════════════════════════════════════════
    // Output
    // ═══════════════════════════════════════════════════════════════

    public void printStats(int topN, int sampleRate) {
        System.out.println("\n🔷 LUA PROFILING STATS (v2.1)");
        System.out.println("───────────────────────────────────────────────────────");
        System.out.printf("  Total Calls: %,d | Tracked: %,d | Untracked: %,d%n",
                getTotalCalls(), getTrackedCalls(), getUntrackedCalls());
        System.out.printf("  Dropped Frames: %,d | Stack Resets: %,d%n",
                getDroppedFrames(), getStackResets());
        System.out.printf("  Windows Opened: %,d | Active Time: %,d ms%n",
                getDetailedWindowsOpened(), getDetailedTotalActiveMs());
        System.out.printf("  Total Time: %.2f ms%n", getTotalTimeMs());
        System.out.println();

        System.out.println("  Top Functions by Time:");
        int rank = 1;
        for (LuaFunctionStats stats : getTopFunctionsByTime(topN)) {
            System.out.printf("    #%d %-30s | calls: %,6d | total: %6.2f ms | self: %6.2f ms%n",
                    rank++,
                    StringUtils.truncate(stats.getName(), 30),
                    stats.getCallCount(),
                    stats.getTotalMs(),
                    stats.getSelfTimeMs());
        }

        if (!eventStats.isEmpty()) {
            System.out.println("\n  Events:");
            for (LuaEventStats stats : eventStats.values()) {
                System.out.printf("    %-25s | fires: %,6d | handlers: %,d | total: %.2f ms%n",
                        StringUtils.truncate(stats.getName(), 25),
                        stats.getFireCount(),
                        stats.getTotalHandlers(),
                        stats.getTotalMs());
            }
        }
        System.out.println();
    }

    /**
     * JSON 출력용 Map.
     */
    public Map<String, Object> toMap(int topN, boolean luaProfilingEnabled,
            boolean detailedActive, int sampleRate) {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("enabled", luaProfilingEnabled);
        map.put("detailed_active", detailedActive);

        // Counters
        map.put("total_calls", getTotalCalls());
        map.put("tracked_calls", getTrackedCalls());
        map.put("untracked_calls", getUntrackedCalls());
        map.put("total_time_ms", Math.round(getTotalTimeMs() * 100) / 100.0);

        // Detailed Window stats
        Map<String, Object> windowStats = new LinkedHashMap<>();
        windowStats.put("windows_opened", getDetailedWindowsOpened());
        windowStats.put("total_active_ms", getDetailedTotalActiveMs());
        map.put("detailed_window_stats", windowStats);

        // Quality metrics
        Map<String, Object> quality = new LinkedHashMap<>();
        quality.put("dropped_frames", getDroppedFrames());
        quality.put("stack_resets", getStackResets());
        quality.put("sample_rate", "1/" + sampleRate);

        long total = getTotalCalls();
        long tracked = getTrackedCalls();
        double trackingRate = (total > 0) ? (tracked * 100.0 / total) : 0;
        quality.put("tracking_rate_percent", Math.round(trackingRate * 10) / 10.0);
        map.put("quality_metrics", quality);

        // Top Functions
        List<Map<String, Object>> topFunctions = new ArrayList<>();
        int rank = 1;
        for (LuaFunctionStats stats : getTopFunctionsByTime(topN)) {
            topFunctions.add(stats.toMap(rank++));
        }
        map.put("top_functions_by_time", topFunctions);

        // Events
        List<Map<String, Object>> events = new ArrayList<>();
        for (LuaEventStats stats : eventStats.values()) {
            events.add(stats.toMap());
        }
        map.put("events", events);

        // UI Elements
        List<Map<String, Object>> uiList = new ArrayList<>();
        List<LuaUIElementStats> sortedUI = new ArrayList<>(uiElementStats.values());
        sortedUI.sort((a, b) -> Long.compare(b.getTotalMicros(), a.getTotalMicros()));
        int count = 0;
        for (LuaUIElementStats stats : sortedUI) {
            if (count++ >= topN)
                break;
            uiList.add(stats.toMap());
        }
        map.put("ui_elements", uiList);

        // Context Stats
        Map<String, Double> contextMap = new LinkedHashMap<>();
        contextStats.entrySet().stream()
                .sorted((a, b) -> Long.compare(b.getValue().sum(), a.getValue().sum()))
                .forEach(e -> contextMap.put(e.getKey(), e.getValue().sum() / 1000.0));
        map.put("context_stats", contextMap);

        // File Stats
        List<Map<String, Object>> fileList = new ArrayList<>();
        fileStats.entrySet().stream()
                .sorted((a, b) -> Long.compare(b.getValue().sum(), a.getValue().sum()))
                .limit(topN)
                .forEach(e -> {
                    Map<String, Object> f = new LinkedHashMap<>();
                    f.put("file", e.getKey());
                    f.put("total_ms", Math.round((e.getValue().sum() / 1000.0) * 100) / 100.0);
                    fileList.add(f);
                });
        map.put("heavy_files", fileList);

        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\LuaUICategory.java =====

package com.echo.lua;

public enum LuaUICategory {
    TOOLTIP, CONTEXT_MENU, INVENTORY_GRID, MODAL_DIALOG, HUD_ELEMENT, OTHER
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\lua\LuaUIElementStats.java =====

package com.echo.lua;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

public class LuaUIElementStats {
    private final LuaUICategory category;
    private final String elementName;
    private final LongAdder drawCount = new LongAdder();
    private final LongAdder totalMicros = new LongAdder();
    private final AtomicLong maxMicros = new AtomicLong(0);

    public LuaUIElementStats(LuaUICategory category, String elementName) {
        this.category = category;
        this.elementName = elementName;
    }

    public void record(long durationMicros) {
        drawCount.increment();
        totalMicros.add(durationMicros);
        long current;
        do {
            current = maxMicros.get();
            if (durationMicros <= current)
                return;
        } while (!maxMicros.compareAndSet(current, durationMicros));
    }

    public LuaUICategory getCategory() {
        return category;
    }

    public String getElementName() {
        return elementName;
    }

    public long getDrawCount() {
        return drawCount.sum();
    }

    public long getTotalMicros() {
        return totalMicros.sum();
    }

    public double getTotalMs() {
        return totalMicros.sum() / 1000.0;
    }

    public double getAverageMs() {
        long count = drawCount.sum();
        return count == 0 ? 0 : getTotalMs() / count;
    }

    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("category", category.name());
        map.put("element", elementName);
        map.put("draw_count", getDrawCount());
        map.put("total_ms", Math.round(getTotalMs() * 100) / 100.0);
        map.put("avg_ms", Math.round(getAverageMs() * 1000) / 1000.0);
        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\EchoProfiler.java =====

package com.echo.measure;

import com.echo.aggregate.TimingData;
import com.echo.aggregate.TickHistogram;
import com.echo.aggregate.SpikeLog;
import com.echo.lua.LuaCallTracker;
import com.echo.history.MetricCollector;
import com.pulse.api.log.PulseLogger;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Echo Profiler - 계층적 프로파일링 엔진
 * 
 * Stack 기반 push/pop으로 중첩된 호출 구조를 추적합니다.
 * ThreadLocal을 사용하여 멀티스레드 환경에서도 안전합니다.
 */
public class EchoProfiler {

    private static EchoProfiler INSTANCE = new EchoProfiler();

    // --- Main Thread Fast-Path ---

    // 메인 스레드 (Fast-Path용)
    private static volatile Thread mainThread = null;

    // 메인 스레드 전용 스택 (ThreadLocal 우회)
    private final Deque<ProfilingFrame> mainThreadStack = new ArrayDeque<>();

    // --- Core Fields ---

    // 스레드별 프로파일링 스택 (메인 스레드 외)
    private final ThreadLocal<Deque<ProfilingFrame>> frameStack = ThreadLocal.withInitial(ArrayDeque::new);

    // Phase 1 최적화: ProfilingScope 객체 풀
    private final ThreadLocal<ProfilingScopePool> scopePool = ThreadLocal.withInitial(ProfilingScopePool::new);
    private final ProfilingScopePool mainThreadScopePool = new ProfilingScopePool();

    // 포인트별 누적 데이터
    private final Map<ProfilingPoint, TimingData> timingRegistry = new ConcurrentHashMap<>();

    // 틱 히스토그램 (Phase 3)
    private final TickHistogram tickHistogram = new TickHistogram();

    // 스파이크 로그 (Phase 3)
    private final SpikeLog spikeLog = new SpikeLog();

    // 메트릭 수집기 (Phase 3)
    private final MetricCollector metricCollector = new MetricCollector();

    // 프로파일링 활성화 상태
    private volatile boolean enabled = false;

    // Lua 프로파일링 (On-Demand)
    private volatile boolean luaProfilingEnabled = false;

    // 세션 시작 시간
    private volatile long sessionStartTime = 0;

    // 의존성
    private final com.echo.config.EchoConfig config;

    /**
     * @deprecated Use Constructor Injection via PulseServiceLocator
     */
    @Deprecated
    private EchoProfiler() {
        this(com.echo.config.EchoConfig.getInstance());
    }

    public EchoProfiler(com.echo.config.EchoConfig config) {
        this.config = config;
        // 모든 ProfilingPoint에 대한 TimingData 초기화
        for (ProfilingPoint point : ProfilingPoint.values()) {
            timingRegistry.put(point, new TimingData(point.name()));
        }
    }

    public static EchoProfiler getInstance() {
        // 1. Try ServiceLocator (Hybrid DI)
        try {
            com.pulse.di.PulseServiceLocator locator = com.pulse.di.PulseServiceLocator.getInstance();
            EchoProfiler service = locator.getService(EchoProfiler.class);
            if (service != null) {
                return service;
            }
        } catch (NoClassDefFoundError | Exception ignored) {
            // Pulse might not be fully loaded
        }

        // 2. Fallback
        if (INSTANCE == null) {
            INSTANCE = new EchoProfiler(com.echo.config.EchoConfig.getInstance());
        }
        return INSTANCE;
    }

    /**
     * 테스트용 인스턴스 설정.
     */
    @com.pulse.api.VisibleForTesting
    static void setInstance(EchoProfiler instance) {
        INSTANCE = instance != null ? instance : new EchoProfiler();
    }

    @com.pulse.api.VisibleForTesting
    static void resetInstance() {
        INSTANCE = new EchoProfiler();
    }

    /** 메인 스레드 설정 */
    public static void setMainThread(Thread thread) {
        mainThread = thread;
        PulseLogger.debug("Echo", "Main thread set: " + thread.getName());
    }

    private boolean isMainThread() {
        return Thread.currentThread() == mainThread;
    }

    private Deque<ProfilingFrame> getFrameStack() {
        if (isMainThread()) {
            return mainThreadStack;
        }
        return frameStack.get();
    }

    private ProfilingScopePool getScopePool() {
        if (isMainThread()) {
            return mainThreadScopePool;
        }
        return scopePool.get();
    }

    // --- Core API: push / pop ---

    public long push(ProfilingPoint point) {
        if (!enabled)
            return -1;
        if (point.isLuaRelated() && !luaProfilingEnabled)
            return -1;

        ProfilingFrame frame = new ProfilingFrame(point, System.nanoTime());
        getFrameStack().push(frame);

        return frame.id;
    }

    public long push(ProfilingPoint point, String customLabel) {
        if (!enabled)
            return -1;
        if (point.isLuaRelated() && !luaProfilingEnabled)
            return -1;

        ProfilingFrame frame = new ProfilingFrame(point, customLabel, System.nanoTime());
        getFrameStack().push(frame);

        return frame.id;
    }

    public void pop(ProfilingPoint point) {
        if (!enabled)
            return;

        Deque<ProfilingFrame> stack = getFrameStack();
        if (stack.isEmpty()) {
            PulseLogger.warn("Echo", "Warning: Unmatched pop for " + point);
            return;
        }

        ProfilingFrame frame = stack.pop();

        if (frame.point != point) {
            PulseLogger.warn("Echo", "Warning: Mismatched push/pop - expected "
                    + frame.point + ", got " + point);
        }

        long elapsed = System.nanoTime() - frame.startTime;
        long elapsedMicros = elapsed / 1000;

        TimingData data = timingRegistry.get(point);
        if (data != null) {
            data.addSample(elapsed, frame.customLabel);
        }

        if (point == ProfilingPoint.TICK) {
            tickHistogram.addSample(elapsedMicros);
        }

        spikeLog.logSpike(elapsedMicros, point, frame.customLabel);
    }

    public ProfilingScope scope(ProfilingPoint point) {
        push(point);
        return getScopePool().acquire(point, this);
    }

    public ProfilingScope scope(ProfilingPoint point, String label) {
        push(point, label);
        return getScopePool().acquire(point, this);
    }

    // --- Raw API (Zero-Allocation) ---

    public long startRaw(ProfilingPoint point) {
        if (!enabled)
            return -1;
        if (point.isLuaRelated() && !luaProfilingEnabled)
            return -1;
        return System.nanoTime();
    }

    public void endRaw(ProfilingPoint point, long startTime) {
        if (startTime < 0)
            return;

        long elapsed = System.nanoTime() - startTime;
        long elapsedMicros = elapsed / 1000;

        TimingData data = timingRegistry.get(point);
        if (data != null) {
            data.addSample(elapsed, null);
        }

        if (point == ProfilingPoint.TICK) {
            tickHistogram.addSample(elapsedMicros);
        }

        spikeLog.logSpike(elapsedMicros, point, null);
    }

    public void endRaw(ProfilingPoint point, long startTime, String label) {
        if (startTime < 0)
            return;

        long elapsed = System.nanoTime() - startTime;
        long elapsedMicros = elapsed / 1000;

        TimingData data = timingRegistry.get(point);
        if (data != null) {
            data.addSample(elapsed, label);
        }

        if (point == ProfilingPoint.TICK) {
            tickHistogram.addSample(elapsedMicros);
        }

        spikeLog.logSpike(elapsedMicros, point, label);
    }

    // --- Control API ---

    public void enable() {
        enable(true);
    }

    public void enable(boolean resetStats) {
        config.sanitize();

        if (!enabled && resetStats) {
            reset();
        }
        this.enabled = true;

        // Apply Lua profiling setting from config
        this.luaProfilingEnabled = config.isLuaProfilingEnabled();
        if (sessionStartTime == 0) {
            this.sessionStartTime = System.currentTimeMillis();
        }
        com.echo.measure.FreezeDetector.getInstance().start();
        com.echo.validation.SelfValidation.getInstance().scheduleValidation();
        com.echo.validation.FallbackTickEmitter.getInstance().startMonitoring();

        PulseLogger.info("Echo", "Profiler ENABLED" + (resetStats ? " (stats reset)" : ""));
    }

    public void disable() {
        int orphanedFrames = clearActiveStacks();
        if (orphanedFrames > 0) {
            PulseLogger.warn("Echo", "Warning: " + orphanedFrames + " orphaned frames cleared on disable");
        }

        this.enabled = false;
        com.echo.measure.FreezeDetector.getInstance().stop();
        com.echo.validation.SelfValidation.getInstance().shutdown();
        com.echo.validation.FallbackTickEmitter.getInstance().stop();

        PulseLogger.info("Echo", "Profiler DISABLED");
    }

    private int clearActiveStacks() {
        int count = 0;
        count += mainThreadStack.size();
        mainThreadStack.clear();

        Deque<ProfilingFrame> currentStack = frameStack.get();
        count += currentStack.size();
        currentStack.clear();

        return count;
    }

    public void enableLuaProfiling() {
        this.luaProfilingEnabled = true;
        PulseLogger.info("Echo", "Lua Profiling ENABLED (On-Demand)");
    }

    public void disableLuaProfiling() {
        this.luaProfilingEnabled = false;
        PulseLogger.info("Echo", "Lua Profiling DISABLED");
    }

    public boolean isEnabled() {
        return enabled;
    }

    public boolean isLuaProfilingEnabled() {
        return luaProfilingEnabled;
    }

    public long getSessionStartTime() {
        return sessionStartTime;
    }

    public void reset() {
        timingRegistry.clear();
        for (ProfilingPoint point : ProfilingPoint.values()) {
            timingRegistry.put(point, new TimingData(point.name()));
        }

        tickHistogram.reset();
        spikeLog.reset();
        sessionStartTime = System.currentTimeMillis();

        SubProfiler.getInstance().reset();
        LuaCallTracker.getInstance().reset();
        com.echo.lua.LuaGCProfiler.getInstance().reset();

        com.echo.fuse.PathfindingProfiler.getInstance().reset();
        com.echo.fuse.ZombieProfiler.getInstance().reset();
        com.echo.fuse.IsoGridProfiler.getInstance().reset();

        PulseLogger.info("Echo", "Profiler stats RESET");
    }

    public SubProfiler getSubProfiler() {
        return SubProfiler.getInstance();
    }

    public Map<ProfilingPoint, TimingData> getTimingData() {
        return timingRegistry;
    }

    public TimingData getTimingData(ProfilingPoint point) {
        return timingRegistry.get(point);
    }

    public TickHistogram getTickHistogram() {
        return tickHistogram;
    }

    public SpikeLog getSpikeLog() {
        return spikeLog;
    }

    public MetricCollector getMetricCollector() {
        return metricCollector;
    }

    // --- Utility ---

    public int getCurrentStackDepth() {
        return getFrameStack().size();
    }

    public ProfilingPoint getCurrentPoint() {
        Deque<ProfilingFrame> stack = getFrameStack();
        if (stack.isEmpty())
            return null;
        return stack.peek().point;
    }

    public void printStatus() {
        System.out.println("\n[Echo] === Profiler Status ===");
        System.out.println("  Enabled: " + enabled);
        System.out.println("  Lua Profiling: " + luaProfilingEnabled);
        System.out.println("  Session Duration: " + getSessionDurationSeconds() + "s");
        System.out.println();

        for (ProfilingPoint point : ProfilingPoint.values()) {
            TimingData data = timingRegistry.get(point);
            if (data != null && data.getCallCount() > 0) {
                System.out.printf("  %-15s | calls: %,8d | avg: %6.2f ms | max: %6.2f ms%n",
                        point.getDisplayName(),
                        data.getCallCount(),
                        data.getAverageMicros() / 1000.0,
                        data.getMaxMicros() / 1000.0);
            }
        }
        System.out.println();
    }

    public long getSessionDurationSeconds() {
        if (sessionStartTime == 0)
            return 0;
        return (System.currentTimeMillis() - sessionStartTime) / 1000;
    }

    public long getSessionDurationMs() {
        if (sessionStartTime == 0)
            return 0;
        return System.currentTimeMillis() - sessionStartTime;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\FreezeDetector.java =====

package com.echo.measure;

import com.pulse.api.log.PulseLogger;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Freeze/Stall Detector
 * 
 * 메인 스레드의 멈춤(Freeze) 현상을 감지하는 Watchdog 스레드입니다.
 * 설정된 임계값(기본 500ms) 이상 메인 스레드가 반응하지 않으면
 * 현재 상태(스택 트레이스, 메모리 등)를 캡처하여 원인을 분석합니다.
 * 
 * @since Echo 1.0
 */
public class FreezeDetector {

    private static final FreezeDetector INSTANCE = new FreezeDetector();

    // 기본 임계값 500ms
    private static final long FREEZE_THRESHOLD_MS = 500;

    // Watchdog 체크 주기 (100ms)
    private static final long CHECK_INTERVAL_MS = 100;

    // --- 스냅샷 데이터 구조 ---

    public static class FreezeSnapshot {
        public long timestamp;
        public long freezeDurationMs;
        public MemorySnapshot memory;
        public List<String> stackTrace;
        public boolean recovered;

        // Context Data
        public java.util.Map<String, Double> currentTickPhases;
        public java.util.Map<String, Double> activeSubTimings;
        public java.util.List<java.util.Map<String, Object>> topHeavyFunctions;

        public FreezeSnapshot(long freezeDurationMs, Thread mainThread) {
            this.timestamp = System.currentTimeMillis();
            this.freezeDurationMs = freezeDurationMs;
            this.memory = new MemorySnapshot();
            this.stackTrace = captureStackTrace(mainThread);
            this.recovered = false;

            // Capture Context
            captureContext();
        }

        private void captureContext() {
            // TickPhase state
            this.currentTickPhases = new java.util.LinkedHashMap<>();
            TickPhaseProfiler.getInstance().getCurrentTickPhaseMs()
                    .forEach((phase, ms) -> this.currentTickPhases.put(phase.getDisplayName(), ms));

            // Active SubTimings (what is currently running?)
            this.activeSubTimings = new java.util.LinkedHashMap<>();
            SubProfiler.getInstance().getActiveDurations()
                    .forEach((label, ms) -> this.activeSubTimings.put(label.getDisplayName(), ms));

            // Heavy Functions (Session)
            this.topHeavyFunctions = SubProfiler.getInstance().getHeavyFunctions(5);
        }

        private List<String> captureStackTrace(Thread thread) {
            List<String> trace = new ArrayList<>();
            if (thread == null)
                return trace;

            for (StackTraceElement elem : thread.getStackTrace()) {
                trace.add(elem.toString());
            }
            return trace;
        }

        /**
         * v1.1: 스택이 메인 루프 스택인지 확인.
         * DebugMonitor 등 비메인 스레드 오염 방지.
         */
        public boolean isMainLoopStack() {
            return FreezeDetector.isMainLoopStack(this.stackTrace);
        }
    }

    public static class MemorySnapshot {
        public long used;
        public long free;
        public long total;
        public long max;

        public MemorySnapshot() {
            Runtime rt = Runtime.getRuntime();
            this.total = rt.totalMemory();
            this.free = rt.freeMemory();
            this.max = rt.maxMemory();
            this.used = this.total - this.free;
        }
    }

    // --- 필드 ---

    private final AtomicLong lastTickTime = new AtomicLong(System.currentTimeMillis());
    private final AtomicBoolean isRunning = new AtomicBoolean(false);

    private Thread watchdogThread;
    private Thread mainThread;

    // 감지된 프리징 목록
    private final List<FreezeSnapshot> recentFreezes = new ArrayList<>();
    private final int MAX_HISTORY = 10;

    private FreezeDetector() {
        // Singleton
    }

    public static FreezeDetector getInstance() {
        return INSTANCE;
    }

    // --- 제어 API ---

    /**
     * 감지기 시작
     * EchoProfiler.enable() 시 호출
     */
    public synchronized void start() {
        if (isRunning.get())
            return;

        // 메인 스레드 참조 획득 (현재 스레드가 메인이라고 가정)
        // 주의: start()는 반드시 메인 스레드에서 호출되어야 함
        this.mainThread = Thread.currentThread();

        this.isRunning.set(true);
        this.lastTickTime.set(System.currentTimeMillis());

        this.watchdogThread = new Thread(this::watchdogLoop, "Echo-FreezeDetector");
        this.watchdogThread.setDaemon(true);
        this.watchdogThread.setPriority(Thread.MAX_PRIORITY); // 높은 우선순위
        this.watchdogThread.start();

        PulseLogger.info("Echo", "FreezeDetector started");
    }

    /**
     * 감지기 종료
     */
    public synchronized void stop() {
        if (!isRunning.get())
            return;

        this.isRunning.set(false);
        if (watchdogThread != null) {
            watchdogThread.interrupt();
            watchdogThread = null;
        }
        PulseLogger.info("Echo", "FreezeDetector stopped");
    }

    /**
     * 메인 스레드 생존 신고 (매 틱마다 호출)
     */
    public void tick() {
        if (!isRunning.get())
            return;

        // 첫 tick 호출 시 진짜 메인 스레드 캡처
        // (start()가 Monitor 스레드에서 호출되었을 수 있음)
        if (this.mainThread == null || !this.mainThread.getName().contains("LWJGL")) {
            Thread current = Thread.currentThread();
            if (current.getName().contains("LWJGL") || current.getName().contains("main") ||
                    current.getName().contains("Main") || this.mainThread == null) {
                boolean wasNull = this.mainThread == null;
                this.mainThread = current;
                if (wasNull) {
                    PulseLogger.debug("Echo", "FreezeDetector: Main thread captured: " + current.getName());
                }
            }
        }

        lastTickTime.set(System.currentTimeMillis());

        // Self-Validation: freeze check heartbeat (Echo 0.9.0)
        com.echo.validation.SelfValidation.getInstance().freezeCheckHeartbeat();
    }

    // --- Watchdog 로직 ---

    private void watchdogLoop() {
        while (isRunning.get()) {
            try {
                Thread.sleep(CHECK_INTERVAL_MS);

                long now = System.currentTimeMillis();
                long last = lastTickTime.get();
                long elapsed = now - last;

                if (elapsed >= FREEZE_THRESHOLD_MS) {
                    onFreezeDetected(elapsed);

                    // 프리즈 상태가 지속되는 동안 반복 캡처 방지
                    // 다음 틱이 올 때까지 대기
                    // (단, 너무 오래 걸리면(5초) 다시 체크)
                    while (isRunning.get() && lastTickTime.get() == last) {
                        Thread.sleep(1000);
                        // 5초마다 갱신된 지속시간 업데이트 등은 여기서 가능
                    }
                }
            } catch (InterruptedException e) {
                break;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void onFreezeDetected(long initialDuration) {
        PulseLogger.warn("Echo", "Freeze Detected! Main thread stalled for " + initialDuration + "ms");

        FreezeSnapshot snapshot = new FreezeSnapshot(initialDuration, mainThread);

        synchronized (recentFreezes) {
            if (recentFreezes.size() >= MAX_HISTORY) {
                recentFreezes.remove(0);
            }
            recentFreezes.add(snapshot);
        }
    }

    // --- 조회 API ---

    public List<FreezeSnapshot> getRecentFreezes() {
        synchronized (recentFreezes) {
            return new ArrayList<>(recentFreezes);
        }
    }

    /**
     * v1.1: 메인 루프 스택만 포함된 freeze 반환.
     * DebugMonitor 등 비메인 스레드 오염 제거.
     */
    public List<FreezeSnapshot> getMainLoopFreezes() {
        synchronized (recentFreezes) {
            List<FreezeSnapshot> filtered = new ArrayList<>();
            for (FreezeSnapshot snapshot : recentFreezes) {
                if (snapshot.isMainLoopStack()) {
                    filtered.add(snapshot);
                }
            }
            return filtered;
        }
    }

    // ===================================================
    // v1.1: 릤인 루프 스택 파턴 판별
    // ===================================================

    /**
     * 메인 루프 스택 패턴 매칭.
     * 핵심 프레임: GameWindow, Core, Main 관련 메서드가 포함되어야 함.
     */
    private static final String[] MAIN_LOOP_PATTERNS = {
            "GameWindow.run",
            "GameWindow.mainThread",
            "Core.run",
            "Core.update",
            "Core.doUpdate",
            "zombie.GameWindow",
            "zombie.core.Core",
            "LWJGL"
    };

    /**
     * 스택이 메인 루프 스택인지 확인.
     * 
     * @param stackTrace 스택 트레이스 문자열 리스트
     * @return 메인 루프 스택이면 true
     */
    public static boolean isMainLoopStack(List<String> stackTrace) {
        if (stackTrace == null || stackTrace.isEmpty()) {
            return false;
        }

        for (String frame : stackTrace) {
            for (String pattern : MAIN_LOOP_PATTERNS) {
                if (frame.contains(pattern)) {
                    return true;
                }
            }
        }
        return false;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\MemoryProfiler.java =====

package com.echo.measure;

import java.lang.management.GarbageCollectorMXBean;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryUsage;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * 메모리 프로파일러
 * 
 * JVM 메모리 사용량 및 GC 이벤트 추적
 */
public class MemoryProfiler {

    private static final MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
    private static final List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();

    // 최근 GC 통계 (델타 계산용)
    private static long lastGcCount = 0;
    private static long lastGcTime = 0;

    /**
     * 힙 사용량 (바이트)
     */
    public static long getHeapUsed() {
        return memoryBean.getHeapMemoryUsage().getUsed();
    }

    /**
     * 힙 최대 크기 (바이트)
     */
    public static long getHeapMax() {
        return memoryBean.getHeapMemoryUsage().getMax();
    }

    /**
     * 힙 커밋 크기 (바이트)
     */
    public static long getHeapCommitted() {
        return memoryBean.getHeapMemoryUsage().getCommitted();
    }

    /**
     * 힙 사용률 (%)
     */
    public static double getHeapUsagePercent() {
        MemoryUsage usage = memoryBean.getHeapMemoryUsage();
        long max = usage.getMax();
        if (max <= 0) {
            max = usage.getCommitted();
        }
        return max > 0 ? (usage.getUsed() * 100.0 / max) : 0;
    }

    /**
     * Non-Heap 사용량 (바이트) - Metaspace 등
     */
    public static long getNonHeapUsed() {
        return memoryBean.getNonHeapMemoryUsage().getUsed();
    }

    /**
     * 총 GC 횟수
     */
    public static long getTotalGcCount() {
        return gcBeans.stream()
                .mapToLong(GarbageCollectorMXBean::getCollectionCount)
                .filter(c -> c >= 0)
                .sum();
    }

    /**
     * 총 GC 시간 (밀리초)
     */
    public static long getTotalGcTimeMs() {
        return gcBeans.stream()
                .mapToLong(GarbageCollectorMXBean::getCollectionTime)
                .filter(t -> t >= 0)
                .sum();
    }

    /**
     * 최근 GC 횟수 (마지막 호출 이후 증가분)
     */
    public static long getRecentGcCount() {
        long current = getTotalGcCount();
        long delta = current - lastGcCount;
        lastGcCount = current;
        return delta;
    }

    /**
     * 최근 GC 시간 (마지막 호출 이후 증가분, 밀리초)
     */
    public static long getRecentGcTimeMs() {
        long current = getTotalGcTimeMs();
        long delta = current - lastGcTime;
        lastGcTime = current;
        return delta;
    }

    // ═══════════════════════════════════════════════════════════════
    // Allocation Rate Tracking
    // ═══════════════════════════════════════════════════════════════

    private static final com.sun.management.ThreadMXBean threadMXBean;
    private static boolean allocationTrackingEnabled = false;
    private static long lastTotalAllocatedBytes = 0;
    private static long currentAllocationRate = 0; // Bytes per tick

    static {
        java.lang.management.ThreadMXBean bean = ManagementFactory.getThreadMXBean();
        if (bean instanceof com.sun.management.ThreadMXBean) {
            threadMXBean = (com.sun.management.ThreadMXBean) bean;
            try {
                if (threadMXBean.isThreadAllocatedMemorySupported()) {
                    threadMXBean.setThreadAllocatedMemoryEnabled(true);
                    allocationTrackingEnabled = true;
                }
            } catch (UnsupportedOperationException e) {
                // Ignore
            }
        } else {
            threadMXBean = null;
        }
    }

    /**
     * Update allocation rate stats (Call once per tick)
     */
    public static void update() {
        if (!allocationTrackingEnabled)
            return;

        long currentTotal = 0;
        long[] ids = threadMXBean.getAllThreadIds();
        // Note: multiple calls to getThreadAllocatedBytes can be expensive
        // Only summing active threads or just current thread?
        // Usually full allocation rate requires summing all threads.
        // For performance, we might limit this or use a more efficient way if
        // available.
        // But getThreadAllocatedBytes(long[]) is available in newer JDKs.
        // Here we use loop for compatibility.
        // Optimization: track only main thread? NO, global allocation is requested.

        // Batch fetch if possible (Java 14+) but fallback to loop
        // getThreadAllocatedBytes(long[]) exists in com.sun.management.ThreadMXBean
        long[] bytes = threadMXBean.getThreadAllocatedBytes(ids);
        for (long b : bytes) {
            if (b != -1)
                currentTotal += b;
        }

        if (lastTotalAllocatedBytes > 0) {
            long delta = currentTotal - lastTotalAllocatedBytes;
            // Handle thread death/birth (total might decrease if threads die? No, allocated
            // bytes are usually cumulative per thread)
            // If threads die, their bytes are lost from the sum.
            // Correct way: Map<Long, Long> lastAllocatedPerThread.
            // But that's heavy.
            // Simple approximation: if delta < 0, assume 0.
            currentAllocationRate = delta > 0 ? delta : 0;
        }
        lastTotalAllocatedBytes = currentTotal;
    }

    /**
     * Get memory allocation rate (bytes per tick)
     */
    public static long getAllocationRate() {
        return currentAllocationRate;
    }

    /**
     * GC 정보 조회
     */
    public static Map<String, Object> getGcInfo() {
        Map<String, Object> info = new LinkedHashMap<>();
        for (GarbageCollectorMXBean gc : gcBeans) {
            Map<String, Object> gcEntry = new LinkedHashMap<>();
            gcEntry.put("count", gc.getCollectionCount());
            gcEntry.put("time_ms", gc.getCollectionTime());
            info.put(gc.getName(), gcEntry);
        }
        return info;
    }

    /**
     * 콘솔 출력용 상태 문자열
     */
    public static String getStatusString() {
        StringBuilder sb = new StringBuilder();
        sb.append("💾 MEMORY STATUS\n");
        sb.append("───────────────────────────────────────────────────────\n");
        sb.append(String.format("  Heap Used:     %,d MB / %,d MB (%.1f%%)%n",
                getHeapUsed() / (1024 * 1024),
                getHeapMax() / (1024 * 1024),
                getHeapUsagePercent()));
        sb.append(String.format("  Non-Heap:      %,d MB%n",
                getNonHeapUsed() / (1024 * 1024)));
        if (allocationTrackingEnabled) {
            sb.append(String.format("  Alloc Rate:    %,d KB/tick%n", currentAllocationRate / 1024));
        }
        sb.append(String.format("  GC Count:      %,d%n", getTotalGcCount()));
        sb.append(String.format("  GC Time:       %,d ms%n", getTotalGcTimeMs()));
        return sb.toString();
    }

    /**
     * JSON 출력용 Map
     */
    public static Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();

        Map<String, Object> heap = new LinkedHashMap<>();
        heap.put("used_mb", Math.round(getHeapUsed() / (1024.0 * 1024.0) * 100) / 100.0);
        heap.put("max_mb", Math.round(getHeapMax() / (1024.0 * 1024.0) * 100) / 100.0);
        heap.put("committed_mb", Math.round(getHeapCommitted() / (1024.0 * 1024.0) * 100) / 100.0);
        heap.put("usage_percent", Math.round(getHeapUsagePercent() * 100) / 100.0);
        map.put("heap", heap);

        map.put("non_heap_mb", Math.round(getNonHeapUsed() / (1024.0 * 1024.0) * 100) / 100.0);

        if (allocationTrackingEnabled) {
            map.put("allocation_rate_bytes", currentAllocationRate);
        }

        Map<String, Object> gc = new LinkedHashMap<>();
        gc.put("total_count", getTotalGcCount());
        gc.put("total_time_ms", getTotalGcTimeMs());
        gc.put("collectors", getGcInfo());
        map.put("gc", gc);

        return map;
    }

    /**
     * 메모리 통계 출력
     */
    public static void printStatus() {
        System.out.println(getStatusString());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\NetworkMetrics.java =====

package com.echo.measure;

import java.util.*;
import com.pulse.api.service.echo.ConnectionQuality;
import com.pulse.api.service.echo.INetworkMetrics;

/**
 * 네트워크 메트릭 수집기.
 * 
 * Phase 5.1: 멀티플레이어 네트워크 성능 모니터링.
 * Ping, 패킷 통계, 대역폭, 손실률 등을 추적합니다.
 * 
 * @since 1.0.1
 */
public class NetworkMetrics implements INetworkMetrics {

    private static final NetworkMetrics INSTANCE = new NetworkMetrics();

    // 네트워크 통계
    private volatile long packetsSent = 0;
    private volatile long packetsReceived = 0;
    private volatile long packetsLost = 0;
    private volatile long bytesSent = 0;
    private volatile long bytesReceived = 0;

    // Ping 통계
    private volatile double currentPingMs = 0;
    private volatile double avgPingMs = 0;
    private volatile double maxPingMs = 0;
    private volatile double minPingMs = Double.MAX_VALUE;
    private final LinkedList<Double> pingHistory = new LinkedList<>();
    private static final int PING_HISTORY_SIZE = 100;

    // 시간 추적
    private long lastUpdateTime = System.currentTimeMillis();
    private long sessionStartTime = System.currentTimeMillis();

    // 대역폭 계산
    private volatile double uploadBandwidthKBps = 0;
    private volatile double downloadBandwidthKBps = 0;
    private long lastBytesSent = 0;
    private long lastBytesReceived = 0;

    public static NetworkMetrics getInstance() {
        return INSTANCE;
    }

    /**
     * 패킷 전송 기록
     */
    public void recordPacketSent(int bytes) {
        packetsSent++;
        bytesSent += bytes;
    }

    /**
     * 패킷 수신 기록
     */
    public void recordPacketReceived(int bytes) {
        packetsReceived++;
        bytesReceived += bytes;
    }

    /**
     * 패킷 손실 기록
     */
    public void recordPacketLost() {
        packetsLost++;
    }

    /**
     * Ping 업데이트
     */
    public void updatePing(double pingMs) {
        this.currentPingMs = pingMs;
        this.maxPingMs = Math.max(maxPingMs, pingMs);
        this.minPingMs = Math.min(minPingMs, pingMs);

        synchronized (pingHistory) {
            pingHistory.addLast(pingMs);
            while (pingHistory.size() > PING_HISTORY_SIZE) {
                pingHistory.removeFirst();
            }

            // 평균 계산
            double sum = 0;
            for (double p : pingHistory) {
                sum += p;
            }
            avgPingMs = sum / pingHistory.size();
        }
    }

    /**
     * 주기적 업데이트 (틱마다 호출)
     */
    public void update() {
        long now = System.currentTimeMillis();
        long deltaTime = now - lastUpdateTime;

        if (deltaTime >= 1000) { // 1초마다 대역폭 계산
            long sentDelta = bytesSent - lastBytesSent;
            long receivedDelta = bytesReceived - lastBytesReceived;

            uploadBandwidthKBps = (sentDelta * 1000.0 / deltaTime) / 1024.0;
            downloadBandwidthKBps = (receivedDelta * 1000.0 / deltaTime) / 1024.0;

            lastBytesSent = bytesSent;
            lastBytesReceived = bytesReceived;
            lastUpdateTime = now;
        }
    }

    // --- Getters ---

    public double getCurrentPingMs() {
        return currentPingMs;
    }

    @Override
    public double getAvgPingMs() {
        return avgPingMs;
    }

    public double getMaxPingMs() {
        return maxPingMs;
    }

    public double getMinPingMs() {
        return minPingMs == Double.MAX_VALUE ? 0 : minPingMs;
    }

    public long getPacketsSent() {
        return packetsSent;
    }

    public long getPacketsReceived() {
        return packetsReceived;
    }

    public long getPacketsLost() {
        return packetsLost;
    }

    @Override
    public double getPacketLossRate() {
        long total = packetsSent + packetsReceived;
        if (total == 0)
            return 0;
        return (double) packetsLost / (packetsLost + packetsReceived) * 100;
    }

    public long getBytesSent() {
        return bytesSent;
    }

    public long getBytesReceived() {
        return bytesReceived;
    }

    public double getUploadBandwidthKBps() {
        return uploadBandwidthKBps;
    }

    public double getDownloadBandwidthKBps() {
        return downloadBandwidthKBps;
    }

    /**
     * 세션 시간 (밀리초)
     */
    public long getSessionDurationMs() {
        return System.currentTimeMillis() - sessionStartTime;
    }

    /**
     * 연결 품질 등급
     */
    @Override
    public ConnectionQuality getConnectionQuality() {
        double loss = getPacketLossRate();
        double ping = avgPingMs;

        if (loss > 10 || ping > 300)
            return ConnectionQuality.POOR;
        if (loss > 5 || ping > 150)
            return ConnectionQuality.FAIR;
        if (loss > 2 || ping > 80)
            return ConnectionQuality.GOOD;
        return ConnectionQuality.EXCELLENT;
    }

    /**
     * 초기화
     */
    public void reset() {
        packetsSent = 0;
        packetsReceived = 0;
        packetsLost = 0;
        bytesSent = 0;
        bytesReceived = 0;
        currentPingMs = 0;
        avgPingMs = 0;
        maxPingMs = 0;
        minPingMs = Double.MAX_VALUE;
        uploadBandwidthKBps = 0;
        downloadBandwidthKBps = 0;
        lastBytesSent = 0;
        lastBytesReceived = 0;
        synchronized (pingHistory) {
            pingHistory.clear();
        }
        sessionStartTime = System.currentTimeMillis();
        lastUpdateTime = sessionStartTime;
    }

    /**
     * JSON 출력
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();

        // Ping
        Map<String, Object> ping = new LinkedHashMap<>();
        ping.put("current_ms", Math.round(currentPingMs * 10) / 10.0);
        ping.put("avg_ms", Math.round(avgPingMs * 10) / 10.0);
        ping.put("max_ms", Math.round(maxPingMs * 10) / 10.0);
        ping.put("min_ms", Math.round(getMinPingMs() * 10) / 10.0);
        map.put("ping", ping);

        // 패킷
        Map<String, Object> packets = new LinkedHashMap<>();
        packets.put("sent", packetsSent);
        packets.put("received", packetsReceived);
        packets.put("lost", packetsLost);
        packets.put("loss_rate_percent", Math.round(getPacketLossRate() * 100) / 100.0);
        map.put("packets", packets);

        // 대역폭
        Map<String, Object> bandwidth = new LinkedHashMap<>();
        bandwidth.put("upload_kbps", Math.round(uploadBandwidthKBps * 10) / 10.0);
        bandwidth.put("download_kbps", Math.round(downloadBandwidthKBps * 10) / 10.0);
        bandwidth.put("total_sent_kb", bytesSent / 1024);
        bandwidth.put("total_received_kb", bytesReceived / 1024);
        map.put("bandwidth", bandwidth);

        // 품질
        map.put("connection_quality", getConnectionQuality().name());
        map.put("session_duration_ms", getSessionDurationMs());

        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\ProfileCategory.java =====

package com.echo.measure;

/**
 * 프로파일링 카테고리.
 * 
 * Phase 2.1: 스레드별 계측을 위한 카테고리 분류.
 * 메인 스레드 외 렌더링/네트워크/I/O 등 병목을 추적합니다.
 * 
 * @since 1.0.1
 */
public enum ProfileCategory {

    /**
     * 메인 게임 틱 (메인 스레드)
     */
    TICK_MAIN("Main Tick", Thread.currentThread().getId()),

    /**
     * 렌더링 스레드
     */
    THREAD_RENDER("Render Thread", -1),

    /**
     * 네트워크 스레드
     */
    THREAD_NETWORK("Network Thread", -1),

    /**
     * I/O 스레드 (파일, 청크 로딩)
     */
    THREAD_IO("I/O Thread", -1),

    /**
     * 워커 스레드 (백그라운드 작업)
     */
    THREAD_WORKER("Worker Thread", -1),

    /**
     * 알 수 없는/기타 스레드
     */
    THREAD_OTHER("Other Thread", -1);

    private final String displayName;
    private long associatedThreadId;

    ProfileCategory(String displayName, long associatedThreadId) {
        this.displayName = displayName;
        this.associatedThreadId = associatedThreadId;
    }

    public String getDisplayName() {
        return displayName;
    }

    public long getAssociatedThreadId() {
        return associatedThreadId;
    }

    /**
     * 현재 스레드에 맞는 카테고리 자동 감지
     */
    public static ProfileCategory fromCurrentThread() {
        Thread current = Thread.currentThread();
        String name = current.getName().toLowerCase();

        if (name.contains("render") || name.contains("lwjgl")) {
            return THREAD_RENDER;
        } else if (name.contains("network") || name.contains("netty") || name.contains("socket")) {
            return THREAD_NETWORK;
        } else if (name.contains("io") || name.contains("file") || name.contains("chunk")) {
            return THREAD_IO;
        } else if (name.contains("worker") || name.contains("pool") || name.contains("executor")) {
            return THREAD_WORKER;
        } else if (name.equals("main") || name.contains("game")) {
            return TICK_MAIN;
        }

        return THREAD_OTHER;
    }

    /**
     * 스레드 ID로 카테고리 연결
     */
    public void associateThread(long threadId) {
        this.associatedThreadId = threadId;
    }

    /**
     * 현재 스레드가 메인 스레드인지 확인
     */
    public static boolean isMainThread() {
        return fromCurrentThread() == TICK_MAIN;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\ProfilingFrame.java =====

package com.echo.measure;

import java.util.concurrent.atomic.AtomicLong;

/**
 * 스택 프레임 - 진행 중인 측정 정보
 */
class ProfilingFrame {
    private static final AtomicLong idCounter = new AtomicLong(0);

    final long id;
    final ProfilingPoint point;
    final String customLabel;
    final long startTime;

    ProfilingFrame(ProfilingPoint point, long startTime) {
        this.id = idCounter.incrementAndGet();
        this.point = point;
        this.customLabel = null;
        this.startTime = startTime;
    }

    ProfilingFrame(ProfilingPoint point, String customLabel, long startTime) {
        this.id = idCounter.incrementAndGet();
        this.point = point;
        this.customLabel = customLabel;
        this.startTime = startTime;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\ProfilingPoint.java =====

package com.echo.measure;

/**
 * 프로파일링 측정 포인트
 * 
 * 카테고리:
 * - CORE: 핵심 게임 루프
 * - SUBSYSTEM: 주요 서브시스템
 * - LUA: Lua 관련 (On-Demand)
 * - CUSTOM: 사용자 정의
 */
public enum ProfilingPoint {

    // --- CORE - 핵심 게임 루프 ---

    /** 전체 게임 틱 */
    TICK(Category.CORE, "Game Tick"),

    /** 전체 렌더링 프레임 */
    FRAME(Category.CORE, "Render Frame"),

    // --- SUBSYSTEM - 주요 서브시스템 ---

    /** 렌더링 서브시스템 */
    RENDER(Category.SUBSYSTEM, "Rendering"),

    /** 월드 렌더링 */
    RENDER_WORLD(Category.SUBSYSTEM, "World Rendering"),

    /** UI 렌더링 */
    RENDER_UI(Category.SUBSYSTEM, "UI Rendering"),

    /** 시뮬레이션 업데이트 */
    SIMULATION(Category.SUBSYSTEM, "Simulation"),

    /** 물리 연산 */
    PHYSICS(Category.SUBSYSTEM, "Physics"),

    /** 좀비 AI 업데이트 */
    ZOMBIE_AI(Category.SUBSYSTEM, "Zombie AI"),

    /** 좀비 플레이어 탐지 (spotted 메서드) */
    ZOMBIE_DETECTION(Category.SUBSYSTEM, "Zombie Detection"),

    /** 좀비 경로 탐색 (pathToCharacter 메서드) */
    ZOMBIE_PATHFINDING(Category.SUBSYSTEM, "Zombie Pathfinding"),

    /** 좀비 소리 반응 (RespondToSound 메서드) */
    ZOMBIE_SOUND(Category.SUBSYSTEM, "Zombie Sound Response"),

    /** NPC AI 업데이트 */
    NPC_AI(Category.SUBSYSTEM, "NPC AI"),

    /** 네트워크 처리 */
    NETWORK(Category.SUBSYSTEM, "Network"),

    /** 사운드 처리 */
    AUDIO(Category.SUBSYSTEM, "Audio"),

    /** 청크 로딩/저장 */
    CHUNK_IO(Category.SUBSYSTEM, "Chunk I/O"),

    // --- LUA - Lua 관련 (On-Demand) ---

    /** Lua 이벤트 디스패치 */
    LUA_EVENT(Category.LUA, "Lua Event"),

    /** 개별 Lua 함수 호출 */
    LUA_FUNCTION(Category.LUA, "Lua Function"),

    /** Lua 가비지 컬렉션 */
    LUA_GC(Category.LUA, "Lua GC"),

    // --- CUSTOM - 사용자/모드 정의 ---

    /** 모드 초기화 */
    MOD_INIT(Category.CUSTOM, "Mod Initialization"),

    /** 모드 틱 핸들러 */
    MOD_TICK(Category.CUSTOM, "Mod Tick Handler"),

    /** 커스텀 측정 1-5 */
    CUSTOM_1(Category.CUSTOM, "Custom 1"),
    CUSTOM_2(Category.CUSTOM, "Custom 2"),
    CUSTOM_3(Category.CUSTOM, "Custom 3"),
    CUSTOM_4(Category.CUSTOM, "Custom 4"),
    CUSTOM_5(Category.CUSTOM, "Custom 5"),

    // --- INTERNAL - 프로파일러 내부 진단 (Phase 4) ---

    /** Echo 프로파일러 자체 오버헤드 (메타 프로파일링) */
    ECHO_OVERHEAD(Category.INTERNAL, "Echo Overhead");

    // --- 필드 및 메서드 ---

    private final Category category;
    private final String displayName;

    ProfilingPoint(Category category, String displayName) {
        this.category = category;
        this.displayName = displayName;
    }

    public Category getCategory() {
        return category;
    }

    public String getDisplayName() {
        return displayName;
    }

    /**
     * Lua 관련 포인트 여부 (On-Demand 토글 대상)
     */
    public boolean isLuaRelated() {
        return category == Category.LUA;
    }

    /**
     * 사용자 정의 포인트 여부
     */
    public boolean isCustom() {
        return category == Category.CUSTOM;
    }

    /**
     * 내부 진단 포인트 여부
     */
    public boolean isInternal() {
        return category == Category.INTERNAL;
    }

    // --- 카테고리 열거형 ---

    public enum Category {
        CORE("Core", "#FF6B6B"),
        SUBSYSTEM("Subsystem", "#4ECDC4"),
        LUA("Lua", "#FFE66D"),
        CUSTOM("Custom", "#95E1D3"),
        INTERNAL("Internal", "#A9A9A9");

        private final String displayName;
        private final String color;

        Category(String displayName, String color) {
            this.displayName = displayName;
            this.color = color;
        }

        public String getDisplayName() {
            return displayName;
        }

        public String getColor() {
            return color;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\ProfilingScope.java =====

package com.echo.measure;

/**
 * try-with-resources용 스코프 (Poolable)
 * 
 * 예외 안전성:
 * try-with-resources 블록 내에서 예외가 발생해도 close()가 자동 호출되어
 * pop()이 실행됩니다. 이로 인해 스택의 정합성이 유지됩니다.
 */
public class ProfilingScope implements AutoCloseable {
    private ProfilingPoint point;
    private EchoProfiler profiler;
    private ProfilingScopePool pool;

    /**
     * 초기화 (객체 재사용을 위해 생성자 대신 사용)
     */
    void init(ProfilingPoint point, EchoProfiler profiler, ProfilingScopePool pool) {
        this.point = point;
        this.profiler = profiler;
        this.pool = pool;
    }

    @Override
    public void close() {
        if (profiler != null) {
            profiler.pop(point);
        }
        if (pool != null) {
            pool.release(this);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\ProfilingScopePool.java =====

package com.echo.measure;

/**
 * ProfilingScope 객체 풀 (Zero-Allocation)
 * 스레드당 하나씩 유지되어 동기화 불필요
 */
class ProfilingScopePool {
    private static final int POOL_SIZE = 16;
    private final ProfilingScope[] pool = new ProfilingScope[POOL_SIZE];
    private int index = 0;

    ProfilingScopePool() {
        for (int i = 0; i < POOL_SIZE; i++) {
            pool[i] = new ProfilingScope();
        }
    }

    ProfilingScope acquire(ProfilingPoint point, EchoProfiler profiler) {
        ProfilingScope scope;
        if (index > 0) {
            scope = pool[--index];
        } else {
            // 풀이 비어있으면 새로 생성 (드문 경우)
            scope = new ProfilingScope();
        }
        scope.init(point, profiler, this);
        return scope;
    }

    void release(ProfilingScope scope) {
        if (index < POOL_SIZE) {
            pool[index++] = scope;
        }
        // 풀이 가득 차면 버림 (GC가 정리)
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\RenderMetrics.java =====

package com.echo.measure;

import java.util.*;
import com.pulse.api.service.echo.RenderEfficiency;
import com.pulse.api.service.echo.IRenderMetrics;

/**
 * 렌더링 메트릭 수집기.
 * 
 * Phase 5.2: 렌더링 성능 모니터링.
 * Draw Call, 배치 통계, (가능시) GPU 시간 추적.
 * 
 * 참고: PZ의 렌더링 파이프라인 접근이 제한적이므로 가능한 범위 내에서 구현.
 * 
 * @since 1.0.1
 */
public class RenderMetrics implements IRenderMetrics {

    private static final RenderMetrics INSTANCE = new RenderMetrics();

    // Draw Call 통계
    private volatile long frameDrawCalls = 0;
    private volatile long totalDrawCalls = 0;
    private volatile long totalFrames = 0;

    // 배치 통계
    private volatile long frameBatches = 0;
    private volatile long totalBatches = 0;

    // 텍스처 스왑
    private volatile long frameTextureSwaps = 0;
    private volatile long totalTextureSwaps = 0;

    // 버텍스/인덱스 카운트
    private volatile long frameVertices = 0;
    private volatile long frameIndices = 0;

    // 프레임 타이밍
    private volatile double lastFrameTimeMs = 0;
    private volatile double avgFrameTimeMs = 0;
    private volatile double maxFrameTimeMs = 0;
    private final LinkedList<Double> frameTimeHistory = new LinkedList<>();
    private static final int HISTORY_SIZE = 60;

    // GPU 타이밍 (가능한 경우만)
    private volatile boolean gpuTimingAvailable = false;
    private volatile double gpuTimeMs = 0;

    public static RenderMetrics getInstance() {
        return INSTANCE;
    }

    /**
     * 프레임 시작
     */
    public void beginFrame() {
        frameDrawCalls = 0;
        frameBatches = 0;
        frameTextureSwaps = 0;
        frameVertices = 0;
        frameIndices = 0;
    }

    /**
     * 프레임 종료
     */
    public void endFrame(double frameTimeMs) {
        this.lastFrameTimeMs = frameTimeMs;
        totalFrames++;
        totalDrawCalls += frameDrawCalls;
        totalBatches += frameBatches;
        totalTextureSwaps += frameTextureSwaps;

        this.maxFrameTimeMs = Math.max(maxFrameTimeMs, frameTimeMs);

        synchronized (frameTimeHistory) {
            frameTimeHistory.addLast(frameTimeMs);
            while (frameTimeHistory.size() > HISTORY_SIZE) {
                frameTimeHistory.removeFirst();
            }

            double sum = 0;
            for (double t : frameTimeHistory) {
                sum += t;
            }
            avgFrameTimeMs = sum / frameTimeHistory.size();
        }
    }

    /**
     * Draw Call 기록
     */
    public void recordDrawCall() {
        frameDrawCalls++;
    }

    /**
     * 다수의 Draw Call 기록
     */
    public void recordDrawCalls(int count) {
        frameDrawCalls += count;
    }

    /**
     * 배치 기록
     */
    public void recordBatch() {
        frameBatches++;
    }

    /**
     * 텍스처 스왑 기록
     */
    public void recordTextureSwap() {
        frameTextureSwaps++;
    }

    /**
     * 지오메트리 기록
     */
    public void recordGeometry(int vertices, int indices) {
        frameVertices += vertices;
        frameIndices += indices;
    }

    /**
     * GPU 타이밍 업데이트 (OpenGL Query 사용 가능 시)
     */
    public void updateGpuTime(double gpuMs) {
        this.gpuTimingAvailable = true;
        this.gpuTimeMs = gpuMs;
    }

    // --- Getters ---

    public long getFrameDrawCalls() {
        return frameDrawCalls;
    }

    public double getAvgDrawCallsPerFrame() {
        return totalFrames > 0 ? (double) totalDrawCalls / totalFrames : 0;
    }

    public long getFrameBatches() {
        return frameBatches;
    }

    public double getBatchingEfficiency() {
        if (frameDrawCalls == 0)
            return 100;
        return (1.0 - (double) frameBatches / frameDrawCalls) * 100;
    }

    public long getFrameTextureSwaps() {
        return frameTextureSwaps;
    }

    public long getFrameVertices() {
        return frameVertices;
    }

    public long getFrameIndices() {
        return frameIndices;
    }

    public double getLastFrameTimeMs() {
        return lastFrameTimeMs;
    }

    @Override
    public double getAvgFrameTimeMs() {
        return avgFrameTimeMs;
    }

    public double getMaxFrameTimeMs() {
        return maxFrameTimeMs;
    }

    @Override
    public double getFps() {
        return avgFrameTimeMs > 0 ? 1000.0 / avgFrameTimeMs : 0;
    }

    public boolean isGpuTimingAvailable() {
        return gpuTimingAvailable;
    }

    public double getGpuTimeMs() {
        return gpuTimeMs;
    }

    public long getTotalFrames() {
        return totalFrames;
    }

    /**
     * 렌더 효율성 등급
     */
    @Override
    public RenderEfficiency getRenderEfficiency() {
        double batching = getBatchingEfficiency();
        double drawCalls = getAvgDrawCallsPerFrame();

        if (batching >= 80 && drawCalls < 500)
            return RenderEfficiency.EXCELLENT;
        if (batching >= 60 && drawCalls < 1000)
            return RenderEfficiency.GOOD;
        if (batching >= 40 || drawCalls < 2000)
            return RenderEfficiency.FAIR;
        return RenderEfficiency.POOR;
    }

    /**
     * 초기화
     */
    public void reset() {
        frameDrawCalls = 0;
        totalDrawCalls = 0;
        totalFrames = 0;
        frameBatches = 0;
        totalBatches = 0;
        frameTextureSwaps = 0;
        totalTextureSwaps = 0;
        frameVertices = 0;
        frameIndices = 0;
        lastFrameTimeMs = 0;
        avgFrameTimeMs = 0;
        maxFrameTimeMs = 0;
        gpuTimingAvailable = false;
        gpuTimeMs = 0;
        synchronized (frameTimeHistory) {
            frameTimeHistory.clear();
        }
    }

    /**
     * JSON 출력
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();

        // 프레임 통계
        Map<String, Object> frame = new LinkedHashMap<>();
        frame.put("total_frames", totalFrames);
        frame.put("fps", Math.round(getFps() * 10) / 10.0);
        frame.put("avg_frame_ms", Math.round(avgFrameTimeMs * 100) / 100.0);
        frame.put("max_frame_ms", Math.round(maxFrameTimeMs * 100) / 100.0);
        map.put("frame", frame);

        // Draw Call 통계
        Map<String, Object> drawCalls = new LinkedHashMap<>();
        drawCalls.put("per_frame", frameDrawCalls);
        drawCalls.put("avg_per_frame", Math.round(getAvgDrawCallsPerFrame()));
        drawCalls.put("total", totalDrawCalls);
        map.put("draw_calls", drawCalls);

        // 배칭 통계
        Map<String, Object> batching = new LinkedHashMap<>();
        batching.put("batches_per_frame", frameBatches);
        batching.put("total_batches", totalBatches);
        batching.put("efficiency_percent", Math.round(getBatchingEfficiency() * 10) / 10.0);
        map.put("batching", batching);

        // 텍스처 스왑
        map.put("texture_swaps_per_frame", frameTextureSwaps);
        map.put("total_texture_swaps", totalTextureSwaps);

        // 지오메트리
        Map<String, Object> geometry = new LinkedHashMap<>();
        geometry.put("vertices", frameVertices);
        geometry.put("indices", frameIndices);
        map.put("geometry", geometry);

        // GPU 타이밍
        if (gpuTimingAvailable) {
            map.put("gpu_time_ms", Math.round(gpuTimeMs * 100) / 100.0);
        }

        // 효율성 등급
        map.put("efficiency", getRenderEfficiency().name());

        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\SubProfiler.java =====

package com.echo.measure;

import com.echo.config.EchoConfig;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

/**
 * SubProfiler - Tick 내부 세부 측정 프로파일러
 * 
 * Tick 내에서 호출되는 주요 엔진 함수들의 실행 시간을 개별적으로 측정합니다.
 * Fuse 최적화 타겟을 자동으로 식별하기 위한 핵심 도구입니다.
 * 
 * 특징:
 * - Wave 기반 점진적 확장: 처음에는 최소한의 후킹 포인트만 사용
 * - Feature Flag: EchoConfig.enableSubTiming으로 활성화/비활성화
 * - Zero-Allocation 친화적 설계
 * 
 * @since Echo 1.0
 */
public class SubProfiler {

    private static final SubProfiler INSTANCE = new SubProfiler();

    // --- SubLabel ---

    /**
     * Wave 1: 최소 핵심 포인트 (3~5개)
     * Wave 2+: 점진적 확장
     */
    public enum SubLabel {
        // Wave 1 - 핵심 (첫 번째 구현)
        ZOMBIE_UPDATE(Category.AI, "ZombieUpdate", 1),
        PATHFINDING(Category.AI, "Pathfinding", 1),
        WORLD_UPDATE(Category.WORLD, "WorldUpdate", 1),

        // Wave 2 - 확장
        ISO_GRID_UPDATE(Category.WORLD, "IsoGrid.Update", 2),
        ISO_LIGHT_UPDATE(Category.RENDER, "IsoLight.Update", 2),
        ISO_GRID_RECALC(Category.WORLD, "IsoGrid.Recalc", 2),
        ISO_CELL_UPDATE(Category.WORLD, "IsoCell.Update", 2),
        RENDERING_PREP(Category.RENDER, "RenderingPrep", 2),
        SOUND_PROPAGATION(Category.AUDIO, "SoundManager", 2),

        // Wave 3 - 심층 분석 (Granular Configs)
        PATHFINDING_LOS(Category.AI, "Pathfinding.LOS", 3),
        PATHFINDING_GRID(Category.AI, "Pathfinding.Grid", 3),
        ZOMBIE_BEHAVIOR(Category.AI, "Zombie.Behavior", 3),
        ZOMBIE_MOTION(Category.AI, "Zombie.Motion", 3),
        ZOMBIE_PERCEPTION(Category.AI, "Zombie.Perception", 3),
        ZOMBIE_COLLISION(Category.AI, "Zombie.Collision", 3);

        private final Category category;
        private final String displayName;
        private final int wave; // 어느 Wave에서 활성화되는지

        SubLabel(Category category, String displayName, int wave) {
            this.category = category;
            this.displayName = displayName;
            this.wave = wave;
        }

        public Category getCategory() {
            return category;
        }

        public String getDisplayName() {
            return displayName;
        }

        public int getWave() {
            return wave;
        }

        /**
         * 현재 설정에서 이 라벨이 활성화되어야 하는지
         */
        public boolean isEnabledByConfig() {
            EchoConfig config = EchoConfig.getInstance();
            if (!config.isDeepAnalysisEnabled())
                return false;

            switch (this) {
                case PATHFINDING_LOS:
                case PATHFINDING_GRID:
                    return config.isEnablePathfindingDetails();
                case ZOMBIE_BEHAVIOR:
                case ZOMBIE_MOTION:
                case ZOMBIE_PERCEPTION:
                case ZOMBIE_COLLISION:
                case ZOMBIE_UPDATE:
                    // ZOMBIE_UPDATE is base, effectively guarded by deepAnalysis,
                    // but if details are on, we might want it too.
                    // Actually ZOMBIE_UPDATE exists in Wave 1.
                    // Wave 1 items should be enabled if deepAnalysisEnabled is true.
                    return this.wave == 1 || config.isEnableZombieDetails();
                case ISO_GRID_RECALC:
                case ISO_CELL_UPDATE:

                    return this.wave == 1 || config.isEnableIsoGridDetails();
                default:
                    return true;
            }
        }

        public enum Category {
            AI("AI", "#FF6B6B"),
            WORLD("World", "#4ECDC4"),
            RENDER("Render", "#FFE66D"),
            AUDIO("Audio", "#95E1D3"),
            PHYSICS("Physics", "#DDA0DD");

            private final String displayName;
            private final String color;

            Category(String displayName, String color) {
                this.displayName = displayName;
                this.color = color;
            }

            public String getDisplayName() {
                return displayName;
            }

            public String getColor() {
                return color;
            }
        }
    }

    // --- SubTimingData ---

    public static class SubTimingData {
        private final SubLabel label;
        private final LongAdder callCount = new LongAdder();
        private final LongAdder totalMicros = new LongAdder();
        private final AtomicLong maxMicros = new AtomicLong(0);
        private final AtomicLong lastMicros = new AtomicLong(0);

        public SubTimingData(SubLabel label) {
            this.label = label;
        }

        public void record(long durationMicros) {
            callCount.increment();
            totalMicros.add(durationMicros);
            lastMicros.set(durationMicros);

            // Update max (lock-free)
            long currentMax;
            do {
                currentMax = maxMicros.get();
                if (durationMicros <= currentMax)
                    break;
            } while (!maxMicros.compareAndSet(currentMax, durationMicros));
        }

        public SubLabel getLabel() {
            return label;
        }

        public long getCallCount() {
            return callCount.sum();
        }

        public long getTotalMicros() {
            return totalMicros.sum();
        }

        public long getMaxMicros() {
            return maxMicros.get();
        }

        public long getLastMicros() {
            return lastMicros.get();
        }

        public double getAverageMicros() {
            long count = callCount.sum();
            return count > 0 ? (double) totalMicros.sum() / count : 0.0;
        }

        public double getTotalMs() {
            return totalMicros.sum() / 1000.0;
        }

        public double getAverageMs() {
            return getAverageMicros() / 1000.0;
        }

        public double getMaxMs() {
            return maxMicros.get() / 1000.0;
        }

        public void reset() {
            callCount.reset();
            totalMicros.reset();
            maxMicros.set(0);
            lastMicros.set(0);
        }

        public Map<String, Object> toMap() {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("label", label.getDisplayName());
            map.put("category", label.getCategory().getDisplayName());
            map.put("call_count", getCallCount());
            map.put("total_ms", getTotalMs());
            map.put("avg_ms", getAverageMs());
            map.put("max_ms", getMaxMs());
            return map;
        }
    }

    // --- Fields ---

    private final Map<SubLabel, SubTimingData> subTimings = new ConcurrentHashMap<>();
    private final Map<SubLabel, Long> activeStarts = new ConcurrentHashMap<>();

    private SubProfiler() {
        // 모든 라벨에 대해 SubTimingData 초기화
        for (SubLabel label : SubLabel.values()) {
            subTimings.put(label, new SubTimingData(label));
        }
    }

    public static SubProfiler getInstance() {
        return INSTANCE;
    }

    // --- Measurement API ---

    /**
     * 서브타이밍 측정 시작
     * 
     * @param label 측정 라벨
     */
    public void start(SubLabel label) {
        if (!isEnabled() || !label.isEnabledByConfig()) {
            return;
        }
        activeStarts.put(label, System.nanoTime());
    }

    /**
     * 서브타이밍 측정 종료
     * 
     * @param label 측정 라벨
     */
    public void end(SubLabel label) {
        if (!isEnabled() || !label.isEnabledByConfig()) {
            return;
        }

        Long startTime = activeStarts.remove(label);
        if (startTime == null) {
            return; // start() 호출 없이 end() 호출됨
        }

        long elapsedNanos = System.nanoTime() - startTime;
        long elapsedMicros = elapsedNanos / 1000;

        SubTimingData data = subTimings.get(label);
        if (data != null) {
            data.record(elapsedMicros);
        }
    }

    /**
     * Raw API - 시작 시간 반환 (Zero-Allocation)
     */
    public long startRaw(SubLabel label) {
        if (!isEnabled() || !label.isEnabledByConfig()) {
            return -1;
        }
        return System.nanoTime();
    }

    /**
     * Raw API - 종료 및 기록 (Zero-Allocation)
     */
    public void endRaw(SubLabel label, long startNanos) {
        if (startNanos < 0) {
            return;
        }

        long elapsedNanos = System.nanoTime() - startNanos;
        long elapsedMicros = elapsedNanos / 1000;

        SubTimingData data = subTimings.get(label);
        if (data != null) {
            data.record(elapsedMicros);
        }
    }

    // --- Query API ---

    /**
     * SubTiming 활성화 여부
     */
    public boolean isEnabled() {
        return EchoConfig.getInstance().isDeepAnalysisEnabled();
    }

    /**
     * 데이터가 있는 엔트리 수 반환 (SelfValidation용)
     * 
     * @since Echo 0.9.0
     */
    public int getEntryCount() {
        int count = 0;
        for (SubTimingData data : subTimings.values()) {
            if (data.getCallCount() > 0) {
                count++;
            }
        }
        return count;
    }

    /**
     * 모든 SubTimingData 조회
     */
    public Collection<SubTimingData> getAllTimings() {
        return Collections.unmodifiableCollection(subTimings.values());
    }

    /**
     * 현재 실행 중인(종료되지 않은) 라벨들의 진행 시간(ms) 반환
     */
    public Map<SubLabel, Double> getActiveDurations() {
        Map<SubLabel, Double> result = new LinkedHashMap<>();
        long now = System.nanoTime();

        // activeStarts is concurrent, so safe to iterate
        for (Map.Entry<SubLabel, Long> entry : activeStarts.entrySet()) {
            double ms = (now - entry.getValue()) / 1000.0 / 1000.0;
            result.put(entry.getKey(), ms);
        }
        return result;
    }

    /**
     * 특정 라벨의 SubTimingData 조회
     */
    public SubTimingData getTimingData(SubLabel label) {
        return subTimings.get(label);
    }

    /**
     * Top N 반환 (총 시간 기준)
     */
    public List<SubTimingData> getTopNByTotalTime(int n) {
        List<SubTimingData> sorted = new ArrayList<>(subTimings.values());
        sorted.removeIf(d -> d.getCallCount() == 0);
        sorted.sort((a, b) -> Long.compare(b.getTotalMicros(), a.getTotalMicros()));
        return sorted.subList(0, Math.min(n, sorted.size()));
    }

    /**
     * Top N 반환 (최대 시간 기준 - 스파이크 탐지)
     */
    public List<SubTimingData> getTopNByMaxTime(int n) {
        List<SubTimingData> sorted = new ArrayList<>(subTimings.values());
        sorted.removeIf(d -> d.getCallCount() == 0);
        sorted.sort((a, b) -> Long.compare(b.getMaxMicros(), a.getMaxMicros()));
        return sorted.subList(0, Math.min(n, sorted.size()));
    }

    /**
     * 카테고리별 SubTimingData 조회
     */
    public List<SubTimingData> getByCategory(SubLabel.Category category) {
        List<SubTimingData> result = new ArrayList<>();
        for (SubTimingData data : subTimings.values()) {
            if (data.getLabel().getCategory() == category && data.getCallCount() > 0) {
                result.add(data);
            }
        }
        return result;
    }

    /**
     * 모든 SubTimingData를 heavy_functions 형식으로 반환
     */
    public List<Map<String, Object>> getHeavyFunctions(int topN) {
        List<Map<String, Object>> result = new ArrayList<>();
        List<SubTimingData> top = getTopNByTotalTime(topN);

        int rank = 1;
        for (SubTimingData data : top) {
            Map<String, Object> entry = data.toMap();
            entry.put("rank", rank++);
            result.add(entry);
        }

        return result;
    }

    /**
     * 초기화
     */
    public void reset() {
        for (SubTimingData data : subTimings.values()) {
            data.reset();
        }
        activeStarts.clear();
    }

    /**
     * JSON 출력용 Map
     */
    public Map<String, Object> toMap() {
        Map<String, Object> result = new LinkedHashMap<>();
        result.put("enabled", isEnabled());
        result.put("heavy_functions", getHeavyFunctions(10));

        // 카테고리별 요약
        Map<String, Double> categoryTotals = new LinkedHashMap<>();
        for (SubLabel.Category cat : SubLabel.Category.values()) {
            double total = 0;
            for (SubTimingData data : getByCategory(cat)) {
                total += data.getTotalMs();
            }
            if (total > 0) {
                categoryTotals.put(cat.getDisplayName(), total);
            }
        }
        result.put("category_totals_ms", categoryTotals);

        return result;
    }

    /**
     * 콘솔 출력
     */
    public void printStats(int topN) {
        if (!isEnabled()) {
            System.out.println("[Echo/SubProfiler] SubTiming is disabled");
            return;
        }

        System.out.println("\n[Echo/SubProfiler] Heavy Functions (Top " + topN + "):");
        System.out.println("─────────────────────────────────────────────────────────────────");
        System.out.printf("%-4s %-20s %-10s %10s %10s %10s%n",
                "Rank", "Label", "Category", "Total(ms)", "Avg(ms)", "Max(ms)");
        System.out.println("─────────────────────────────────────────────────────────────────");

        int rank = 1;
        for (SubTimingData data : getTopNByTotalTime(topN)) {
            System.out.printf("%-4d %-20s %-10s %10.2f %10.2f %10.2f%n",
                    rank++,
                    data.getLabel().getDisplayName(),
                    data.getLabel().getCategory().getDisplayName(),
                    data.getTotalMs(),
                    data.getAverageMs(),
                    data.getMaxMs());
        }
        System.out.println();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\measure\TickPhaseProfiler.java =====

package com.echo.measure;

import com.echo.config.EchoConfig;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

/**
 * Tick Phase 분해 프로파일러
 * 
 * 게임 틱을 여러 단계(AI, Physics, World Update, Rendering Prep, IsoGrid)로
 * 분해하여 각 단계별 소요 시간을 측정합니다.
 * 
 * Fuse 개발 시 "AI Phase만 20→10ms로 줄었다" 같은 정량화가 가능해집니다.
 * 
 * @since Echo 1.0
 */
public class TickPhaseProfiler {

    private static final TickPhaseProfiler INSTANCE = new TickPhaseProfiler();

    // --- TickPhase Enum ---

    public enum TickPhase {
        AI_PHASE("AI Phase", "#FF6B6B"),
        PHYSICS_PHASE("Physics Phase", "#4ECDC4"),
        WORLD_UPDATE("World Update", "#FFE66D"),
        RENDERING_PREP("Rendering Prep", "#95E1D3"),
        ISO_GRID_UPDATE("IsoGrid Update", "#DDA0DD");

        private final String displayName;
        private final String color;

        TickPhase(String displayName, String color) {
            this.displayName = displayName;
            this.color = color;
        }

        public String getDisplayName() {
            return displayName;
        }

        public String getColor() {
            return color;
        }
    }

    // --- PhaseTimingData - 단계별 타이밍 데이터 ---

    public static class PhaseTimingData {
        private final TickPhase phase;
        private final LongAdder callCount = new LongAdder();
        private final LongAdder totalMicros = new LongAdder();
        private final AtomicLong maxMicros = new AtomicLong(0);
        private final AtomicLong lastMicros = new AtomicLong(0);

        public PhaseTimingData(TickPhase phase) {
            this.phase = phase;
        }

        public void record(long durationMicros) {
            callCount.increment();
            totalMicros.add(durationMicros);
            lastMicros.set(durationMicros);

            // Update max (lock-free)
            long currentMax;
            do {
                currentMax = maxMicros.get();
                if (durationMicros <= currentMax)
                    break;
            } while (!maxMicros.compareAndSet(currentMax, durationMicros));
        }

        public TickPhase getPhase() {
            return phase;
        }

        public long getCallCount() {
            return callCount.sum();
        }

        public long getTotalMicros() {
            return totalMicros.sum();
        }

        public long getMaxMicros() {
            return maxMicros.get();
        }

        public long getLastMicros() {
            return lastMicros.get();
        }

        public double getAverageMicros() {
            long count = callCount.sum();
            return count > 0 ? (double) totalMicros.sum() / count : 0.0;
        }

        public double getTotalMs() {
            return totalMicros.sum() / 1000.0;
        }

        public double getAverageMs() {
            return getAverageMicros() / 1000.0;
        }

        public double getMaxMs() {
            return maxMicros.get() / 1000.0;
        }

        public double getLastMs() {
            return lastMicros.get() / 1000.0;
        }

        public void reset() {
            callCount.reset();
            totalMicros.reset();
            maxMicros.set(0);
            lastMicros.set(0);
        }

        public Map<String, Object> toMap() {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("phase", phase.getDisplayName());
            map.put("call_count", getCallCount());
            map.put("total_ms", getTotalMs());
            map.put("avg_ms", getAverageMs());
            map.put("max_ms", getMaxMs());
            map.put("last_ms", getLastMs());
            return map;
        }
    }

    // --- 필드 ---

    private final Map<TickPhase, PhaseTimingData> phaseTimings = new EnumMap<>(TickPhase.class);
    private final Map<TickPhase, Long> activeStarts = new EnumMap<>(TickPhase.class);

    // 현재 틱의 Phase별 시간 (틱 완료 시 리셋)
    private final Map<TickPhase, Long> currentTickPhases = new EnumMap<>(TickPhase.class);

    private TickPhaseProfiler() {
        for (TickPhase phase : TickPhase.values()) {
            phaseTimings.put(phase, new PhaseTimingData(phase));
        }
    }

    public static TickPhaseProfiler getInstance() {
        return INSTANCE;
    }

    // --- 측정 API ---

    /**
     * Phase 측정 시작
     */
    public void startPhase(TickPhase phase) {
        if (!isEnabled())
            return;
        activeStarts.put(phase, System.nanoTime());
    }

    /**
     * Phase 측정 종료
     */
    public void endPhase(TickPhase phase) {
        if (!isEnabled())
            return;

        Long startTime = activeStarts.remove(phase);
        if (startTime == null)
            return;

        long elapsedNanos = System.nanoTime() - startTime;
        long elapsedMicros = elapsedNanos / 1000;

        PhaseTimingData data = phaseTimings.get(phase);
        if (data != null) {
            data.record(elapsedMicros);
        }

        // 현재 틱 Phase 시간 누적
        currentTickPhases.merge(phase, elapsedMicros, Long::sum);
    }

    /**
     * Raw API - 시작 시간 반환 (Zero-Allocation)
     */
    public long startPhaseRaw(TickPhase phase) {
        if (!isEnabled())
            return -1;
        return System.nanoTime();
    }

    /**
     * Raw API - 종료 및 기록 (Zero-Allocation)
     */
    public void endPhaseRaw(TickPhase phase, long startNanos) {
        if (startNanos < 0)
            return;

        long elapsedNanos = System.nanoTime() - startNanos;
        long elapsedMicros = elapsedNanos / 1000;

        PhaseTimingData data = phaseTimings.get(phase);
        if (data != null) {
            data.record(elapsedMicros);
        }

        currentTickPhases.merge(phase, elapsedMicros, Long::sum);
    }

    /**
     * 틱 완료 시 현재 틱의 Phase 타이밍 리셋
     */
    public void onTickComplete() {
        currentTickPhases.clear();
    }

    // --- 조회 API ---

    public boolean isEnabled() {
        return EchoConfig.getInstance().isDeepAnalysisEnabled();
    }

    public PhaseTimingData getPhaseData(TickPhase phase) {
        return phaseTimings.get(phase);
    }

    public Collection<PhaseTimingData> getAllPhaseData() {
        return Collections.unmodifiableCollection(phaseTimings.values());
    }

    /**
     * 데이터가 있는 Phase 수 반환 (Quality Scorer용)
     * 
     * @since Echo 0.9.0
     */
    public int getTotalPhaseCount() {
        int count = 0;
        for (PhaseTimingData data : phaseTimings.values()) {
            if (data.getCallCount() > 0) {
                count++;
            }
        }
        return count;
    }

    /**
     * 현재 틱의 Phase별 시간 반환 (ms 단위)
     */
    public Map<TickPhase, Double> getCurrentTickPhaseMs() {
        Map<TickPhase, Double> result = new EnumMap<>(TickPhase.class);
        for (Map.Entry<TickPhase, Long> entry : currentTickPhases.entrySet()) {
            result.put(entry.getKey(), entry.getValue() / 1000.0);
        }
        return result;
    }

    /**
     * 전체 Phase 합계 대비 비율 반환
     */
    public Map<TickPhase, Double> getPhasePercentages() {
        Map<TickPhase, Double> result = new EnumMap<>(TickPhase.class);
        long total = 0;

        for (PhaseTimingData data : phaseTimings.values()) {
            total += data.getTotalMicros();
        }

        if (total > 0) {
            for (Map.Entry<TickPhase, PhaseTimingData> entry : phaseTimings.entrySet()) {
                double percentage = (entry.getValue().getTotalMicros() * 100.0) / total;
                result.put(entry.getKey(), percentage);
            }
        }

        return result;
    }

    /**
     * 초기화
     */
    public void reset() {
        for (PhaseTimingData data : phaseTimings.values()) {
            data.reset();
        }
        activeStarts.clear();
        currentTickPhases.clear();
    }

    /**
     * JSON 출력용 Map
     */
    public Map<String, Object> toMap() {
        Map<String, Object> result = new LinkedHashMap<>();
        result.put("enabled", isEnabled());

        List<Map<String, Object>> phases = new ArrayList<>();
        for (PhaseTimingData data : phaseTimings.values()) {
            if (data.getCallCount() > 0) {
                phases.add(data.toMap());
            }
        }
        result.put("phases", phases);

        // 비율 추가
        Map<String, Double> percentages = new LinkedHashMap<>();
        for (Map.Entry<TickPhase, Double> entry : getPhasePercentages().entrySet()) {
            percentages.put(entry.getKey().getDisplayName(),
                    Math.round(entry.getValue() * 100.0) / 100.0);
        }
        result.put("percentages", percentages);

        return result;
    }

    /**
     * 콘솔 출력
     */
    public void printStats() {
        if (!isEnabled()) {
            System.out.println("[Echo/TickPhase] Tick Phase Breakdown is disabled");
            return;
        }

        System.out.println("\n[Echo/TickPhase] Tick Phase Breakdown:");
        System.out.println("─────────────────────────────────────────────────────────────────");
        System.out.printf("%-20s %10s %10s %10s %8s%n",
                "Phase", "Total(ms)", "Avg(ms)", "Max(ms)", "%");
        System.out.println("─────────────────────────────────────────────────────────────────");

        Map<TickPhase, Double> percentages = getPhasePercentages();

        for (PhaseTimingData data : phaseTimings.values()) {
            if (data.getCallCount() > 0) {
                double pct = percentages.getOrDefault(data.getPhase(), 0.0);
                System.out.printf("%-20s %10.2f %10.2f %10.2f %7.1f%%%n",
                        data.getPhase().getDisplayName(),
                        data.getTotalMs(),
                        data.getAverageMs(),
                        data.getMaxMs(),
                        pct);
            }
        }
        System.out.println();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\monitor\EchoMonitorServer.java =====

package com.echo.monitor;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.aggregate.TimingData;
import com.echo.aggregate.TickHistogram;
import com.echo.aggregate.SpikeLog;
import com.echo.measure.MemoryProfiler;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpExchange;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.nio.charset.StandardCharsets;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.Executors;

/**
 * Echo 실시간 모니터링 HTTP 서버
 * 
 * 외부 도구에서 프로파일링 데이터에 접근할 수 있는 간단한 REST API 제공
 */
public class EchoMonitorServer {

    private static final int DEFAULT_PORT = 8765;
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static EchoMonitorServer instance;
    private HttpServer server;
    private boolean running = false;

    private EchoMonitorServer() {
    }

    public static EchoMonitorServer getInstance() {
        if (instance == null) {
            instance = new EchoMonitorServer();
        }
        return instance;
    }

    /**
     * 서버 시작
     */
    public void start() {
        start(DEFAULT_PORT);
    }

    public void start(int port) {
        if (running) {
            System.out.println("[Echo] Monitor server already running on port " + server.getAddress().getPort());
            return;
        }

        try {
            server = HttpServer.create(new InetSocketAddress(port), 0);
            server.setExecutor(Executors.newFixedThreadPool(2));

            // API 엔드포인트 등록
            server.createContext("/api/status", new StatusHandler());
            server.createContext("/api/summary", new SummaryHandler());
            server.createContext("/api/histogram", new HistogramHandler());
            server.createContext("/api/spikes", new SpikesHandler());
            server.createContext("/api/memory", new MemoryHandler());
            server.createContext("/", new RootHandler());

            server.start();
            running = true;
            System.out.println("[Echo] Monitor server started on http://localhost:" + port);
            System.out.println("[Echo] Endpoints: /api/status, /api/summary, /api/histogram, /api/spikes, /api/memory");
        } catch (IOException e) {
            System.err.println("[Echo] Failed to start monitor server: " + e.getMessage());
        }
    }

    /**
     * 서버 중지
     */
    public void stop() {
        if (!running || server == null) {
            System.out.println("[Echo] Monitor server not running");
            return;
        }

        server.stop(1);
        running = false;
        System.out.println("[Echo] Monitor server stopped");
    }

    public boolean isRunning() {
        return running;
    }

    // --- HTTP Handlers ---

    private static class RootHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            String response = "Echo Profiler Monitor API\n\n" +
                    "Endpoints:\n" +
                    "  GET /api/status    - Profiler status\n" +
                    "  GET /api/summary   - Tick summary\n" +
                    "  GET /api/histogram - Tick distribution\n" +
                    "  GET /api/spikes    - Recent spikes\n" +
                    "  GET /api/memory    - Memory stats\n";
            sendResponse(exchange, 200, response, "text/plain");
        }
    }

    private static class StatusHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            EchoProfiler profiler = EchoProfiler.getInstance();
            Map<String, Object> status = new LinkedHashMap<>();
            status.put("enabled", profiler.isEnabled());
            status.put("lua_profiling", profiler.isLuaProfilingEnabled());
            status.put("session_duration_seconds", profiler.getSessionDurationSeconds());
            status.put("current_stack_depth", profiler.getCurrentStackDepth());
            sendJsonResponse(exchange, status);
        }
    }

    private static class SummaryHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            EchoProfiler profiler = EchoProfiler.getInstance();
            TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);

            Map<String, Object> summary = new LinkedHashMap<>();
            if (tickData != null && tickData.getCallCount() > 0) {
                summary.put("total_ticks", tickData.getCallCount());
                summary.put("average_ms", round(tickData.getAverageMicros() / 1000.0));
                summary.put("max_ms", round(tickData.getMaxMicros() / 1000.0));
                summary.put("min_ms", round(tickData.getMinMicros() / 1000.0));

                TimingData.RollingStats stats5s = tickData.getStats5s();
                Map<String, Object> rolling = new LinkedHashMap<>();
                rolling.put("avg_ms", round(stats5s.getAverage() / 1000.0));
                rolling.put("max_ms", round(stats5s.getMax() / 1000.0));
                rolling.put("samples", stats5s.getSampleCount());
                summary.put("last_5s", rolling);
            }
            sendJsonResponse(exchange, summary);
        }
    }

    private static class HistogramHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            TickHistogram histogram = EchoProfiler.getInstance().getTickHistogram();
            sendJsonResponse(exchange, histogram.toMap());
        }
    }

    private static class SpikesHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            SpikeLog spikeLog = EchoProfiler.getInstance().getSpikeLog();
            sendJsonResponse(exchange, spikeLog.toMap());
        }
    }

    private static class MemoryHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            sendJsonResponse(exchange, MemoryProfiler.toMap());
        }
    }

    // --- Utility Methods ---

    private static void sendJsonResponse(HttpExchange exchange, Object data) throws IOException {
        String json = GSON.toJson(data);
        sendResponse(exchange, 200, json, "application/json");
    }

    private static void sendResponse(HttpExchange exchange, int status, String body, String contentType)
            throws IOException {
        exchange.getResponseHeaders().add("Content-Type", contentType + "; charset=UTF-8");
        exchange.getResponseHeaders().add("Access-Control-Allow-Origin", "*");
        byte[] bytes = body.getBytes(StandardCharsets.UTF_8);
        exchange.sendResponseHeaders(status, bytes.length);
        try (OutputStream os = exchange.getResponseBody()) {
            os.write(bytes);
        }
    }

    private static double round(double value) {
        return Math.round(value * 100.0) / 100.0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\EchoProfilerSink.java =====

package com.echo.pulse;

import com.echo.fuse.ZombieProfiler;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.ProfilerBridge;
import com.pulse.api.profiler.ProfilerSink;

/**
 * Echo의 ProfilerSink 구현.
 * 
 * Pulse의 ProfilerBridge에 등록되어,
 * Fuse가 보내는 zombie step 데이터를 ZombieProfiler로 전달.
 * 
 * @since Echo 2.0
 */
public class EchoProfilerSink implements ProfilerSink {

    private static EchoProfilerSink INSTANCE;

    private EchoProfilerSink() {
    }

    public static void register() {
        try {
            INSTANCE = new EchoProfilerSink();
            ProfilerBridge.setSink(INSTANCE);
            PulseLogger.info("Echo", "ProfilerSink registered with Pulse");
        } catch (Throwable t) {
            PulseLogger.error("Echo", "Failed to register ProfilerSink: " + t.getMessage());
        }
    }

    public static void unregister() {
        ProfilerBridge.clearSink();
        INSTANCE = null;
    }

    @Override
    public void recordZombieStep(String step, long durationMicros) {
        try {
            ZombieProfiler.ZombieStep zombieStep = ZombieProfiler.ZombieStep.valueOf(step);
            ZombieProfiler.getInstance().recordStep(zombieStep, durationMicros);
        } catch (IllegalArgumentException e) {
            // Unknown step name, ignore
        }
    }

    @Override
    public void incrementZombieUpdates() {
        ZombieProfiler.getInstance().incrementZombieUpdates();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\IsoGridBridge.java =====

package com.echo.pulse;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.IsoGridHook;

/**
 * Bridge for IsoGrid profiling hooks.
 */
public class IsoGridBridge implements IsoGridHook.IIsoGridCallback {

    private static IsoGridBridge INSTANCE;

    private final ThreadLocal<Long> floorStart = new ThreadLocal<>();
    private final ThreadLocal<Long> lightingStart = new ThreadLocal<>();
    private final ThreadLocal<Long> weatherStart = new ThreadLocal<>();
    private final ThreadLocal<Long> recalcStart = new ThreadLocal<>();

    private IsoGridBridge() {
    }

    public static void register() {
        if (INSTANCE != null)
            return;
        INSTANCE = new IsoGridBridge();
        IsoGridHook.setCallback(INSTANCE);

        // Phase 2: Sync fast-flag
        boolean detailsEnabled = com.echo.config.EchoConfig.getInstance().isEnableIsoGridDetails();

        PulseLogger.info("Echo", "IsoGridBridge registered with Pulse (Details: " + detailsEnabled + ")");
    }

    @Override
    public void onRecalcPropertiesStart() {
        long t = com.echo.measure.SubProfiler.getInstance()
                .startRaw(com.echo.measure.SubProfiler.SubLabel.ISO_GRID_RECALC);
        // We reuse a thread local or add new one?
        // Let's assume weatherStart is free or add a new one. Recalc is frequent.
        // Adding new ThreadLocal for Recalc.
        recalcStart.set(t);
    }

    @Override
    public void onRecalcPropertiesEnd() {
        Long start = recalcStart.get();
        if (start != null && start != -1) {
            com.echo.measure.SubProfiler.getInstance().endRaw(com.echo.measure.SubProfiler.SubLabel.ISO_GRID_RECALC,
                    start);
        }
    }

    @Override
    public void onFloorUpdateStart() {
        long t = com.echo.measure.SubProfiler.getInstance()
                .startRaw(com.echo.measure.SubProfiler.SubLabel.ISO_GRID_UPDATE);
        floorStart.set(t);
    }

    @Override
    public void onFloorUpdateEnd() {
        Long start = floorStart.get();
        if (start != null && start != -1) {
            com.echo.measure.SubProfiler.getInstance().endRaw(com.echo.measure.SubProfiler.SubLabel.ISO_GRID_UPDATE,
                    start);
        }
    }

    @Override
    public void onLightingUpdateStart() {
        long t = com.echo.measure.SubProfiler.getInstance()
                .startRaw(com.echo.measure.SubProfiler.SubLabel.ISO_LIGHT_UPDATE);
        lightingStart.set(t);
    }

    @Override
    public void onLightingUpdateEnd() {
        Long start = lightingStart.get();
        if (start != null && start != -1) {
            com.echo.measure.SubProfiler.getInstance().endRaw(com.echo.measure.SubProfiler.SubLabel.ISO_LIGHT_UPDATE,
                    start);
        }
    }

    @Override
    public void onWeatherImpactStart() {
        long t = com.echo.measure.SubProfiler.getInstance()
                .startRaw(com.echo.measure.SubProfiler.SubLabel.ISO_CELL_UPDATE); // Mapping to Cell Update for now
        weatherStart.set(t);
    }

    @Override
    public void onWeatherImpactEnd() {
        Long start = weatherStart.get();
        if (start != null && start != -1) {
            com.echo.measure.SubProfiler.getInstance().endRaw(com.echo.measure.SubProfiler.SubLabel.ISO_CELL_UPDATE,
                    start);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\LuaHookAdapter.java =====

package com.echo.pulse;

import com.echo.lua.LuaCallTracker;
import com.echo.measure.EchoProfiler;
import com.pulse.api.log.PulseLogger;
import com.pulse.hook.HookTypes;
import com.pulse.hook.HookTypes.ILuaCallCallback;
import com.pulse.hook.PulseHookRegistry;

/**
 * Pulse LUA_CALL Hook 어댑터 (v2.0 - 중계자 역할)
 * 
 * Pulse의 MixinKahluaThread가 브로드캐스트하는 Lua 호출을 수신하여
 * LuaCallTracker에 직접 위임합니다.
 * 
 * 기존 스택 관리 로직 제거 - LuaCallTracker가 전담.
 */
public class LuaHookAdapter implements ILuaCallCallback {

    private static LuaHookAdapter INSTANCE;
    private static volatile boolean registered = false;

    private final EchoProfiler profiler;
    private final LuaCallTracker tracker;

    public LuaHookAdapter(EchoProfiler profiler, LuaCallTracker tracker) {
        this.profiler = profiler;
        this.tracker = tracker;
    }

    /**
     * Pulse Hook Registry에 콜백 등록
     */
    public static void register() {
        if (registered) {
            PulseLogger.debug("Echo/LuaHook", "Already registered");
            return;
        }

        EchoProfiler profiler = EchoProfiler.getInstance();
        LuaCallTracker tracker = LuaCallTracker.getInstance();
        INSTANCE = new LuaHookAdapter(profiler, tracker);

        registerPulseLuaHookCallback(tracker, profiler);

        try {
            PulseHookRegistry.register(HookTypes.LUA_CALL, INSTANCE, "Echo");
            registered = true;

            int callbackCount = PulseHookRegistry.getCallbacks(HookTypes.LUA_CALL).size();
            PulseLogger.info("Echo/LuaHook", "✅ LUA_CALL callback registered (v2.0)");
            PulseLogger.debug("Echo/LuaHook", "lua_profiling.enabled = " + profiler.isLuaProfilingEnabled());
            PulseLogger.debug("Echo/LuaHook", "LUA_CALL callbacks count = " + callbackCount);
        } catch (Exception e) {
            PulseLogger.error("Echo/LuaHook", "❌ Failed to register LUA_CALL callback: " + e.getMessage());
            registered = false;
        }
    }

    private static void registerPulseLuaHookCallback(LuaCallTracker tracker, EchoProfiler profiler) {
        try {
            com.pulse.internal.InternalLuaHook.setCallback(
                    (eventName, durationMicros) -> {
                        tracker.recordEventCall(eventName, durationMicros, 1);
                    });

            com.pulse.internal.InternalLuaHook.setProfilingEnabled(profiler.isLuaProfilingEnabled());
            PulseLogger.info("Echo/LuaHook", "✅ InternalLuaHook callback registered");
        } catch (NoClassDefFoundError e) {
            PulseLogger.warn("Echo/LuaHook", "⚠ InternalLuaHook not available");
        } catch (Exception e) {
            PulseLogger.error("Echo/LuaHook", "❌ Failed to register InternalLuaHook: " + e.getMessage());
        }
    }

    public static void unregister() {
        if (!registered || INSTANCE == null)
            return;

        try {
            PulseHookRegistry.unregister(HookTypes.LUA_CALL, INSTANCE);
            PulseLogger.info("Echo/LuaHook", "LUA_CALL callback unregistered");
        } catch (Exception e) {
            PulseLogger.error("Echo/LuaHook", "Failed to unregister: " + e.getMessage());
        } finally {
            registered = false;
            INSTANCE = null;
        }
    }

    public static boolean isRegistered() {
        return registered;
    }

    // ─────────────────────────────────────────────────────────────
    // ILuaCallCallback Implementation (nanoTime 버전 사용)
    // ─────────────────────────────────────────────────────────────

    @Override
    public void onLuaCallStart(Object function, long startNanos) {
        // LuaCallTracker에 직접 위임 (스택 관리는 Tracker에서)
        tracker.recordCallStart(function, startNanos);
    }

    @Override
    public void onLuaCallEnd(Object function, long endNanos) {
        // LuaCallTracker에 직접 위임
        tracker.recordCallEnd(function, endNanos);
    }

    // Legacy 메서드 (하위 호환성 - 사용되지 않음)
    @Override
    public void onLuaCallStart(Object function) {
        // nanoTime 버전이 호출되므로 여기는 실행되지 않음
    }

    @Override
    public void onLuaCallEnd(Object function) {
        // nanoTime 버전이 호출되므로 여기는 실행되지 않음
    }

    /**
     * 진단 정보 출력
     */
    public static void printDiagnostics() {
        PulseLogger.info("Echo/LuaHook", "=== Diagnostics ===");
        PulseLogger.info("Echo/LuaHook", "registered = " + registered);
        if (INSTANCE != null) {
            PulseLogger.info("Echo/LuaHook", "lua_profiling.enabled = " + INSTANCE.profiler.isLuaProfilingEnabled());
            PulseLogger.info("Echo/LuaHook", "detailed_active = " + INSTANCE.tracker.isDetailedActive());
            PulseLogger.info("Echo/LuaHook", "total_calls = " + INSTANCE.tracker.getTotalCalls());
            PulseLogger.info("Echo/LuaHook", "sampled_calls = " + INSTANCE.tracker.getSampledCalls());
        }
        try {
            int count = PulseHookRegistry.getCallbacks(HookTypes.LUA_CALL).size();
            PulseLogger.info("Echo/LuaHook", "LUA_CALL callbacks = " + count);
        } catch (Exception e) {
            PulseLogger.warn("Echo/LuaHook", "LUA_CALL callbacks = (error: " + e.getMessage() + ")");
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\LuaProfiler.java =====

package com.echo.pulse;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;

/**
 * Lua 프로파일러
 * 
 * Lua 이벤트 및 함수 호출을 측정합니다.
 * On-Demand 방식으로 필요할 때만 활성화합니다.
 * 
 * 주의: Lua 호출은 빈도가 높으므로 성능 영향을 줄 수 있습니다.
 */
public class LuaProfiler {

    private static final EchoProfiler profiler = EchoProfiler.getInstance();

    /**
     * Lua 이벤트 래퍼
     */
    public static void profileEvent(String eventName, Runnable luaCallback) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            luaCallback.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_EVENT, eventName)) {
            luaCallback.run();
        }
    }

    /**
     * Lua 함수 호출 래퍼
     */
    public static void profileFunction(String functionName, Runnable luaFunction) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            luaFunction.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_FUNCTION, functionName)) {
            luaFunction.run();
        }
    }

    /**
     * 결과를 반환하는 Lua 함수 호출 래퍼
     */
    public static <T> T profileFunctionWithResult(String functionName, java.util.function.Supplier<T> luaFunction) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            return luaFunction.get();
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_FUNCTION, functionName)) {
            return luaFunction.get();
        }
    }

    /**
     * Lua GC 측정
     */
    public static void profileGC(Runnable gcTask) {
        if (!profiler.isEnabled() || !profiler.isLuaProfilingEnabled()) {
            gcTask.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.LUA_GC)) {
            gcTask.run();
        }
    }

    /**
     * Lua 프로파일링 활성화
     */
    public static void enable() {
        profiler.enableLuaProfiling();
    }

    /**
     * Lua 프로파일링 비활성화
     */
    public static void disable() {
        profiler.disableLuaProfiling();
    }

    /**
     * Lua 프로파일링 상태 확인
     */
    public static boolean isEnabled() {
        return profiler.isLuaProfilingEnabled();
    }

    /**
     * Lua 프로파일링 토글
     */
    public static boolean toggle() {
        if (profiler.isLuaProfilingEnabled()) {
            profiler.disableLuaProfiling();
            return false;
        } else {
            profiler.enableLuaProfiling();
            return true;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\OptimizationPointSync.java =====

package com.echo.pulse;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.optimization.OptimizationPointRegistry;
import com.pulse.api.optimization.OptimizationPointRegistry.OptimizationPointInfo;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Pulse OptimizationPointRegistry와 Echo 측정 시스템 동기화
 * 
 * Pulse에 등록된 모든 최적화 포인트를 Echo 프로파일러에서
 * 동적으로 사용할 수 있도록 합니다.
 * 
 * @since 2.0.0 - Pulse Native Integration
 */
public class OptimizationPointSync {

    // 동기화된 포인트 캐시
    private static final Map<String, OptimizationPointInfo> loadedPoints = new ConcurrentHashMap<>();

    // 동기화 상태
    private static boolean synced = false;

    private OptimizationPointSync() {
        // Utility class
    }

    /**
     * Pulse OptimizationPointRegistry에서 모든 포인트 동기화
     * EchoMod.init()에서 호출됨
     */
    public static void syncFromPulse() {
        if (synced) {
            PulseLogger.debug("Echo", "OptimizationPoint already synced");
            return;
        }

        try {
            Collection<OptimizationPointInfo> all = OptimizationPointRegistry.getAll();

            for (OptimizationPointInfo info : all) {
                loadedPoints.put(info.getId(), info);
            }

            synced = true;
            PulseLogger.info("Echo", "Synced " + loadedPoints.size() + " optimization points from Pulse");

            int count = 0;
            for (OptimizationPointInfo info : loadedPoints.values()) {
                if (count++ >= 5) {
                    PulseLogger.debug("Echo", "... and " + (loadedPoints.size() - 5) + " more");
                    break;
                }
                PulseLogger.debug("Echo", "- " + info.getId() + " (tier " + info.getTier() + ")");
            }
        } catch (Exception e) {
            PulseLogger.error("Echo", "Failed to sync optimization points: " + e.getMessage());
        }
    }

    /**
     * 동기화된 모든 포인트 반환
     * 
     * @return 불변 컬렉션
     */
    public static Collection<OptimizationPointInfo> getPoints() {
        return Collections.unmodifiableCollection(loadedPoints.values());
    }

    /**
     * ID로 포인트 조회
     * 
     * @param id 포인트 ID
     * @return OptimizationPointInfo or null
     */
    public static OptimizationPointInfo getPoint(String id) {
        return loadedPoints.get(id);
    }

    /**
     * 포인트 ID 존재 여부 확인
     * 
     * @param id 포인트 ID
     * @return 존재하면 true
     */
    public static boolean hasPoint(String id) {
        return loadedPoints.containsKey(id);
    }

    /**
     * 동기화된 포인트 수
     */
    public static int getPointCount() {
        return loadedPoints.size();
    }

    /**
     * 동기화 상태 확인
     */
    public static boolean isSynced() {
        return synced;
    }

    /**
     * Echo 라벨로 포인트 찾기
     * 
     * @param echoPrefix Echo 라벨 접두사
     * @return Optional containing the info
     */
    public static Optional<OptimizationPointInfo> findByEchoPrefix(String echoPrefix) {
        return loadedPoints.values().stream()
                .filter(info -> echoPrefix.equals(info.getEchoPrefix()))
                .findFirst();
    }

    /**
     * Tier로 포인트 필터링
     * 
     * @param tier Tier 레벨
     * @return 해당 Tier의 포인트 목록
     */
    public static List<OptimizationPointInfo> getPointsByTier(int tier) {
        return loadedPoints.values().stream()
                .filter(info -> info.getTier() == tier)
                .toList();
    }

    /**
     * 동기화 초기화 (테스트용)
     */
    public static void reset() {
        loadedPoints.clear();
        synced = false;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\PathfindingBridge.java =====

package com.echo.pulse;

import com.echo.fuse.PathfindingProfiler;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.PathfindingHook;

/**
 * Bridge between Pulse Mixins and Echo's PathfindingProfiler.
 * Handles timing calculation using ThreadLocal.
 */
public class PathfindingBridge implements PathfindingHook.IPathfindingCallback {

    private static PathfindingBridge INSTANCE;

    private final ThreadLocal<Long> losStart = new ThreadLocal<>();
    private final ThreadLocal<Long> gridStart = new ThreadLocal<>();

    private PathfindingBridge() {
    }

    public static void register() {
        if (INSTANCE != null)
            return;
        INSTANCE = new PathfindingBridge();
        PathfindingHook.setCallback(INSTANCE);

        // Phase 2: Sync fast-flag
        boolean enabled = com.echo.config.EchoConfig.getInstance().isEnablePathfindingDetails();

        PulseLogger.info("Echo", "PathfindingBridge registered with Pulse (Details: " + enabled + ")");
    }

    @Override
    public void onLosCalculationStart() {
        // Zero-Allocation Start (ThreadLocal for thread safety)
        long t = com.echo.measure.SubProfiler.getInstance()
                .startRaw(com.echo.measure.SubProfiler.SubLabel.PATHFINDING_LOS);
        losStart.set(t);
    }

    @Override
    public void onLosCalculationEnd() {
        Long start = losStart.get();
        if (start != null && start != -1) {
            com.echo.measure.SubProfiler.getInstance().endRaw(com.echo.measure.SubProfiler.SubLabel.PATHFINDING_LOS,
                    start);
        }
    }

    @Override
    public void onGridSearchStart() {
        // Map Grid Search to Generic Pathfinding or specific if we add PATHFINDING_GRID
        // later
        long t = com.echo.measure.SubProfiler.getInstance()
                .startRaw(com.echo.measure.SubProfiler.SubLabel.PATHFINDING_GRID);
        gridStart.set(t);
    }

    @Override
    public void onGridSearchEnd() {
        Long start = gridStart.get();
        if (start != null && start != -1) {
            com.echo.measure.SubProfiler.getInstance().endRaw(com.echo.measure.SubProfiler.SubLabel.PATHFINDING_GRID,
                    start);
        }
    }

    @Override
    public void onPathRequest() {
        PathfindingProfiler.getInstance().incrementPathRequests();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\PulseEventAdapter.java =====

package com.echo.pulse;

import com.echo.EchoMod;
import com.echo.measure.FreezeDetector;
import com.echo.session.SessionManager;
import com.pulse.api.log.PulseLogger;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.event.lifecycle.GameTickStartEvent;
import com.pulse.event.lifecycle.GameTickEndEvent;
import com.pulse.event.lifecycle.WorldLoadEvent;
import com.pulse.event.lifecycle.WorldUnloadEvent;
import com.pulse.event.gui.GuiRenderEvent;

import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Pulse 이벤트 버스 어댑터
 * 
 * Pulse EventBus API를 직접 사용하여 Echo 프로파일러와 연결합니다.
 * 
 * @since 2.0.0 - Pulse Native Integration (Reflection 제거)
 * @since 2.1.0 - Session-based recording (WorldLoad/Unload)
 */
public class PulseEventAdapter {

    private static final AtomicBoolean registered = new AtomicBoolean(false);
    private static TickProfiler tickProfiler;
    private static RenderProfiler renderProfiler;

    /**
     * Pulse 이벤트 버스에 리스너 등록
     * EchoMod.init()에서 호출됨
     */
    public static void register() {
        if (!registered.compareAndSet(false, true)) {
            PulseLogger.debug("Echo", "Pulse adapter already registered");
            return;
        }

        tickProfiler = new TickProfiler();
        renderProfiler = new RenderProfiler();

        // Pulse EventBus 직접 구독 (v2.0 Native)

        // v0.9: GameTickStartEvent - 틱 시작 (계약 검증용)
        EventBus.subscribe(GameTickStartEvent.class, event -> {
            tickProfiler.onTickStart();

            if (event.getTick() == 1) {
                PulseLogger.debug("Echo", "First GameTickStartEvent received!");
            }
        }, EchoMod.MOD_ID);

        // v0.9: GameTickEndEvent - 정밀 틱 소요 시간 기록 (Primary API)
        EventBus.subscribe(GameTickEndEvent.class, event -> {
            // Echo 1.0: FreezeDetector 생존 신고
            FreezeDetector.getInstance().tick();

            // 정밀 타이밍 기록 (Pulse에서 계산한 nanos 사용)
            tickProfiler.recordTickDuration(event.getDurationNanos());

            // Phase 3: Metric Collection
            com.echo.measure.EchoProfiler.getInstance().getMetricCollector().collect(tickProfiler, renderProfiler);
            com.echo.fuse.ZombieProfiler.getInstance().endTick();

            // v2.1: 세션 데이터 수집 마킹
            SessionManager.getInstance().onTick();

            // v1.1: 주기적 Echo 상태 로깅 (60초마다)
            if (event.getTick() > 0 && event.getTick() % 3600 == 0) {
                logEchoStatusSummary();
            }

            if (event.getTick() == 1) {
                PulseLogger.debug("Echo", "First GameTickEndEvent received! durationMs=" + event.getDurationMs());
            }
            if (event.getTick() % 1000 == 0) {
                PulseLogger.debug("Echo", String.format("GameTickEndEvent #%d, durationMs=%.4f",
                        event.getTick(), event.getDurationMs()));
            }
        }, EchoMod.MOD_ID);

        // Legacy: GameTickEvent - 하위 호환성 유지 (deltaTime 기반 계약 검증)
        // GameTickEvent는 틱 완료 후 발생하므로 Pre/Post가 아닌 단일 이벤트로 처리
        EventBus.subscribe(GameTickEvent.class, event -> {
            // Contract 검증만 수행 (Start/End가 primary)
            com.echo.validation.PulseContractVerifier.getInstance().onGameTick(event.getDeltaTime());

            if (event.getTick() == 1) {
                PulseLogger.debug("Echo", "First GameTickEvent received (legacy) deltaTime=" + event.getDeltaTime());
            }
        }, EchoMod.MOD_ID);

        EventBus.subscribe(GuiRenderEvent.class, event -> {
            // 렌더 프레임 시작 알림
            PulseMetricsAdapter.onFrameStart();
            renderProfiler.onRenderPre();
        }, EchoMod.MOD_ID);

        // v2.1: 세션 라이프사이클 이벤트
        EventBus.subscribe(WorldLoadEvent.class, event -> {
            boolean isMP = isMultiplayerWorld();
            SessionManager.getInstance().onWorldLoad(event.getWorldName(), isMP);
        }, EchoMod.MOD_ID);

        EventBus.subscribe(WorldUnloadEvent.class, event -> {
            SessionManager.getInstance().onWorldUnload();
        }, EchoMod.MOD_ID);

        // v2.1: 메인 메뉴 렌더 이벤트 구독 - 세션 종료 감지
        EventBus.subscribe(com.pulse.event.lifecycle.MainMenuRenderEvent.class, event -> {
            SessionManager.getInstance().onMainMenuRender();
        }, EchoMod.MOD_ID);

        // Lua Call Hook (On-Demand profiling)
        LuaHookAdapter.register();

        try {
            com.echo.lua.DetailedWindowManager.getInstance()
                    .startManualCapture(5000);
            PulseLogger.info("Echo", "✓ Initial Detailed Window opened (5s auto-capture)");
        } catch (Exception e) {
            PulseLogger.error("Echo", "Failed to open initial Detailed Window: " + e.getMessage());
        }

        PulseLogger.info("Echo", "Pulse event adapter registered (Native EventBus)");
        PulseLogger.debug("Echo", "- TickProfiler: GameTickEvent");
        PulseLogger.debug("Echo", "- RenderProfiler: GuiRenderEvent");
        PulseLogger.debug("Echo", "- SessionManager: WorldLoad/Unload/MainMenuRender");
        PulseLogger.debug("Echo", "- LuaHookAdapter: LUA_CALL (Auto-capture enabled)");
    }

    /**
     * 이벤트 버스에서 리스너 해제
     */
    public static void unregister() {
        if (!registered.compareAndSet(true, false))
            return;

        // 모든 Echo 리스너 해제
        EventBus.unsubscribeAll(EchoMod.MOD_ID);

        // Lua Hook 해제
        LuaHookAdapter.unregister();

        PulseLogger.info("Echo", "Pulse event adapter unregistered");
    }

    /**
     * 등록 상태 확인
     */
    public static boolean isRegistered() {
        return registered.get();
    }

    /**
     * 멀티플레이어 환경인지 확인
     */
    private static boolean isMultiplayerWorld() {
        try {
            Class<?> gameClient = Class.forName("zombie.network.GameClient");
            java.lang.reflect.Field bClient = gameClient.getField("bClient");
            return Boolean.TRUE.equals(bClient.get(null));
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * v1.1: 주기적 Echo 상태 요약 로깅 (60초마다).
     * PulseContractVerifier의 stall_events 분리 확인용.
     */
    private static void logEchoStatusSummary() {
        try {
            com.echo.validation.PulseContractVerifier verifier = com.echo.validation.PulseContractVerifier
                    .getInstance();

            StringBuilder sb = new StringBuilder();
            sb.append("\n========== [Echo v1.1] 60s Status Summary ==========\n");
            sb.append("  Contract Status: ").append(verifier.getStatusForDisplay()).append("\n");
            sb.append("  True Violations: ").append(verifier.getTotalViolationCount()).append("\n");
            sb.append("  Stall Events: ").append(verifier.getStallEventCount()).append("\n");

            // Freeze 정보
            com.echo.measure.FreezeDetector detector = com.echo.measure.FreezeDetector.getInstance();
            sb.append("  Freezes (main loop): ").append(detector.getMainLoopFreezes().size()).append("\n");
            sb.append("  Freezes (all): ").append(detector.getRecentFreezes().size()).append("\n");

            sb.append("====================================================\n");

            PulseLogger.info("Echo", sb.toString());
        } catch (Exception e) {
            PulseLogger.warn("Echo", "Failed to log status summary: " + e.getMessage());
        }
    }

    /**
     * TickProfiler 인스턴스 반환
     */
    public static TickProfiler getTickProfiler() {
        return tickProfiler;
    }

    /**
     * RenderProfiler 인스턴스 반환
     */
    public static RenderProfiler getRenderProfiler() {
        return renderProfiler;
    }

    // --- Legacy Manual API ---

    /**
     * 틱 시작 시 호출 (수동)
     * 
     * @deprecated Use GameTickEvent-based profiling instead
     */
    @Deprecated
    public static void onTickStart() {
        if (tickProfiler != null) {
            tickProfiler.onTickPre();
        }
    }

    /**
     * 틱 종료 시 호출 (수동)
     * 
     * @deprecated Use GameTickEvent-based profiling instead
     */
    @Deprecated
    public static void onTickEnd() {
        if (tickProfiler != null) {
            tickProfiler.onTickPost();
        }
    }

    /**
     * 렌더 시작 시 호출 (수동)
     */
    public static void onRenderStart() {
        // PulseMetricsAdapter에 프레임 시작 알림
        PulseMetricsAdapter.onFrameStart();

        if (renderProfiler != null) {
            renderProfiler.onRenderPre();
        }
    }

    /**
     * 렌더 종료 시 호출 (수동)
     */
    public static void onRenderEnd() {
        if (renderProfiler != null) {
            renderProfiler.onRenderPost();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\PulseMetricsAdapter.java =====

package com.echo.pulse;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.aggregate.TimingData;

/**
 * Pulse 메트릭 어댑터
 * 
 * HUD/Panel에서 사용하는 메트릭 API입니다.
 * Pulse API가 있으면 Pulse에서, 없으면 Echo 내부 데이터에서 가져옵니다.
 */
public final class PulseMetricsAdapter {

    private static final long UPDATE_INTERVAL_MS = 500;

    // 캐시된 값 (0.5초마다 갱신)
    private static volatile double cachedFps = 60.0;
    private static volatile double cachedFrameTimeMs = 16.67;
    private static volatile double cachedTickTimeMs = 16.67;
    private static volatile long lastCacheUpdate = 0;

    // FPS 계산용
    private static long lastFrameTime = System.nanoTime();
    private static double frameTimeSmoothed = 16.67;
    private static final double SMOOTHING_FACTOR = 0.1;

    private PulseMetricsAdapter() {
        // Utility class
    }

    /**
     * 현재 FPS 조회
     * 
     * @return FPS (frames per second)
     */
    public static double getFps() {
        updateCacheIfNeeded();
        return cachedFps;
    }

    /**
     * 현재 프레임 시간 조회 (밀리초)
     * 
     * @return 프레임 시간 (ms)
     */
    public static double getFrameTimeMs() {
        updateCacheIfNeeded();
        return cachedFrameTimeMs;
    }

    /**
     * 현재 틱 시간 조회 (밀리초)
     * 
     * @return 틱 시간 (ms)
     */
    public static double getTickTimeMs() {
        updateCacheIfNeeded();
        return cachedTickTimeMs;
    }

    /**
     * 렌더 시작 시 호출 (프레임 시간 계산용)
     * PulseEventAdapter에서 호출됨
     */
    public static void onFrameStart() {
        long now = System.nanoTime();
        double deltaMs = (now - lastFrameTime) / 1_000_000.0;
        lastFrameTime = now;

        // Exponential smoothing
        frameTimeSmoothed = frameTimeSmoothed * (1 - SMOOTHING_FACTOR) + deltaMs * SMOOTHING_FACTOR;
    }

    /**
     * 캐시 업데이트 (0.5초마다)
     */
    private static void updateCacheIfNeeded() {
        long now = System.currentTimeMillis();
        if (now - lastCacheUpdate < UPDATE_INTERVAL_MS) {
            return;
        }
        lastCacheUpdate = now;

        // Pulse API 시도
        if (tryPulseApi()) {
            return;
        }

        // 폴백: Echo 내부 데이터
        updateFromEchoData();
    }

    /**
     * Pulse API에서 메트릭 가져오기 시도
     * 
     * @return Pulse API 사용 성공 여부
     */
    private static boolean tryPulseApi() {
        try {
            Class<?> pulseMetrics = Class.forName("com.pulse.api.PulseMetrics");

            // getFrameTimeMs()
            java.lang.reflect.Method getFrameTime = pulseMetrics.getMethod("getFrameTimeMs");
            Object frameTime = getFrameTime.invoke(null);
            if (frameTime instanceof Number) {
                cachedFrameTimeMs = ((Number) frameTime).doubleValue();
            }

            // getTickTimeMs()
            java.lang.reflect.Method getTickTime = pulseMetrics.getMethod("getTickTimeMs");
            Object tickTime = getTickTime.invoke(null);
            if (tickTime instanceof Number) {
                cachedTickTimeMs = ((Number) tickTime).doubleValue();
            }

            // getFps()
            java.lang.reflect.Method getFps = pulseMetrics.getMethod("getFps");
            Object fps = getFps.invoke(null);
            if (fps instanceof Number) {
                cachedFps = ((Number) fps).doubleValue();
            }

            return true;
        } catch (ClassNotFoundException e) {
            // Pulse API 없음
            return false;
        } catch (Exception e) {
            // Pulse API 호출 실패
            return false;
        }
    }

    /**
     * Echo 내부 데이터에서 메트릭 계산
     */
    private static void updateFromEchoData() {
        EchoProfiler profiler = EchoProfiler.getInstance();

        // Frame Time: smoothed value 사용
        cachedFrameTimeMs = frameTimeSmoothed;

        // FPS: 1000 / frameTimeMs
        if (cachedFrameTimeMs > 0) {
            cachedFps = 1000.0 / cachedFrameTimeMs;
        }

        // Tick Time: EchoProfiler의 TICK 데이터
        if (profiler.isEnabled()) {
            TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);
            if (tickData != null && tickData.getCallCount() > 0) {
                // 1초 윈도우의 평균 사용
                TimingData.RollingStats stats1s = tickData.getStats1s();
                if (stats1s.getSampleCount() > 0) {
                    cachedTickTimeMs = stats1s.getAverage() / 1000.0; // micros → ms
                }
            }
        }
    }

    /**
     * FPS 색상 등급 계산
     * 
     * @return 0=Good, 1=Warning, 2=Critical
     */
    public static int getFpsGrade() {
        double fps = getFps();
        if (fps >= 55)
            return 0; // Good
        if (fps >= 30)
            return 1; // Warning
        return 2; // Critical
    }

    /**
     * 프레임 시간 색상 등급 계산
     * 
     * @return 0=Good, 1=Warning, 2=Critical
     */
    public static int getFrameTimeGrade() {
        double ms = getFrameTimeMs();
        if (ms <= 16.67)
            return 0; // Good (60fps)
        if (ms <= 33.33)
            return 1; // Warning (30fps)
        return 2; // Critical
    }

    /**
     * 틱 시간 색상 등급 계산
     * 
     * @return 0=Good, 1=Warning, 2=Critical
     */
    public static int getTickTimeGrade() {
        double ms = getTickTimeMs();
        if (ms <= 16.67)
            return 0; // Good
        if (ms <= 33.33)
            return 1; // Warning
        return 2; // Critical
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\RenderProfiler.java =====

package com.echo.pulse;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.measure.ProfilingScope;

/**
 * 렌더 프로파일러
 * 
 * 렌더링 프레임 시간을 측정합니다.
 * Pulse OnRender 이벤트와 연동됩니다.
 */
public class RenderProfiler {

    private final EchoProfiler profiler = EchoProfiler.getInstance();

    // 현재 활성 스코프
    private ProfilingScope currentScope = null;

    // 프레임 카운터
    private long frameCount = 0;

    // FPS 계산용
    private long fpsStartTime = 0;
    private int fpsFrameCount = 0;
    private double currentFps = 0;

    // 마지막 프레임 시간
    private long lastFrameStartTime = 0;
    private long lastFrameDuration = 0;

    /**
     * 렌더 시작 시 호출
     */
    public void onRenderPre() {
        if (!profiler.isEnabled())
            return;

        lastFrameStartTime = System.nanoTime();
        currentScope = profiler.scope(ProfilingPoint.FRAME);
        frameCount++;
        fpsFrameCount++;

        // 1초마다 FPS 계산
        long now = System.currentTimeMillis();
        if (fpsStartTime == 0) {
            fpsStartTime = now;
        } else if (now - fpsStartTime >= 1000) {
            currentFps = fpsFrameCount * 1000.0 / (now - fpsStartTime);
            fpsFrameCount = 0;
            fpsStartTime = now;
        }
    }

    /**
     * 렌더 종료 시 호출
     */
    public void onRenderPost() {
        if (currentScope == null)
            return;

        currentScope.close();
        currentScope = null;

        // 프레임 시간 계산
        long elapsed = System.nanoTime() - lastFrameStartTime;
        lastFrameDuration = elapsed / 1000; // 마이크로초
    }

    /**
     * 월드 렌더링 래퍼
     */
    public void profileWorldRender(Runnable worldRender) {
        if (!profiler.isEnabled()) {
            worldRender.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.RENDER_WORLD)) {
            worldRender.run();
        }
    }

    /**
     * UI 렌더링 래퍼
     */
    public void profileUIRender(Runnable uiRender) {
        if (!profiler.isEnabled()) {
            uiRender.run();
            return;
        }

        try (var scope = profiler.scope(ProfilingPoint.RENDER_UI)) {
            uiRender.run();
        }
    }

    // --- 조회 ---

    /**
     * 총 프레임 카운트
     */
    public long getFrameCount() {
        return frameCount;
    }

    /**
     * 현재 FPS
     */
    public double getCurrentFps() {
        return currentFps;
    }

    /**
     * 마지막 프레임 시간 (마이크로초)
     */
    public long getLastFrameDurationMicros() {
        return lastFrameDuration;
    }

    /**
     * 마지막 프레임 시간 (밀리초)
     */
    public double getLastFrameDurationMs() {
        return lastFrameDuration / 1000.0;
    }

    // GPU Timing (Requires GL33)
    private boolean glQuerySupported = false;
    private long lastGpuDuration = 0;

    // Placeholder for OpenGL Query Object
    private final GpuQueryRing gpuQueryRing = new GpuQueryRing();

    /**
     * GPU 시간 측정 시작 (glQueryCounter)
     */
    public void startGpuTimer() {
        if (!glQuerySupported)
            return;
        gpuQueryRing.start();
    }

    /**
     * GPU 시간 측정 종료 및 수집
     */
    public void endGpuTimer() {
        if (!glQuerySupported)
            return;
        gpuQueryRing.end();
    }

    /**
     * 프레임 드랍 원인 분석
     */
    public FrameDropCause analyzeFrameDrop() {
        if (lastFrameDuration < 16666) { // 60 FPS (16.6ms)
            return FrameDropCause.NONE;
        }

        // If GPU time makes up > 80% of frame time, it's likely GPU bound
        if (lastGpuDuration > 0 && lastGpuDuration > lastFrameDuration * 0.8) {
            return FrameDropCause.GPU_BOUND;
        }

        // Otherwise, assume CPU bound
        return FrameDropCause.CPU_BOUND;
    }

    public enum FrameDropCause {
        NONE,
        CPU_BOUND,
        GPU_BOUND,
        UNKNOWN
    }

    /**
     * Placeholder Inner Class for GPU Queries
     */
    private static class GpuQueryRing {
        public void start() {
        }

        public void end() {
        }
    }

    /**
     * 카운터 초기화
     */
    public void reset() {
        frameCount = 0;
        lastFrameDuration = 0;
        fpsStartTime = 0;
        fpsFrameCount = 0;
        currentFps = 0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\SubProfilerBridge.java =====

package com.echo.pulse;

import com.echo.measure.SubProfiler;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.SubProfilerHook;

/**
 * SubProfiler Pulse 연동
 * 
 * Echo 초기화 시 Pulse의 SubProfilerHook에 콜백을 등록하여
 * Pulse Mixin에서 SubProfiler를 호출할 수 있게 합니다.
 * 
 * @since Echo 1.0
 */
public class SubProfilerBridge implements SubProfilerHook.ISubProfilerCallback {

    private static SubProfilerBridge INSTANCE;

    private SubProfilerBridge() {
    }

    /**
     * SubProfiler 브릿지 등록
     * EchoMod.init()에서 호출됨
     */
    public static void register() {
        PulseLogger.debug("Echo/SubProfilerBridge", "register() called");

        if (INSTANCE != null) {
            PulseLogger.debug("Echo/SubProfilerBridge", "Already registered, skipping");
            return;
        }

        try {
            INSTANCE = new SubProfilerBridge();
            SubProfilerHook.setCallback(INSTANCE);

            PulseLogger.info("Echo", "SubProfilerBridge registered with Pulse");
            PulseLogger.debug("Echo/SubProfilerBridge", "Callback instance: " + INSTANCE.getClass().getName());
        } catch (Throwable t) {
            PulseLogger.error("Echo/SubProfilerBridge", "FAILED to register: " + t.getMessage(), t);
            INSTANCE = null;
        }
    }

    /**
     * SubProfiler 브릿지 해제
     */
    public static void unregister() {
        SubProfilerHook.clearCallback();
        INSTANCE = null;
    }

    @Override
    public long start(String label) {
        SubProfiler.SubLabel subLabel = parseLabel(label);
        if (subLabel != null) {
            return SubProfiler.getInstance().startRaw(subLabel);
        }
        return -1;
    }

    @Override
    public void end(String label, long startTime) {
        if (startTime < 0)
            return;
        SubProfiler.SubLabel subLabel = parseLabel(label);
        if (subLabel != null) {
            SubProfiler.getInstance().endRaw(subLabel, startTime);
        }
    }

    /**
     * 문자열 라벨을 SubLabel enum으로 변환
     */
    private SubProfiler.SubLabel parseLabel(String label) {
        if (label == null)
            return null;
        try {
            return SubProfiler.SubLabel.valueOf(label);
        } catch (IllegalArgumentException e) {
            // Unknown label - 무시
            return null;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\SubsystemProfiler.java =====

package com.echo.pulse;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;

/**
 * 서브시스템 프로파일러
 * 
 * 개별 게임 서브시스템(Zombie AI, Physics, Network 등)을 측정합니다.
 * Callable wrapping 방식으로 기존 로직을 감싸서 사용합니다.
 */
public class SubsystemProfiler {

    private static final EchoProfiler profiler = EchoProfiler.getInstance();

    // --- AI 서브시스템 ---

    /**
     * 좀비 AI 업데이트 래퍼
     */
    public static void profileZombieAI(Runnable zombieUpdate) {
        profile(ProfilingPoint.ZOMBIE_AI, zombieUpdate);
    }

    /**
     * 좀비 AI 업데이트 래퍼 (라벨 포함)
     */
    public static void profileZombieAI(String label, Runnable zombieUpdate) {
        profile(ProfilingPoint.ZOMBIE_AI, label, zombieUpdate);
    }

    /**
     * NPC AI 업데이트 래퍼
     */
    public static void profileNpcAI(Runnable npcUpdate) {
        profile(ProfilingPoint.NPC_AI, npcUpdate);
    }

    /**
     * NPC AI 업데이트 래퍼 (라벨 포함)
     */
    public static void profileNpcAI(String label, Runnable npcUpdate) {
        profile(ProfilingPoint.NPC_AI, label, npcUpdate);
    }

    // --- 물리/시뮬레이션 ---

    /**
     * 물리 엔진 업데이트 래퍼
     */
    public static void profilePhysics(Runnable physicsUpdate) {
        profile(ProfilingPoint.PHYSICS, physicsUpdate);
    }

    /**
     * 시뮬레이션 업데이트 래퍼
     */
    public static void profileSimulation(Runnable simulation) {
        profile(ProfilingPoint.SIMULATION, simulation);
    }

    // --- I/O & 네트워크 ---

    /**
     * 네트워크 처리 래퍼
     */
    public static void profileNetwork(Runnable networkUpdate) {
        profile(ProfilingPoint.NETWORK, networkUpdate);
    }

    /**
     * 네트워크 처리 래퍼 (라벨 포함)
     */
    public static void profileNetwork(String label, Runnable networkUpdate) {
        profile(ProfilingPoint.NETWORK, label, networkUpdate);
    }

    /**
     * 청크 I/O 래퍼
     */
    public static void profileChunkIO(Runnable chunkIO) {
        profile(ProfilingPoint.CHUNK_IO, chunkIO);
    }

    /**
     * 청크 I/O 래퍼 (라벨 포함)
     */
    public static void profileChunkIO(String label, Runnable chunkIO) {
        profile(ProfilingPoint.CHUNK_IO, label, chunkIO);
    }

    // --- 오디오 ---

    /**
     * 오디오 처리 래퍼
     */
    public static void profileAudio(Runnable audioUpdate) {
        profile(ProfilingPoint.AUDIO, audioUpdate);
    }

    // --- 렌더링 ---

    /**
     * 렌더링 래퍼
     */
    public static void profileRender(Runnable render) {
        profile(ProfilingPoint.RENDER, render);
    }

    /**
     * 월드 렌더링 래퍼
     */
    public static void profileWorldRender(Runnable worldRender) {
        profile(ProfilingPoint.RENDER_WORLD, worldRender);
    }

    /**
     * UI 렌더링 래퍼
     */
    public static void profileUIRender(Runnable uiRender) {
        profile(ProfilingPoint.RENDER_UI, uiRender);
    }

    // --- 모드 관련 ---

    /**
     * 모드 초기화 래퍼
     */
    public static void profileModInit(String modId, Runnable modInit) {
        profile(ProfilingPoint.MOD_INIT, modId, modInit);
    }

    /**
     * 모드 틱 래퍼
     */
    public static void profileModTick(String modId, Runnable modTick) {
        profile(ProfilingPoint.MOD_TICK, modId, modTick);
    }

    // --- 커스텀 측정 ---

    /**
     * 커스텀 측정 1
     */
    public static void profileCustom1(String label, Runnable task) {
        profile(ProfilingPoint.CUSTOM_1, label, task);
    }

    /**
     * 커스텀 측정 2
     */
    public static void profileCustom2(String label, Runnable task) {
        profile(ProfilingPoint.CUSTOM_2, label, task);
    }

    /**
     * 커스텀 측정 3
     */
    public static void profileCustom3(String label, Runnable task) {
        profile(ProfilingPoint.CUSTOM_3, label, task);
    }

    // --- 범용 메서드 ---

    /**
     * 범용 프로파일링 래퍼
     */
    public static void profile(ProfilingPoint point, Runnable task) {
        if (!profiler.isEnabled()) {
            task.run();
            return;
        }

        try (var scope = profiler.scope(point)) {
            task.run();
        }
    }

    /**
     * 범용 프로파일링 래퍼 (라벨 포함)
     */
    public static void profile(ProfilingPoint point, String label, Runnable task) {
        if (!profiler.isEnabled()) {
            task.run();
            return;
        }

        try (var scope = profiler.scope(point, label)) {
            task.run();
        }
    }

    /**
     * 결과를 반환하는 프로파일링 래퍼
     */
    public static <T> T profileWithResult(ProfilingPoint point, java.util.function.Supplier<T> task) {
        if (!profiler.isEnabled()) {
            return task.get();
        }

        try (var scope = profiler.scope(point)) {
            return task.get();
        }
    }

    /**
     * 결과를 반환하는 프로파일링 래퍼 (라벨 포함)
     */
    public static <T> T profileWithResult(ProfilingPoint point, String label, java.util.function.Supplier<T> task) {
        if (!profiler.isEnabled()) {
            return task.get();
        }

        try (var scope = profiler.scope(point, label)) {
            return task.get();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\TickPhaseBridge.java =====

package com.echo.pulse;

import com.echo.measure.TickPhaseProfiler;
import com.echo.validation.PulseContractVerifier;
import com.echo.validation.SelfValidation;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.TickPhaseHook;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * TickPhase Pulse 연동
 * 
 * Echo 초기화 시 Pulse의 TickPhaseHook에 콜백을 등록하여
 * Pulse Mixin에서 TickPhaseProfiler를 호출할 수 있게 합니다.
 * 
 * v0.9: Pulse predefined phase 상수를 Echo TickPhase로 자동 매핑
 * v0.9: Phase mismatch 감지 시 품질 점수 페널티
 * 
 * @since Echo 1.0
 */
public class TickPhaseBridge implements TickPhaseHook.ITickPhaseCallback {

    private static TickPhaseBridge INSTANCE;

    // v0.9: Phase mismatch 품질 페널티 추적
    private static final AtomicInteger phaseMismatchCount = new AtomicInteger(0);
    private static final int QUALITY_PENALTY_PER_MISMATCH = 5; // 품질 점수 5점 감점
    private static final int MAX_PENALTY = 50; // 최대 50점 감점

    // v0.9: Pulse phase 상수 → Echo TickPhase 매핑
    private static final Map<String, TickPhaseProfiler.TickPhase> PHASE_MAPPING = new HashMap<>();

    static {
        // Pulse predefined phases → Echo TickPhase 매핑
        PHASE_MAPPING.put(TickPhaseHook.PHASE_WORLD_UPDATE, TickPhaseProfiler.TickPhase.WORLD_UPDATE);
        PHASE_MAPPING.put(TickPhaseHook.PHASE_AI_UPDATE, TickPhaseProfiler.TickPhase.AI_PHASE);
        PHASE_MAPPING.put(TickPhaseHook.PHASE_PHYSICS_UPDATE, TickPhaseProfiler.TickPhase.PHYSICS_PHASE);
        PHASE_MAPPING.put(TickPhaseHook.PHASE_ZOMBIE_UPDATE, TickPhaseProfiler.TickPhase.AI_PHASE); // Zombie = AI
                                                                                                    // category
        PHASE_MAPPING.put(TickPhaseHook.PHASE_PLAYER_UPDATE, TickPhaseProfiler.TickPhase.AI_PHASE); // Player = AI
                                                                                                    // category
        PHASE_MAPPING.put(TickPhaseHook.PHASE_RENDER_PREP, TickPhaseProfiler.TickPhase.RENDERING_PREP);
        PHASE_MAPPING.put(TickPhaseHook.PHASE_ISOGRID_UPDATE, TickPhaseProfiler.TickPhase.ISO_GRID_UPDATE);

        // Legacy 매핑 (Echo 자체 호출용)
        PHASE_MAPPING.put("WORLD_UPDATE", TickPhaseProfiler.TickPhase.WORLD_UPDATE);
        PHASE_MAPPING.put("AI_PHASE", TickPhaseProfiler.TickPhase.AI_PHASE);
        PHASE_MAPPING.put("PHYSICS_PHASE", TickPhaseProfiler.TickPhase.PHYSICS_PHASE);
        PHASE_MAPPING.put("RENDERING_PREP", TickPhaseProfiler.TickPhase.RENDERING_PREP);
        PHASE_MAPPING.put("ISO_GRID_UPDATE", TickPhaseProfiler.TickPhase.ISO_GRID_UPDATE);
    }

    private TickPhaseBridge() {
    }

    /**
     * TickPhase 브릿지 등록
     * EchoMod.init()에서 호출됨
     */
    public static void register() {
        if (INSTANCE != null) {
            return;
        }
        INSTANCE = new TickPhaseBridge();
        TickPhaseHook.setCallback(INSTANCE);
        PulseLogger.info("Echo", "TickPhaseBridge registered with Pulse (v0.9 mapping enabled)");
    }

    /**
     * TickPhase 브릿지 해제
     */
    public static void unregister() {
        TickPhaseHook.clearCallback();
        INSTANCE = null;
    }

    @Override
    public long startPhase(String phase) {
        TickPhaseProfiler.TickPhase tickPhase = parsePhase(phase);
        if (tickPhase != null) {
            // v0.9: Pulse에서 이미 phase sequence 검증을 수행하므로
            // 여기서는 Echo ContractVerifier에 알림만 전달
            PulseContractVerifier.getInstance().onPhaseStart(tickPhase);

            // v0.9: SelfValidation heartbeat
            SelfValidation.getInstance().phaseStartHeartbeat();

            return TickPhaseProfiler.getInstance().startPhaseRaw(tickPhase);
        }

        // Unknown phase - 경미한 경고만 (품질에 영향 없음)
        return -1;
    }

    @Override
    public void endPhase(String phase, long startTime) {
        if (startTime < 0)
            return;
        TickPhaseProfiler.TickPhase tickPhase = parsePhase(phase);
        if (tickPhase != null) {
            // v0.9: Phase 순서 검증은 Pulse TickPhaseHook에서 수행
            // Echo는 결과만 기록
            PulseContractVerifier.getInstance().onPhaseEnd(tickPhase);

            // v0.9: SelfValidation heartbeat
            SelfValidation.getInstance().phaseEndHeartbeat();

            TickPhaseProfiler.getInstance().endPhaseRaw(tickPhase, startTime);
        }
    }

    @Override
    public void onTickComplete() {
        // v0.9: Pulse TickPhaseHook에서 phase sequence 에러가 발생했는지 확인
        int pulsePhaseErrors = TickPhaseHook.getPhaseErrorCount();
        if (pulsePhaseErrors > 0 && phaseMismatchCount.get() < pulsePhaseErrors) {
            // 새로운 에러 발생
            phaseMismatchCount.set(pulsePhaseErrors);
        }

        // v2.0: Lua 경로 히트 프로브 (30초 후 1회 검증)
        com.echo.lua.LuaPathHitBridge probe = com.echo.lua.LuaPathHitBridge.getInstance();
        if (probe != null) {
            probe.onTick();
        }

        TickPhaseProfiler.getInstance().onTickComplete();
    }

    /**
     * Pulse phase 문자열을 Echo TickPhase enum으로 변환
     * v0.9: 매핑 테이블 사용, enum.valueOf() 폴백
     */
    private TickPhaseProfiler.TickPhase parsePhase(String phase) {
        if (phase == null)
            return null;

        // 매핑 테이블에서 먼저 검색
        TickPhaseProfiler.TickPhase mapped = PHASE_MAPPING.get(phase);
        if (mapped != null) {
            return mapped;
        }

        // 폴백: enum 직접 매칭 시도
        try {
            return TickPhaseProfiler.TickPhase.valueOf(phase);
        } catch (IllegalArgumentException e) {
            // Unknown phase - 무시 (디버그 로그용)
            return null;
        }
    }

    /**
     * 등록된 매핑 수 반환 (디버그용)
     */
    public static int getMappingCount() {
        return PHASE_MAPPING.size();
    }

    // ═══════════════════════════════════════════════════════════════
    // v0.9: 품질 점수 페널티 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * Phase mismatch로 인한 품질 점수 페널티 반환
     * 
     * @return 0-50 범위의 품질 감점
     */
    public static int getQualityPenalty() {
        int penalty = phaseMismatchCount.get() * QUALITY_PENALTY_PER_MISMATCH;
        return Math.min(penalty, MAX_PENALTY);
    }

    /**
     * Phase mismatch 카운트 반환
     */
    public static int getPhaseMismatchCount() {
        return phaseMismatchCount.get();
    }

    /**
     * 상태 리셋 (세션 리셋 시)
     */
    public static void reset() {
        phaseMismatchCount.set(0);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\TickProfiler.java =====

package com.echo.pulse;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.measure.ProfilingScope;
import com.pulse.api.log.PulseLogger;

/**
 * 틱 프로파일러
 * 
 * 게임 틱 시작/종료 시점을 측정합니다.
 * Pulse GameTickStartEvent/GameTickEndEvent와 연동됩니다.
 * 
 * @since Echo 0.9 - Added Start/End event-based profiling
 */
public class TickProfiler {

    private final EchoProfiler profiler = EchoProfiler.getInstance();

    // 현재 활성 스코프
    private ProfilingScope currentScope = null;

    // 틱 카운터
    private long tickCount = 0;

    // 스파이크 감지 임계값 (마이크로초)
    private long spikeThresholdMicros = 33_000; // 33ms (2 프레임)

    // 마지막 틱 시간
    private long lastTickStartTime = 0;
    private long lastTickDuration = 0;

    /**
     * 틱 완료 시 호출 (GameTickEvent의 deltaTime 기반)
     * 
     * GameTickEvent는 틱 완료 후 발생하므로 Pre/Post 패턴이 아닌
     * 단일 이벤트로 deltaTime을 직접 기록합니다.
     * 
     * @param deltaTimeMs 틱 소요 시간 (밀리초)
     */
    public void onTick(float deltaTimeMs) {
        // Self-Validation: heartbeat 증가 (Echo 0.9.0)
        com.echo.validation.SelfValidation.getInstance().tickHeartbeat();

        if (tickCount % 100 == 0) {
            PulseLogger.debug("Echo", String.format("onTick called: tick=%d, deltaMs=%.2f, profilerEnabled=%b",
                    tickCount, deltaTimeMs, profiler.isEnabled()));
        }

        if (!profiler.isEnabled()) {
            if (tickCount == 0) {
                PulseLogger.warn("Echo", "TickProfiler.onTick(): Profiler is DISABLED!");
            }
            tickCount++;
            return;
        }

        long durationMicros = (long) (deltaTimeMs * 1000);
        long durationNanos = durationMicros * 1000;

        tickCount++;
        lastTickDuration = durationMicros;

        // TimingData에 직접 샘플 추가 (Raw API와 동일한 방식)
        profiler.getTimingData(ProfilingPoint.TICK).addSample(durationNanos, null);

        // Histogram에 기록
        // Histogram에 기록 (Warmup 체크: 3초)
        if (profiler.getSessionDurationMs() < 3000) {
            profiler.getTickHistogram().addWarmupSample(durationMicros);
        } else {
            profiler.getTickHistogram().addSample(durationMicros);
        }

        // 스파이크 로그에 기록
        profiler.getSpikeLog().logSpike(durationMicros, ProfilingPoint.TICK, null);

        // 스파이크 감지
        if (durationMicros > spikeThresholdMicros) {
            onSpikeDetected(durationMicros);
        }

        if (tickCount == 1) {
            PulseLogger.info("Echo", "✓ First tick recorded successfully!");
        }
    }

    // --- v0.9: Start/End Event-Based Profiling (Primary API) ---

    /**
     * 틱 시작 시 호출 (GameTickStartEvent)
     * 타이밍은 GameTickEndEvent의 durationNanos로 측정하므로
     * 이 메서드는 contract 검증용으로만 사용됩니다.
     */
    public void onTickStart() {
        lastTickStartTime = System.nanoTime();
        // Contract verification은 PulseContractVerifier에서 처리
    }

    /**
     * 정밀 틱 소요 시간 기록 (GameTickEndEvent)
     * Pulse에서 직접 계산한 나노초 단위의 정밀 타이밍을 사용합니다.
     * 
     * @param durationNanos 틱 소요 시간 (나노초) - Pulse에서 계산됨
     */
    public void recordTickDuration(long durationNanos) {
        // v0.9.1: Real tick 수신 알림 - Fallback 자동 비활성화
        com.echo.validation.FallbackTickEmitter.getInstance().onRealTickReceived();

        // Self-Validation: heartbeat 증가
        com.echo.validation.SelfValidation.getInstance().tickHeartbeat();

        if (!profiler.isEnabled()) {
            if (tickCount == 0) {
                PulseLogger.warn("Echo", "TickProfiler: Profiler is DISABLED!");
            }
            tickCount++;
            return;
        }

        tickCount++;
        long durationMicros = durationNanos / 1000;
        lastTickDuration = durationMicros;

        // TimingData에 직접 샘플 추가
        profiler.getTimingData(ProfilingPoint.TICK).addSample(durationNanos, null);

        // Histogram에 기록 (Warmup 체크: 3초)
        if (profiler.getSessionDurationMs() < 3000) {
            profiler.getTickHistogram().addWarmupSample(durationMicros);
        } else {
            profiler.getTickHistogram().addSample(durationMicros);
        }

        // 스파이크 로그에 기록
        profiler.getSpikeLog().logSpike(durationMicros, ProfilingPoint.TICK, null);

        // 스파이크 감지
        if (durationMicros > spikeThresholdMicros) {
            onSpikeDetected(durationMicros);
        }

        if (tickCount == 1) {
            PulseLogger.info("Echo", "✓ First tick recorded via Start/End events!");
        } else if (tickCount % 100 == 0) {
            PulseLogger.debug("Echo", String.format("recordTickDuration: tick=%d, durationMs=%.2f",
                    tickCount, durationNanos / 1_000_000.0));
        }
    }

    /**
     * 틱 시작 시 호출 (Legacy - 수동 계측용)
     * 
     * @deprecated Use onTick(float deltaTimeMs) instead
     */
    @Deprecated
    public void onTickPre() {
        if (!profiler.isEnabled())
            return;

        lastTickStartTime = System.nanoTime();
        currentScope = profiler.scope(ProfilingPoint.TICK);
        tickCount++;
    }

    /**
     * 틱 종료 시 호출 (Legacy - 수동 계측용)
     * 
     * @deprecated Use onTick(float deltaTimeMs) instead
     */
    @Deprecated
    public void onTickPost() {
        if (currentScope == null)
            return;

        currentScope.close();
        currentScope = null;

        // 틱 시간 계산
        long elapsed = System.nanoTime() - lastTickStartTime;
        lastTickDuration = elapsed / 1000; // 마이크로초

        // 스파이크 감지
        if (lastTickDuration > spikeThresholdMicros) {
            onSpikeDetected(lastTickDuration);
        }
    }

    /**
     * 스파이크 감지 시 호출
     */
    private void onSpikeDetected(long durationMicros) {
        double durationMs = durationMicros / 1000.0;
        PulseLogger.warn("Echo", String.format("⚠ SPIKE DETECTED: Tick #%d took %.2f ms (threshold: %.2f ms)",
                tickCount, durationMs, spikeThresholdMicros / 1000.0));

        try {
            com.echo.lua.DetailedWindowManager.getInstance()
                    .trigger(com.echo.lua.DetailedWindowManager.DetailedTrigger.SLOW_TICK);
        } catch (Exception ignored) {
        }
    }

    // --- 설정 및 조회 ---

    /**
     * 스파이크 임계값 설정 (밀리초)
     */
    public void setSpikeThresholdMs(double thresholdMs) {
        this.spikeThresholdMicros = (long) (thresholdMs * 1000);
        PulseLogger.info("Echo", String.format("Spike threshold set to %.2f ms", thresholdMs));
    }

    /**
     * 현재 스파이크 임계값 (밀리초)
     */
    public double getSpikeThresholdMs() {
        return spikeThresholdMicros / 1000.0;
    }

    /**
     * 총 틱 카운트
     */
    public long getTickCount() {
        return tickCount;
    }

    /**
     * 마지막 틱 시간 (마이크로초)
     */
    public long getLastTickDurationMicros() {
        return lastTickDuration;
    }

    /**
     * 마지막 틱 시간 (밀리초)
     */
    public double getLastTickDurationMs() {
        return lastTickDuration / 1000.0;
    }

    /**
     * 카운터 초기화
     */
    public void reset() {
        tickCount = 0;
        lastTickDuration = 0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\pulse\ZombieBridge.java =====

package com.echo.pulse;

import com.echo.fuse.ZombieProfiler;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.ZombieHook;

/**
 * Bridge for Zombie profiling hooks.
 */
public class ZombieBridge implements ZombieHook.IZombieCallback {

    private static ZombieBridge INSTANCE;

    private final ThreadLocal<Long> motionStart = new ThreadLocal<>();
    private final ThreadLocal<Long> soundStart = new ThreadLocal<>();
    private final ThreadLocal<Long> trackingStart = new ThreadLocal<>();

    private ZombieBridge() {
    }

    public static void register() {
        if (INSTANCE != null)
            return;
        INSTANCE = new ZombieBridge();
        ZombieHook.setCallback(INSTANCE);

        // Phase 2: Sync fast-flag
        boolean detailsEnabled = com.echo.config.EchoConfig.getInstance().isEnableZombieDetails();

        PulseLogger.info("Echo", "ZombieBridge registered with Pulse (Details: " + detailsEnabled + ")");
    }

    @Override
    public void onMotionUpdateStart() {
        long t = com.echo.measure.SubProfiler.getInstance()
                .startRaw(com.echo.measure.SubProfiler.SubLabel.ZOMBIE_MOTION);
        motionStart.set(t);
    }

    @Override
    public void onMotionUpdateEnd() {
        Long start = motionStart.get();
        if (start != null && start != -1) {
            com.echo.measure.SubProfiler.getInstance().endRaw(com.echo.measure.SubProfiler.SubLabel.ZOMBIE_MOTION,
                    start);
        }
    }

    @Override
    public void onSoundPerceptionStart() {
        long t = com.echo.measure.SubProfiler.getInstance()
                .startRaw(com.echo.measure.SubProfiler.SubLabel.ZOMBIE_PERCEPTION);
        soundStart.set(t);
    }

    @Override
    public void onSoundPerceptionEnd() {
        Long start = soundStart.get();
        if (start != null && start != -1) {
            com.echo.measure.SubProfiler.getInstance().endRaw(com.echo.measure.SubProfiler.SubLabel.ZOMBIE_PERCEPTION,
                    start);
        }
    }

    @Override
    public void onTargetTrackingStart() {
        // Mapping TargetTracking to Perception for now, or Behavior if preferred.
        // Using Perception as it relates to sensing.
        long t = com.echo.measure.SubProfiler.getInstance()
                .startRaw(com.echo.measure.SubProfiler.SubLabel.ZOMBIE_PERCEPTION);
        trackingStart.set(t);
    }

    @Override
    public void onTargetTrackingEnd() {
        Long start = trackingStart.get();
        if (start != null && start != -1) {
            com.echo.measure.SubProfiler.getInstance().endRaw(com.echo.measure.SubProfiler.SubLabel.ZOMBIE_PERCEPTION,
                    start);
        }
    }

    @Override
    public void onZombieUpdate() {
        // Just a counter or check. SubProfiler ZOMBIE_UPDATE is handled by mixin
        // wrapper directly.
        // But for consistency we could increment a counter if needed.
        ZombieProfiler.getInstance().incrementZombieUpdates();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\report\EchoReport.java =====

package com.echo.report;

import com.echo.measure.EchoProfiler;
import com.echo.report.generator.ReportGenerator;
import com.echo.report.generator.JsonReportGenerator;
import com.echo.report.generator.TextReportGenerator;
import com.echo.report.generator.CsvReportGenerator;
import com.echo.report.generator.HtmlReportGenerator;

import java.io.*;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * Echo Report 생성기
 * 
 * JSON 및 텍스트 형식의 프로파일링 리포트 생성
 * 데이터 수집 로직은 ReportDataCollector로 위임.
 */
public class EchoReport {

    public static final String VERSION = "1.0.1";

    private final ReportDataCollector collector;
    private final Map<String, ReportGenerator> generators = new HashMap<>();

    public EchoReport(EchoProfiler profiler) {
        this(profiler, 10);
    }

    public EchoReport(EchoProfiler profiler, int topN) {
        this.collector = new ReportDataCollector(profiler, topN);

        // Initialize generators
        generators.put("json", new JsonReportGenerator());
        generators.put("text", new TextReportGenerator());
        generators.put("csv", new CsvReportGenerator());
        generators.put("html", new HtmlReportGenerator());
    }

    public void setScenarioName(String name) {
        collector.setScenarioName(name);
    }

    public void addScenarioTag(String tag) {
        collector.addScenarioTag(tag);
    }

    public void setScenarioTags(Set<String> tags) {
        collector.setScenarioTags(tags);
    }

    /**
     * 리포트 데이터 수집 (Map 형태)
     */
    public Map<String, Object> collectReportData() {
        return collector.collect();
    }

    /**
     * 특정 포맷의 리포트 생성
     */
    public String generate(String format) {
        ReportGenerator generator = generators.get(format.toLowerCase());
        if (generator == null) {
            throw new IllegalArgumentException("Unsupported report format: " + format);
        }
        return generator.generate(collectReportData());
    }

    /**
     * JSON 리포트 생성 (Delegated)
     */
    public String generateJson() {
        return generate("json");
    }

    /**
     * 콘솔 출력용 텍스트 리포트
     */
    public String generateText() {
        return generate("text");
    }

    /**
     * 콘솔에 리포트 출력
     */
    public void printToConsole() {
        System.out.println(generateText());
    }

    /**
     * JSON 파일로 저장
     */
    public void saveToFile(String path) throws IOException {
        try (Writer writer = new FileWriter(path)) {
            writer.write(generateJson());
        }
        System.out.println("[Echo] Report saved to: " + path);
    }

    /**
     * 타임스탬프 파일명으로 자동 저장
     */
    public String saveWithTimestamp(String directory) throws IOException {
        // Check for empty data (Phase 2.3)
        if (collector.getProfiler().getTickHistogram().getTotalSamples() == 0) {
            System.out.println("[Echo] Skipping report save: No data collected (0 ticks).");
            return null;
        }

        // Phase 5.2 + v0.9: Quality-based three-tier path separation
        int score = ReportQualityScorer.getInstance().calculateScore(collector.getProfiler()).score;
        int minQuality = com.echo.config.EchoConfig.getInstance().getMinQualityToSave();
        int baselineThreshold = com.echo.config.EchoConfig.getInstance().getBaselineQualityThreshold();

        // Determine save location based on quality score
        String subFolder;
        if (score >= baselineThreshold) {
            subFolder = "baseline";
            System.out.println("[Echo] High quality report (" + score + ") → baseline folder.");
        } else if (score >= minQuality) {
            subFolder = "normal";
            System.out.println("[Echo] Report quality (" + score + ") → normal folder.");
        } else {
            subFolder = "low_quality";
            System.out.println("[Echo] Low quality report (" + score + ") below threshold (" + minQuality
                    + ") → low_quality folder.");
        }
        directory = directory + File.separator + subFolder;

        String timestamp = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
                .format(java.time.LocalDateTime.now());
        String filename = "echo_report_" + timestamp + ".json";
        String fullPath = directory + File.separator + filename;

        File dir = new File(directory);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        saveToFile(fullPath);
        return fullPath;
    }

    /**
     * CSV 리포트 생성 (Delegated)
     */
    public String generateCsv() {
        return generate("csv");
    }

    /**
     * CSV 파일로 저장
     */
    public String saveCsv(String directory) throws IOException {
        String timestamp = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
                .format(java.time.LocalDateTime.now());
        String filename = "echo_report_" + timestamp + ".csv";
        String fullPath = directory + File.separator + filename;

        File dir = new File(directory);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        try (Writer writer = new FileWriter(fullPath)) {
            writer.write(generateCsv());
        }
        System.out.println("[Echo] CSV report saved to: " + fullPath);
        return fullPath;
    }

    /**
     * HTML 리포트 생성 (Delegated)
     */
    public String generateHtml() {
        return generate("html");
    }

    /**
     * HTML 파일로 저장
     */
    public String saveHtml(String directory) throws IOException {
        String timestamp = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")
                .format(java.time.LocalDateTime.now());
        String filename = "echo_report_" + timestamp + ".html";
        String fullPath = directory + File.separator + filename;

        File dir = new File(directory);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        try (Writer writer = new FileWriter(fullPath)) {
            writer.write(generateHtml());
        }
        System.out.println("[Echo] HTML report saved to: " + fullPath);
        return fullPath;
    }

    /**
     * 세션 종료 시 품질 요약 출력 (Phase 6.2)
     */
    public void printQualitySummary() {
        ReportQualityScorer.QualityResult result = ReportQualityScorer.getInstance()
                .calculateScore(collector.getProfiler());
        System.out.println("\n═══════════════════════════════════════════════════════");
        System.out.printf(" 🎯 ECHO SESSION QUALITY: %d/100%n", result.score);
        System.out.println("═══════════════════════════════════════════════════════");

        if (result.hasIssues()) {
            System.out.println(" Detected Issues:");
            for (Map<String, String> issue : result.issues) {
                String severity = issue.get("severity").toUpperCase();
                String desc = issue.get("description");
                System.out.printf("   [%s] %s%n", severity, desc);
            }
        } else {
            System.out.println(" ✅ No significant data quality issues.");
        }

        // Recommendations
        List<String> recs = collector.generateRecommendations();
        if (!recs.isEmpty()) {
            System.out.println("\n Recommendations:");
            for (String rec : recs) {
                System.out.println("   - " + rec);
            }
        }
        System.out.println("═══════════════════════════════════════════════════════\n");
    }

    public void onTick() {
        collector.onTick();
    }

    /**
     * 품질 플래그 기록 (Phase 1)
     */
    public void recordQualityFlag(com.echo.aggregate.DataQualityFlag flag) {
        collector.recordQualityFlag(flag);
    }

    /**
     * ReportMetadata 접근자
     */
    public ReportMetadata getReportMetadata() {
        return collector.getReportMetadata();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\report\generator\CsvReportGenerator.java =====

package com.echo.report.generator;

import java.util.Map;

/**
 * CSV 포맷 리포트 생성기.
 * 
 * @since 1.1.0
 */
public class CsvReportGenerator implements ReportGenerator {

    @Override
    public String generate(Map<String, Object> data) {
        StringBuilder sb = new StringBuilder();

        // Header
        sb.append("point,avgMs,maxMs,minMs,callCount\n");

        // Subsystems data
        if (data.containsKey("subsystems")) {
            @SuppressWarnings("unchecked")
            Map<String, Object> subsystems = (Map<String, Object>) data.get("subsystems");
            for (Map.Entry<String, Object> entry : subsystems.entrySet()) {
                @SuppressWarnings("unchecked")
                Map<String, Object> subsystem = (Map<String, Object>) entry.getValue();
                sb.append(String.format("%s,%.4f,%.4f,%.4f,%d\n",
                        escapeCsv(entry.getKey()),
                        getDouble(subsystem, "average_time_ms"),
                        getDouble(subsystem, "max_time_ms"),
                        getDouble(subsystem, "min_time_ms"),
                        getInt(subsystem, "call_count")));
            }
        }

        return sb.toString();
    }

    @Override
    public String getFormatName() {
        return "CSV";
    }

    @Override
    public String getFileExtension() {
        return ".csv";
    }

    private String escapeCsv(String value) {
        if (value == null)
            return "";
        if (value.contains(",") || value.contains("\"") || value.contains("\n")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }

    private double getDouble(Map<String, Object> map, String key) {
        Object value = map.get(key);
        return value instanceof Number ? ((Number) value).doubleValue() : 0.0;
    }

    private int getInt(Map<String, Object> map, String key) {
        Object value = map.get(key);
        return value instanceof Number ? ((Number) value).intValue() : 0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\report\generator\HtmlReportGenerator.java =====

package com.echo.report.generator;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * HTML 포맷 리포트 생성기.
 * 인터랙티브 대시보드를 포함한 HTML 파일을 생성합니다.
 * 
 * @since 1.1.0
 */
public class HtmlReportGenerator implements ReportGenerator {

    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    @Override
    public String generate(Map<String, Object> data) {
        // Embed JSON for JS to use
        String jsonChain = GSON.toJson(data);

        StringBuilder sb = new StringBuilder();
        sb.append("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n");
        sb.append("  <meta charset=\"UTF-8\">\n");
        sb.append("  <title>Echo Profiler Report</title>\n");
        sb.append("  <style>\n");
        sb.append("    :root { --bg: #1a1a2e; --card: #16213e; --text: #eee; --accent: #4ecdc4; --warn: #ff6b6b; }\n");
        sb.append(
                "    body { font-family: sans-serif; background: var(--bg); color: var(--text); padding: 0; margin: 0; }\n");
        sb.append(
                "    .header { background: #0f3460; padding: 20px; display: flex; justify-content: space-between; align-items: center; }\n");
        sb.append("    .tabs { display: flex; background: #1a1a40; }\n");
        sb.append("    .tab { padding: 15px 25px; cursor: pointer; opacity: 0.7; transition: 0.3s; }\n");
        sb.append("    .tab:hover { opacity: 1; background: #2a2a50; }\n");
        sb.append("    .tab.active { border-bottom: 3px solid var(--accent); opacity: 1; }\n");
        sb.append("    .content { padding: 20px; display: none; }\n");
        sb.append("    .content.active { display: block; animation: fadein 0.3s; }\n");
        sb.append(
                "    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; }\n");
        sb.append(
                "    .card { background: var(--card); padding: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }\n");
        sb.append("    .metric-value { font-size: 2em; font-weight: bold; color: var(--accent); }\n");
        sb.append("    table { width: 100%; border-collapse: collapse; margin-top: 10px; }\n");
        sb.append("    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #333; }\n");
        sb.append("    th { background: rgba(255,255,255,0.05); color: var(--accent); }\n");
        sb.append("    .bar-container { background: #333; height: 10px; border-radius: 5px; overflow: hidden; }\n");
        sb.append("    .bar-fill { height: 100%; background: var(--accent); }\n");
        sb.append("    @keyframes fadein { from { opacity: 0; } to { opacity: 1; } }\n");
        sb.append("  </style>\n");
        sb.append("</head>\n<body>\n");

        // Header
        sb.append("<div class=\"header\">\n");
        sb.append("  <h1>🔊 Echo Profiler</h1>\n");
        sb.append("  <div>").append(LocalDateTime.now()).append("</div>\n");
        sb.append("</div>\n");

        // Tabs
        sb.append("<div class=\"tabs\">\n");
        sb.append("  <div class=\"tab active\" onclick=\"showTab('summary')\">Summary</div>\n");
        sb.append("  <div class=\"tab\" onclick=\"showTab('heavy')\">Heavy Functions</div>\n");
        sb.append("  <div class=\"tab\" onclick=\"showTab('lua')\">Lua / Context</div>\n");
        sb.append("  <div class=\"tab\" onclick=\"showTab('deep')\">Deep Analysis</div>\n");
        sb.append("  <div class=\"tab\" onclick=\"showTab('raw')\">Raw JSON</div>\n");
        sb.append("</div>\n");

        // TAB 1: Summary
        sb.append("<div id=\"summary\" class=\"content active\">\n");
        sb.append("  <div class=\"grid\">\n");

        Map<String, Object> echoReport = getMap(data, "echo_report"); // Check if wrapped in echo_report
        Map<String, Object> root = echoReport != null ? echoReport : data;

        Map<String, Object> summary = getMap(root, "summary");
        if (summary != null) {
            sb.append("    <div class=\"card\"><div>Avg Tick</div><div class=\"metric-value\">")
                    .append(String.format("%.2f ms", getDouble(summary, "average_tick_ms"))).append("</div></div>\n");
            sb.append(
                    "    <div class=\"card\"><div>Max Spike</div><div class=\"metric-value\" style=\"color:var(--warn)\">")
                    .append(String.format("%.2f ms", getDouble(summary, "max_tick_spike_ms"))).append("</div></div>\n");
            sb.append("    <div class=\"card\"><div>Total Ticks</div><div class=\"metric-value\">")
                    .append(String.format("%,d", getLong(summary, "total_ticks"))).append("</div></div>\n");
        }
        sb.append("  </div>\n");

        sb.append("  <div class=\"card\"><h3>Tick Distribution</h3>\n");
        Map<String, Object> histogram = getMap(root, "tick_histogram");
        if (histogram != null) {
            // Assuming histogram map has 'counts' and 'buckets' lists
            // Since traversing lists in untyped map maps is hard, and the JS can do it
            // easier...
            // But we want server-side rendering for static viewing.
            // We'll rely on JS for complex charts if possible, or simple HTML bars.
            // The original code used Java arrays. Here we have List<Double> and List<Long>.
            // Implementing purely in JS might be cleaner given we pass the full JSON.
            sb.append("    <div id=\"histogram-chart\">Loading Chart...</div>\n");
        }
        sb.append("  </div>\n");
        sb.append("</div>\n");

        // TAB 2: Heavy Functions
        sb.append("<div id=\"heavy\" class=\"content\">\n");
        sb.append("  <div class=\"card\"><h3>Top Heavy Functions (Java/Engine)</h3><table>\n");
        sb.append("    <tr><th>Function</th><th>Total (ms)</th><th>Avg (ms)</th><th>Count</th></tr>\n");

        Map<String, Object> heavyFuncs = getMap(root, "heavy_functions");
        if (heavyFuncs != null) {
            @SuppressWarnings("unchecked")
            List<Map<String, Object>> byTotal = (List<Map<String, Object>>) heavyFuncs.get("by_total_time");
            if (byTotal != null) {
                for (int i = 0; i < Math.min(byTotal.size(), 20); i++) {
                    Map<String, Object> f = byTotal.get(i);
                    sb.append("<tr><td>").append(f.get("label")).append("</td>");
                    sb.append("<td>").append(f.get("total_time_ms")).append("</td>");
                    sb.append("<td>").append(f.get("average_time_ms")).append("</td>");
                    sb.append("<td>").append(f.get("call_count")).append("</td></tr>\n");
                }
            }
        }
        sb.append("  </table></div>\n");
        sb.append("</div>\n");

        // TAB 3: Lua
        sb.append("<div id=\"lua\" class=\"content\">\n");
        sb.append("  <div class=\"grid\">\n");
        sb.append("    <div class=\"card\"><h3>Lua Contexts</h3><div id=\"lua-context-list\"></div></div>\n");
        sb.append("    <div class=\"card\"><h3>Heavy Lua Files</h3><div id=\"lua-file-list\"></div></div>\n");
        sb.append("  </div>\n");
        sb.append("  <div class=\"card\"><h3>Top Lua Functions</h3><div id=\"lua-func-list\"></div></div>\n");
        sb.append("</div>\n");

        // TAB 4: Deep Analysis
        sb.append("<div id=\"deep\" class=\"content\">\n");
        sb.append("  <p>Granular breakdown of Pathfinding, Zombie, and IsoGrid.</p>\n");
        sb.append("  <div class=\"grid\">\n");
        sb.append("     <div class=\"card\"><h3>Pathfinding</h3><div id=\"deep-path\"></div></div>\n");
        sb.append("     <div class=\"card\"><h3>Zombie</h3><div id=\"deep-zombie\"></div></div>\n");
        sb.append("  </div>\n");
        sb.append("  <div class=\"card\"><h3>IsoGrid</h3><div id=\"deep-grid\"></div></div>\n");
        sb.append("</div>\n");

        // TAB 5: Raw
        sb.append("<div id=\"raw\" class=\"content\">\n");
        sb.append("  <textarea style=\"width:100%; height:400px; background:#111; color:#ccc; border:none;\">")
                .append(jsonChain).append("</textarea>\n");
        sb.append("</div>\n");

        // SCRIPT
        sb.append("<script>\n");
        sb.append("  const data = ").append(jsonChain).append(";\n");
        sb.append("  const root = data.echo_report || data;\n"); // Handle wrapper
        sb.append(
                "  function showTab(id) { document.querySelectorAll('.content').forEach(c => c.classList.remove('active')); document.querySelectorAll('.tab').forEach(t => t.classList.remove('active')); document.getElementById(id).classList.add('active'); event.target.classList.add('active'); }\n");
        sb.append("  \n");

        // JS Histogram Rendering (replacing Java loop)
        sb.append("  if(root.tick_histogram) {\n");
        sb.append("      const h = root.tick_histogram;\n");
        sb.append("      let html = '';\n");
        sb.append("      const max = Math.max(...h.counts, 1);\n");
        sb.append("      for(let i=0; i<h.buckets.length; i++) {\n");
        sb.append("          const w = (h.counts[i] * 100) / max;\n");
        sb.append("          html += `<div style=\"display:flex; align-items:center; margin:5px 0\">`;\n");
        sb.append("          html += `<div style=\"width:60px\">${h.buckets[i].toFixed(1)}</div>`;\n");
        sb.append(
                "          html += `<div class=\"bar-container\" style=\"flex-grow:1\"><div class=\"bar-fill\" style=\"width:${w}%\\\"></div></div>`;\n");
        sb.append("          html += `<div style=\"width:50px; text-align:right\">${h.counts[i]}</div>`;\n");
        sb.append("          html += `</div>`;\n");
        sb.append("      }\n");
        sb.append("      document.getElementById('histogram-chart').innerHTML = html;\n");
        sb.append("  }\n");

        sb.append("  // Populate Lua\n");
        sb.append("  if(root.lua_profiling) {\n");
        sb.append("     const lua = root.lua_profiling;\n");
        sb.append("     // Contexts\n");
        sb.append("     if(lua.context_totals) {\n"); // context_stats or context_totals? check EchoReport
        sb.append("        let html = '<table><tr><th>Context</th><th>Total (ms)</th></tr>';\n");
        sb.append(
                "        for(const [k,v] of Object.entries(lua.context_totals)) html += `<tr><td>${k}</td><td>${Number(v).toFixed(2)}</td></tr>`;\n"); // Assuming
                                                                                                                                                       // simplified
                                                                                                                                                       // map
        sb.append("        html += '</table>'; document.getElementById('lua-context-list').innerHTML = html;\n");
        sb.append("     }\n");
        sb.append("     // Files\n");
        sb.append("     if(lua.heavy_files) {\n");
        sb.append("        let html = '<table><tr><th>File</th><th>Total (ms)</th></tr>';\n");
        sb.append(
                "        lua.heavy_files.forEach(f => html += `<tr><td>${f.file}</td><td>${f.total_ms}</td></tr>`);\n");
        sb.append("        html += '</table>'; document.getElementById('lua-file-list').innerHTML = html;\n");
        sb.append("     }\n");
        sb.append("     // Functions\n");
        sb.append("     if(lua.top_functions_by_time) {\n");
        sb.append("        let html = '<table><tr><th>Name</th><th>Calls</th><th>Total (ms)</th></tr>';\n");
        sb.append(
                "        lua.top_functions_by_time.forEach(f => html += `<tr><td>${f.name}</td><td>${f.call_count}</td><td>${f.total_time_ms}</td></tr>`);\n");
        sb.append("        html += '</table>'; document.getElementById('lua-func-list').innerHTML = html;\n");
        sb.append("     }\n");
        sb.append("  }\n");
        sb.append("  \n");
        sb.append("  // Populate Deep\n");
        sb.append("  if(root.fuse_deep_analysis) {\n");
        sb.append("     const deep = root.fuse_deep_analysis;\n");
        sb.append("     const renderDeep = (obj) => {\n");
        sb.append("        if(!obj || !obj.steps) return 'No Data';\n");
        sb.append("        let html = '<table><tr><th>Step</th><th>Count</th><th>Total (ms)</th></tr>';\n");
        sb.append(
                "        for(const [k,v] of Object.entries(obj.steps)) html += `<tr><td>${k}</td><td>${v.count}</td><td>${v.total_ms.toFixed(2)}</td></tr>`;\n");
        sb.append("        return html + '</table>';\n");
        sb.append("     };\n");
        sb.append("     document.getElementById('deep-path').innerHTML = renderDeep(deep.pathfinding);\n");
        sb.append("     document.getElementById('deep-zombie').innerHTML = renderDeep(deep.zombie);\n");
        sb.append("     document.getElementById('deep-grid').innerHTML = renderDeep(deep.iso_grid);\n");
        sb.append("  }\n");
        sb.append("</script>\n");

        sb.append("</body>\n</html>");
        return sb.toString();
    }

    @Override
    public String getFormatName() {
        return "HTML";
    }

    @Override
    public String getFileExtension() {
        return ".html";
    }

    @SuppressWarnings("unchecked")
    private Map<String, Object> getMap(Map<String, Object> map, String key) {
        Object val = map.get(key);
        if (val instanceof Map) {
            return (Map<String, Object>) val;
        }
        return null;
    }

    private double getDouble(Map<String, Object> map, String key) {
        Object val = map.get(key);
        if (val instanceof Number)
            return ((Number) val).doubleValue();
        return 0.0;
    }

    private long getLong(Map<String, Object> map, String key) {
        Object val = map.get(key);
        if (val instanceof Number)
            return ((Number) val).longValue();
        return 0L;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\report\generator\JsonReportGenerator.java =====

package com.echo.report.generator;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.util.Map;

/**
 * JSON 포맷 리포트 생성기.
 * 
 * @since 1.1.0
 */
public class JsonReportGenerator implements ReportGenerator {

    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    @Override
    public String generate(Map<String, Object> data) {
        return GSON.toJson(data);
    }

    @Override
    public String getFormatName() {
        return "JSON";
    }

    @Override
    public String getFileExtension() {
        return ".json";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\report\generator\ReportGenerator.java =====

package com.echo.report.generator;

import java.util.Map;

/**
 * 리포트 생성 전략 인터페이스.
 * EchoReport에서 분리된 포맷별 리포트 생성기.
 * 
 * @since 1.1.0
 */
public interface ReportGenerator {

    /**
     * 리포트 생성.
     * 
     * @param data 리포트 데이터 (key-value)
     * @return 생성된 리포트 문자열
     */
    String generate(Map<String, Object> data);

    /**
     * 리포트 포맷 이름.
     */
    String getFormatName();

    /**
     * 파일 확장자.
     */
    String getFileExtension();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\report\generator\TextReportGenerator.java =====

package com.echo.report.generator;

import java.util.List;
import java.util.Map;

/**
 * 텍스트 포맷 리포트 생성기 (콘솔 출력용).
 * 
 * @since 1.1.0
 */
public class TextReportGenerator implements ReportGenerator {

    @Override
    public String generate(Map<String, Object> data) {
        StringBuilder sb = new StringBuilder();

        sb.append("\n");
        sb.append("╔═══════════════════════════════════════════════════════════════╗\n");
        sb.append("║                    ECHO PROFILING REPORT                      ║\n");
        sb.append("╚═══════════════════════════════════════════════════════════════╝\n");
        sb.append("\n");

        // Summary section
        if (data.containsKey("summary")) {
            @SuppressWarnings("unchecked")
            Map<String, Object> summary = (Map<String, Object>) data.get("summary");
            sb.append("┌─ Summary ─────────────────────────────────────────────────────┐\n");
            sb.append(String.format("│  Sessions: %-10s  Tick Count: %-20s │\n",
                    "1", // Single session per report
                    summary.getOrDefault("total_ticks", 0)));
            sb.append(String.format("│  Avg Tick: %-10s  Max Tick: %-21s │\n",
                    formatMs(summary.get("average_tick_ms")),
                    formatMs(summary.get("max_tick_spike_ms"))));
            sb.append("└───────────────────────────────────────────────────────────────┘\n");
            sb.append("\n");
        }

        // Subsystems section
        if (data.containsKey("subsystems")) {
            @SuppressWarnings("unchecked")
            Map<String, Object> subsystems = (Map<String, Object>) data.get("subsystems");
            sb.append("┌─ Subsystems ──────────────────────────────────────────────────┐\n");
            for (Map.Entry<String, Object> entry : subsystems.entrySet()) {
                @SuppressWarnings("unchecked")
                Map<String, Object> subsystem = (Map<String, Object>) entry.getValue();
                sb.append(String.format("│  %-15s avg: %-8s  max: %-8s  calls: %-6s │\n",
                        entry.getKey(),
                        formatMs(subsystem.get("average_time_ms")),
                        formatMs(subsystem.get("max_time_ms")),
                        subsystem.getOrDefault("call_count", 0)));
            }
            sb.append("└───────────────────────────────────────────────────────────────┘\n");
            sb.append("\n");
        }

        // Heavy functions section
        if (data.containsKey("heavy_functions")) {
            @SuppressWarnings("unchecked")
            Map<String, Object> heavyRoot = (Map<String, Object>) data.get("heavy_functions");
            @SuppressWarnings("unchecked")
            List<Map<String, Object>> heavy = (List<Map<String, Object>>) heavyRoot.get("by_total_time");
            if (heavy != null && !heavy.isEmpty()) {
                sb.append("┌─ Heavy Functions (Top 5) ─────────────────────────────────────┐\n");
                int count = 0;
                for (Map<String, Object> func : heavy) {
                    if (count++ >= 5)
                        break;
                    sb.append(String.format("│  %d. %-40s %8s │\n",
                            count,
                            truncate(String.valueOf(func.get("label")), 40),
                            formatMs(func.get("total_time_ms"))));
                }
                sb.append("└───────────────────────────────────────────────────────────────┘\n");
                sb.append("\n");
            }
        }

        // Recommendations section
        if (data.containsKey("recommendations")) {
            @SuppressWarnings("unchecked")
            List<String> recommendations = (List<String>) data.get("recommendations");
            if (!recommendations.isEmpty()) {
                sb.append("┌─ Recommendations ─────────────────────────────────────────────┐\n");
                for (String rec : recommendations) {
                    sb.append(String.format("│  • %-60s │\n", truncate(rec, 60)));
                }
                sb.append("└───────────────────────────────────────────────────────────────┘\n");
            }
        }

        return sb.toString();
    }

    @Override
    public String getFormatName() {
        return "Text";
    }

    @Override
    public String getFileExtension() {
        return ".txt";
    }

    private String formatMs(Object value) {
        if (value instanceof Number) {
            return String.format("%.2fms", ((Number) value).doubleValue());
        }
        return "N/A";
    }

    private String truncate(String s, int maxLen) {
        if (s == null)
            return "";
        return s.length() > maxLen ? s.substring(0, maxLen - 3) + "..." : s;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\report\ReportDataCollector.java =====

package com.echo.report;

import com.echo.aggregate.DataQualityFlag;
import com.echo.aggregate.SpikeLog;
import com.echo.aggregate.TickHistogram;
import com.echo.aggregate.TimingData;
import com.echo.aggregate.MemoryTimeSeries;
import com.echo.aggregate.TimeSeriesStore;
import com.echo.analysis.CorrelationAnalyzer;
import com.echo.analysis.ExtendedCorrelationAnalyzer;
import com.echo.analysis.BottleneckDetector;
import com.echo.config.EchoConfig;
import com.echo.fuse.IsoGridProfiler;
import com.echo.fuse.PathfindingProfiler;
import com.echo.fuse.ZombieProfiler;
import com.echo.lua.LuaCallTracker;
import com.echo.lua.LuaGCProfiler;
import com.echo.measure.EchoProfiler;
import com.echo.history.MetricCollector;
import com.echo.measure.FreezeDetector;
import com.echo.measure.MemoryProfiler;
import com.echo.measure.NetworkMetrics;
import com.echo.measure.ProfilingPoint;
import com.echo.measure.RenderMetrics;
import com.echo.measure.SubProfiler;
import com.echo.measure.TickPhaseProfiler;
import com.echo.validation.PulseContractVerifier;
import com.echo.validation.SelfValidation;

import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * Report Data Collector.
 * Separated from EchoReport to handle data aggregation and collection.
 */
public class ReportDataCollector {

    private final EchoProfiler profiler;
    private final int topN;

    // Phase 3: Metadata
    private String scenarioName = "default";
    private Set<String> scenarioTags = new HashSet<>();

    // Phase 1: Enhanced Metadata
    private final ReportMetadata reportMetadata = new ReportMetadata();

    // Phase 1: Quality Flag Aggregation
    // EnumMap requires the key type class
    private final EnumMap<DataQualityFlag, Integer> qualityFlagCounts = new EnumMap<>(DataQualityFlag.class);

    // Phase 3: Analysis

    public ReportDataCollector(EchoProfiler profiler, int topN) {
        this.profiler = profiler;
        this.topN = topN;
        reportMetadata.collectFromPulse();
    }

    public void setScenarioName(String name) {
        this.scenarioName = name;
    }

    public void addScenarioTag(String tag) {
        this.scenarioTags.add(tag);
    }

    public void setScenarioTags(Set<String> tags) {
        this.scenarioTags = new HashSet<>(tags);
    }

    public void onTick() {
        // Handled by PulseEventAdapter -> MetricCollector
    }

    public void recordQualityFlag(DataQualityFlag flag) {
        qualityFlagCounts.merge(flag, 1, Integer::sum);
    }

    public ReportMetadata getReportMetadata() {
        return reportMetadata;
    }

    public EchoProfiler getProfiler() {
        return profiler;
    }

    /**
     * 리포트 데이터 수집 (Map 형태)
     */
    public Map<String, Object> collect() {
        Map<String, Object> report = new LinkedHashMap<>();
        Map<String, Object> echoReport = new LinkedHashMap<>();

        echoReport.put("version", "1.0.1");
        echoReport.put("generated_at", formatInstant(Instant.now()));
        echoReport.put("session_duration_seconds", profiler.getSessionDurationSeconds());

        echoReport.put("summary", generateSummary());
        echoReport.put("subsystems", generateSubsystems());
        echoReport.put("heavy_functions", generateHeavyFunctions());

        // Safely collect singleton-based data
        echoReport.put("tick_phase_breakdown", safeGetMap(() -> TickPhaseProfiler.getInstance().toMap()));
        echoReport.put("tick_histogram", generateHistogram());
        echoReport.put("spikes", generateSpikes());
        echoReport.put("freeze_history", generateFreezes());
        echoReport.put("memory", generateMemoryStats());
        echoReport.put("lua_profiling", generateLuaProfiling());
        echoReport.put("lua_gc", generateLuaGCStats());
        echoReport.put("fuse_deep_analysis", generateFuseDeepAnalysis());
        echoReport.put("validation_status", generateValidationStatus());
        echoReport.put("pulse_contract",
                safeGetMap(() -> PulseContractVerifier.getInstance().toMap()));
        echoReport.put("report_quality", generateReportQuality());
        echoReport.put("recommendations", generateRecommendations());
        echoReport.put("analysis", generateAnalysis());
        echoReport.put("metadata", generateMetadata());

        // Phase 2-5: Extended Analysis
        echoReport.put("extended_analysis",
                safeGetMap(() -> ExtendedCorrelationAnalyzer.getInstance().analyze()));
        echoReport.put("memory_timeseries",
                safeGetMap(() -> MemoryTimeSeries.getInstance().toMap()));
        echoReport.put("bottleneck_detection",
                safeGetMap(() -> BottleneckDetector.getInstance().toMap()));
        echoReport.put("network", safeGetMap(() -> NetworkMetrics.getInstance().toMap()));
        echoReport.put("render", safeGetMap(() -> RenderMetrics.getInstance().toMap()));
        echoReport.put("timeseries_summary",
                safeGetMap(() -> TimeSeriesStore.getInstance().toSummary()));

        report.put("echo_report", echoReport);
        return report;
    }

    private Map<String, Object> safeGetMap(java.util.function.Supplier<Map<String, Object>> supplier) {
        try {
            return supplier.get();
        } catch (Exception e) {
            Map<String, Object> err = new HashMap<>();
            err.put("error", "Data collection failed: " + e.getMessage());
            return err;
        }
    }

    private Map<String, Object> generateSummary() {
        Map<String, Object> summary = new LinkedHashMap<>();
        TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);

        if (tickData != null) {
            summary.put("total_ticks", tickData.getCallCount());
            summary.put("average_tick_ms", round(tickData.getAverageMicros() / 1000.0));
            summary.put("max_tick_spike_ms", round(tickData.getMaxMicros() / 1000.0));
            summary.put("min_tick_ms", round(tickData.getMinMicros() / 1000.0));
            summary.put("target_tick_ms", 16.67);

            double avgMs = tickData.getAverageMicros() / 1000.0;
            double score = Math.max(0, 100 - Math.max(0, avgMs - 16.67) * 5);
            summary.put("performance_score", round(Math.min(100, score)));
        }

        return summary;
    }

    private List<Map<String, Object>> generateSubsystems() {
        List<Map<String, Object>> list = new ArrayList<>();

        for (ProfilingPoint point : ProfilingPoint.values()) {
            TimingData data = profiler.getTimingData(point);
            if (data != null && data.getCallCount() > 0) {
                Map<String, Object> item = new LinkedHashMap<>();
                item.put("name", point.name());
                item.put("display_name", point.getDisplayName());
                item.put("category", point.getCategory().name());

                Map<String, Object> stats = new LinkedHashMap<>();
                stats.put("call_count", data.getCallCount());
                stats.put("total_time_ms", round(data.getTotalMicros() / 1000.0));
                stats.put("average_time_ms", round(data.getAverageMicros() / 1000.0));
                stats.put("max_time_ms", round(data.getMaxMicros() / 1000.0));
                stats.put("min_time_ms", round(data.getMinMicros() / 1000.0));
                item.put("stats", stats);

                Map<String, Object> rolling = new LinkedHashMap<>();
                rolling.put("last_1s", createRollingStats(data.getStats1s()));
                rolling.put("last_5s", createRollingStats(data.getStats5s()));
                rolling.put("last_60s", createRollingStats(data.getStats60s()));
                item.put("rolling_stats", rolling);

                list.add(item);
            }
        }

        return list;
    }

    private Map<String, Object> createRollingStats(TimingData.RollingStats stats) {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("avg_ms", round(stats.getAverage() / 1000.0));
        map.put("max_ms", round(stats.getMax() / 1000.0));
        map.put("samples", stats.getSampleCount());
        return map;
    }

    private Map<String, Object> generateHeavyFunctions() {
        Map<String, Object> heavy = new LinkedHashMap<>();
        SubProfiler subProfiler = SubProfiler.getInstance();
        if (subProfiler.isEnabled()) {
            heavy.put("subtiming", subProfiler.toMap());
        }

        List<RankedFunction> byTotal = collectHeavyFunctions();

        List<Map<String, Object>> byTotalList = new ArrayList<>();
        int rank = 1;
        for (RankedFunction func : byTotal) {
            if (rank > topN)
                break;
            byTotalList.add(func.toMap(rank++));
        }
        heavy.put("by_total_time", byTotalList);

        List<RankedFunction> byMax = new ArrayList<>(byTotal);
        byMax.sort((a, b) -> Long.compare(b.maxMicros, a.maxMicros));

        List<Map<String, Object>> byMaxList = new ArrayList<>();
        rank = 1;
        for (RankedFunction func : byMax) {
            if (rank > topN)
                break;
            byMaxList.add(func.toMap(rank++));
        }
        heavy.put("by_max_spike", byMaxList);

        List<RankedFunction> byCount = new ArrayList<>(byTotal);
        byCount.sort((a, b) -> Long.compare(b.callCount, a.callCount));

        List<Map<String, Object>> byCountList = new ArrayList<>();
        rank = 1;
        for (RankedFunction func : byCount) {
            if (rank > topN)
                break;
            byCountList.add(func.toMap(rank++));
        }
        heavy.put("by_call_frequency", byCountList);

        return heavy;
    }

    private List<RankedFunction> collectHeavyFunctions() {
        List<RankedFunction> functions = new ArrayList<>();
        SubProfiler subProfiler = SubProfiler.getInstance();
        if (subProfiler.isEnabled()) {
            for (SubProfiler.SubTimingData subData : subProfiler.getAllTimings()) {
                if (subData.getCallCount() > 0) {
                    functions.add(new RankedFunction(
                            subData.getLabel().getDisplayName(),
                            subData.getLabel().getCategory().getDisplayName(),
                            subData.getCallCount(),
                            subData.getTotalMicros(),
                            subData.getMaxMicros()));
                }
            }
        }

        for (Map.Entry<ProfilingPoint, TimingData> entry : profiler.getTimingData().entrySet()) {
            ProfilingPoint point = entry.getKey();
            TimingData data = entry.getValue();

            for (TimingData.SubTimingData sub : data.getLabelStats().values()) {
                functions.add(new RankedFunction(
                        sub.getLabel(),
                        point.name(),
                        sub.getCallCount(),
                        sub.getTotalMicros(),
                        sub.getMaxMicros()));
            }
        }

        functions.sort((a, b) -> Long.compare(b.totalMicros, a.totalMicros));
        return functions;
    }

    private Map<String, Object> generateHistogram() {
        return profiler.getTickHistogram().toMap();
    }

    private Map<String, Object> generateSpikes() {
        return profiler.getSpikeLog().toMap();
    }

    private Map<String, Object> generateFreezes() {
        Map<String, Object> map = new LinkedHashMap<>();
        // v1.1: 메인 루프 스택만 포함된 freeze 사용 (오염 제거)
        List<FreezeDetector.FreezeSnapshot> freezes = FreezeDetector.getInstance().getMainLoopFreezes();
        List<FreezeDetector.FreezeSnapshot> allFreezes = FreezeDetector.getInstance().getRecentFreezes();
        map.put("total_freezes", freezes.size());
        map.put("filtered_count", allFreezes.size() - freezes.size()); // v1.1: 필터링된 수

        List<Map<String, Object>> list = new ArrayList<>();
        for (FreezeDetector.FreezeSnapshot snapshot : freezes) {
            Map<String, Object> item = new LinkedHashMap<>();
            item.put("timestamp", formatInstant(Instant.ofEpochMilli(snapshot.timestamp)));
            item.put("duration_ms", snapshot.freezeDurationMs);

            Map<String, Object> mem = new LinkedHashMap<>();
            mem.put("used_mb", snapshot.memory.used / 1024 / 1024);
            mem.put("total_mb", snapshot.memory.total / 1024 / 1024);
            item.put("memory", mem);

            List<String> stack = new ArrayList<>();
            int limit = 0;
            for (String line : snapshot.stackTrace) {
                if (limit++ > 10)
                    break;
                stack.add(line);
            }
            item.put("stack_trace", stack);
            list.add(item);
        }
        map.put("history", list);
        return map;
    }

    public List<String> generateRecommendations() {
        List<String> recommendations = new ArrayList<>();
        TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);
        TickHistogram histogram = profiler.getTickHistogram();
        SpikeLog spikeLog = profiler.getSpikeLog();

        if (tickData != null && tickData.getCallCount() > 0) {
            double avgMs = tickData.getAverageMicros() / 1000.0;
            double maxMs = tickData.getMaxMicros() / 1000.0;

            if (avgMs > 33.33) {
                recommendations.add("CRITICAL: Average tick time (" + round(avgMs)
                        + "ms) exceeds 33ms. Game is running below 30 FPS.");
            } else if (avgMs > 16.67) {
                recommendations.add("WARNING: Average tick time (" + round(avgMs)
                        + "ms) exceeds 16.67ms target. Consider optimization.");
            }

            if (spikeLog.getTotalSpikes() > 10) {
                recommendations.add("High spike count (" + spikeLog.getTotalSpikes() + "). Investigate: "
                        + spikeLog.getWorstSpikeLabel());
            }

            if (maxMs > 100) {
                recommendations.add("SEVERE: Max tick spike (" + round(maxMs) + "ms) exceeded 100ms.");
            }

            double p95 = histogram.getP95();
            if (p95 > 33.33) {
                recommendations.add("P95 tick time (" + round(p95) + "ms) is high. 5% of ticks are causing stutters.");
            }
        }

        // 현재 상태로 검증 (캐시된 결과가 아닌 실시간)
        SelfValidation.ValidationResult val = SelfValidation.getInstance().validate();
        if (val != null && val.hookStatus != SelfValidation.HookStatus.OK) {
            recommendations.add("CRITICAL: Pulse hooks are MISSING or PARTIAL. Check Mixin logs.");
        }

        // v0.9.1: 두 레벨로 분리
        com.echo.validation.FallbackTickEmitter fallback = com.echo.validation.FallbackTickEmitter.getInstance();
        if (fallback.isHistogramContaminated()) {
            recommendations
                    .add("WARNING: Fallback ticks contaminated timing data. Histogram/percentiles may be inaccurate.");
        } else if (EchoConfig.getInstance().isUsedFallbackTicks()) {
            recommendations.add("INFO: Fallback tick emitter was activated but timing data is clean.");
        }

        long sessionMs = profiler.getSessionDurationMs();
        if (sessionMs < 10000) {
            recommendations.add("INFO: Short session (<10s). Data may be noisy.");
        }

        if (recommendations.isEmpty()) {
            recommendations.add("Performance looks good! No critical issues detected.");
        }

        return recommendations;
    }

    private Map<String, Object> generateMemoryStats() {
        return MemoryProfiler.toMap();
    }

    private Map<String, Object> generateLuaProfiling() {
        return LuaCallTracker.getInstance().toMap(topN);
    }

    private Map<String, Object> generateLuaGCStats() {
        return LuaGCProfiler.getInstance().toMap();
    }

    private Map<String, Object> generateFuseDeepAnalysis() {
        if (!EchoConfig.getInstance().isDeepAnalysisEnabled()) {
            return null;
        }
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("pathfinding", PathfindingProfiler.getInstance().toMap());
        map.put("zombie", ZombieProfiler.getInstance().toMap());
        map.put("iso_grid", IsoGridProfiler.getInstance().toMap());
        return map;
    }

    private Map<String, Object> generateValidationStatus() {
        return SelfValidation.getInstance().toMap();
    }

    private Map<String, Object> generateReportQuality() {
        ReportQualityScorer.QualityResult result = ReportQualityScorer.getInstance().calculateScore(profiler);
        return result.toMap();
    }

    private Map<String, Object> generateAnalysis() {
        Map<String, Object> map = new LinkedHashMap<>();
        MetricCollector collector = profiler.getMetricCollector();
        if (collector != null) {
            double corr = collector.getCorrelation("zombie_count", "tick_time");
            map.put("zombie_tick_correlation", corr);
            map.put("interpretation", CorrelationAnalyzer.interpret(corr));
        }
        return map;
    }

    private Map<String, Object> generateMetadata() {
        reportMetadata.finalizeSampling();
        Map<String, Object> meta = reportMetadata.toMap();
        meta.put("echo_version", "1.0.1");
        meta.put("session_start_time", formatInstant(Instant.ofEpochMilli(profiler.getSessionStartTime())));
        meta.put("scenario_name", scenarioName);
        meta.put("scenario_tags", scenarioTags);
        meta.put("quality_flags", generateQualityFlagSummary());
        return meta;
    }

    private Map<String, Object> generateQualityFlagSummary() {
        Map<String, Object> summary = new LinkedHashMap<>();
        Map<String, Integer> counts = new LinkedHashMap<>();
        for (var entry : qualityFlagCounts.entrySet()) {
            counts.put(entry.getKey().name(), entry.getValue());
        }
        summary.put("flag_counts", counts);
        int totalFlags = qualityFlagCounts.values().stream().mapToInt(Integer::intValue).sum();
        summary.put("total_flags", totalFlags);
        long totalTicks = profiler.getTickHistogram().getTotalSamples();
        double qualityScore = totalTicks > 0 ? Math.max(0, 1.0 - (double) totalFlags / totalTicks) : 1.0;
        summary.put("data_quality_score", round(qualityScore * 100));
        return summary;
    }

    private String formatInstant(Instant instant) {
        return DateTimeFormatter.ISO_INSTANT.format(instant);
    }

    private double round(double value) {
        return Math.round(value * 100.0) / 100.0;
    }

    private static class RankedFunction {
        final String label;
        final String parentPoint;
        final long callCount;
        final long totalMicros;
        final long maxMicros;

        RankedFunction(String label, String parentPoint, long callCount, long totalMicros, long maxMicros) {
            this.label = label;
            this.parentPoint = parentPoint;
            this.callCount = callCount;
            this.totalMicros = totalMicros;
            this.maxMicros = maxMicros;
        }

        Map<String, Object> toMap(int rank) {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("rank", rank);
            map.put("label", label);
            map.put("parent_point", parentPoint);
            map.put("call_count", callCount);
            map.put("total_time_ms", Math.round(totalMicros / 10.0) / 100.0);
            map.put("average_time_ms", callCount > 0 ? Math.round((double) totalMicros / callCount / 10.0) / 100.0 : 0);
            map.put("max_time_ms", Math.round(maxMicros / 10.0) / 100.0);
            return map;
        }
    }

}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\report\ReportMetadata.java =====

package com.echo.report;

import java.util.*;

/**
 * Echo 리포트 메타데이터.
 * 
 * 리포트 재현성을 위한 환경 정보를 수집합니다.
 * A/B 비교나 최적화 효과 측정에 필수적입니다.
 * 
 * @since 1.0.1
 */
public class ReportMetadata {

    private String pulseVersion = "1.0.1";
    private String echoVersion = "1.0.1";
    private List<String> loadedMods = new ArrayList<>();
    private String jvmOptions = "";
    private String mapSeed = "unknown";
    private long sessionStartTime;
    private long samplingDurationMs;
    private String gameMode = "unknown";
    private boolean isMultiplayer = false;
    private int playerCount = 1;

    // 시스템 정보
    private String javaVersion;
    private String osName;
    private int availableProcessors;
    private long maxMemoryMB;

    public ReportMetadata() {
        this.sessionStartTime = System.currentTimeMillis();
        collectSystemInfo();
    }

    /**
     * 시스템 정보 자동 수집
     */
    private void collectSystemInfo() {
        this.javaVersion = System.getProperty("java.version");
        this.osName = System.getProperty("os.name");
        this.availableProcessors = Runtime.getRuntime().availableProcessors();
        this.maxMemoryMB = Runtime.getRuntime().maxMemory() / (1024 * 1024);

        // JVM 옵션 수집 시도
        try {
            java.lang.management.RuntimeMXBean runtimeMxBean = java.lang.management.ManagementFactory
                    .getRuntimeMXBean();
            List<String> arguments = runtimeMxBean.getInputArguments();
            this.jvmOptions = String.join(" ", arguments);
        } catch (Exception e) {
            this.jvmOptions = "unavailable";
        }
    }

    /**
     * Pulse에서 메타데이터 수집
     */
    public void collectFromPulse() {
        try {
            // GameAccess를 통해 맵 시드 수집
            Class<?> gameAccessClass = Class.forName("com.pulse.api.GameAccess");

            // 맵 시드
            try {
                java.lang.reflect.Method getMapSeed = gameAccessClass.getMethod("getMapSeed");
                Object seed = getMapSeed.invoke(null);
                if (seed != null) {
                    this.mapSeed = seed.toString();
                }
            } catch (Exception e) {
                // 무시
            }

            // 멀티플레이어 여부
            try {
                java.lang.reflect.Method isMultiplayer = gameAccessClass.getMethod("isMultiplayer");
                Object result = isMultiplayer.invoke(null);
                if (result instanceof Boolean) {
                    this.isMultiplayer = (Boolean) result;
                }
            } catch (Exception e) {
                // 무시
            }
        } catch (ClassNotFoundException e) {
            // Pulse 없이 실행 중
        }
    }

    /**
     * 샘플링 종료 시 호출
     */
    public void finalizeSampling() {
        this.samplingDurationMs = System.currentTimeMillis() - sessionStartTime;
    }

    // Getters and Setters

    public String getPulseVersion() {
        return pulseVersion;
    }

    public void setPulseVersion(String pulseVersion) {
        this.pulseVersion = pulseVersion;
    }

    public String getEchoVersion() {
        return echoVersion;
    }

    public void setEchoVersion(String echoVersion) {
        this.echoVersion = echoVersion;
    }

    public List<String> getLoadedMods() {
        return loadedMods;
    }

    public void setLoadedMods(List<String> loadedMods) {
        this.loadedMods = loadedMods;
    }

    public void addLoadedMod(String modId) {
        this.loadedMods.add(modId);
    }

    public String getJvmOptions() {
        return jvmOptions;
    }

    public String getMapSeed() {
        return mapSeed;
    }

    public void setMapSeed(String mapSeed) {
        this.mapSeed = mapSeed;
    }

    public long getSessionStartTime() {
        return sessionStartTime;
    }

    public long getSamplingDurationMs() {
        return samplingDurationMs;
    }

    public String getGameMode() {
        return gameMode;
    }

    public void setGameMode(String gameMode) {
        this.gameMode = gameMode;
    }

    public boolean isMultiplayer() {
        return isMultiplayer;
    }

    public void setMultiplayer(boolean multiplayer) {
        isMultiplayer = multiplayer;
    }

    public int getPlayerCount() {
        return playerCount;
    }

    public void setPlayerCount(int playerCount) {
        this.playerCount = playerCount;
    }

    /**
     * Map 형태로 변환 (JSON 직렬화용)
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();

        // 버전 정보
        Map<String, String> versions = new LinkedHashMap<>();
        versions.put("pulse", pulseVersion);
        versions.put("echo", echoVersion);
        map.put("versions", versions);

        // 세션 정보
        Map<String, Object> session = new LinkedHashMap<>();
        session.put("start_time", sessionStartTime);
        session.put("duration_ms", samplingDurationMs);
        session.put("game_mode", gameMode);
        session.put("multiplayer", isMultiplayer);
        session.put("player_count", playerCount);
        session.put("map_seed", mapSeed);
        map.put("session", session);

        // 시스템 정보
        Map<String, Object> system = new LinkedHashMap<>();
        system.put("java_version", javaVersion);
        system.put("os", osName);
        system.put("cpu_cores", availableProcessors);
        system.put("max_memory_mb", maxMemoryMB);
        system.put("jvm_options", jvmOptions);
        map.put("system", system);

        // 모드 정보
        map.put("loaded_mods", loadedMods);

        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\report\ReportQualityScorer.java =====

package com.echo.report;

import com.echo.aggregate.TimingData;
import com.echo.config.EchoConfig;
import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.measure.SubProfiler;
import com.echo.measure.TickPhaseProfiler;
import com.echo.validation.SelfValidation;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Echo Report Quality Scorer
 * 
 * 리포트 품질을 0~100 점수로 평가합니다.
 * 품질이 낮은 리포트는 별도 폴더에 저장하거나 저장을 건너뜁니다.
 * 
 * @since Echo 0.9.0
 */
public class ReportQualityScorer {

    private static final ReportQualityScorer INSTANCE = new ReportQualityScorer();

    // 패널티 최대값
    private static final int TICK_PENALTY_MAX = 25;
    private static final int PHASE_PENALTY_MAX = 15;
    @SuppressWarnings("unused") // Reserved for Lua profiling penalties
    private static final int LUA_PENALTY_MAX = 10;
    private static final int SESSION_PENALTY_MAX = 15;
    @SuppressWarnings("unused") // Reserved for stability scoring
    private static final int STABILITY_PENALTY_MAX = 10;
    private static final int VALIDATION_PENALTY_MAX = 25;

    private ReportQualityScorer() {
    }

    public static ReportQualityScorer getInstance() {
        return INSTANCE;
    }

    /**
     * 품질 점수 계산 (0~100)
     */
    public QualityResult calculateScore(EchoProfiler profiler) {
        QualityResult result = new QualityResult();
        int score = 100;

        // 1. Tick Coverage Penalty
        TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);
        if (tickData == null || tickData.getCallCount() == 0) {
            score -= TICK_PENALTY_MAX;
            result.addIssue("no_tick_data", "critical", "No tick data collected (total_ticks = 0)");
        } else if (tickData.getCallCount() < 10) {
            score -= 15;
            result.addIssue("low_tick_count", "warning", "Very few ticks: " + tickData.getCallCount());
        } else if (tickData.getCallCount() < 100) {
            score -= 5;
            result.addIssue("short_sample", "info", "Limited tick sample: " + tickData.getCallCount());
        }

        // 2. Session Length Penalty
        long sessionMs = profiler.getSessionDurationMs();
        if (sessionMs < 3000) { // 3초 미만
            score -= SESSION_PENALTY_MAX;
            result.addIssue("session_too_short", "warning", "Session < 3 seconds: " + (sessionMs / 1000.0) + "s");
        } else if (sessionMs < 10000) { // 10초 미만
            score -= 8;
            result.addIssue("short_session", "info", "Session < 10 seconds");
        }

        // 3. Phase Coverage Penalty (DeepAnalysis가 켜진 경우만)
        EchoConfig config = EchoConfig.getInstance();
        if (config.isDeepAnalysisEnabled()) {
            TickPhaseProfiler tickPhase = TickPhaseProfiler.getInstance();
            if (tickPhase.getTotalPhaseCount() == 0) {
                score -= PHASE_PENALTY_MAX;
                result.addIssue("no_phase_data", "warning", "DeepAnalysis enabled but no phase data");
            }

            // SubProfiler 체크
            SubProfiler subProfiler = SubProfiler.getInstance();
            if (subProfiler.getEntryCount() == 0) {
                score -= 10;
                result.addIssue("no_subprofiler_data", "warning", "DeepAnalysis enabled but SubProfiler empty");
            }
        }

        // 4. Lua Profiling Penalty (Lua가 켜진 경우만)
        if (config.isLuaProfilingEnabled()) {
            // Lua가 켜졌는데 데이터가 없으면 패널티
            // (추후 LuaCallTracker 연동)
        }

        // 5. Validation Status Penalty (현재 상태로 검증)
        SelfValidation.ValidationResult validationResult = SelfValidation.getInstance().validate();
        if (validationResult != null) {
            if (validationResult.hookStatus == SelfValidation.HookStatus.MISSING) {
                score -= VALIDATION_PENALTY_MAX;
                result.addIssue("hook_missing", "critical", "Pulse hook not firing");
            } else if (validationResult.hookStatus == SelfValidation.HookStatus.PARTIAL) {
                score -= 10;
                result.addIssue("hook_partial", "warning", "Tick hook firing intermittently");
            }

            if (validationResult.freezeDetectorStatus == SelfValidation.FreezeDetectorStatus.INACTIVE) {
                score -= 5;
                result.addIssue("freeze_detector_inactive", "info", "FreezeDetector not receiving ticks");
            }
        }

        // 6. Fallback Tick Penalty (v0.9.1: 두 레벨로 분리)
        com.echo.validation.FallbackTickEmitter fallback = com.echo.validation.FallbackTickEmitter.getInstance();

        // (A) 골든 탈락 조건: timing 데이터가 오염된 경우에만 패널티
        if (fallback.isHistogramContaminated()) {
            score -= 20;
            result.addIssue("fallback_contaminated", "warning",
                    "Fallback ticks contaminated timing data - histogram/percentiles may be inaccurate");
        }

        // (B) 진단 정보: fallback이 켜졌던 사실은 info로 남김 (골든 판정에 영향 없음)
        if (config.isUsedFallbackTicks()) {
            // 패널티 없음 - 정보성 경고만
            result.addIssue("used_fallback_ticks", "info",
                    "Fallback tick emitter was activated during session (timing data not contaminated)");
        }

        result.score = Math.max(0, score);
        return result;
    }

    /**
     * 저장 여부 판단
     */
    public boolean shouldSave(int score) {
        return score >= EchoConfig.getInstance().getMinQualityToSave();
    }

    /**
     * 저장 위치 결정
     * 
     * @return "normal" or "low_quality"
     */
    public String getSaveLocation(int score) {
        int threshold = EchoConfig.getInstance().getMinQualityToSave();
        if (score < threshold) {
            return "low_quality";
        }
        return "normal";
    }

    // --- Result Class ---

    public static class QualityResult {
        public int score = 100;
        public final List<Map<String, String>> issues = new ArrayList<>();

        public void addIssue(String issue, String severity, String description) {
            Map<String, String> issueMap = new LinkedHashMap<>();
            issueMap.put("issue", issue);
            issueMap.put("severity", severity);
            issueMap.put("description", description);
            issues.add(issueMap);
        }

        public boolean hasIssues() {
            return !issues.isEmpty();
        }

        public boolean isCritical() {
            return issues.stream().anyMatch(i -> "critical".equals(i.get("severity")));
        }

        public Map<String, Object> toMap() {
            Map<String, Object> map = new LinkedHashMap<>();
            map.put("score", score);
            map.put("issues", issues);
            return map;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\session\SessionManager.java =====

package com.echo.session;

import com.echo.EchoConstants;
import com.echo.config.EchoConfig;
import com.echo.measure.EchoProfiler;
import com.echo.report.EchoReport;
import com.pulse.api.log.PulseLogger;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * Echo 세션 관리자
 * 
 * 싱글플레이/멀티플레이 세션 단위로 프로파일링 데이터를 관리합니다.
 * - 세션 시작: 프로파일러 리셋
 * - 세션 종료: 비동기 리포트 저장 (MainMenuRenderEvent)
 * - Shutdown: 동기 리포트 저장 (비정상 종료 대비)
 * 
 * @since 2.1.0 - MainMenuRenderEvent 기반 세션 종료 감지
 */
public class SessionManager {

    private static final SessionManager INSTANCE = new SessionManager();

    // --- 세션 상태 ---
    private volatile boolean sessionActive = false;
    private volatile boolean dirty = false;
    private volatile String currentWorldName = null;
    private volatile boolean isMultiplayer = false;

    // --- dirty 최소 조건 ---
    private volatile int tickCount = 0;

    // --- 메인 메뉴 렌더 기반 세션 종료 감지 ---
    private volatile int menuRenderCount = 0;

    // --- 메인 메뉴 상태 (false 세션 방지) ---
    private volatile boolean onMainMenu = true;

    // --- 메인 메뉴 이탈 감지 (틱 기반) ---
    private volatile int ticksSinceMenuRender = 0;

    // --- 비동기 저장 ---
    private final ExecutorService saveExecutor = Executors.newSingleThreadExecutor(r -> new Thread(r, "Echo-Save"));

    private SessionManager() {
    }

    public static SessionManager getInstance() {
        return INSTANCE;
    }

    // --- 세션 라이프사이클 ---

    /**
     * 월드 로드 시 호출 (세션 시작)
     */
    public void onWorldLoad(String worldName, boolean multiplayer) {
        // 메인 메뉴 플래그 해제 - 게임에 진입함
        onMainMenu = false;

        if (!sessionActive) {
            sessionActive = true;
            dirty = false;
            tickCount = 0;
            currentWorldName = worldName;
            isMultiplayer = multiplayer;

            EchoProfiler.getInstance().reset();
            PulseLogger.info("Echo", "Session started: " + worldName +
                    (multiplayer ? " (MP)" : " (SP)"));
        }
    }

    public void onWorldUnload() {
        if (sessionActive && dirty) {
            sessionActive = false;
            saveAsync();
            PulseLogger.info("Echo", "Session ended - saving report");
        } else if (sessionActive) {
            sessionActive = false;
            PulseLogger.debug("Echo", "Session ended - no data to save (tickCount=" + tickCount + ")");
        }
        menuRenderCount = 0;
    }

    /**
     * 메인 메뉴 렌더 시 호출 (세션이 활성 상태면 종료 감지)
     * 
     * 게임 중에는 MainScreenState.render()가 호출되지 않으므로,
     * 이 메서드가 호출되면 메인 메뉴로 돌아온 것입니다.
     */
    public void onMainMenuRender() {
        // 메인 메뉴 플래그 설정 - 새 세션 시작 방지
        onMainMenu = true;

        // 틱 카운터 리셋 - 메뉴 렌더가 호출되면 아직 메인 메뉴임
        ticksSinceMenuRender = 0;

        // 메인 메뉴에서는 wasWorldLoaded를 현재 상태로 동기화
        // 이렇게 하면 onTick()의 false→true 전환 감지가 작동하지 않음
        wasWorldLoaded = com.pulse.api.access.WorldAccess.isWorldLoaded();

        if (!sessionActive) {
            menuRenderCount = 0;
            return;
        }

        menuRenderCount++;

        if (menuRenderCount >= EchoConstants.MENU_RENDER_THRESHOLD && dirty) {
            PulseLogger.info("Echo", "Menu detected (" + menuRenderCount + " frames) - saving session");
            sessionActive = false;
            dirty = false;
            tickCount = 0;
            saveAsync();
            menuRenderCount = 0;
        }
    }

    // --- Mixin 실패 대비: 월드 상태 변화 감지 ---
    private volatile boolean wasWorldLoaded = false;

    /**
     * 틱 완료 시 호출 (데이터 수집 마킹)
     * 
     * Pulse GameStateAccess와 WorldAccess를 사용하여 정확한 상태 감지.
     * - GameStateAccess.isOnMainMenu(): 메인 메뉴 상태 확인
     * - WorldAccess.isWorldLoaded(): 월드 로드 상태 확인 (Cell 존재 여부 포함)
     * 
     * @since 2.1.1 - Pulse GameStateAccess 기반으로 개선
     */
    public void onTick() {
        // Phase 1: Pulse API로 현재 상태 확인
        boolean isOnMainMenuNow = com.pulse.api.access.GameStateAccess.isOnMainMenu();
        boolean isWorldLoaded = com.pulse.api.access.WorldAccess.isWorldLoaded();

        // 메인 메뉴 상태 동기화 (Pulse API 결과 반영)
        if (isOnMainMenuNow) {
            onMainMenu = true;
            ticksSinceMenuRender = 0;
        } else if (onMainMenu) {
            // 틱 기반 감지 (GameStateAccess 실패 시 폴백)
            ticksSinceMenuRender++;
            if (ticksSinceMenuRender >= EchoConstants.MENU_EXIT_THRESHOLD) {
                onMainMenu = false;
                wasWorldLoaded = false;
                PulseLogger.debug("Echo",
                        "Game entered (fallback: no menu render for " + ticksSinceMenuRender + " ticks)");
            }
        }

        // 세션이 없을 때: 게임 진입 및 월드 로드 감지
        if (!sessionActive) {
            // 메인 메뉴에서는 세션 시작하지 않음 (wasWorldLoaded 업데이트하지 않음)
            if (onMainMenu || isOnMainMenuNow) {
                // 중요: wasWorldLoaded를 업데이트하지 않음 - 게임 진입 후 false→true 감지 보장
                return;
            }

            // 월드 로드 상태가 false→true로 변경됐을 때 또는 게임 진입 직후 월드가 로드된 경우
            if (isWorldLoaded && !wasWorldLoaded) {
                sessionActive = true;
                dirty = false;
                tickCount = 0;
                currentWorldName = com.pulse.api.access.WorldAccess.getWorldName();
                if (currentWorldName == null || currentWorldName.isEmpty()) {
                    currentWorldName = "AutoDetected";
                }
                isMultiplayer = isMultiplayerWorld();

                EchoProfiler.getInstance().reset();
                PulseLogger.info("Echo", "Session started (world: " + currentWorldName + ")");
            }
            wasWorldLoaded = isWorldLoaded;
            return;
        }

        // 세션이 활성 상태: 틱 카운트 증가
        tickCount++;
        if (tickCount >= EchoConstants.MIN_TICKS_FOR_DIRTY && !dirty) {
            dirty = true;
            PulseLogger.debug("Echo", "Session marked dirty (sufficient data)");
        }

        wasWorldLoaded = isWorldLoaded;
    }

    private boolean isMultiplayerWorld() {
        try {
            Class<?> gameClient = Class.forName("zombie.network.GameClient");
            java.lang.reflect.Field bClient = gameClient.getField("bClient");
            return Boolean.TRUE.equals(bClient.get(null));
        } catch (Exception e) {
            return false;
        }
    }

    // --- 저장 ---

    /**
     * 비동기 저장 (메뉴 복귀 시 프리즈 방지)
     */
    private void saveAsync() {
        if (!EchoConfig.getInstance().isAutoSaveReports()) {
            return;
        }

        EchoReport report = new EchoReport(EchoProfiler.getInstance());
        saveExecutor.submit(() -> saveReport(report));
    }

    /**
     * 동기 저장 (shutdown hook용)
     */
    public void saveSync() {
        boolean shouldSave = sessionActive && tickCount > 0;

        if (!shouldSave) {
            return;
        }
        if (!EchoConfig.getInstance().isAutoSaveReports()) {
            return;
        }

        PulseLogger.info("Echo", "Shutdown - saving session...");
        EchoReport report = new EchoReport(EchoProfiler.getInstance());
        saveReport(report);
    }

    private boolean saveReport(EchoReport report) {
        try {
            EchoConfig config = EchoConfig.getInstance();
            String path = report.saveWithTimestamp(config.getReportDirectory());
            report.printQualitySummary();
            PulseLogger.info("Echo", "Report saved: " + path);
            return true;
        } catch (Exception e) {
            PulseLogger.error("Echo", "Failed to save report: " + e.getMessage());
            return false;
        }
    }

    // --- Executor 종료 ---

    /**
     * Executor 정리 (shutdown hook에서 호출)
     */
    public void shutdownExecutor() {
        saveExecutor.shutdown();
        try {
            if (!saveExecutor.awaitTermination(2, TimeUnit.SECONDS)) {
                saveExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            saveExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    // --- 상태 조회 ---

    public boolean hasUnsavedData() {
        return sessionActive && dirty;
    }

    public boolean isSessionActive() {
        return sessionActive;
    }

    public String getCurrentWorldName() {
        return currentWorldName;
    }

    public boolean isMultiplayer() {
        return isMultiplayer;
    }

    public int getTickCount() {
        return tickCount;
    }

    /**
     * 테스트용 리셋
     */
    public void resetForTest() {
        sessionActive = false;
        dirty = false;
        tickCount = 0;
        currentWorldName = null;
        isMultiplayer = false;
        onMainMenu = true;
        ticksSinceMenuRender = 0;
        wasWorldLoaded = false;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\spi\EchoProfilerProvider.java =====

package com.echo.spi;

import com.pulse.api.spi.IProfilerProvider;
import com.pulse.api.spi.Priority;
import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.aggregate.TimingData;

/**
 * Echo의 IProfilerProvider 구현.
 * Pulse SPI를 통해 다른 모드와 연동 가능.
 */
public class EchoProfilerProvider implements IProfilerProvider {

    private static final String ID = "echo";
    private static final String NAME = "Echo Profiler";
    private static final String VERSION = "1.0.0";

    private final EchoProfiler profiler;
    private boolean enabled = true;

    public EchoProfilerProvider() {
        this.profiler = EchoProfiler.getInstance();
    }

    // --- IProvider 기본 메서드 ---

    @Override
    public String getId() {
        return ID;
    }

    @Override
    public String getName() {
        return NAME;
    }

    @Override
    public String getVersion() {
        return VERSION;
    }

    @Override
    public String getDescription() {
        return "Real-time performance profiling tool for Project Zomboid";
    }

    @Override
    public int getPriority() {
        return Priority.HIGH; // 프로파일러는 높은 우선순위
    }

    @Override
    public void onInitialize() {
        System.out.println("[Echo] ProfilerProvider initialized");
        profiler.enable();
    }

    @Override
    public void onShutdown() {
        System.out.println("[Echo] ProfilerProvider shutting down");
        profiler.disable();
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    // --- IProfilerProvider 구현 ---

    @Override
    public void onTickStart() {
        profiler.push(ProfilingPoint.TICK);
    }

    @Override
    public void onTickEnd(long tickTimeNanos) {
        profiler.pop(ProfilingPoint.TICK);
    }

    @Override
    public void onFrameStart() {
        profiler.push(ProfilingPoint.RENDER);
    }

    @Override
    public void onFrameEnd(long frameTimeNanos) {
        profiler.pop(ProfilingPoint.RENDER);
    }

    @Override
    public double getCurrentFps() {
        TimingData renderData = profiler.getTimingData(ProfilingPoint.RENDER);
        if (renderData != null && renderData.getCallCount() > 0) {
            double avgMicros = renderData.getStats1s().getAverage();
            if (avgMicros > 0) {
                return 1_000_000.0 / avgMicros;
            }
        }
        return 60.0; // 기본값
    }

    @Override
    public double getAverageTickTimeMs() {
        TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);
        if (tickData != null && tickData.getCallCount() > 0) {
            return tickData.getStats1s().getAverage() / 1000.0; // micros to ms
        }
        return 16.67; // 기본값
    }

    @Override
    public double getAverageFrameTimeMs() {
        TimingData renderData = profiler.getTimingData(ProfilingPoint.RENDER);
        if (renderData != null && renderData.getCallCount() > 0) {
            return renderData.getStats1s().getAverage() / 1000.0; // micros to ms
        }
        return 16.67; // 기본값
    }

    @Override
    public void startProfiling() {
        profiler.enable();
        enabled = true;
        System.out.println("[Echo] Profiling started");
    }

    @Override
    public void stopProfiling() {
        profiler.disable();
        enabled = false;
        System.out.println("[Echo] Profiling stopped");
    }

    @Override
    public boolean isProfiling() {
        return profiler.isEnabled();
    }

    @Override
    public void resetData() {
        profiler.reset();
        System.out.println("[Echo] Profiling data reset");
    }

    // --- Echo 전용 확장 메서드 ---

    /**
     * 내부 EchoProfiler 인스턴스 접근
     */
    public EchoProfiler getProfiler() {
        return profiler;
    }

    /**
     * 특정 ProfilingPoint의 데이터 조회
     */
    public TimingData getTimingData(ProfilingPoint point) {
        return profiler.getTimingData(point);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\spi\EchoTickHealthProvider.java =====

package com.echo.spi;

import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.aggregate.TimingData;
import com.pulse.api.spi.ITickHealthProvider;
import com.pulse.api.spi.Priority;

/**
 * Echo 기반 Tick Health Provider.
 * 
 * Pulse SPI(ITickHealthProvider) 구현체.
 * Echo의 프로파일링 데이터를 기반으로 Tick 건강 상태 제공.
 * 
 * Nerve는 이 클래스를 직접 참조하지 않고, Pulse 레지스트리를 통해
 * ITickHealthProvider 인터페이스로만 접근함.
 * 
 * @since Echo 1.1
 */
public class EchoTickHealthProvider implements ITickHealthProvider {

    private static final String PROVIDER_ID = "echo-tick-health";
    private static final String PROVIDER_NAME = "Echo Tick Health Provider";
    private static final String VERSION = "1.1.0";

    // --- 임계값 ---
    private static final double SLOW_TICK_THRESHOLD_MS = 33.33; // 30fps 기준
    private static final int SPIKE_WINDOW_SECONDS = 5;

    // --- 캐시 (틱당 계산 최소화) ---
    private volatile boolean slowTickCached = false;
    private volatile int spikeCountCached = 0;
    private volatile double last1sMaxCached = 0.0;
    private volatile double last5sAvgCached = 0.0;
    private volatile long lastUpdateTick = -1;

    private EchoProfiler profiler;

    public EchoTickHealthProvider() {
        // Profiler는 나중에 설정 (lazy init)
    }

    /**
     * EchoProfiler 참조 설정.
     * Echo 초기화 시 호출.
     */
    public void setProfiler(EchoProfiler profiler) {
        this.profiler = profiler;
    }

    /**
     * 틱마다 호출하여 데이터 갱신.
     * EchoMod.onTick()에서 호출.
     */
    public void update() {
        if (profiler == null) {
            return;
        }

        long currentTick = profiler.getTickHistogram().getTotalSamples();
        if (currentTick == lastUpdateTick) {
            return; // 이미 이번 틱에 갱신됨
        }
        lastUpdateTick = currentTick;

        try {
            TimingData tickData = profiler.getTimingData(ProfilingPoint.TICK);
            if (tickData != null) {
                TimingData.RollingStats stats1s = tickData.getStats1s();
                TimingData.RollingStats stats5s = tickData.getStats5s();

                // 1초 내 최대값
                last1sMaxCached = stats1s.getMax() / 1000.0;

                // 5초 평균
                last5sAvgCached = stats5s.getAverage() / 1000.0;

                // SlowTick 판정
                slowTickCached = last1sMaxCached > SLOW_TICK_THRESHOLD_MS;

                // 스파이크 카운트 (최근 N초 내 스파이크 수)
                // SpikeLog.getAllSpikes()에서 timestamp 기반으로 필터링
                spikeCountCached = countRecentSpikes(SPIKE_WINDOW_SECONDS);
            }
        } catch (Exception e) {
            // 오류 시 안전 기본값
            slowTickCached = false;
            spikeCountCached = 0;
        }
    }

    /**
     * 최근 N초 내 스파이크 수 계산.
     */
    @SuppressWarnings("unused") // windowSeconds 파라미터는 향후 정밀 필터링에 사용 예정
    private int countRecentSpikes(int windowSeconds) {
        if (profiler == null) {
            return 0;
        }
        // SpikeLog의 총 스파이크 수 반환 (단순화)
        // 더 정밀한 시간 기반 필터링이 필요하면 getAllSpikes() 사용
        return (int) Math.min(profiler.getSpikeLog().getTotalSpikes(), Integer.MAX_VALUE);
    }

    // ===================================
    // ITickHealthProvider 구현
    // ===================================

    @Override
    public boolean isSlowTick() {
        return slowTickCached;
    }

    @Override
    public int getRecentSpikeCount() {
        return spikeCountCached;
    }

    @Override
    public double getLast1sMaxMs() {
        return last1sMaxCached;
    }

    @Override
    public double getLast5sAvgMs() {
        return last5sAvgCached;
    }

    // ===================================
    // IProvider 구현
    // ===================================

    @Override
    public String getId() {
        return PROVIDER_ID;
    }

    @Override
    public String getName() {
        return PROVIDER_NAME;
    }

    @Override
    public String getVersion() {
        return VERSION;
    }

    @Override
    public String getDescription() {
        return "Provides tick health metrics based on Echo profiling data";
    }

    @Override
    public int getPriority() {
        return Priority.NORMAL;
    }

    @Override
    public boolean isEnabled() {
        return profiler != null;
    }

    @Override
    public void onInitialize() {
        // Profiler는 setProfiler()를 통해 나중에 설정됨
    }

    @Override
    public void onShutdown() {
        // 정리 작업 없음 (profiler는 EchoMod에서 관리)
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\tool\ReportDiff.java =====

package com.echo.tool;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import java.io.FileReader;

/**
 * CLI Tool to diff two Echo Reports.
 * Usage: java -cp Echo.jar com.echo.tool.ReportDiff report1.json report2.json
 */
public class ReportDiff {

    private static final Gson GSON = new Gson();

    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("Usage: ReportDiff <baseline.json> <candidate.json>");
            return;
        }

        String fileA = args[0];
        String fileB = args[1];

        try {
            JsonObject jsonA = GSON.fromJson(new FileReader(fileA), JsonObject.class);
            JsonObject jsonB = GSON.fromJson(new FileReader(fileB), JsonObject.class);

            if (jsonA == null || jsonB == null) {
                System.err.println("Failed to parse JSON.");
                return;
            }

            JsonObject echoA = jsonA.getAsJsonObject("echo_report");
            JsonObject echoB = jsonB.getAsJsonObject("echo_report");

            if (echoA == null || echoB == null) {
                // Try parsing as raw echo report if not wrapped
                if (jsonA.has("version"))
                    echoA = jsonA;
                if (jsonB.has("version"))
                    echoB = jsonB;
            }

            printDiff(fileA, echoA, fileB, echoB);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void printDiff(String nameA, JsonObject a, String nameB, JsonObject b) {
        System.out.println("ECHO REPORT DIFF");
        System.out.println("A: " + nameA + "  vs  B: " + nameB);
        System.out.println("--------------------------------------------------");

        compareSummary(a.getAsJsonObject("summary"), b.getAsJsonObject("summary"));
        // Compare other sections as needed...
    }

    private static void compareSummary(JsonObject a, JsonObject b) {
        System.out.println("\n[SUMMARY Comparison]");
        if (a == null || b == null) {
            System.out.println("  Missing summary section.");
            return;
        }

        double tickA = a.get("average_tick_ms").getAsDouble();
        double tickB = b.get("average_tick_ms").getAsDouble();

        diff("Avg Tick (ms)", tickA, tickB);

        long totalA = a.get("total_ticks").getAsLong();
        long totalB = b.get("total_ticks").getAsLong();

        diff("Total Ticks", totalA, totalB);

        double spikeA = a.get("max_tick_spike_ms").getAsDouble();
        double spikeB = b.get("max_tick_spike_ms").getAsDouble();

        diff("Max Spike (ms)", spikeA, spikeB);
    }

    private static void diff(String label, double valA, double valB) {
        double delta = valB - valA;
        double pct = (valA == 0) ? 0 : (delta / valA) * 100.0;
        String sign = delta > 0 ? "+" : "";
        String color = Math.abs(pct) < 5 ? "" : (delta < 0 ? " (Improved)" : " (Regressed)");

        System.out.printf("  %-20s: %8.2f -> %8.2f | %s%.2f (%.1f%%)%s%n",
                label, valA, valB, sign, delta, pct, color);
    }

    private static void diff(String label, long valA, long valB) {
        long delta = valB - valA;
        System.out.printf("  %-20s: %8d -> %8d | %+d%n",
                label, valA, valB, delta);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\ui\EchoExtendedHUD.java =====

package com.echo.ui;

import com.echo.EchoRuntime;
import com.echo.analysis.BottleneckDetector;
import com.echo.analysis.BottleneckDetector.*;
import com.echo.measure.*;
import com.pulse.api.service.echo.ConnectionQuality;
import com.pulse.api.service.echo.RenderEfficiency;

import com.pulse.ui.HUDOverlay;
import com.pulse.ui.UIRenderContext;

import java.util.*;

/**
 * Echo 확장 HUD - 추가 메트릭 표시
 * 
 * 병목 진단, 네트워크, 메모리 트렌드 등 고급 정보를 표시합니다.
 * F7 키로 토글할 수 있습니다.
 * 
 * @since 2.1.0
 */
public class EchoExtendedHUD extends HUDOverlay.HUDLayer {

    public static final String LAYER_ID = "echo_extended_hud";
    public static final int LAYER_PRIORITY = 101;

    private static final long UPDATE_INTERVAL_MS = 1000;
    private static final int PADDING = 6;
    private static final int LINE_HEIGHT = 14;
    private static final int BOX_WIDTH = 200;

    private static EchoExtendedHUD INSTANCE;
    private static boolean visible = false;

    private int hudX = 170;
    private int hudY = 10;

    private long lastCacheUpdate = 0;

    // 캐시된 값들
    private String cachedMemoryText = "Mem: --";
    private String cachedGcText = "GC: --";
    private String cachedNetworkText = "Net: --";
    private String cachedRenderText = "Render: --";
    private String cachedTopBottleneck = "Bottleneck: None";
    private String cachedBottleneckHint = "";

    private int memoryColor = EchoTheme.GOOD;
    private int networkColor = EchoTheme.GOOD;
    private int renderColor = EchoTheme.GOOD;
    private int bottleneckColor = EchoTheme.TEXT_SECONDARY;

    private EchoExtendedHUD() {
    }

    public static void register() {
        if (INSTANCE != null)
            return;

        INSTANCE = new EchoExtendedHUD();
        HUDOverlay.registerLayer(LAYER_ID, INSTANCE, LAYER_PRIORITY);
        System.out.println("[Echo] Extended HUD registered (F7 to toggle)");
    }

    public static void unregister() {
        if (INSTANCE == null)
            return;
        HUDOverlay.unregisterLayer(LAYER_ID);
        INSTANCE = null;
    }

    public static EchoExtendedHUD getInstance() {
        return INSTANCE;
    }

    public static void toggle() {
        visible = !visible;
        System.out.println("[Echo] Extended HUD: " + (visible ? "ON" : "OFF"));
    }

    public static boolean isShown() {
        return visible;
    }

    @Override
    public void render(UIRenderContext ctx) {
        if (!EchoRuntime.isEnabled() || !visible) {
            return;
        }

        try {
            updateCacheIfNeeded();
            renderExtendedHud(ctx);
        } catch (Exception e) {
            EchoRuntime.recordError("ExtendedHUD", e);
        }
    }

    @Override
    public void update(float deltaTime) {
    }

    private void updateCacheIfNeeded() {
        long now = System.currentTimeMillis();
        if (now - lastCacheUpdate < UPDATE_INTERVAL_MS)
            return;
        lastCacheUpdate = now;

        // 메모리
        double heapPercent = MemoryProfiler.getHeapUsagePercent();
        long gcCount = MemoryProfiler.getTotalGcCount();
        cachedMemoryText = String.format("Mem: %.0f%%", heapPercent);
        cachedGcText = String.format("GC: %d", gcCount);
        memoryColor = heapPercent > 85 ? EchoTheme.CRITICAL : heapPercent > 70 ? EchoTheme.WARNING : EchoTheme.GOOD;

        // 네트워크
        NetworkMetrics net = NetworkMetrics.getInstance();
        ConnectionQuality quality = net.getConnectionQuality();
        cachedNetworkText = String.format("Net: %.0fms (%s)",
                net.getAvgPingMs(), qualityToShort(quality));
        networkColor = quality == ConnectionQuality.POOR ? EchoTheme.CRITICAL
                : quality == ConnectionQuality.FAIR ? EchoTheme.WARNING : EchoTheme.GOOD;

        // 렌더링
        RenderMetrics render = RenderMetrics.getInstance();
        RenderEfficiency efficiency = render.getRenderEfficiency();
        cachedRenderText = String.format("DC: %.0f B:%.0f%%",
                render.getAvgDrawCallsPerFrame(), render.getBatchingEfficiency());
        renderColor = efficiency == RenderEfficiency.POOR ? EchoTheme.CRITICAL
                : efficiency == RenderEfficiency.FAIR ? EchoTheme.WARNING : EchoTheme.GOOD;

        // 병목
        List<Bottleneck> bottlenecks = BottleneckDetector.getInstance().identifyTopN(1);
        if (!bottlenecks.isEmpty()) {
            Bottleneck top = bottlenecks.get(0);
            cachedTopBottleneck = String.format("⚠ %s (%.1f%%)",
                    shortenName(top.displayName), top.ratio * 100);
            cachedBottleneckHint = top.suggestedModule == OptimizationModule.FUSE ? "→ Fuse target" : "→ Nerve target";
            bottleneckColor = top.priority > 70 ? EchoTheme.CRITICAL
                    : top.priority > 40 ? EchoTheme.WARNING : EchoTheme.GOOD;
        } else {
            cachedTopBottleneck = "No bottleneck";
            cachedBottleneckHint = "";
            bottleneckColor = EchoTheme.GOOD;
        }
    }

    private void renderExtendedHud(UIRenderContext ctx) {
        int lineCount = 6;
        int boxHeight = PADDING * 2 + lineCount * LINE_HEIGHT;

        // 배경
        ctx.fillRect(hudX, hudY, BOX_WIDTH, boxHeight, EchoTheme.getBackgroundRGB(), EchoTheme.getBackgroundAlpha());

        int y = hudY + PADDING;

        // 헤더
        ctx.drawText("─ Extended ─", hudX + PADDING, y, EchoTheme.TEXT_HIGHLIGHT);
        y += LINE_HEIGHT;

        // 메모리
        ctx.drawText(cachedMemoryText, hudX + PADDING, y, memoryColor);
        ctx.drawText(cachedGcText, hudX + BOX_WIDTH - PADDING - 50, y, EchoTheme.TEXT_SECONDARY);
        y += LINE_HEIGHT;

        // 네트워크
        ctx.drawText(cachedNetworkText, hudX + PADDING, y, networkColor);
        y += LINE_HEIGHT;

        // 렌더링
        ctx.drawText(cachedRenderText, hudX + PADDING, y, renderColor);
        y += LINE_HEIGHT;

        // 병목
        ctx.drawText(cachedTopBottleneck, hudX + PADDING, y, bottleneckColor);
        y += LINE_HEIGHT;

        // 병목 힌트
        if (!cachedBottleneckHint.isEmpty()) {
            ctx.drawText(cachedBottleneckHint, hudX + PADDING + 10, y, EchoTheme.TEXT_SECONDARY);
        }
    }

    private String qualityToShort(ConnectionQuality quality) {
        return switch (quality) {
            case EXCELLENT -> "EX";
            case GOOD -> "OK";
            case FAIR -> "FA";
            case POOR -> "PO";
        };
    }

    private String shortenName(String name) {
        return name.length() > 15 ? name.substring(0, 15) + "…" : name;
    }

    public void setPosition(int x, int y) {
        this.hudX = x;
        this.hudY = y;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\ui\EchoHUD.java =====

package com.echo.ui;

import com.echo.EchoRuntime;
import com.echo.input.EchoKeyBindings;
import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.aggregate.TimingData;
import com.echo.pulse.PulseMetricsAdapter;

import com.pulse.ui.HUDOverlay;
import com.pulse.ui.UIRenderContext;

import java.util.List;
import java.util.Map;

/**
 * Echo HUD - 인게임 성능 오버레이
 * 
 * Pulse HUDOverlay 시스템을 통해 렌더링됩니다.
 * F6 키로 토글할 수 있습니다.
 * 
 * @since 2.0.0 - Pulse Native Integration
 */
public class EchoHUD extends HUDOverlay.HUDLayer {

    // --- 상수 ---

    /** HUD 레이어 ID */
    public static final String LAYER_ID = "echo_hud";

    /** HUD 레이어 우선순위 (낮을수록 먼저 렌더링) */
    public static final int LAYER_PRIORITY = 100;

    /** HUD 갱신 주기 (밀리초) */
    private static final long UPDATE_INTERVAL_MS = 500;

    /** Top Hotspot 표시 개수 */
    private static final int TOP_HOTSPOT_COUNT = 3;

    /** HUD 패딩 */
    private static final int PADDING = 6;

    /** 줄 높이 */
    private static final int LINE_HEIGHT = 14;

    // --- 싱글톤 인스턴스 ---

    private static EchoHUD INSTANCE;

    // --- 인스턴스 필드 ---

    /** HUD 위치 */
    private int hudX = 10;
    private int hudY = 10;

    // --- 캐시 (0.5초마다 갱신) ---

    private long lastCacheUpdate = 0;

    // Zero-Allocation: StringBuilder 재사용
    private final StringBuilder formatBuffer = new StringBuilder(64);

    // 캐시된 표시 값
    private String cachedFpsText = "FPS: --";
    private String cachedFrameTimeText = "Frame: --ms";
    private String cachedTickTimeText = "Tick: --ms";
    private String cachedProfileStatus = "[OFF]";
    private final String[] cachedHotspots = new String[TOP_HOTSPOT_COUNT];
    private final int[] cachedHotspotColors = new int[TOP_HOTSPOT_COUNT];

    private int fpsColor = EchoTheme.GOOD;
    private int frameTimeColor = EchoTheme.GOOD;
    private int tickTimeColor = EchoTheme.GOOD;

    // --- 생성자 및 등록 ---

    private EchoHUD() {
        // Private constructor for singleton
    }

    /**
     * HUD 레이어 등록
     * EchoMod.init()에서 호출됨
     */
    public static void register() {
        if (INSTANCE != null) {
            System.out.println("[Echo] EchoHUD already registered");
            return;
        }

        INSTANCE = new EchoHUD();
        HUDOverlay.registerLayer(LAYER_ID, INSTANCE, LAYER_PRIORITY);
        System.out.println("[Echo] EchoHUD registered as Pulse HUD layer");
    }

    /**
     * HUD 레이어 등록 해제
     */
    public static void unregister() {
        if (INSTANCE == null)
            return;
        HUDOverlay.unregisterLayer(LAYER_ID);
        INSTANCE = null;
        System.out.println("[Echo] EchoHUD unregistered");
    }

    /**
     * 인스턴스 가져오기
     */
    public static EchoHUD getInstance() {
        return INSTANCE;
    }

    // --- HUDLayer 구현 ---

    @Override
    public void render(UIRenderContext ctx) {
        // 안전 체크
        if (!EchoRuntime.isEnabled() || !EchoKeyBindings.isHudVisible()) {
            return;
        }

        try {
            updateCacheIfNeeded();
            renderHud(ctx);
        } catch (Exception e) {
            EchoRuntime.recordError("HUD", e);
        }
    }

    @Override
    public void update(float deltaTime) {
        // HUD는 render에서 캐시 갱신하므로 별도 업데이트 불필요
    }

    // --- 캐시 갱신 ---

    /**
     * 캐시 갱신 (0.5초마다)
     */
    private void updateCacheIfNeeded() {
        long now = System.currentTimeMillis();
        if (now - lastCacheUpdate < UPDATE_INTERVAL_MS) {
            return;
        }
        lastCacheUpdate = now;

        // FPS / Frame Time / Tick Time (Zero-Allocation formatting)
        double fps = PulseMetricsAdapter.getFps();
        double frameTimeMs = PulseMetricsAdapter.getFrameTimeMs();
        double tickTimeMs = PulseMetricsAdapter.getTickTimeMs();

        cachedFpsText = formatFps(fps);
        cachedFrameTimeText = formatTime("Frame: ", frameTimeMs);
        cachedTickTimeText = formatTime("Tick: ", tickTimeMs);

        fpsColor = EchoTheme.getGradeColor(PulseMetricsAdapter.getFpsGrade());
        frameTimeColor = EchoTheme.getGradeColor(PulseMetricsAdapter.getFrameTimeGrade());
        tickTimeColor = EchoTheme.getGradeColor(PulseMetricsAdapter.getTickTimeGrade());

        // 프로파일링 상태
        EchoProfiler profiler = EchoProfiler.getInstance();
        cachedProfileStatus = profiler.isEnabled() ? "[ON]" : "[OFF]";

        // Top Hotspots
        updateHotspots(profiler);
    }

    /**
     * Top Hotspot 갱신
     */
    private void updateHotspots(EchoProfiler profiler) {
        if (!profiler.isEnabled()) {
            for (int i = 0; i < TOP_HOTSPOT_COUNT; i++) {
                cachedHotspots[i] = null;
            }
            return;
        }

        Map<ProfilingPoint, TimingData> allData = profiler.getTimingData();

        // 5초 윈도우 평균 기준 정렬
        List<Map.Entry<ProfilingPoint, TimingData>> sorted = allData.entrySet().stream()
                .filter(e -> e.getValue().getCallCount() > 0)
                .sorted((a, b) -> {
                    double avgA = a.getValue().getStats5s().getAverage();
                    double avgB = b.getValue().getStats5s().getAverage();
                    return Double.compare(avgB, avgA); // 내림차순
                })
                .limit(TOP_HOTSPOT_COUNT)
                .toList();

        for (int i = 0; i < TOP_HOTSPOT_COUNT; i++) {
            if (i < sorted.size()) {
                Map.Entry<ProfilingPoint, TimingData> entry = sorted.get(i);
                ProfilingPoint point = entry.getKey();
                TimingData data = entry.getValue();
                double avgMs = data.getStats5s().getAverage() / 1000.0; // micros → ms

                cachedHotspots[i] = formatHotspot(i + 1, point.name(), avgMs);
                cachedHotspotColors[i] = getPointColor(point);
            } else {
                cachedHotspots[i] = null;
            }
        }
    }

    // --- 렌더링 (UIRenderContext 사용) ---

    /**
     * HUD 렌더링 (Pulse UI API 사용)
     */
    private void renderHud(UIRenderContext ctx) {
        // 배경 박스 크기 계산
        int lineCount = 4; // FPS, Frame, Tick, Status
        for (String hotspot : cachedHotspots) {
            if (hotspot != null)
                lineCount++;
        }
        int boxWidth = 150;
        int boxHeight = PADDING * 2 + lineCount * LINE_HEIGHT;

        // 배경 렌더링
        ctx.fillRect(hudX, hudY, boxWidth, boxHeight, EchoTheme.getBackgroundRGB(), EchoTheme.getBackgroundAlpha());

        // 텍스트 렌더링
        int y = hudY + PADDING;

        // FPS
        ctx.drawText(cachedFpsText, hudX + PADDING, y, fpsColor);
        // 프로파일링 상태 (오른쪽)
        int statusColor = cachedProfileStatus.equals("[ON]") ? EchoTheme.GOOD : EchoTheme.TEXT_SECONDARY;
        ctx.drawText(cachedProfileStatus, hudX + boxWidth - PADDING - 30, y, statusColor);
        y += LINE_HEIGHT;

        // Frame Time
        ctx.drawText(cachedFrameTimeText, hudX + PADDING, y, frameTimeColor);
        y += LINE_HEIGHT;

        // Tick Time
        ctx.drawText(cachedTickTimeText, hudX + PADDING, y, tickTimeColor);
        y += LINE_HEIGHT;

        // 구분선
        y += 2;

        // Hotspots
        for (int i = 0; i < TOP_HOTSPOT_COUNT; i++) {
            if (cachedHotspots[i] != null) {
                ctx.drawText(cachedHotspots[i], hudX + PADDING, y, cachedHotspotColors[i]);
                y += LINE_HEIGHT;
            }
        }
    }

    // --- 유틸리티 ---

    // --- Zero-Allocation 포맷터 (String.format 대체) ---

    /**
     * FPS 텍스트 생성 (Zero-Allocation)
     * 예: "FPS: 60"
     */
    private String formatFps(double fps) {
        formatBuffer.setLength(0);
        formatBuffer.append("FPS: ").append((int) fps);
        return formatBuffer.toString();
    }

    /**
     * 시간 텍스트 생성 (Zero-Allocation)
     * 예: "Frame: 16.7ms"
     */
    private String formatTime(String prefix, double ms) {
        formatBuffer.setLength(0);
        formatBuffer.append(prefix);
        appendDecimal(formatBuffer, ms, 1);
        formatBuffer.append("ms");
        return formatBuffer.toString();
    }

    /**
     * Hotspot 항목 생성 (Zero-Allocation)
     * 예: "1. RENDER 16.70ms"
     */
    private String formatHotspot(int index, String name, double ms) {
        formatBuffer.setLength(0);
        formatBuffer.append(index).append(". ");

        // 이름 처리 (10자 고정폭 패딩)
        String safeName = (name != null) ? name : "";
        if (safeName.length() > 10) {
            formatBuffer.append(safeName, 0, 10);
        } else {
            formatBuffer.append(safeName);
            // 패딩 공백 추가 (%-10s 효과)
            for (int i = 0; i < 10 - safeName.length(); i++) {
                formatBuffer.append(' ');
            }
        }

        formatBuffer.append(' ');
        appendDecimal(formatBuffer, ms, 2); // 소수점 2자리
        formatBuffer.append("ms");
        return formatBuffer.toString();
    }

    /**
     * 소수점 포맷팅 (Zero-Allocation, Truncation 방식)
     * String.format("%.Nf") 대체
     * 
     * @param sb       StringBuilder (재사용)
     * @param value    포맷팅할 값
     * @param decimals 소수점 자릿수
     */
    private void appendDecimal(StringBuilder sb, double value, int decimals) {
        if (value < 0) {
            sb.append('-');
            value = -value;
        }
        long intPart = (long) value;
        sb.append(intPart).append('.');
        double fracPart = value - intPart;
        for (int i = 0; i < decimals; i++) {
            fracPart *= 10;
            sb.append((int) fracPart % 10);
        }
    }

    /**
     * ProfilingPoint별 색상
     */
    private int getPointColor(ProfilingPoint point) {
        return switch (point) {
            case RENDER, RENDER_WORLD, RENDER_UI -> EchoTheme.SUBSYSTEM_RENDER;
            case ZOMBIE_AI, NPC_AI -> EchoTheme.SUBSYSTEM_AI;
            case PHYSICS, SIMULATION -> EchoTheme.SUBSYSTEM_PHYSICS;
            case NETWORK -> EchoTheme.SUBSYSTEM_NETWORK;
            case LUA_EVENT, LUA_FUNCTION, LUA_GC -> EchoTheme.SUBSYSTEM_LUA;
            case AUDIO -> EchoTheme.SUBSYSTEM_LIGHTING; // 오디오는 조명 색상 재사용
            default -> EchoTheme.SUBSYSTEM_OTHER;
        };
    }

    // --- 설정 ---

    public void setPosition(int x, int y) {
        this.hudX = x;
        this.hudY = y;
    }

    public int getX() {
        return hudX;
    }

    public int getY() {
        return hudY;
    }

    // Static 호환성 메서드 (기존 코드 호환)
    public static void setHudPosition(int x, int y) {
        if (INSTANCE != null) {
            INSTANCE.setPosition(x, y);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\ui\EchoTheme.java =====

package com.echo.ui;

/**
 * Echo UI 색상 테마
 * 
 * 부드러운 색상 팔레트를 사용하여 눈의 피로를 줄입니다.
 */
public final class EchoTheme {

    private EchoTheme() {
        // Utility class
    }

    // --- Status Colors ---

    /** 양호 상태 (청록) - FPS ≥55, Frame Time ≤16.67ms */
    public static final int GOOD = 0x4ECDC4;

    /** 경고 상태 (연한 노랑) - FPS ≥30, Frame Time ≤33.33ms */
    public static final int WARNING = 0xFFE66D;

    /** 위험 상태 (연한 빨강) - FPS <30, Frame Time >33.33ms */
    public static final int CRITICAL = 0xFF6B6B;

    // --- Base Colors ---

    /** 기본 텍스트 색상 (흰색) */
    public static final int TEXT = 0xFFFFFF;

    /** 보조 텍스트 색상 (연한 회색) */
    public static final int TEXT_SECONDARY = 0xAAAAAA;

    /** 강조 텍스트 색상 (밝은 청록) */
    public static final int TEXT_HIGHLIGHT = 0x7FDBDA;

    /** 배경 색상 (검정, Alpha 별도 적용) */
    public static final int BACKGROUND = 0x000000;

    /** 배경 불투명도 (80%) */
    public static final int BG_ALPHA = 0xCC;

    /** 패널 테두리 색상 */
    public static final int BORDER = 0x555555;

    // --- Subsystem Colors ---

    /** 렌더링 시스템 색상 */
    public static final int SUBSYSTEM_RENDER = 0x6C5CE7;

    /** AI 시스템 색상 */
    public static final int SUBSYSTEM_AI = 0xE17055;

    /** 물리 시스템 색상 */
    public static final int SUBSYSTEM_PHYSICS = 0x00B894;

    /** 네트워크 시스템 색상 */
    public static final int SUBSYSTEM_NETWORK = 0x0984E3;

    /** Lua 시스템 색상 */
    public static final int SUBSYSTEM_LUA = 0xFDCB6E;

    /** 조명 시스템 색상 */
    public static final int SUBSYSTEM_LIGHTING = 0xF39C12;

    /** 기타 시스템 색상 */
    public static final int SUBSYSTEM_OTHER = 0x95A5A6;

    // --- Utility ---

    /**
     * 등급에 따른 색상 반환
     * 
     * @param grade 0=Good, 1=Warning, 2=Critical
     * @return 해당 등급의 색상
     */
    public static int getGradeColor(int grade) {
        return switch (grade) {
            case 0 -> GOOD;
            case 1 -> WARNING;
            default -> CRITICAL;
        };
    }

    /**
     * ARGB 색상 생성
     * 
     * @param rgb   RGB 색상 (0xRRGGBB)
     * @param alpha 불투명도 (0-255)
     * @return ARGB 색상
     */
    public static int withAlpha(int rgb, int alpha) {
        return (alpha << 24) | (rgb & 0xFFFFFF);
    }

    /**
     * 배경색 (반투명 검정) 반환
     * 
     * @return ARGB 배경색
     */
    public static int getBackground() {
        return withAlpha(BACKGROUND, BG_ALPHA);
    }

    /**
     * 진행률 바 색상 (0-100%)
     * 
     * @param percent 백분율 (0-100)
     * @return 해당 백분율에 맞는 색상
     */
    public static int getPercentColor(double percent) {
        if (percent <= 50)
            return GOOD;
        if (percent <= 75)
            return WARNING;
        return CRITICAL;
    }

    // --- UIRenderContext Compatibility ---

    /**
     * 배경 RGB 색상 반환 (UIRenderContext용)
     * 
     * @return RGB 색상 (0xRRGGBB)
     */
    public static int getBackgroundRGB() {
        return BACKGROUND;
    }

    /**
     * 배경 알파 값 반환 (UIRenderContext용)
     * 
     * @return 알파 값 (0.0 - 1.0)
     */
    public static float getBackgroundAlpha() {
        return BG_ALPHA / 255.0f;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\ui\HotspotPanel.java =====

package com.echo.ui;

import com.echo.EchoRuntime;
import com.echo.input.EchoKeyBindings;
import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import com.echo.aggregate.TimingData;
import com.echo.aggregate.SpikeLog;

import com.pulse.ui.HUDOverlay;
import com.pulse.ui.UIRenderContext;
import com.pulse.api.lua.LuaBudgetManager;
import com.pulse.api.lua.LuaBudgetManager.LuaBudgetStats;

import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;

/**
 * HotspotPanel - 상세 성능 분석 패널
 * 
 * Pulse HUDOverlay 시스템을 통해 렌더링됩니다.
 * F8 키로 토글할 수 있습니다.
 * 5초/60초 윈도우 핫스팟, 스파이크 로그, Lua 상태를 표시합니다.
 * 
 * @since 2.0.0 - Pulse Native Integration
 */
public class HotspotPanel extends HUDOverlay.HUDLayer {

    // --- 상수 ---

    /** 패널 레이어 ID */
    public static final String LAYER_ID = "echo_hotspot_panel";

    /** 패널 레이어 우선순위 (EchoHUD보다 위에 렌더링) */
    public static final int LAYER_PRIORITY = 110;

    /** 패널 갱신 주기 (밀리초) */
    private static final long UPDATE_INTERVAL_MS = 1000; // 1초마다 정렬

    /** 패널 크기 */
    private static final int PANEL_WIDTH = 280;
    private static final int PADDING = 8;
    private static final int LINE_HEIGHT = 14;
    private static final int SECTION_GAP = 6;

    /** Top N 개수 */
    private static final int TOP_N = 5;
    private static final int SPIKE_COUNT = 3;
    private static final int LUA_TOP_N = 3;

    // 시간 포맷
    private static final DateTimeFormatter TIME_FORMAT = DateTimeFormatter.ofPattern("HH:mm:ss");

    // --- 싱글톤 인스턴스 ---

    private static HotspotPanel INSTANCE;

    // --- 인스턴스 필드 ---

    /** 패널 위치 */
    private int panelX = 170;
    private int panelY = 10;

    // --- 캐시 ---

    private long lastCacheUpdate = 0;

    // 5초 윈도우 핫스팟
    private final String[] cached5sHotspots = new String[TOP_N];
    private final int[] cached5sColors = new int[TOP_N];
    private int cached5sCount = 0;

    // 60초 윈도우 핫스팟
    private final String[] cached60sHotspots = new String[TOP_N];
    private final int[] cached60sColors = new int[TOP_N];
    private int cached60sCount = 0;

    // 스파이크 로그
    private final String[] cachedSpikes = new String[SPIKE_COUNT];
    private int cachedSpikeCount = 0;

    // Lua 상태
    private final String[] cachedLuaTop = new String[LUA_TOP_N];
    private int cachedLuaCount = 0;
    private String cachedLuaSummary = "";

    // --- 생성자 및 등록 ---

    private HotspotPanel() {
        // Private constructor for singleton
    }

    /**
     * 패널 레이어 등록
     * EchoMod.init()에서 호출됨
     */
    public static void register() {
        if (INSTANCE != null) {
            System.out.println("[Echo] HotspotPanel already registered");
            return;
        }

        INSTANCE = new HotspotPanel();
        HUDOverlay.registerLayer(LAYER_ID, INSTANCE, LAYER_PRIORITY);
        System.out.println("[Echo] HotspotPanel registered as Pulse HUD layer");
    }

    /**
     * 패널 레이어 등록 해제
     */
    public static void unregister() {
        if (INSTANCE == null)
            return;
        HUDOverlay.unregisterLayer(LAYER_ID);
        INSTANCE = null;
        System.out.println("[Echo] HotspotPanel unregistered");
    }

    /**
     * 인스턴스 가져오기
     */
    public static HotspotPanel getInstance() {
        return INSTANCE;
    }

    // --- HUDLayer 구현 ---

    @Override
    public void render(UIRenderContext ctx) {
        // F8 토글 체크 - HUDLayer.setVisible() 대신 KeyBindings 확인
        if (!EchoRuntime.isEnabled() || !EchoKeyBindings.isPanelVisible()) {
            return;
        }

        try {
            updateCacheIfNeeded();
            renderPanel(ctx);
        } catch (Exception e) {
            EchoRuntime.recordError("Panel", e);
        }
    }

    @Override
    public void update(float deltaTime) {
        // Panel은 render에서 캐시 갱신하므로 별도 업데이트 불필요
    }

    // --- 캐시 갱신 ---

    /**
     * 캐시 갱신 (1초마다)
     */
    private void updateCacheIfNeeded() {
        long now = System.currentTimeMillis();
        if (now - lastCacheUpdate < UPDATE_INTERVAL_MS) {
            return;
        }
        lastCacheUpdate = now;

        EchoProfiler profiler = EchoProfiler.getInstance();
        if (!profiler.isEnabled()) {
            cached5sCount = 0;
            cached60sCount = 0;
            cachedSpikeCount = 0;
            cachedLuaCount = 0;
            return;
        }

        // 5초 윈도우 핫스팟
        updateHotspots(profiler, true);

        // 60초 윈도우 핫스팟
        updateHotspots(profiler, false);

        // 스파이크 로그
        updateSpikes(profiler);

        // Lua 상태
        updateLuaStats();
    }

    /**
     * 핫스팟 갱신
     */
    private void updateHotspots(EchoProfiler profiler, boolean is5s) {
        Map<ProfilingPoint, TimingData> allData = profiler.getTimingData();

        List<Map.Entry<ProfilingPoint, TimingData>> sorted = allData.entrySet().stream()
                .filter(e -> e.getValue().getCallCount() > 0)
                .sorted((a, b) -> {
                    double avgA = is5s ? a.getValue().getStats5s().getAverage()
                            : a.getValue().getStats60s().getAverage();
                    double avgB = is5s ? b.getValue().getStats5s().getAverage()
                            : b.getValue().getStats60s().getAverage();
                    return Double.compare(avgB, avgA);
                })
                .limit(TOP_N)
                .toList();

        String[] hotspots = is5s ? cached5sHotspots : cached60sHotspots;
        int[] colors = is5s ? cached5sColors : cached60sColors;
        int count = Math.min(sorted.size(), TOP_N);

        for (int i = 0; i < TOP_N; i++) {
            if (i < count) {
                Map.Entry<ProfilingPoint, TimingData> entry = sorted.get(i);
                ProfilingPoint point = entry.getKey();
                TimingData data = entry.getValue();

                double avgMs = (is5s ? data.getStats5s().getAverage() : data.getStats60s().getAverage()) / 1000.0;
                long total = data.getTotalMicros() / 1000; // total ms

                // 전체 시간 대비 비율 계산: use EchoProfiler session time instead of deprecated
                // getWindowMs()
                long sessionMs = Math.max(1, EchoProfiler.getInstance().getSessionDurationMs());
                double percent = Math.min(100, (total * 100.0) / sessionMs);

                hotspots[i] = String.format("%-12s %5.1fms %4.0f%% %s",
                        truncate(point.name(), 12),
                        avgMs,
                        percent,
                        getBar(percent));
                colors[i] = getPointColor(point);
            } else {
                hotspots[i] = null;
            }
        }

        if (is5s) {
            cached5sCount = count;
        } else {
            cached60sCount = count;
        }
    }

    /**
     * 스파이크 로그 갱신
     */
    private void updateSpikes(EchoProfiler profiler) {
        SpikeLog spikeLog = profiler.getSpikeLog();
        List<SpikeLog.SpikeEntry> recent = spikeLog.getRecentSpikes(SPIKE_COUNT);

        cachedSpikeCount = Math.min(recent.size(), SPIKE_COUNT);

        for (int i = 0; i < SPIKE_COUNT; i++) {
            if (i < cachedSpikeCount) {
                SpikeLog.SpikeEntry spike = recent.get(i);
                String time = TIME_FORMAT.format(spike.getTimestamp().atZone(java.time.ZoneId.systemDefault()));
                String severity = getSeverityIndicator(spike.getDurationMs());

                cachedSpikes[i] = String.format("%s %-10s %5.0fms %s",
                        time,
                        truncate(spike.getPoint().name(), 10),
                        spike.getDurationMs(),
                        severity);
            } else {
                cachedSpikes[i] = null;
            }
        }
    }

    /**
     * Lua 상태 갱신
     * Pulse LuaBudgetManager에서 통계를 가져옴 (Phase 4 Native Integration)
     */
    private void updateLuaStats() {
        try {
            LuaBudgetManager budget = LuaBudgetManager.getInstance();

            // 주요 컨텍스트의 통계 수집
            LuaBudgetStats tickStats = budget.getStats(LuaBudgetManager.CTX_ON_TICK);

            // 요약 정보
            cachedLuaSummary = String.format("Avg: %.2fms / Exceeded: %d",
                    tickStats.avgExecutionMicros / 1000.0,
                    tickStats.budgetExceededCount);

            // 컨텍스트별 상세 정보
            String[] contexts = {
                    LuaBudgetManager.CTX_ON_TICK,
                    LuaBudgetManager.CTX_ON_PLAYER_UPDATE,
                    LuaBudgetManager.CTX_ON_RENDER_TICK
            };

            cachedLuaCount = 0;
            for (int i = 0; i < LUA_TOP_N && i < contexts.length; i++) {
                LuaBudgetStats stats = budget.getStats(contexts[i]);
                if (stats.totalExecutions > 0) {
                    String contextName = contexts[i].replace("lua.event.", "");
                    cachedLuaTop[i] = String.format("%-14s %5.1fms max",
                            truncate(contextName, 14),
                            stats.maxExecutionMicros / 1000.0);
                    cachedLuaCount++;
                } else {
                    cachedLuaTop[i] = null;
                }
            }
        } catch (Exception e) {
            // LuaBudgetManager 사용 불가 시 폴백
            cachedLuaSummary = "Lua stats unavailable";
            cachedLuaCount = 0;
        }
    }

    // --- 렌더링 (UIRenderContext 사용) ---

    /**
     * 패널 렌더링 (Pulse UI API 사용)
     */
    private void renderPanel(UIRenderContext ctx) {
        int y = panelY;

        // 전체 높이 계산
        int totalHeight = PADDING * 2;
        totalHeight += LINE_HEIGHT; // 5s 타이틀
        totalHeight += cached5sCount * LINE_HEIGHT;
        totalHeight += SECTION_GAP + LINE_HEIGHT; // 60s 타이틀
        totalHeight += cached60sCount * LINE_HEIGHT;
        totalHeight += SECTION_GAP + LINE_HEIGHT; // Spikes 타이틀
        totalHeight += Math.max(1, cachedSpikeCount) * LINE_HEIGHT;
        totalHeight += SECTION_GAP + LINE_HEIGHT; // Lua 타이틀
        totalHeight += LINE_HEIGHT; // Lua summary
        totalHeight += cachedLuaCount * LINE_HEIGHT;

        // 배경
        ctx.fillRect(panelX, panelY, PANEL_WIDTH, totalHeight, EchoTheme.getBackgroundRGB(),
                EchoTheme.getBackgroundAlpha());

        y += PADDING;

        // --- Last 5 Seconds---
        ctx.drawText("━━ Last 5 Seconds ━━", panelX + PADDING, y, EchoTheme.TEXT_HIGHLIGHT);
        y += LINE_HEIGHT;

        for (int i = 0; i < cached5sCount; i++) {
            if (cached5sHotspots[i] != null) {
                ctx.drawText(cached5sHotspots[i], panelX + PADDING, y, cached5sColors[i]);
                y += LINE_HEIGHT;
            }
        }

        y += SECTION_GAP;

        // --- Last 60 Seconds---
        ctx.drawText("━━ Last 60 Seconds ━━", panelX + PADDING, y, EchoTheme.TEXT_HIGHLIGHT);
        y += LINE_HEIGHT;

        for (int i = 0; i < cached60sCount; i++) {
            if (cached60sHotspots[i] != null) {
                ctx.drawText(cached60sHotspots[i], panelX + PADDING, y, cached60sColors[i]);
                y += LINE_HEIGHT;
            }
        }

        y += SECTION_GAP;

        // --- Recent Spikes---
        ctx.drawText("━━ Recent Spikes ━━", panelX + PADDING, y, EchoTheme.TEXT_HIGHLIGHT);
        y += LINE_HEIGHT;

        if (cachedSpikeCount == 0) {
            ctx.drawText("No spikes recorded", panelX + PADDING, y, EchoTheme.TEXT_SECONDARY);
            y += LINE_HEIGHT;
        } else {
            for (int i = 0; i < cachedSpikeCount; i++) {
                if (cachedSpikes[i] != null) {
                    int spikeColor = i == 0 ? EchoTheme.CRITICAL : EchoTheme.WARNING;
                    ctx.drawText(cachedSpikes[i], panelX + PADDING, y, spikeColor);
                    y += LINE_HEIGHT;
                }
            }
        }

        y += SECTION_GAP;

        // --- Lua Status---
        ctx.drawText("━━ Lua Status ━━", panelX + PADDING, y, EchoTheme.TEXT_HIGHLIGHT);
        y += LINE_HEIGHT;

        ctx.drawText(cachedLuaSummary, panelX + PADDING, y, EchoTheme.SUBSYSTEM_LUA);
        y += LINE_HEIGHT;

        for (int i = 0; i < cachedLuaCount; i++) {
            if (cachedLuaTop[i] != null) {
                ctx.drawText(cachedLuaTop[i], panelX + PADDING, y, EchoTheme.SUBSYSTEM_LUA);
                y += LINE_HEIGHT;
            }
        }
    }

    // --- 유틸리티 ---

    private String truncate(String str, int maxLen) {
        if (str == null)
            return "";
        if (str.length() <= maxLen)
            return str;
        return str.substring(0, maxLen - 1) + "…";
    }

    private String getBar(double percent) {
        int bars = (int) Math.min(5, percent / 20);
        return "█".repeat(Math.max(0, bars)) + "░".repeat(Math.max(0, 5 - bars));
    }

    private String getSeverityIndicator(double ms) {
        if (ms > 100)
            return "!!!";
        if (ms > 50)
            return "!!";
        if (ms > 33.33)
            return "!";
        return "";
    }

    private int getPointColor(ProfilingPoint point) {
        return switch (point) {
            case RENDER, RENDER_WORLD, RENDER_UI -> EchoTheme.SUBSYSTEM_RENDER;
            case ZOMBIE_AI, NPC_AI -> EchoTheme.SUBSYSTEM_AI;
            case PHYSICS, SIMULATION -> EchoTheme.SUBSYSTEM_PHYSICS;
            case NETWORK -> EchoTheme.SUBSYSTEM_NETWORK;
            case LUA_EVENT, LUA_FUNCTION, LUA_GC -> EchoTheme.SUBSYSTEM_LUA;
            case AUDIO -> EchoTheme.SUBSYSTEM_LIGHTING;
            default -> EchoTheme.SUBSYSTEM_OTHER;
        };
    }

    // --- 설정 ---

    public void setPosition(int x, int y) {
        this.panelX = x;
        this.panelY = y;
    }

    public int getX() {
        return panelX;
    }

    public int getY() {
        return panelY;
    }

    // Static 호환성 메서드 (기존 코드 호환)
    public static void setPanelPosition(int x, int y) {
        if (INSTANCE != null) {
            INSTANCE.setPosition(x, y);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\util\StringUtils.java =====

package com.echo.util;

/**
 * 문자열 유틸리티
 */
public final class StringUtils {

    private StringUtils() {
        // 유틸리티 클래스
    }

    /**
     * 문자열을 최대 길이로 자름
     * 
     * @param s      원본 문자열
     * @param maxLen 최대 길이
     * @return 잘린 문자열 (초과 시 "..." 추가)
     */
    public static String truncate(String s, int maxLen) {
        if (s == null)
            return "";
        return s.length() <= maxLen ? s : s.substring(0, maxLen - 3) + "...";
    }

    /**
     * 마이크로초를 밀리초 문자열로 변환
     */
    public static String formatMs(double micros) {
        return String.format("%.2f", micros / 1000.0);
    }

    /**
     * 마이크로초를 밀리초로 반올림
     */
    public static double toMs(long micros) {
        return Math.round(micros / 10.0) / 100.0;
    }

    /**
     * 밀리초 포맷 (소수점 2자리)
     */
    public static String formatDuration(long micros) {
        return String.format("%.2f ms", micros / 1000.0);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\validation\FallbackTickEmitter.java =====

package com.echo.validation;

import com.echo.config.EchoConfig;
import com.pulse.api.log.PulseLogger;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

/**
 * FallbackTickEmitter - 디버그 전용 Fallback Tick 생성기
 * 
 * Pulse Hook이 완전히 누락된 경우에만 작동하며,
 * Echo 파이프라인이 정상인지 검증하기 위한 **최소한의 데이터**를 생성합니다.
 * 
 * ⚠️ 중요: 이 fallback tick은 실제 게임 성능과 관련이 없습니다!
 * - 성능 분석(histogram, P95/P99)에서 **절대 사용되지 않음**
 * - `used_fallback_ticks: true` 플래그로 명확히 라벨링
 * - 기본값 OFF (`EchoConfig.allowFallbackTicks = false`)
 * 
 * @since Echo 0.9.0
 */
public class FallbackTickEmitter {

    private static final FallbackTickEmitter INSTANCE = new FallbackTickEmitter();

    /** Fallback 활성화 대기 시간 (밀리초) - 실제 tick hook을 기다림 */
    private static final long ACTIVATION_DELAY_MS = 3000;

    private ScheduledExecutorService scheduler;
    private ScheduledFuture<?> fallbackTask;

    private final AtomicBoolean fallbackActive = new AtomicBoolean(false);
    private final AtomicLong fallbackTickCount = new AtomicLong(0);

    /**
     * v0.9.1: Fallback이 히스토그램 데이터를 오염시켰는지 추적
     * 이전 버전에서는 fallback tick이 히스토그램에 기록됐음
     * 이 플래그는 레거시 오염 감지용 (새 버전에서는 항상 false)
     */
    private final AtomicBoolean histogramContaminated = new AtomicBoolean(false);

    private FallbackTickEmitter() {
    }

    public static FallbackTickEmitter getInstance() {
        return INSTANCE;
    }

    /**
     * Real tick 수신 시 호출 - Fallback 자동 비활성화
     * 
     * TickProfiler.recordTickDuration()에서 호출됨.
     * Real tick이 들어오면 fallback은 더 이상 필요 없음.
     * 
     * @since Echo 0.9.1
     */
    public void onRealTickReceived() {
        if (fallbackActive.compareAndSet(true, false)) {
            // Fallback task 중지
            if (fallbackTask != null) {
                fallbackTask.cancel(false);
                fallbackTask = null;
            }
            PulseLogger.info("Echo/FallbackTick", "Real tick received - Fallback DEACTIVATED after "
                    + fallbackTickCount.get() + " fallback ticks");
        }
    }

    /**
     * Fallback 모니터링 시작
     * 지정된 시간 후 tick hook이 없으면 fallback 활성화
     */
    public synchronized void startMonitoring() {
        EchoConfig config = EchoConfig.getInstance();

        // Config에서 허용하지 않으면 즉시 반환
        if (!config.isAllowFallbackTicks()) {
            PulseLogger.debug("Echo/FallbackTick", "Fallback ticks disabled (Config.allowFallbackTicks = false)");
            return;
        }

        // 이미 실행 중이면 반환
        if (scheduler != null && !scheduler.isShutdown()) {
            return;
        }

        scheduler = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "Echo-FallbackTickEmitter");
            t.setDaemon(true);
            return t;
        });

        // 지정된 시간 후 tick hook 상태 확인
        scheduler.schedule(this::checkAndActivateFallback, ACTIVATION_DELAY_MS, TimeUnit.MILLISECONDS);
        PulseLogger.debug("Echo/FallbackTick", "Monitoring started (will check in " + ACTIVATION_DELAY_MS + "ms)");
    }

    /**
     * Tick hook 상태 확인 및 필요 시 fallback 활성화
     * 
     * v0.9.1: 강화된 조건 - heartbeat == 0 AND phase_start_count == 0
     * 둘 다 0이어야 진짜 hook 누락으로 판정
     */
    private int retryCount = 0;
    private static final int MAX_RETRIES = 3;

    private void checkAndActivateFallback() {
        SelfValidation validation = SelfValidation.getInstance();
        long heartbeat = validation.getHeartbeatCount();
        long phaseStartCount = validation.getPhaseStartCount();

        // v0.9.1: 강화된 조건 - tick과 phase 둘 다 없어야 fallback 활성화
        boolean noTickHook = heartbeat == 0;
        boolean noPhaseHook = phaseStartCount == 0;

        if (noTickHook && noPhaseHook) {
            retryCount++;
            if (retryCount >= MAX_RETRIES) {
                PulseLogger.warn("Echo/FallbackTick", "⚠️ No tick/phase hook detected after "
                        + (ACTIVATION_DELAY_MS + retryCount * 1000) + "ms!");
                PulseLogger.warn("Echo/FallbackTick", "⚠️ Starting FALLBACK tick emitter (PIPELINE TESTING ONLY)");
                activateFallback();
            } else {
                PulseLogger.debug("Echo/FallbackTick", "Heartbeat=0, phase=0, retry " + retryCount + "/" + MAX_RETRIES);
                scheduler.schedule(this::checkAndActivateFallback, 1000, TimeUnit.MILLISECONDS);
            }
        } else {
            PulseLogger.debug("Echo/FallbackTick",
                    "Hook detected (heartbeat=" + heartbeat + ", phase=" + phaseStartCount
                            + "). No fallback needed.");
        }
    }

    /**
     * Fallback tick 생성 활성화
     */
    private void activateFallback() {
        if (fallbackActive.getAndSet(true)) {
            return; // 이미 활성화됨
        }

        // Config에 fallback 사용 표시
        EchoConfig config = EchoConfig.getInstance();
        config.setUsedFallbackTicks(true);

        // Configurable interval로 fallback tick 생성 (default: 200ms)
        long intervalMs = config.getFallbackTickIntervalMs();
        PulseLogger.debug("Echo/FallbackTick", "Using interval: " + intervalMs + "ms");

        fallbackTask = scheduler.scheduleAtFixedRate(
                this::emitFallbackTick,
                0,
                intervalMs,
                TimeUnit.MILLISECONDS);
    }

    /**
     * Fallback tick 발생
     * 
     * v0.9.1: 히스토그램에는 기록하지 않음 (데이터 오염 방지)
     * Fallback tick은 파이프라인 검증용으로만 사용
     */
    private void emitFallbackTick() {
        fallbackTickCount.incrementAndGet();

        // SelfValidation heartbeat 증가 (파이프라인 검증용)
        SelfValidation.getInstance().tickHeartbeat();

        // SessionManager.onTick() 호출 - 세션 자동 시작 및 데이터 수집 마킹
        com.echo.session.SessionManager.getInstance().onTick();

        // v0.9.1: 히스토그램에는 기록하지 않음!
        // 이전 버전에서는 200ms 고정값이 기록되어 P95/P99를 오염시켰음
        // 이제 fallback tick은 heartbeat/session 유지용으로만 사용

        if (fallbackTickCount.get() % 50 == 0) {
            PulseLogger.debug("Echo/FallbackTick",
                    fallbackTickCount.get() + " fallback ticks (pipeline only, no histogram)");
        }
    }

    /**
     * Fallback 모니터링 중지
     */
    public synchronized void stop() {
        if (fallbackTask != null) {
            fallbackTask.cancel(false);
            fallbackTask = null;
        }

        if (scheduler != null && !scheduler.isShutdown()) {
            scheduler.shutdownNow();
            scheduler = null;
        }

        if (fallbackActive.get()) {
            PulseLogger.info("Echo/FallbackTick", "Stopped after " + fallbackTickCount.get() + " fallback ticks");
        }

        fallbackActive.set(false);
    }

    /**
     * 리셋
     */
    public void reset() {
        stop();
        fallbackTickCount.set(0);
    }

    // --- 조회 API ---

    public boolean isFallbackActive() {
        return fallbackActive.get();
    }

    public long getFallbackTickCount() {
        return fallbackTickCount.get();
    }

    /**
     * v0.9.1: 히스토그램 데이터가 fallback tick으로 오염됐는지 확인
     * 
     * 새 버전(0.9.1+)에서는 fallback tick이 히스토그램에 기록되지 않으므로
     * 항상 false를 반환합니다. 이 플래그는 레거시 호환성과
     * 명시적인 "오염 없음" 확인을 위해 유지됩니다.
     * 
     * @return true if histogram was contaminated by fallback ticks (legacy only)
     */
    public boolean isHistogramContaminated() {
        return histogramContaminated.get();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\validation\PulseContractVerifier.java =====

package com.echo.validation;

import com.echo.measure.TickPhaseProfiler.TickPhase;
import com.pulse.api.TickContract;
import java.util.Map;
import java.util.LinkedHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Pulse-Echo API Contract Verifier (Phase 4)
 * 
 * Verifies that Pulse is sending events in the expected order and format.
 * - Phase Order: Update -> Render (or specific sequence)
 * - Tick Consistency: DeltaTime sanity check
 * - Duplicate Detection: Zero deltaTime indicates duplicate events
 * - Thread Contention: Detects multi-thread access in multiplayer
 * 
 * @since Echo 0.9 - Enhanced deltaTime anomaly detection, thread safety,
 *        Fuse/Nerve API
 */
public class PulseContractVerifier {

    private static final PulseContractVerifier INSTANCE = new PulseContractVerifier();

    // Contract State
    private TickPhase lastPhase = null;
    @SuppressWarnings("unused") // Reserved for phase timing analysis
    private long lastPhaseTime = 0;
    private final AtomicBoolean contractViolated = new AtomicBoolean(false);

    // Violations (진짜 계약 파손)
    private final AtomicLong orderViolations = new AtomicLong(0);
    private final AtomicLong invalidDeltaTimes = new AtomicLong(0);
    private final AtomicLong zeroDeltaTimes = new AtomicLong(0);
    private final AtomicLong duplicateEvents = new AtomicLong(0);

    // Stall Events (환경 이벤트 - 계약 파손 아님)
    private final AtomicLong largeDeltaTimes = new AtomicLong(0);
    private volatile String lastStallMessage = null;

    // v0.9: Burst tick allowance for MP catch-up (server sync)
    private int burstTickCount = 0;
    private static final int MAX_BURST_ALLOWANCE = 5;

    // Last reported violation
    private volatile String lastViolationMessage = null;

    // Duplicate detection
    private long lastTickNanos = 0;

    // v0.9: TickContract 기반 임계값 (단위: seconds)
    private static final float LARGE_DELTA_THRESHOLD = TickContract.MAX_REASONABLE_DELTA_MS / 1000f;
    private static final float MAX_REASONABLE_DELTA = TickContract.MAX_ABSOLUTE_DELTA_MS / 1000f;

    // v0.9: Tick 누락 감지 (FallbackTickEmitter용)
    private volatile boolean tickMissing = false;
    private volatile long lastTickReceivedTime = 0;

    // v0.9: Thread contention detection (multiplayer support)
    private volatile long expectedThreadId = -1;
    private final AtomicLong threadContentions = new AtomicLong(0);
    private static final int MAX_THREAD_WARNINGS = 3;

    // v0.9: Scheduler order verification
    private volatile boolean schedulerTickedThisCycle = false;

    private PulseContractVerifier() {
    }

    public static PulseContractVerifier getInstance() {
        return INSTANCE;
    }

    private final AtomicLong phaseSignalCount = new AtomicLong(0);
    private final AtomicLong gameTickCount = new AtomicLong(0);

    public void onPhaseStart(TickPhase phase) {
        phaseSignalCount.incrementAndGet();
        lastPhase = phase;
        lastPhaseTime = System.nanoTime();
    }

    /**
     * Called on each game tick. Performs comprehensive deltaTime validation.
     * 
     * @param deltaTime Time since last tick in seconds
     */
    public void onGameTick(float deltaTime) {
        gameTickCount.incrementAndGet();
        lastTickReceivedTime = System.currentTimeMillis();
        tickMissing = false;
        long currentNanos = System.nanoTime();

        // Check 1: Zero deltaTime with burst allowance (v0.9 MP catch-up fix)
        if (deltaTime <= 0.000001f) {
            burstTickCount++;
            if (burstTickCount > MAX_BURST_ALLOWANCE) {
                if (zeroDeltaTimes.incrementAndGet() == 1) {
                    recordViolation("Excessive zero-delta ticks (Limit: " + MAX_BURST_ALLOWANCE + ")");
                }
            }
            // Within burst allowance - treat as normal server sync
        } else {
            burstTickCount = 0; // Reset burst counter on normal tick
        }

        // Check 2: Large deltaTime (indicates stall or lag spike)
        // v1.1: 스톨은 환경 이벤트로 분리 - 계약 파손으로 처리하지 않음
        if (deltaTime > LARGE_DELTA_THRESHOLD && deltaTime <= MAX_REASONABLE_DELTA) {
            if (largeDeltaTimes.incrementAndGet() <= 3) { // Only log first 3
                recordStallEvent("Large deltaTime: " + String.format("%.1f", deltaTime * 1000) + "ms (possible stall)");
            }
        }

        // Check 3: Invalid deltaTime (negative or extremely large)
        if (deltaTime < 0 || deltaTime > MAX_REASONABLE_DELTA) {
            if (invalidDeltaTimes.incrementAndGet() == 1) {
                recordViolation("Invalid deltaTime: " + deltaTime + "s");
            }
        }

        // Check 4: Duplicate event detection via timestamp (TickContract 기준)
        if (lastTickNanos > 0) {
            long elapsed = currentNanos - lastTickNanos;
            if (elapsed < TickContract.DUPLICATE_THRESHOLD_NS && elapsed >= 0) {
                if (duplicateEvents.incrementAndGet() == 1) {
                    recordViolation("Duplicate tick event detected (elapsed: " + (elapsed / 1000) + "µs)");
                }
            }
        }
        lastTickNanos = currentNanos;

        // Check 5: Thread contention detection (v0.9 multiplayer support)
        long currentThread = Thread.currentThread().getId();
        if (expectedThreadId == -1) {
            expectedThreadId = currentThread;
        } else if (expectedThreadId != currentThread) {
            long count = threadContentions.incrementAndGet();
            if (count <= MAX_THREAD_WARNINGS) {
                recordViolation("Thread contention: expected thread " + expectedThreadId
                        + ", got " + currentThread + " (may cause race conditions)");
            }
        }

        // Reset scheduler flag for next cycle
        schedulerTickedThisCycle = false;
    }

    /**
     * Called by PulseScheduler to indicate it has ticked this cycle.
     * Used to verify PulseScheduler -> Echo TickProfiler order.
     */
    public void onSchedulerTick() {
        schedulerTickedThisCycle = true;
    }

    /**
     * Check if PulseScheduler ticked before Echo received events this cycle.
     * Used to verify execution order is correct.
     */
    public boolean isSchedulerOrderCorrect() {
        return schedulerTickedThisCycle;
    }

    public void onPhaseEnd(TickPhase phase) {
        if (lastPhase != phase) {
            recordViolation("Phase Mismatch: Ended " + phase + " but expected " + lastPhase);
        }
        lastPhase = null;
    }

    public boolean isPhaseSignalMissing() {
        // If we have many ticks (>60) but NO phase signals, something is wrong.
        return gameTickCount.get() > 60 && phaseSignalCount.get() == 0;
    }

    private void recordViolation(String message) {
        contractViolated.set(true);
        lastViolationMessage = message;
        System.err.println("[Echo] Pulse Contract Violation: " + message);
    }

    /**
     * 스톨 이벤트 기록 (환경 이벤트 - 계약 파손 아님).
     * v1.1: 스톨은 WARNING으로만 표시, VIOLATED 상태로 전환하지 않음.
     */
    private void recordStallEvent(String message) {
        lastStallMessage = message;
        System.out.println("[Echo] Stall Event: " + message);
    }

    /**
     * Reset all counters (for testing)
     */
    public void reset() {
        contractViolated.set(false);
        orderViolations.set(0);
        invalidDeltaTimes.set(0);
        zeroDeltaTimes.set(0);
        largeDeltaTimes.set(0);
        duplicateEvents.set(0);
        phaseSignalCount.set(0);
        gameTickCount.set(0);
        lastTickNanos = 0;
        lastViolationMessage = null;
        lastPhase = null;
        tickMissing = false;
        burstTickCount = 0;
        lastTickReceivedTime = 0;
    }

    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();
        // v0.9: TickContract 버전 포함
        map.put("pulse_contract_version", TickContract.VERSION);
        map.put("tick_contract_valid", !contractViolated.get());
        map.put("status", getStatusForDisplay()); // v1.1: use getStatusForDisplay()

        // 진짜 계약 파손
        map.put("order_violations", orderViolations.get());
        map.put("invalid_delta_times", invalidDeltaTimes.get());
        map.put("zero_delta_times", zeroDeltaTimes.get());
        map.put("duplicate_events", duplicateEvents.get());
        map.put("thread_contentions", threadContentions.get());

        // v1.1: 스톨 이벤트 (환경 이벤트 - 별도 카테고리)
        map.put("stall_events", largeDeltaTimes.get());
        if (lastStallMessage != null) {
            map.put("last_stall", lastStallMessage);
        }

        map.put("burst_tick_allowance", MAX_BURST_ALLOWANCE);
        map.put("current_burst_count", burstTickCount);
        map.put("missing_phase_data", isPhaseSignalMissing());
        map.put("tick_missing", tickMissing);
        map.put("total_ticks", gameTickCount.get());
        map.put("phase_signals", phaseSignalCount.get());
        if (lastViolationMessage != null) {
            map.put("last_violation", lastViolationMessage);
        }
        return map;
    }

    // ═══════════════════════════════════════════════════════════════
    // v0.9: Fuse/Nerve Integration API
    // ═══════════════════════════════════════════════════════════════

    /**
     * Get contract status for Fuse/Nerve debug display.
     * 
     * v1.1: 스톨은 WARNING, 진짜 계약 파손만 VIOLATED
     * 
     * @return "OK", "WARNING", or "VIOLATED"
     */
    public String getStatusForDisplay() {
        if (contractViolated.get())
            return "VIOLATED";
        if (threadContentions.get() > 0 || largeDeltaTimes.get() > 0)
            return "WARNING";
        return "OK";
    }

    /**
     * Get total violation count for Fuse/Nerve display.
     * v1.1: stall_events 제외 (환경 이벤트는 계약 파손 아님)
     */
    public long getTotalViolationCount() {
        return orderViolations.get() + invalidDeltaTimes.get() + zeroDeltaTimes.get()
                + duplicateEvents.get() + threadContentions.get();
    }

    /**
     * Get stall event count (환경 이벤트).
     */
    public long getStallEventCount() {
        return largeDeltaTimes.get();
    }

    /**
     * Get last violation message for Fuse/Nerve display.
     */
    public String getLastViolation() {
        return lastViolationMessage;
    }

    /**
     * Check if contract is currently violated.
     */
    public boolean isViolated() {
        return contractViolated.get();
    }

    // ═══════════════════════════════════════════════════════════════
    // v0.9.1: Tick 누락 감지 API (개선됨)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 리포트용: 세션 중 마지막으로 확인된 tick_missing 상태 반환
     * 
     * v0.9.1: 리포트 생성 시점이 아닌 세션 중 상태를 반환하여
     * 게임 종료 후 false positive 방지
     * 
     * @return 세션 중 tick 누락이 발생했는지 여부
     */
    public boolean isTickMissing() {
        // 세션 중 마지막으로 저장된 상태 반환 (false positive 방지)
        return tickMissing;
    }

    /**
     * 실시간 체크: 현재 tick이 누락되었는지 확인
     * FallbackTickEmitter에서 활성화 조건으로 사용.
     * 
     * @return 현재 시점에서 tick 누락 여부
     */
    public boolean checkTickMissingNow() {
        if (lastTickReceivedTime == 0) {
            return false; // 아직 시작 안됨
        }
        long elapsed = System.currentTimeMillis() - lastTickReceivedTime;
        // 3초 이상 Tick이 없으면 누락으로 판정
        if (elapsed > TickContract.FALLBACK_ACTIVATION_DELAY_MS) {
            tickMissing = true; // 세션 상태 업데이트
            return true;
        }
        return false;
    }

    /**
     * Real tick 수신 시 tick_missing 상태 리셋
     * onGameTick()에서 자동 호출됨
     */
    public void onRealTickReceived() {
        tickMissing = false;
        lastTickReceivedTime = System.currentTimeMillis();
    }

    /**
     * Tick 누락 상태 수동 설정 (테스트용)
     */
    public void setTickMissing(boolean missing) {
        this.tickMissing = missing;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\validation\SelfValidation.java =====

package com.echo.validation;

import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;

import com.pulse.api.profiler.TickPhaseHook;

/**
 * Echo Self-Validation Layer
 * 
 * Echo가 스스로 살아있는지 확인하는 자가 검증 시스템.
 * enable() 후 일정 시간이 지나면 자동으로 검증을 수행하여
 * Hook 누락, FreezeDetector 비활성화, SubProfiler 데이터 없음 등을 감지합니다.
 * 
 * @since Echo 0.9.0
 */
public class SelfValidation {

    private static final SelfValidation INSTANCE = new SelfValidation();

    // 검증 지연 시간 (10초 - 월드 로드 대기)
    // Note: 게임 시작 후 월드 로드까지 시간이 걸리므로 충분한 지연 필요
    private static final long VALIDATION_DELAY_MS = 10000;

    // --- Heartbeat Counters ---

    /** Tick 호출 횟수 (매 onTick() 마다 증가) */
    private final AtomicLong heartbeatCount = new AtomicLong(0);

    /** FreezeDetector.tick() 호출 횟수 */
    private final AtomicLong freezeCheckCount = new AtomicLong(0);

    // Phase 2 State (reserved for future use)
    @SuppressWarnings("unused")
    private volatile boolean usedFallbackTicks = false;

    /** SubProfiler 엔트리 수 (마지막 검증 시점) */
    @SuppressWarnings("unused")
    private volatile int subProfilerEntryCount = 0;

    // --- v0.9: Phase State Tracking ---

    /** Phase 시작 호출 횟수 */
    private final AtomicLong phaseStartCount = new AtomicLong(0);

    /** Phase 종료 호출 횟수 */
    private final AtomicLong phaseEndCount = new AtomicLong(0);

    // --- Validation State ---

    /** 마지막 검증 시간 (reserved for future use) */
    @SuppressWarnings("unused")
    private volatile long lastValidationTime = 0;

    /** 검증 결과 */
    private volatile ValidationResult lastResult = null;

    /** 검증 스케줄러 */
    private ScheduledExecutorService scheduler;

    private SelfValidation() {
        // Singleton
    }

    public static SelfValidation getInstance() {
        return INSTANCE;
    }

    // --- Heartbeat API (호출되는 쪽에서 증가) ---

    /**
     * Tick heartbeat 증가 (TickProfiler.onTick()에서 호출)
     */
    public void tickHeartbeat() {
        heartbeatCount.incrementAndGet();
    }

    /**
     * FreezeDetector check 증가 (FreezeDetector.tick()에서 호출)
     */
    public void freezeCheckHeartbeat() {
        freezeCheckCount.incrementAndGet();
    }

    /**
     * 현재 heartbeat 카운트 반환
     */
    public long getHeartbeatCount() {
        return heartbeatCount.get();
    }

    /**
     * 현재 freeze check 카운트 반환
     */
    public long getFreezeCheckCount() {
        return freezeCheckCount.get();
    }

    /**
     * v0.9: Phase 시작 heartbeat (TickPhaseBridge.startPhase()에서 호출)
     */
    public void phaseStartHeartbeat() {
        phaseStartCount.incrementAndGet();
    }

    /**
     * v0.9: Phase 종료 heartbeat (TickPhaseBridge.endPhase()에서 호출)
     */
    public void phaseEndHeartbeat() {
        phaseEndCount.incrementAndGet();
    }

    /**
     * v0.9: Phase 시작 카운트 반환
     */
    public long getPhaseStartCount() {
        return phaseStartCount.get();
    }

    /**
     * v0.9: Phase 종료 카운트 반환
     */
    public long getPhaseEndCount() {
        return phaseEndCount.get();
    }

    // --- Validation Control ---

    /**
     * 검증 스케줄 시작 (EchoProfiler.enable() 에서 호출)
     * 지정된 지연 시간 후 자동으로 validate() 실행
     */
    public synchronized void scheduleValidation() {
        // 이전 스케줄러가 있으면 종료
        if (scheduler != null && !scheduler.isShutdown()) {
            scheduler.shutdownNow();
        }

        scheduler = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "Echo-SelfValidation");
            t.setDaemon(true);
            return t;
        });

        scheduler.schedule(this::performValidation, VALIDATION_DELAY_MS, TimeUnit.MILLISECONDS);
        System.out.println("[Echo] Self-validation scheduled in " + VALIDATION_DELAY_MS + "ms");
    }

    /**
     * 검증 수행
     */
    private void performValidation() {
        ValidationResult result = validate();
        this.lastResult = result;
        this.lastValidationTime = System.currentTimeMillis();

        // 콘솔에 결과 출력
        printValidationResult(result);
    }

    /**
     * 즉시 검증 수행 (수동 호출용)
     */
    public ValidationResult validate() {
        ValidationResult result = new ValidationResult();

        // 1. Tick Hook 검증
        long ticks = heartbeatCount.get();
        if (ticks == 0) {
            result.hookStatus = HookStatus.MISSING;
            result.addIssue(ValidationIssue.TICK_HOOK_MISSING);
        } else if (ticks < 10) {
            result.hookStatus = HookStatus.PARTIAL;
            result.addIssue(ValidationIssue.TICK_HOOK_LOW_COUNT);
        } else {
            result.hookStatus = HookStatus.OK;
        }
        result.heartbeatCount = ticks;

        // 2. FreezeDetector 검증
        long freezeChecks = freezeCheckCount.get();
        if (freezeChecks == 0) {
            result.freezeDetectorStatus = FreezeDetectorStatus.INACTIVE;
            result.addIssue(ValidationIssue.FREEZE_DETECTOR_INACTIVE);
        } else {
            result.freezeDetectorStatus = FreezeDetectorStatus.ACTIVE;
        }
        result.freezeCheckCount = freezeChecks;

        // 3. SubProfiler 검증 (DeepAnalysis가 켜진 경우만)
        if (com.echo.config.EchoConfig.getInstance().isDeepAnalysisEnabled()) {
            com.echo.measure.SubProfiler subProfiler = com.echo.measure.SubProfiler.getInstance();
            int entryCount = subProfiler.getEntryCount();
            this.subProfilerEntryCount = entryCount;

            if (entryCount == 0) {
                result.subProfilerStatus = SubProfilerStatus.NO_DATA;
                result.addIssue(ValidationIssue.SUBPROFILER_NO_DATA);
            } else {
                result.subProfilerStatus = SubProfilerStatus.OK;
            }
            result.subProfilerEntryCount = entryCount;
        } else {
            result.subProfilerStatus = SubProfilerStatus.DISABLED;
        }

        // 4. v0.9: Phase State 검증
        result.phaseStartCount = phaseStartCount.get();
        result.phaseEndCount = phaseEndCount.get();

        // Phase Hook에서 발생한 에러 검사
        int phaseErrors = TickPhaseHook.getPhaseErrorCount();
        result.phaseErrorCount = phaseErrors;

        if (phaseErrors > 0) {
            result.phaseStatus = PhaseStatus.ERRORS;
            result.addIssue(ValidationIssue.PHASE_SEQUENCE_ERRORS);
        } else if (phaseStartCount.get() == 0 && heartbeatCount.get() > 60) {
            // 60틱 이상 지났는데 phase가 하나도 없음
            result.phaseStatus = PhaseStatus.NO_PHASES;
            result.addIssue(ValidationIssue.NO_PHASE_DATA);
        } else if (phaseStartCount.get() != phaseEndCount.get()) {
            // Start/End 불일치 (Phase 누수)
            result.phaseStatus = PhaseStatus.MISMATCH;
            result.addIssue(ValidationIssue.PHASE_COUNT_MISMATCH);
        } else {
            result.phaseStatus = PhaseStatus.OK;
        }

        // 5. v0.9: Pulse Contract 검증
        PulseContractVerifier contract = PulseContractVerifier.getInstance();
        result.contractViolated = contract.isViolated();
        result.tickMissing = contract.isTickMissing();
        if (contract.isViolated()) {
            result.addIssue(ValidationIssue.PULSE_CONTRACT_VIOLATED);
        }

        result.validationTime = System.currentTimeMillis();
        return result;
    }

    /**
     * 검증 결과 콘솔 출력
     */
    private void printValidationResult(ValidationResult result) {
        System.out.println("\n[Echo] ══════════════════════════════════════");
        System.out.println("[Echo]          SELF-VALIDATION RESULT");
        System.out.println("[Echo] ══════════════════════════════════════");

        // Hook Status
        String hookIcon = result.hookStatus == HookStatus.OK ? "✓"
                : result.hookStatus == HookStatus.PARTIAL ? "⚠" : "✗";
        System.out.printf("[Echo] %s Hook Status: %s (heartbeat: %d)%n",
                hookIcon, result.hookStatus, result.heartbeatCount);

        // FreezeDetector Status
        String freezeIcon = result.freezeDetectorStatus == FreezeDetectorStatus.ACTIVE ? "✓" : "✗";
        System.out.printf("[Echo] %s FreezeDetector: %s (checks: %d)%n",
                freezeIcon, result.freezeDetectorStatus, result.freezeCheckCount);

        // SubProfiler Status
        if (result.subProfilerStatus != SubProfilerStatus.DISABLED) {
            String subIcon = result.subProfilerStatus == SubProfilerStatus.OK ? "✓" : "✗";
            System.out.printf("[Echo] %s SubProfiler: %s (entries: %d)%n",
                    subIcon, result.subProfilerStatus, result.subProfilerEntryCount);
        }

        // Issues
        if (!result.issues.isEmpty()) {
            System.out.println("[Echo] ──────────────────────────────────────");
            for (ValidationIssue issue : result.issues) {
                System.out.printf("[Echo] ⚠ %s: %s%n", issue.name(), issue.getDescription());
            }
        }

        // Critical Error: Hook Missing
        if (result.hookStatus == HookStatus.MISSING) {
            System.err.println("[Echo] ══════════════════════════════════════");
            System.err.println("[Echo] ERROR: Tick hook not firing!");
            System.err.println("[Echo] Pulse hook may be missing or misconfigured.");
            System.err.println("[Echo] total_ticks will be 0 in the report.");
            System.err.println("[Echo] ══════════════════════════════════════");
        }

        System.out.println("[Echo] ══════════════════════════════════════\n");
    }

    /**
     * 카운터 초기화 (세션 리셋 시)
     */
    public void reset() {
        heartbeatCount.set(0);
        freezeCheckCount.set(0);
        phaseStartCount.set(0);
        phaseEndCount.set(0);
        subProfilerEntryCount = 0;
        lastValidationTime = 0;
        lastResult = null;
    }

    /**
     * 스케줄러 종료 (EchoProfiler.disable() 에서 호출)
     */
    public synchronized void shutdown() {
        if (scheduler != null && !scheduler.isShutdown()) {
            scheduler.shutdownNow();
            scheduler = null;
        }
    }

    /**
     * 마지막 검증 결과
     */
    public ValidationResult getLastResult() {
        return lastResult;
    }

    /**
     * 보고서용 Map 생성
     */
    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();

        // 리포트 생성 시 항상 최신 검증 수행 (캐시된 초기 결과는 월드 로드 전일 수 있음)
        ValidationResult result = validate();

        map.put("hook_status", result.hookStatus.name());
        map.put("heartbeat_count", result.heartbeatCount);

        // Data Sufficiency Check (Phase 2.3)
        if (result.heartbeatCount < 10) {
            map.put("min_required_data", "INSUFFICIENT");
        } else if (result.heartbeatCount < 100) {
            map.put("min_required_data", "WARMUP");
        } else {
            map.put("min_required_data", "OK");
        }
        map.put("freeze_detector", result.freezeDetectorStatus.name());
        map.put("freeze_check_count", result.freezeCheckCount);
        map.put("subprofiler_status", result.subProfilerStatus.name());
        map.put("subprofiler_entry_count", result.subProfilerEntryCount);

        if (result.validationTime > 0) {
            map.put("validation_time", java.time.Instant.ofEpochMilli(result.validationTime).toString());
        }

        // Issues 목록
        List<String> issueList = new ArrayList<>();
        for (ValidationIssue issue : result.issues) {
            issueList.add(issue.name());
        }
        if (!issueList.isEmpty()) {
            map.put("issues", issueList);
        }

        // Fallback Tick 정보 (Echo 0.9.0 / 0.9.1 강화)
        FallbackTickEmitter fallback = FallbackTickEmitter.getInstance();
        map.put("used_fallback_ticks", com.echo.config.EchoConfig.getInstance().isUsedFallbackTicks());
        map.put("fallback_tick_count", fallback.getFallbackTickCount());

        // v0.9.1: 핵심 플래그 - "데이터 오염 여부" (골든 판정 기준)
        // used_fallback_ticks: fallback이 활성화된 적이 있었는지 (진단용)
        // fallback_contaminated_timing: timing 데이터가 오염됐는지 (골든 판정용)
        map.put("fallback_contaminated_timing", fallback.isHistogramContaminated());

        // v0.9: Phase State 정보
        map.put("phase_status", result.phaseStatus != null ? result.phaseStatus.name() : "UNKNOWN");
        map.put("phase_start_count", result.phaseStartCount);
        map.put("phase_end_count", result.phaseEndCount);
        map.put("phase_error_count", result.phaseErrorCount);

        // v0.9: Pulse Contract 정보
        map.put("pulse_contract_violated", result.contractViolated);
        map.put("tick_missing", result.tickMissing);

        return map;
    }

    // --- Inner Classes ---

    public static class ValidationResult {
        public HookStatus hookStatus = HookStatus.UNKNOWN;
        public FreezeDetectorStatus freezeDetectorStatus = FreezeDetectorStatus.UNKNOWN;
        public SubProfilerStatus subProfilerStatus = SubProfilerStatus.UNKNOWN;

        public long heartbeatCount = 0;
        public long freezeCheckCount = 0;
        public int subProfilerEntryCount = 0;
        public long validationTime = 0;

        // v0.9: Phase State
        public PhaseStatus phaseStatus = PhaseStatus.UNKNOWN;
        public long phaseStartCount = 0;
        public long phaseEndCount = 0;
        public int phaseErrorCount = 0;

        // v0.9: Pulse Contract
        public boolean contractViolated = false;
        public boolean tickMissing = false;

        public final List<ValidationIssue> issues = new ArrayList<>();

        public void addIssue(ValidationIssue issue) {
            issues.add(issue);
        }

        public boolean hasIssues() {
            return !issues.isEmpty();
        }

        public boolean isCritical() {
            return hookStatus == HookStatus.MISSING;
        }
    }

    public enum HookStatus {
        OK, // 정상 (heartbeat > 10)
        PARTIAL, // 부분 작동 (0 < heartbeat < 10)
        MISSING, // 누락 (heartbeat == 0)
        UNKNOWN
    }

    public enum FreezeDetectorStatus {
        ACTIVE, // 정상 작동 중
        INACTIVE, // 비활성화됨
        UNKNOWN
    }

    public enum SubProfilerStatus {
        OK, // 데이터 있음
        NO_DATA, // DeepAnalysis ON인데 데이터 없음
        DISABLED, // DeepAnalysis OFF
        UNKNOWN
    }

    public enum ValidationIssue {
        TICK_HOOK_MISSING("Pulse tick hook is not firing. Check Pulse installation."),
        TICK_HOOK_LOW_COUNT("Very few ticks recorded. Session may be too short."),
        FREEZE_DETECTOR_INACTIVE("FreezeDetector is not receiving tick updates."),
        SUBPROFILER_NO_DATA("DeepAnalysis enabled but no SubProfiler data collected."),
        // v0.9: Phase 검증 이슈
        PHASE_SEQUENCE_ERRORS("Phase sequence errors detected (startPhase/endPhase mismatch)."),
        NO_PHASE_DATA("No phase data received despite active tick hook."),
        PHASE_COUNT_MISMATCH("Phase start/end count mismatch (possible phase leak)."),
        PULSE_CONTRACT_VIOLATED("Pulse tick contract violated (abnormal deltaTime detected).");

        private final String description;

        ValidationIssue(String description) {
            this.description = description;
        }

        public String getDescription() {
            return description;
        }
    }

    // v0.9: Phase Status Enum
    public enum PhaseStatus {
        OK, // Phase 정상 동작
        NO_PHASES, // Phase 데이터 없음
        MISMATCH, // Start/End 불일치
        ERRORS, // 시퀀스 에러 발생
        UNKNOWN
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\java\com\echo\validation\WarmupDetector.java =====

package com.echo.validation;

import com.echo.aggregate.DataQualityFlag;

/**
 * Warmup 감지기.
 * 
 * 게임 시작 직후 몇 초간은 클래스 로딩, JIT 컴파일 등으로
 * 프로파일링 데이터가 불안정합니다. 이 기간을 감지하여
 * 데이터 품질 플래그를 적용합니다.
 * 
 * @since 1.0.1
 */
public class WarmupDetector {

    private static final WarmupDetector INSTANCE = new WarmupDetector();

    // Warmup 기간 (밀리초)
    private static final long DEFAULT_WARMUP_DURATION_MS = 5000; // 5초

    private long sessionStartTime;
    private long warmupDurationMs = DEFAULT_WARMUP_DURATION_MS;
    private volatile boolean warmupComplete = false;

    private WarmupDetector() {
        this.sessionStartTime = System.currentTimeMillis();
    }

    public static WarmupDetector getInstance() {
        return INSTANCE;
    }

    /**
     * 세션 시작 시간 초기화
     */
    public void startSession() {
        this.sessionStartTime = System.currentTimeMillis();
        this.warmupComplete = false;
    }

    /**
     * Warmup 기간 설정
     * 
     * @param durationMs 밀리초 단위 기간
     */
    public void setWarmupDuration(long durationMs) {
        this.warmupDurationMs = durationMs;
    }

    /**
     * 현재 Warmup 기간 중인지 확인
     */
    public boolean isInWarmup() {
        if (warmupComplete) {
            return false;
        }

        long elapsed = System.currentTimeMillis() - sessionStartTime;
        if (elapsed >= warmupDurationMs) {
            warmupComplete = true;
            return false;
        }
        return true;
    }

    /**
     * Warmup 상태를 확인하고 해당 시 플래그 반환
     * 
     * @return WARMUP_PERIOD if in warmup, null otherwise
     */
    public DataQualityFlag checkAndFlag() {
        return isInWarmup() ? DataQualityFlag.WARMUP_PERIOD : null;
    }

    /**
     * Warmup 경과 시간 (밀리초)
     */
    public long getElapsedWarmupMs() {
        return System.currentTimeMillis() - sessionStartTime;
    }

    /**
     * Warmup 진행률 (0.0 ~ 1.0)
     */
    public double getWarmupProgress() {
        if (warmupComplete)
            return 1.0;
        long elapsed = System.currentTimeMillis() - sessionStartTime;
        return Math.min(1.0, (double) elapsed / warmupDurationMs);
    }

    /**
     * Warmup 완료 여부
     */
    public boolean isWarmupComplete() {
        // 부작용으로 상태 업데이트
        isInWarmup();
        return warmupComplete;
    }

    /**
     * 강제로 Warmup 완료 처리
     */
    public void forceComplete() {
        this.warmupComplete = true;
    }

    /**
     * 상태 초기화
     */
    public void reset() {
        this.sessionStartTime = System.currentTimeMillis();
        this.warmupComplete = false;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\main\resources\pulse.mod.json =====

{
  "id": "echo",
  "name": "Echo Profiler",
  "version": "2.0.0",
  "description": "Performance profiling tool for Project Zomboid - Automatic data collection and reporting",
  "authors": ["Echo Team"],
  "entrypoint": "com.echo.EchoMod",
  "dependencies": [
    {
      "id": "Pulse",
      "version": ">=0.8.0",
      "optional": false
    }
  ],
  "conflicts": [],
  "mixins": []
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\test\java\com\echo\aggregate\SpikeLogTest.java =====

package com.echo.aggregate;

import com.echo.measure.ProfilingPoint;
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * SpikeLog 단위 테스트
 */
class SpikeLogTest {

    private SpikeLog spikeLog;

    @BeforeEach
    void setUp() {
        spikeLog = new SpikeLog(10.0); // 10ms threshold
    }

    @Test
    @DisplayName("Initial state")
    void testInitialState() {
        assertEquals(0, spikeLog.getTotalSpikes());
        assertEquals(0.0, spikeLog.getWorstSpikeMs());
        assertEquals(10.0, spikeLog.getThresholdMs());
    }

    @Test
    @DisplayName("Spikes below threshold not logged")
    void testBelowThreshold() {
        spikeLog.logSpike(5000, ProfilingPoint.TICK, null); // 5ms < 10ms
        assertEquals(0, spikeLog.getTotalSpikes());
    }

    @Test
    @DisplayName("Spikes above threshold logged")
    void testAboveThreshold() {
        spikeLog.logSpike(15000, ProfilingPoint.TICK, null); // 15ms > 10ms
        assertEquals(1, spikeLog.getTotalSpikes());
    }

    @Test
    @DisplayName("Worst spike tracking")
    void testWorstSpike() {
        spikeLog.logSpike(20000, ProfilingPoint.TICK, "first");
        spikeLog.logSpike(50000, ProfilingPoint.TICK, "worst");
        spikeLog.logSpike(30000, ProfilingPoint.TICK, "third");

        assertEquals(50.0, spikeLog.getWorstSpikeMs());
        assertEquals("worst", spikeLog.getWorstSpikeLabel());
    }

    @Test
    @DisplayName("Threshold can be changed at runtime")
    void testThresholdChange() {
        spikeLog.setThresholdMs(5.0);
        assertEquals(5.0, spikeLog.getThresholdMs());

        spikeLog.logSpike(7000, ProfilingPoint.TICK, null); // 7ms > 5ms
        assertEquals(1, spikeLog.getTotalSpikes());
    }

    @Test
    @DisplayName("Recent spikes retrieval")
    void testRecentSpikes() {
        spikeLog.logSpike(15000, ProfilingPoint.TICK, "spike1");
        spikeLog.logSpike(20000, ProfilingPoint.RENDER, "spike2");

        var recent = spikeLog.getRecentSpikes(5);
        assertEquals(2, recent.size());
    }

    @Test
    @DisplayName("Reset clears all data")
    void testReset() {
        spikeLog.logSpike(20000, ProfilingPoint.TICK, "test");
        spikeLog.reset();

        assertEquals(0, spikeLog.getTotalSpikes());
        assertEquals(0.0, spikeLog.getWorstSpikeMs());
    }

    @Test
    @DisplayName("toMap generates valid output")
    void testToMap() {
        spikeLog.logSpike(20000, ProfilingPoint.TICK, "spike");

        var map = spikeLog.toMap();
        assertNotNull(map);
        assertTrue(map.containsKey("total_spikes"));
        assertTrue(map.containsKey("worst_spike_ms"));
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\test\java\com\echo\aggregate\TimingDataTest.java =====

package com.echo.aggregate;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * TimingData 단위 테스트
 */
class TimingDataTest {

    private TimingData data;

    @BeforeEach
    void setUp() {
        data = new TimingData("test");
    }

    @Test
    @DisplayName("Initial state")
    void testInitialState() {
        assertEquals("test", data.getName());
        assertEquals(0, data.getCallCount());
        assertEquals(0, data.getAverageMicros());
        assertEquals(0, data.getMaxMicros());
    }

    @Test
    @DisplayName("Add sample updates statistics")
    void testAddSample() {
        data.addSample(1000000); // 1ms in nanos

        assertEquals(1, data.getCallCount());
        assertEquals(1000, data.getAverageMicros()); // 1000 micros
    }

    @Test
    @DisplayName("Multiple samples average correctly")
    void testMultipleSamples() {
        data.addSample(1000000); // 1ms
        data.addSample(3000000); // 3ms

        assertEquals(2, data.getCallCount());
        assertEquals(2000, data.getAverageMicros()); // 2ms average
    }

    @Test
    @DisplayName("Max value tracking")
    void testMaxTracking() {
        data.addSample(1000000);
        data.addSample(5000000);
        data.addSample(2000000);

        assertEquals(5000, data.getMaxMicros());
    }

    @Test
    @DisplayName("Min value tracking")
    void testMinTracking() {
        data.addSample(5000000);
        data.addSample(1000000);
        data.addSample(3000000);

        assertEquals(1000, data.getMinMicros());
    }

    @Test
    @DisplayName("Labeled sub-timing data")
    void testLabeledData() {
        data.addSample(1000000, "func1");
        data.addSample(2000000, "func1");
        data.addSample(3000000, "func2");

        var labelStats = data.getLabelStats();
        assertEquals(2, labelStats.size());

        var func1Stats = labelStats.get("func1");
        assertEquals(2, func1Stats.getCallCount());
    }

    @Test
    @DisplayName("Top N by total time")
    void testTopN() {
        data.addSample(1000000, "slow");
        data.addSample(1000000, "slow");
        data.addSample(500000, "fast");

        var topN = data.getTopNByTotalTime(1);
        assertEquals(1, topN.size());
        assertEquals("slow", topN.get(0).getLabel());
    }

    @Test
    @DisplayName("Reset clears all data")
    void testReset() {
        data.addSample(1000000, "test");
        data.reset();

        assertEquals(0, data.getCallCount());
        assertTrue(data.getLabelStats().isEmpty());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\test\java\com\echo\di\EchoDIIntegrationTest.java =====

package com.echo.di;

import com.echo.config.EchoConfig;
import com.echo.lua.LuaCallTracker;
import com.echo.measure.EchoProfiler;
import com.pulse.di.PulseServiceLocator;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Verifies that the Hybrid DI system correctly allows mocking dependencies
 * for legacy singleton-based classes.
 */
public class EchoDIIntegrationTest {

    @BeforeEach
    void setUp() {
        PulseServiceLocator.getInstance().clear();
        // Reset singletons if possible?
        // Note: We can't easily reset static singletons without reflection or adding
        // reset methods.
        // For this test, we rely on the fact that getInstance() checks the Locator
        // FIRST.
    }

    @AfterEach
    void tearDown() {
        PulseServiceLocator.getInstance().clear();
    }

    @Test
    void testLuaCallTrackerUsesMockedDependencies() {
        // 1. Create Mocks (using anonymous classes for simplicity, or Mockito if
        // available)
        EchoConfig mockConfig = new EchoConfig() {
            @Override
            public boolean isLuaProfilingEnabled() {
                return true; // Force enabled
            }
        };

        EchoProfiler mockProfiler = new EchoProfiler(mockConfig) {
            @Override
            public boolean isLuaProfilingEnabled() {
                return true;
            }
        };

        // 2. Register Mocks in ServiceLocator
        PulseServiceLocator.getInstance().registerService(EchoConfig.class, mockConfig);
        PulseServiceLocator.getInstance().registerService(EchoProfiler.class, mockProfiler);

        // 3. Create LuaCallTracker via ServiceLocator (or manually injecting mocks)
        // If we use getInstance(), it should pick up the mocks if it uses the locator
        // logic internally.
        // Wait, LuaCallTracker.getInstance() logic:
        // Try Locator -> Returns service if found.
        // So if we register LuaCallTracker WITH the mocks, getInstance() returns it.

        LuaCallTracker trackerWithMocks = new LuaCallTracker(mockConfig, mockProfiler);
        PulseServiceLocator.getInstance().registerService(LuaCallTracker.class, trackerWithMocks);

        // 4. Verify generic getInstance() returns our instance
        LuaCallTracker instance = LuaCallTracker.getInstance();
        assertSame(trackerWithMocks, instance, "Should return the registered instance from ServiceLocator");

        // 5. Verify it is using our mocks
        // recordFunctionCall checks profiler.isLuaProfilingEnabled().
        // If it was using the real singleton which might be disabled, it wouldn't
        // record.
        // Our mock forces true.

        instance.recordFunctionCall("test_function", 1000);
        assertNotNull(instance.getFunctionStats("test_function"), "Should have recorded usage because mock enabled it");
    }

    @Test
    void testEchoConfigMocking() {
        // Register a mock config
        EchoConfig mockConfig = new EchoConfig() {
            @Override
            public double getSpikeThresholdMs() {
                return 9999.0;
            }
        };
        PulseServiceLocator.getInstance().registerService(EchoConfig.class, mockConfig);

        // EchoConfig.getInstance() logic:
        // Try Locator -> Return service.
        EchoConfig instance = EchoConfig.getInstance();
        assertSame(mockConfig, instance);
        assertEquals(9999.0, instance.getSpikeThresholdMs());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\test\java\com\echo\measure\EchoProfilerTest.java =====

package com.echo.measure;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * EchoProfiler 단위 테스트
 */
class EchoProfilerTest {

    private EchoProfiler profiler;

    @BeforeEach
    void setUp() {
        profiler = EchoProfiler.getInstance();
        profiler.reset();
        profiler.enable(true);
    }

    @AfterEach
    void tearDown() {
        profiler.disable();
    }

    @Test
    @DisplayName("Profiler singleton instance")
    void testSingleton() {
        EchoProfiler instance1 = EchoProfiler.getInstance();
        EchoProfiler instance2 = EchoProfiler.getInstance();
        assertSame(instance1, instance2);
    }

    @Test
    @DisplayName("Enable/Disable profiler")
    void testEnableDisable() {
        profiler.disable();
        assertFalse(profiler.isEnabled());

        profiler.enable();
        assertTrue(profiler.isEnabled());
    }

    @Test
    @DisplayName("Push/Pop records timing data")
    void testPushPop() {
        profiler.push(ProfilingPoint.TICK);
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        profiler.pop(ProfilingPoint.TICK);

        var data = profiler.getTimingData(ProfilingPoint.TICK);
        assertNotNull(data);
        assertEquals(1, data.getCallCount());
        assertTrue(data.getAverageMicros() > 0);
    }

    @Test
    @DisplayName("Scope API with try-with-resources")
    void testScopeApi() {
        try (var scope = profiler.scope(ProfilingPoint.ZOMBIE_AI)) {
            // Simulated work
            Thread.sleep(5);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        var data = profiler.getTimingData(ProfilingPoint.ZOMBIE_AI);
        assertNotNull(data);
        assertEquals(1, data.getCallCount());
    }

    @Test
    @DisplayName("Raw API for zero-allocation")
    void testRawApi() {
        long start = profiler.startRaw(ProfilingPoint.RENDER);
        assertTrue(start > 0);
        profiler.endRaw(ProfilingPoint.RENDER, start);

        var data = profiler.getTimingData(ProfilingPoint.RENDER);
        assertEquals(1, data.getCallCount());
    }

    @Test
    @DisplayName("Labeled profiling")
    void testLabeledProfiling() {
        try (var scope = profiler.scope(ProfilingPoint.ZOMBIE_AI, "pathfinding")) {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        var data = profiler.getTimingData(ProfilingPoint.ZOMBIE_AI);
        var labelStats = data.getLabelStats();
        assertTrue(labelStats.containsKey("pathfinding"));
    }

    @Test
    @DisplayName("Reset clears all data")
    void testReset() {
        try (var scope = profiler.scope(ProfilingPoint.TICK)) {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        profiler.reset();

        var data = profiler.getTimingData(ProfilingPoint.TICK);
        assertEquals(0, data.getCallCount());
    }

    @Test
    @DisplayName("Session duration tracking")
    void testSessionDuration() throws InterruptedException {
        Thread.sleep(100);
        // Session duration should be at least 0 seconds
        assertTrue(profiler.getSessionDurationSeconds() >= 0);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Echo\src\test\java\com\echo\report\EchoReportTest.java =====

package com.echo.report;

import com.echo.aggregate.TickHistogram;
import com.echo.aggregate.TimingData;
import com.echo.measure.EchoProfiler;
import com.echo.measure.ProfilingPoint;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

public class EchoReportTest {

    private EchoProfiler profiler;
    private EchoReport echoReport;

    @BeforeEach
    void setUp() {
        // Validation of strategy pattern implementation
        // Manual stubbing to avoid Mockito dependency issues
        profiler = new EchoProfilerStub();
        echoReport = new EchoReport(profiler);
    }

    @Test
    void testCollectReportData() {
        Map<String, Object> data = echoReport.collectReportData();
        assertNotNull(data);
        assertTrue(data.containsKey("echo_report"));

        @SuppressWarnings("unchecked")
        Map<String, Object> inner = (Map<String, Object>) data.get("echo_report");
        assertEquals(100L, inner.get("session_duration_seconds"));
    }

    @Test
    void testJsonGeneration() {
        String json = echoReport.generateJson();
        assertNotNull(json);
        assertTrue(json.contains("\"session_duration_seconds\": 100"));
        assertTrue(json.contains("\"echo_report\""));
    }

    @Test
    void testHtmlGeneration() {
        String html = echoReport.generateHtml();
        assertNotNull(html);
        assertTrue(html.contains("<!DOCTYPE html>"));
        // Check for embedded JSON
        assertTrue(html.contains("const data = {"));
    }

    @Test
    void testCsvGeneration() {
        String csv = echoReport.generateCsv();
        assertNotNull(csv);
        assertTrue(csv.contains("point,avgMs,maxMs,minMs,callCount"));
    }

    @Test
    void testTextGeneration() {
        String text = echoReport.generateText();
        assertNotNull(text);
        assertTrue(text.contains("ECHO PROFILING REPORT"));
        // Note: Stub might return empty/null data, checking basic structure
        // If stub returns valid TimingData, we can check content
    }

    // --- Golden Master Tests for Phase 2 Refactoring Safety ---

    /**
     * Golden Master Test: JSON 구조 안정성 검증.
     * Phase 2 리팩토링 시 출력 형식이 변경되지 않았음을 보장.
     */
    @Test
    void goldenMasterJsonStructure() {
        Map<String, Object> data = echoReport.collectReportData();
        assertNotNull(data, "Report data should not be null");
        assertTrue(data.containsKey("echo_report"), "Should contain echo_report key");

        @SuppressWarnings("unchecked")
        Map<String, Object> echoReportData = (Map<String, Object>) data.get("echo_report");
        assertNotNull(echoReportData, "echo_report should not be null");

        // 필수 키만 검증 (싱글톤 의존성으로 인해 일부는 실패할 수 있음)
        assertTrue(echoReportData.containsKey("version"), "Missing version");
        assertTrue(echoReportData.containsKey("generated_at"), "Missing generated_at");
        assertTrue(echoReportData.containsKey("session_duration_seconds"), "Missing session_duration_seconds");
    }

    /**
     * Golden Master Test: 포맷 생성 일관성 검증.
     */
    @Test
    void goldenMasterFormatConsistency() {
        // 동일한 데이터로 여러 번 생성해도 일관된 결과
        String json1 = echoReport.generateJson();
        String json2 = echoReport.generateJson();

        assertNotNull(json1);
        assertNotNull(json2);

        // 기본 구조가 동일한지만 확인 (타임스탬프 때문에 완전 동일하지 않을 수 있음)
        assertTrue(json1.contains("\"echo_report\""));
        assertTrue(json2.contains("\"echo_report\""));
    }

    // --- Stubs ---

    private static class EchoProfilerStub extends EchoProfiler {
        // Need to override used methods.
        // EchoProfiler dependencies: config, tracker (passed in constructor)
        // Since we didn't use the constructor with args in stub, we need to be careful.
        // But EchoProfiler has a no-arg constructor? No, we added
        // `EchoProfiler(EchoConfig)`
        // and commented out calling super.
        // Wait, default constructor of EchoProfiler might be missing if I added
        // parameterized one.
        // I need to check EchoProfiler constructors.
        // Assuming I can't call super easily if it has dependencies.
        // But internal logic of EchoProfiler uses fields.

        public EchoProfilerStub() {
            super(new com.echo.config.EchoConfig()); // Requires EchoConfig public constructor (I made it public in
                                                     // Phase 4.1)
        }

        @Override
        public long getSessionDurationSeconds() {
            return 100L;
        }

        @Override
        public TickHistogram getTickHistogram() {
            return new TickHistogram() {
                @Override
                public Map<String, Object> toMap() {
                    return new HashMap<>();
                }

                @Override
                public long[] getCounts() {
                    return new long[10];
                }

                @Override
                public double[] getBuckets() {
                    return new double[10];
                }
            };
        }

        @Override
        public com.echo.aggregate.SpikeLog getSpikeLog() {
            return new com.echo.aggregate.SpikeLog();
        }

        @Override
        public Map<ProfilingPoint, TimingData> getTimingData() {
            Map<ProfilingPoint, TimingData> map = new HashMap<>();
            map.put(ProfilingPoint.TICK, getTimingData(ProfilingPoint.TICK));
            return map;
        }

        @Override
        public TimingData getTimingData(ProfilingPoint point) {
            if (point == ProfilingPoint.TICK) {
                return new TimingDataStub("TICK"); // Manual stub
            }
            return new TimingDataStub(point.name());
        }
    }

    private static class TimingDataStub extends TimingData {
        public TimingDataStub(String name) {
            super(name);
        }

        @Override
        public long getCallCount() {
            return 1000L;
        }

        @Override
        public double getAverageMicros() {
            return 16000.0;
        }

        @Override
        public long getMaxMicros() {
            return 32000L;
        }

        @Override
        public long getMinMicros() {
            return 8000L;
        }

        @Override
        public TimingData.RollingStats getStats5s() {
            return new TimingData.RollingStats(5000) {
                @Override
                public long getAverage() {
                    return 16000L;
                }
            };
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\example-mod\build.gradle =====

plugins {
    id 'java'
}

group = 'com.example'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // Pulse API - 컴파일 타임에만 필요
    compileOnly files('../build/libs/Pulse-1.0.0-all.jar')
}

jar {
    // pulse.mod.json을 JAR 루트에 포함
    from('src/main/resources') {
        include 'pulse.mod.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Example Mod',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\example-mod\src\main\java\com\example\examplemod\ExampleCommands.java =====

package com.example.examplemod;

import com.pulse.command.Arg;
import com.pulse.command.Command;
import com.pulse.command.CommandContext;
import com.pulse.command.CommandRegistry;

/**
 * 예제 명령어 클래스.
 * 
 * @Command 어노테이션을 사용한 명령어 정의 예제.
 */
public class ExampleCommands {

    /**
     * 명령어 등록
     */
    public static void register() {
        // 어노테이션 기반 등록
        CommandRegistry.register(new ExampleCommands());

        // 람다 기반 등록
        CommandRegistry.register("examplehelp", "Show example mod help", ctx -> {
            ctx.reply("═══════════════════════════════════════");
            ctx.reply("  Example Mod Commands");
            ctx.reply("═══════════════════════════════════════");
            ctx.reply("/examplestatus - Show current status");
            ctx.reply("/exampleheal [amount] - Heal player");
            ctx.reply("/exampletoggle <feature> - Toggle feature");
            ctx.reply("/examplehelp - Show this help");
            ctx.reply("═══════════════════════════════════════");
        });
    }

    // ─────────────────────────────────────────────────────────────
    // 명령어 핸들러
    // ─────────────────────────────────────────────────────────────

    @Command(name = "examplestatus", description = "Show example mod status", aliases = { "exstatus" })
    public void statusCommand(CommandContext ctx) {
        ctx.reply("Example Mod Status:");
        ctx.reply("  Debug Mode: " + ExampleConfig.debugMode);
        ctx.reply("  Log Interval: " + ExampleConfig.logInterval + " ticks");
        ctx.reply("  Damage Reduction: " + (ExampleConfig.damageReduction * 100) + "%");
        ctx.reply("  Fire Immunity: " + ExampleConfig.fireImmunity);
    }

    @Command(name = "exampleheal", description = "Heal the player", usage = "/exampleheal [amount]", playerOnly = true)
    public void healCommand(CommandContext ctx, @Arg(value = "amount", optional = true) Float amount) {
        float healAmount = amount != null ? amount : 100.0f;

        // 실제 힐 로직은 GameAccess API를 통해 구현
        // GameAccess.setPlayerHealth(GameAccess.getPlayerHealth() + healAmount);

        ctx.reply("Healed for " + healAmount + " HP!");
    }

    @Command(name = "exampletoggle", description = "Toggle a feature", usage = "/exampletoggle <debug|fire|nightvision>")
    public void toggleCommand(CommandContext ctx, @Arg(value = "feature") String feature) {
        switch (feature.toLowerCase()) {
            case "debug":
                ExampleConfig.debugMode = !ExampleConfig.debugMode;
                ctx.reply("Debug mode: " + (ExampleConfig.debugMode ? "ON" : "OFF"));
                break;

            case "fire":
                ExampleConfig.fireImmunity = !ExampleConfig.fireImmunity;
                ctx.reply("Fire immunity: " + (ExampleConfig.fireImmunity ? "ON" : "OFF"));
                break;

            case "nightvision":
            case "nv":
                ExampleConfig.nightVision = !ExampleConfig.nightVision;
                ctx.reply("Night vision: " + (ExampleConfig.nightVision ? "ON" : "OFF"));
                break;

            default:
                ctx.reply("Unknown feature: " + feature);
                ctx.reply("Available: debug, fire, nightvision");
                break;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\example-mod\src\main\java\com\example\examplemod\ExampleConfig.java =====

package com.example.examplemod;

import com.pulse.config.Config;
import com.pulse.config.ConfigValue;

/**
 * Example Mod 설정.
 * 
 * @Config 어노테이션이 붙은 클래스는 자동으로 JSON 설정 파일로 관리됩니다.
 *         파일 위치: config/examplemod.json
 */
@Config(modId = "examplemod")
public class ExampleConfig {

    // ─────────────────────────────────────────────────────────────
    // 일반 설정
    // ─────────────────────────────────────────────────────────────

    @ConfigValue(comment = "Enable debug logging")
    public static boolean debugMode = false;

    @ConfigValue(comment = "Status log interval in ticks (600 = 10 seconds)")
    public static int logInterval = 600;

    // ─────────────────────────────────────────────────────────────
    // 게임플레이 설정
    // ─────────────────────────────────────────────────────────────

    @ConfigValue(comment = "Damage reduction multiplier (0.0 - 1.0)")
    public static float damageReduction = 0.0f;

    @ConfigValue(comment = "Enable fire damage immunity")
    public static boolean fireImmunity = false;

    @ConfigValue(comment = "Enable night vision effect")
    public static boolean nightVision = false;

    // ─────────────────────────────────────────────────────────────
    // 알림 설정
    // ─────────────────────────────────────────────────────────────

    @ConfigValue(comment = "Show status notifications")
    public static boolean showNotifications = true;

    @ConfigValue(comment = "Notification display duration in ticks")
    public static int notificationDuration = 100;
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\example-mod\src\main\java\com\example\examplemod\ExampleMod.java =====

package com.example.examplemod;

import com.pulse.api.GameAccess;
import com.pulse.api.Pulse;
import com.pulse.attachment.DataAttachments;
import com.pulse.config.ConfigManager;
import com.pulse.event.EventBus;
import com.pulse.event.EventPriority;
import com.pulse.event.lifecycle.GameInitEvent;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.event.lifecycle.WorldLoadEvent;
import com.pulse.event.lifecycle.WorldUnloadEvent;
import com.pulse.event.player.PlayerDamageEvent;
import com.pulse.event.player.PlayerUpdateEvent;
import com.pulse.input.KeyBinding;
import com.pulse.input.KeyBindingRegistry;
import com.pulse.input.KeyCode;
import com.pulse.mod.PulseMod;
import com.pulse.scheduler.PulseScheduler;

/**
 * Example Mod - Pulse API 사용 예제
 *
 * 이 모드는 Pulse의 주요 기능을 보여줍니다:
 * - 설정 시스템 (@Config)
 * - 이벤트 구독 및 처리
 * - 명령어 시스템 (@Command)
 * - 데이터 첨부 (DataAttachments)
 * - 스케줄러 (PulseScheduler)
 * - 키 바인딩 (KeyBinding)
 * - GameAccess API 사용
 */
public class ExampleMod implements PulseMod {

    private static final String MOD_ID = "examplemod";
    private long lastLogTick = 0;

    // 키 바인딩
    private KeyBinding openMenuKey;
    private KeyBinding toggleDebugKey;

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "Example Mod initializing...");

        // 1. 설정 등록 및 로드
        ConfigManager.register(ExampleConfig.class);
        Pulse.log(MOD_ID, "Config loaded - Debug mode: " + ExampleConfig.debugMode);

        // 2. 명령어 등록
        ExampleCommands.register();
        Pulse.log(MOD_ID, "Commands registered");

        // 3. 이벤트 리스너 등록
        registerEventListeners();

        // 4. 키 바인딩 등록
        registerKeyBindings();

        // 5. 스케줄러 예제
        scheduleExampleTasks();

        Pulse.log(MOD_ID, "Example Mod initialized!");
    }

    private void registerEventListeners() {
        // 게임 초기화 완료 이벤트
        EventBus.subscribe(GameInitEvent.class, this::onGameInit);

        // 게임 틱 이벤트
        EventBus.subscribe(GameTickEvent.class, this::onGameTick);

        // 월드 로드/언로드 이벤트
        EventBus.subscribe(WorldLoadEvent.class, this::onWorldLoad);
        EventBus.subscribe(WorldUnloadEvent.class, this::onWorldUnload);

        // 플레이어 이벤트
        EventBus.subscribe(PlayerUpdateEvent.class, this::onPlayerUpdate);

        // 플레이어 데미지 이벤트 - 높은 우선순위로 설정 적용
        EventBus.subscribe(PlayerDamageEvent.class, this::onPlayerDamage, EventPriority.HIGH);
    }

    private void registerKeyBindings() {
        // 메뉴 열기 키 (M)
        openMenuKey = KeyBinding.create(MOD_ID, "open_menu")
                .defaultKey(KeyCode.KEY_M)
                .category("Example Mod")
                .build();
        KeyBindingRegistry.register(openMenuKey);

        // 디버그 토글 키 (Ctrl+D)
        toggleDebugKey = KeyBinding.create(MOD_ID, "toggle_debug")
                .defaultKey(KeyCode.KEY_D)
                .withCtrl()
                .category("Example Mod")
                .build();
        KeyBindingRegistry.register(toggleDebugKey);
    }

    private void scheduleExampleTasks() {
        // 게임 시작 후 5초(100틱) 뒤에 환영 메시지
        PulseScheduler.runLater(() -> {
            Pulse.log(MOD_ID, "Welcome to Example Mod! Press M to open menu.");
        }, 100, "welcome-message");

        // 1분마다 플레이어 데이터 자동 저장 (1200틱)
        PulseScheduler.runTimer(() -> {
            Object player = GameAccess.getLocalPlayer();
            if (player != null) {
                DataAttachments.save(player, "examplemod_player.json");
                if (ExampleConfig.debugMode) {
                    Pulse.log(MOD_ID, "Player data auto-saved");
                }
            }
        }, 1200, 1200, "auto-save");
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 핸들러
    // ─────────────────────────────────────────────────────────────

    private void onGameInit(GameInitEvent event) {
        Pulse.log(MOD_ID, "Game initialization complete!");
    }

    private void onGameTick(GameTickEvent event) {
        // 키 바인딩 체크
        checkKeyBindings();

        // 플레이어 데이터 업데이트
        updatePlayerData();

        // 설정된 간격으로 상태 로그 출력
        if (event.getTick() - lastLogTick >= ExampleConfig.logInterval) {
            lastLogTick = event.getTick();
            if (ExampleConfig.debugMode) {
                logGameStatus();
            }
        }
    }

    private void checkKeyBindings() {
        if (openMenuKey != null && openMenuKey.wasPressed()) {
            Pulse.log(MOD_ID, "Menu key pressed! (Placeholder for actual menu)");
        }

        if (toggleDebugKey != null && toggleDebugKey.wasPressed()) {
            ExampleConfig.debugMode = !ExampleConfig.debugMode;
            ConfigManager.save(ExampleConfig.class);
            Pulse.log(MOD_ID, "Debug mode: " + (ExampleConfig.debugMode ? "ON" : "OFF"));
        }
    }

    private void updatePlayerData() {
        Object player = GameAccess.getLocalPlayer();
        if (player == null)
            return;

        // 플레이어 데이터 가져오기 (없으면 자동 생성)
        PlayerExtraData data = DataAttachments.get(player, PlayerExtraData.TYPE);

        // 플레이 시간 증가
        data.incrementPlayTime();

        // 현재 위치 저장
        String location = String.format("%.0f, %.0f, %.0f",
                GameAccess.getPlayerX(),
                GameAccess.getPlayerY(),
                GameAccess.getPlayerZ());
        data.setLastLocation(location);
    }

    private void onWorldLoad(WorldLoadEvent event) {
        Pulse.log(MOD_ID, "World loaded: " + event.getWorldName());

        // 플레이어 데이터 로드 시도
        Object player = GameAccess.getLocalPlayer();
        if (player != null) {
            DataAttachments.load(player, "examplemod_player.json");
            PlayerExtraData data = DataAttachments.get(player, PlayerExtraData.TYPE);
            Pulse.log(MOD_ID, "Loaded player data: " + data);
        }

        // 월드 로드 시 게임 상태 출력
        if (ExampleConfig.debugMode) {
            logGameStatus();
        }
    }

    private void onWorldUnload(WorldUnloadEvent event) {
        Pulse.log(MOD_ID, "World unloaded");

        // 플레이어 데이터 저장
        Object player = GameAccess.getLocalPlayer();
        if (player != null) {
            DataAttachments.save(player, "examplemod_player.json");
            Pulse.log(MOD_ID, "Player data saved on world unload");
        }
    }

    private void onPlayerUpdate(PlayerUpdateEvent event) {
        // 플레이어 업데이트는 매우 빈번하므로 로그 생략
        // 필요시 여기서 플레이어 상태 모니터링 가능
    }

    private void onPlayerDamage(PlayerDamageEvent event) {
        float damage = event.getDamage();
        String type = event.getDamageType();

        if (ExampleConfig.debugMode) {
            Pulse.log(MOD_ID, String.format(
                    "Player taking %.1f damage (type: %s)", damage, type));
        }

        // 설정에 따른 데미지 감소
        if (ExampleConfig.damageReduction > 0) {
            float reducedDamage = damage * (1.0f - ExampleConfig.damageReduction);
            event.setDamage(reducedDamage);
            if (ExampleConfig.debugMode) {
                Pulse.log(MOD_ID, String.format(
                        "Damage reduced: %.1f -> %.1f", damage, reducedDamage));
            }
        }

        // 화염 면역 설정
        if (ExampleConfig.fireImmunity && "fire".equals(type)) {
            event.cancel();
            Pulse.log(MOD_ID, "Fire damage blocked!");
        }

        // 사망 시 데이터 업데이트
        if (!event.isCancelled() && damage >= GameAccess.getPlayerHealth()) {
            Object player = GameAccess.getLocalPlayer();
            if (player != null) {
                PlayerExtraData data = DataAttachments.get(player, PlayerExtraData.TYPE);
                data.addDeath();
            }
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    private void logGameStatus() {
        StringBuilder sb = new StringBuilder();
        sb.append("\n");
        sb.append("═══════════════════════════════════════\n");
        sb.append("       EXAMPLE MOD - GAME STATUS       \n");
        sb.append("═══════════════════════════════════════\n");

        // 월드 정보
        sb.append("World: ").append(GameAccess.isWorldLoaded() ? GameAccess.getWorldName() : "Not loaded").append("\n");

        // 시간 정보
        sb.append(String.format("Time: Day %d, %02d:%02d (%s)\n",
                GameAccess.getGameDay(),
                GameAccess.getGameHour(),
                GameAccess.getGameMinute(),
                GameAccess.isNight() ? "Night" : "Day"));

        // 플레이어 정보
        Object player = GameAccess.getLocalPlayer();
        if (player != null) {
            sb.append(String.format("Player: %.1f HP at (%.0f, %.0f, %.0f)\n",
                    GameAccess.getPlayerHealth(),
                    GameAccess.getPlayerX(),
                    GameAccess.getPlayerY(),
                    GameAccess.getPlayerZ()));
            sb.append("Status: ").append(GameAccess.isPlayerAlive() ? "Alive" : "Dead").append("\n");

            // 커스텀 데이터
            PlayerExtraData data = DataAttachments.get(player, PlayerExtraData.TYPE);
            sb.append(String.format("Stats: %d kills, %d deaths, %s played\n",
                    data.getKillCount(), data.getDeathCount(), data.getPlayTimeFormatted()));
        } else {
            sb.append("Player: Not spawned\n");
        }

        // 게임 상태
        sb.append("Mode: ").append(GameAccess.isSinglePlayer() ? "Singleplayer" : "Multiplayer").append("\n");
        sb.append("Paused: ").append(GameAccess.isPaused() ? "Yes" : "No").append("\n");

        sb.append("═══════════════════════════════════════");

        Pulse.log(MOD_ID, sb.toString());
    }

    // ─────────────────────────────────────────────────────────────
    // 라이프사이클
    // ─────────────────────────────────────────────────────────────

    @Override
    public void onWorldLoad() {
        // PulseMod 인터페이스의 월드 로드 콜백
        Pulse.log(MOD_ID, "PulseMod.onWorldLoad() called");
    }

    @Override
    public void onWorldUnload() {
        // PulseMod 인터페이스의 월드 언로드 콜백
        Pulse.log(MOD_ID, "PulseMod.onWorldUnload() called");
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Example Mod unloading...");

        // 설정 저장
        ConfigManager.save(ExampleConfig.class);

        // 플레이어 데이터 저장
        Object player = GameAccess.getLocalPlayer();
        if (player != null) {
            DataAttachments.save(player, "examplemod_player.json");
        }

        Pulse.log(MOD_ID, "Example Mod unloaded");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\example-mod\src\main\java\com\example\examplemod\PlayerExtraData.java =====

package com.example.examplemod;

import com.pulse.attachment.AttachmentType;

/**
 * 플레이어에 첨부할 커스텀 데이터 예제.
 * 
 * DataAttachments API를 사용하여 게임 객체에 붙일 수 있습니다.
 */
public class PlayerExtraData {

    /**
     * 커스텀 데이터 첨부 타입 정의.
     * - persistent(): JSON으로 저장됨
     * - copyOnDeath(): 사망 시 새 플레이어에 복사됨
     */
    public static final AttachmentType<PlayerExtraData> TYPE = AttachmentType
            .builder("examplemod", "player_extra", PlayerExtraData::new)
            .persistent()
            .copyOnDeath()
            .build();

    // ─────────────────────────────────────────────────────────────
    // 데이터 필드
    // ─────────────────────────────────────────────────────────────

    private int killCount = 0;
    private int deathCount = 0;
    private long playTime = 0; // 틱 단위
    private String lastLocation = "";
    private boolean hasCompletedTutorial = false;

    // ─────────────────────────────────────────────────────────────
    // Getters & Setters
    // ─────────────────────────────────────────────────────────────

    public int getKillCount() {
        return killCount;
    }

    public void addKill() {
        this.killCount++;
    }

    public int getDeathCount() {
        return deathCount;
    }

    public void addDeath() {
        this.deathCount++;
    }

    public long getPlayTime() {
        return playTime;
    }

    public void incrementPlayTime() {
        this.playTime++;
    }

    public String getPlayTimeFormatted() {
        long seconds = playTime / 60;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        return String.format("%02d:%02d:%02d", hours, minutes % 60, seconds % 60);
    }

    public String getLastLocation() {
        return lastLocation;
    }

    public void setLastLocation(String lastLocation) {
        this.lastLocation = lastLocation;
    }

    public boolean hasCompletedTutorial() {
        return hasCompletedTutorial;
    }

    public void setCompletedTutorial(boolean completed) {
        this.hasCompletedTutorial = completed;
    }

    @Override
    public String toString() {
        return String.format("PlayerExtraData{kills=%d, deaths=%d, playTime=%s}",
                killCount, deathCount, getPlayTimeFormatted());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\example-mod\src\main\resources\pulse.mod.json =====

{
  "id": "examplemod",
  "name": "Example Mod",
  "version": "1.0.0",
  "author": "Pulse Team",
  "description": "An example mod demonstrating Pulse API usage",
  "entrypoint": "com.example.examplemod.ExampleMod",
  "dependencies": [
    {
      "id": "Pulse",
      "version": ">=1.0.0"
    }
  ]
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\build.gradle =====

plugins {
    id 'java'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'com.fuse'
version = '0.3.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // Pulse API dependency
    compileOnly project(':pulse-api')
    
    // Pulse Core dependency (required for PulseServiceLocator)
    compileOnly project(':Pulse')
    
    // PZ stubs (optional, graceful handling when missing)
    compileOnly fileTree(dir: '../Pulse/libs', include: ['pz-stubs.jar'])
}

jar {
    manifest {
        attributes(
            'Implementation-Title': 'Fuse',
            'Implementation-Version': version
        )
    }
}

shadowJar {
    archiveBaseName.set('Fuse')
    archiveClassifier.set('')
    archiveVersion.set(version)
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\settings.gradle =====

rootProject.name = 'Fuse'



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\cache\ZombieStateCache.java =====

package com.fuse.cache;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Zombie State Cache for Fuse Optimization.
 * 
 * IsoZombie 상태를 캐싱하여 throttle 정책에 활용합니다.
 * - FakeDead, Eating 상태 좀비는 더 공격적으로 throttle
 * - 플레이어 근처 좀비는 throttle 면제
 * 
 * @since Fuse 0.3.1
 */
public class ZombieStateCache {

    private static final ZombieStateCache INSTANCE = new ZombieStateCache();
    private static final int MAX_CACHE_SIZE = 10000;

    /** 좀비 ID → 상태 캐시 */
    private final ConcurrentHashMap<Integer, ZombieState> stateCache = new ConcurrentHashMap<>();

    /** 통계 */
    private final AtomicInteger cacheHits = new AtomicInteger(0);
    private final AtomicInteger cacheMisses = new AtomicInteger(0);

    public static ZombieStateCache getInstance() {
        return INSTANCE;
    }

    /**
     * 좀비 상태 업데이트
     */
    public void updateState(int zombieId, ZombieState state) {
        if (stateCache.size() > MAX_CACHE_SIZE) {
            evictOldEntries();
        }
        stateCache.put(zombieId, state);
    }

    /**
     * 좀비 상태 조회
     */
    public ZombieState getState(int zombieId) {
        ZombieState state = stateCache.get(zombieId);
        if (state != null) {
            cacheHits.incrementAndGet();
            return state;
        }
        cacheMisses.incrementAndGet();
        return ZombieState.UNKNOWN;
    }

    /**
     * 좀비 제거 (사망 시)
     */
    public void removeZombie(int zombieId) {
        stateCache.remove(zombieId);
    }

    /**
     * 캐시 정리
     */
    private void evictOldEntries() {
        // 절반 제거 (LRU 대신 간단한 랜덤 제거)
        int toRemove = stateCache.size() / 2;
        stateCache.keySet().stream()
                .limit(toRemove)
                .forEach(stateCache::remove);
    }

    /**
     * 캐시 통계
     */
    public float getHitRatio() {
        int total = cacheHits.get() + cacheMisses.get();
        return total == 0 ? 0f : (float) cacheHits.get() / total;
    }

    public void reset() {
        stateCache.clear();
        cacheHits.set(0);
        cacheMisses.set(0);
    }

    public int getCacheSize() {
        return stateCache.size();
    }

    // --- Zombie State Enum ---

    public enum ZombieState {
        UNKNOWN(1.0f), // 기본 - 일반 throttle
        IDLE(1.5f), // 대기 중 - 더 공격적 throttle
        FAKE_DEAD(2.0f), // 누워있음 - 매우 공격적 throttle
        EATING(1.8f), // 시체 섭취 - 공격적 throttle
        ALERT(0.5f), // 경계 상태 - 덜 throttle
        CHASING(0.0f), // 추격 중 - throttle 면제
        ATTACKING(0.0f); // 공격 중 - throttle 면제

        /** Throttle 배수 (높을수록 더 공격적으로 throttle) */
        public final float throttleMultiplier;

        ZombieState(float throttleMultiplier) {
            this.throttleMultiplier = throttleMultiplier;
        }

        /**
         * 이 상태에서 throttle 가능 여부
         */
        public boolean canThrottle() {
            return throttleMultiplier > 0.0f;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\config\FuseConfig.java =====

package com.fuse.config;

import com.pulse.api.log.PulseLogger;

/**
 * Fuse Configuration.
 * 
 * v1.1: Conservative Preset 기본값 + 신규 파라미터
 * 
 * @since Fuse 0.3.0
 * @since Fuse 1.1.0 - Conservative Preset
 */
public class FuseConfig {

    private static final FuseConfig INSTANCE = new FuseConfig();
    /** Config file path (reserved for future file-based config loading) */
    @SuppressWarnings("unused")
    private static final String CONFIG_FILE = "Fuse/fuse.json";

    // ========================================
    // Throttling Settings
    // ========================================

    /** Throttling master switch */
    private boolean enableThrottling = true;

    /** Step-level throttling */
    private boolean enableStepThrottling = true;

    /** Throttle intensity (Conservative: 0.5) */
    private float throttleIntensity = 0.5f;

    /** Distance bands (squared) */
    private int nearDistSq = 400; // 20² tiles
    private int mediumDistSq = 1600; // 40² tiles
    private int farDistSq = 6400; // 80² tiles

    // ========================================
    // Governor Settings (v1.1)
    // ========================================

    /** Tick budget for 60fps */
    private double tickBudgetMs = 16.67;

    /** Force cutoff threshold for 30fps */
    private double forceCutoffMs = 33.33;

    /** Batch check size (zombies per time check) */
    private int batchCheckSize = 20;

    // ========================================
    // Panic Protocol Settings (v1.1)
    // ========================================

    /** Spike threshold (ms) */
    private long spikeThresholdMs = 100;

    /** Sliding window size (ms) */
    private long windowSizeMs = 5000;

    /** Spike count threshold for panic entry */
    private int spikeCountThreshold = 2;

    /** Ticks per recovery phase */
    private int recoveryPhaseTicks = 30;

    // ========================================
    // Hysteresis Settings (v1.1)
    // ========================================

    /** Entry: 1s max threshold */
    private double entryMax1sMs = 33.33;

    /** Entry: 5s avg threshold */
    private double entryAvg5sMs = 20.0;

    /** Exit: 5s avg threshold */
    private double exitAvg5sMs = 12.0;

    /** Exit: stability ticks required */
    private int exitStabilityTicks = 300;

    // ========================================
    // Guard Settings (v1.1)
    // ========================================

    /** Vehicle guard: entry speed */
    private float vehicleSpeedEntryKmh = 30f;

    /** Vehicle guard: exit speed */
    private float vehicleSpeedExitKmh = 20f;

    /** Streaming guard: player speed threshold */
    private float playerSpeedThreshold = 15f;

    /** Streaming guard: frame drop threshold (ms) */
    private long frameDropThresholdMs = 50;

    // ========================================
    // Failsoft Settings (v1.1)
    // ========================================

    /** Max consecutive errors before intervention disabled */
    private int maxConsecutiveErrors = 3;

    // ========================================
    // Singleton
    // ========================================

    public static FuseConfig getInstance() {
        return INSTANCE;
    }

    private FuseConfig() {
        load();
    }

    public void load() {
        // 간단한 기본값 사용 (파일 로드는 추후 구현)
        PulseLogger.info("Fuse", "Config loaded (v1.1 Conservative Preset)");
    }

    public void save() {
        // 추후 구현
    }

    // ========================================
    // Throttling Getters
    // ========================================

    public boolean isThrottlingEnabled() {
        return enableThrottling;
    }

    public boolean isStepThrottlingEnabled() {
        return enableStepThrottling;
    }

    public float getThrottleIntensity() {
        return throttleIntensity;
    }

    public int getNearDistSq() {
        return nearDistSq;
    }

    public int getMediumDistSq() {
        return mediumDistSq;
    }

    public int getFarDistSq() {
        return farDistSq;
    }

    // ========================================
    // Governor Getters (v1.1)
    // ========================================

    public double getTickBudgetMs() {
        return tickBudgetMs;
    }

    public double getForceCutoffMs() {
        return forceCutoffMs;
    }

    public int getBatchCheckSize() {
        return batchCheckSize;
    }

    // ========================================
    // Panic Getters (v1.1)
    // ========================================

    public long getSpikeThresholdMs() {
        return spikeThresholdMs;
    }

    public long getWindowSizeMs() {
        return windowSizeMs;
    }

    public int getSpikeCountThreshold() {
        return spikeCountThreshold;
    }

    public int getRecoveryPhaseTicks() {
        return recoveryPhaseTicks;
    }

    // ========================================
    // Hysteresis Getters (v1.1)
    // ========================================

    public double getEntryMax1sMs() {
        return entryMax1sMs;
    }

    public double getEntryAvg5sMs() {
        return entryAvg5sMs;
    }

    public double getExitAvg5sMs() {
        return exitAvg5sMs;
    }

    public int getExitStabilityTicks() {
        return exitStabilityTicks;
    }

    // ========================================
    // Guard Getters (v1.1)
    // ========================================

    public float getVehicleSpeedEntryKmh() {
        return vehicleSpeedEntryKmh;
    }

    public float getVehicleSpeedExitKmh() {
        return vehicleSpeedExitKmh;
    }

    public float getPlayerSpeedThreshold() {
        return playerSpeedThreshold;
    }

    public long getFrameDropThresholdMs() {
        return frameDropThresholdMs;
    }

    // ========================================
    // Failsoft Getters (v1.1)
    // ========================================

    public int getMaxConsecutiveErrors() {
        return maxConsecutiveErrors;
    }

    // ========================================
    // Setters
    // ========================================

    public void setThrottlingEnabled(boolean enabled) {
        this.enableThrottling = enabled;
        PulseLogger.info("Fuse", "Throttling: " + (enabled ? "ON" : "OFF"));
    }

    public void setThrottleIntensity(float intensity) {
        this.throttleIntensity = Math.max(0f, Math.min(1f, intensity));
        PulseLogger.info("Fuse", "Throttle intensity: " + this.throttleIntensity);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\FuseMod.java =====

package com.fuse;

import com.fuse.config.FuseConfig;
import com.fuse.governor.RollingTickStats;
import com.fuse.governor.SpikePanicProtocol;
import com.fuse.governor.TickBudgetGovernor;
import com.fuse.guard.FailsoftController;
import com.fuse.guard.StreamingGuard;
import com.fuse.guard.VehicleGuard;
import com.fuse.hook.FuseHookAdapter;
import com.fuse.optimizer.FuseOptimizer;
import com.fuse.telemetry.ReasonStats;
import com.fuse.telemetry.TelemetryReason;
import com.fuse.throttle.FuseStepPolicy;
import com.fuse.throttle.FuseThrottleController;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.ZombieHook;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameTickEndEvent;
import com.pulse.mod.PulseMod;

import java.util.Map;

/**
 * Fuse - Performance Optimizer for Project Zomboid
 * 
 * v1.1: 안정성과 예측 가능성 확보
 * - Tick Budget Governor (컷오프 스위치)
 * - Spike Panic Protocol (슬라이딩 윈도우 + 점진적 복구)
 * - Window-based Hysteresis
 * - Vehicle/Streaming Guards
 * - Failsoft Controller
 * 
 * @since Fuse 0.3.0
 * @since Fuse 1.1.0 - Stabilization Release
 */
public class FuseMod implements PulseMod {

    public static final String MOD_ID = "Fuse";
    public static final String VERSION = "1.1.0";

    private static FuseMod instance;

    // --- Core Components ---
    private FuseOptimizer optimizer;
    private FuseHookAdapter hookAdapter;
    private FuseThrottleController throttleController;
    private FuseStepPolicy stepPolicy;

    // --- v1.1 Stabilization Components ---
    private TickBudgetGovernor governor;
    private SpikePanicProtocol panicProtocol;
    private RollingTickStats stats;
    private VehicleGuard vehicleGuard;
    private StreamingGuard streamingGuard;
    private FailsoftController failsoftController;
    private ReasonStats reasonStats;

    // --- 주기적 로깅 ---
    private long tickCounter = 0;
    private static final long LOG_INTERVAL_TICKS = 3600; // 60초 (60fps 기준)

    private boolean initialized = false;

    public static FuseMod getInstance() {
        return instance;
    }

    @Override
    public void onInitialize() {
        init();
    }

    @Override
    public void onUnload() {
        shutdown();
    }

    public void init() {
        instance = this;
        System.out.println();
        System.out.println("╔═══════════════════════════════════════════════╗");
        System.out.println("║     Fuse v" + VERSION + " - Stabilization Release     ║");
        System.out.println("║     \"Always Safe, Always Predictable\"         ║");
        System.out.println("╚═══════════════════════════════════════════════╝");

        // Config 초기화
        FuseConfig config = FuseConfig.getInstance();

        // ========================================
        // Phase 1: v1.1 Core Safety Components
        // ========================================

        try {
            // Rolling Tick Stats (윈도우 통계)
            stats = new RollingTickStats();
            PulseLogger.info("Fuse", "RollingTickStats initialized");

            // Tick Budget Governor (컷오프 스위치)
            governor = new TickBudgetGovernor();
            governor.setForceCutoffMs(config.getForceCutoffMs());
            governor.setBatchCheckSize(config.getBatchCheckSize());

            // Spike Panic Protocol (슬라이딩 윈도우 + 점진적 복구)
            panicProtocol = new SpikePanicProtocol();

            // Reason Stats (개입 이유 통계)
            reasonStats = new ReasonStats();

            PulseLogger.info("Fuse", "Core safety components initialized");
        } catch (Exception e) {
            PulseLogger.error("Fuse", "Failed to initialize safety components: " + e.getMessage(), e);
        }

        // ========================================
        // Phase 2: Guards
        // ========================================

        try {
            // Vehicle Guard
            vehicleGuard = new VehicleGuard();
            vehicleGuard.setSpeedEntryKmh(config.getVehicleSpeedEntryKmh());
            vehicleGuard.setSpeedExitKmh(config.getVehicleSpeedExitKmh());

            // Streaming Guard
            streamingGuard = new StreamingGuard();

            // Failsoft Controller
            failsoftController = new FailsoftController();
            failsoftController.setMaxConsecutiveErrors(config.getMaxConsecutiveErrors());

            PulseLogger.info("Fuse", "Guards initialized");
        } catch (Exception e) {
            PulseLogger.error("Fuse", "Failed to initialize guards: " + e.getMessage(), e);
        }

        // ========================================
        // Phase 3: Hook Adapter 등록
        // ========================================

        try {
            hookAdapter = new FuseHookAdapter();
            ZombieHook.setCallback(hookAdapter);
            ZombieHook.profilingEnabled = true;
            PulseLogger.info("Fuse", "ZombieHook callback registered");
        } catch (Exception e) {
            PulseLogger.error("Fuse", "Failed to register ZombieHook: " + e.getMessage(), e);
        }

        // ========================================
        // Phase 4: Throttle Controller with v1.1 Integration
        // ========================================

        try {
            throttleController = new FuseThrottleController();

            // v1.1 컴포넌트 연동
            throttleController.setGovernor(governor);
            throttleController.setPanicProtocol(panicProtocol);
            throttleController.setStats(stats);
            throttleController.setGuards(vehicleGuard, streamingGuard);
            throttleController.setReasonStats(reasonStats);

            ZombieHook.setThrottlePolicy(throttleController);
            PulseLogger.info("Fuse", "ThrottleController registered (v1.1 with hysteresis)");
        } catch (Exception e) {
            PulseLogger.error("Fuse", "Failed to register ThrottlePolicy: " + e.getMessage(), e);
        }

        // ========================================
        // Phase 5: Step-level Throttle Policy
        // ========================================

        try {
            stepPolicy = new FuseStepPolicy();
            com.pulse.api.profiler.ZombieStepHook.setStepPolicy(stepPolicy);
            PulseLogger.info("Fuse", "StepPolicy registered");
        } catch (Exception e) {
            PulseLogger.error("Fuse", "Failed to register StepPolicy: " + e.getMessage(), e);
        }

        // ========================================
        // Phase 6: Optimizer
        // ========================================

        optimizer = FuseOptimizer.getInstance();
        optimizer.enable();
        optimizer.setAutoOptimize(false);

        // ========================================
        // Phase 7: Tick Event Subscription (로그 출력용)
        // ========================================
        try {
            EventBus.subscribe(GameTickEndEvent.class, event -> {
                onTick();
            }, MOD_ID);
            PulseLogger.info("Fuse", "GameTickEndEvent subscription active");
        } catch (Exception e) {
            PulseLogger.warn("Fuse", "Failed to subscribe to GameTickEndEvent: " + e.getMessage());
        }

        initialized = true;
        PulseLogger.info("Fuse", "Initialization complete (v1.1 Stabilization)");
        PulseLogger.info("Fuse", "Use /fuse status to view v1.1 component status");
    }

    /**
     * 게임 틱에서 호출
     */
    public void onTick() {
        if (!initialized) {
            return;
        }

        // Failsoft 체크 - 개입 비활성화 시 바닐라 동작
        if (failsoftController != null && failsoftController.isInterventionDisabled()) {
            return;
        }

        try {
            // Governor: 틱 시작
            if (governor != null) {
                governor.beginTick();
            }

            // 옵티마이저 업데이트
            optimizer.update();

            // Governor: 틱 종료
            if (governor != null) {
                governor.endTick();
                double lastTickMs = governor.getLastTickMs();

                // 통계 기록
                if (stats != null) {
                    stats.record(lastTickMs);
                }

                // Panic Protocol 기록
                if (panicProtocol != null) {
                    panicProtocol.recordTickDuration((long) lastTickMs);
                }

                // Streaming Guard 기록
                if (streamingGuard != null) {
                    streamingGuard.recordTickDuration((long) lastTickMs);
                }
            }

            if (failsoftController != null) {
                failsoftController.recordSuccess();
            }

            // 주기적 상태 로깅 (60초마다)
            tickCounter++;
            if (tickCounter % LOG_INTERVAL_TICKS == 0) {
                logStatusSummary();
            }
        } catch (Throwable t) {
            // Failsoft 오류 기록
            if (failsoftController != null) {
                failsoftController.recordError(t);
            } else {
                PulseLogger.error("Fuse", "onTick error: " + t.getMessage(), t);
            }
        }
    }

    /** 자동 최적화 토글 */
    public void toggleAutoOptimize() {
        optimizer.setAutoOptimize(!optimizer.isAutoOptimize());
    }

    /** 현재 타겟에 수동 최적화 적용 */
    public void applyCurrentTarget() {
        var target = optimizer.getCurrentTarget();
        if (target != null) {
            optimizer.applyOptimization(target);
        } else {
            PulseLogger.info("Fuse", "No optimization target available");
        }
    }

    /** 상태 출력 (v1.1 확장) */
    public void printStatus() {
        System.out.println();
        System.out.println("╔═══════════════════════════════════════════════╗");
        System.out.println("║         FUSE v1.1 STABILIZATION STATUS        ║");
        System.out.println("╚═══════════════════════════════════════════════╝");

        // Failsoft 상태
        if (failsoftController != null && failsoftController.isInterventionDisabled()) {
            System.out.println();
            System.out.println("  ⚠️  FAILSOFT: Intervention DISABLED");
            failsoftController.printStatus();
            return;
        }

        // Panic 상태
        if (panicProtocol != null) {
            System.out.println();
            System.out.println("  Panic State: " + panicProtocol.getState());
            System.out.println("  Panic Multiplier: " + panicProtocol.getThrottleMultiplier());
        }

        // Governor 상태
        if (governor != null) {
            System.out.println();
            governor.printStatus();
        }

        // Guards 상태
        System.out.println();
        System.out.println("  Guards:");
        if (vehicleGuard != null) {
            System.out.println("    Vehicle: " + (vehicleGuard.isPassiveMode() ? "PASSIVE" : "normal"));
        }
        if (streamingGuard != null) {
            System.out.println("    Streaming: " + (streamingGuard.isYieldMode() ? "YIELD" : "normal"));
        }

        // Throttle Controller 상태
        if (throttleController != null) {
            System.out.println();
            throttleController.printStatus();
        }

        // Optimizer 상태
        var status = optimizer.getStatus();
        System.out.println();
        System.out.println("  Optimizer:");
        System.out.println("    Enabled:       " + status.get("enabled"));
        System.out.println("    Auto-Optimize: " + status.get("auto_optimize"));
        System.out.println("    Applied:       " + status.get("optimizations_applied"));

        // v1.1: Reason 통계
        if (reasonStats != null && reasonStats.getTotalCount() > 0) {
            System.out.println();
            System.out.println("  Intervention Reasons (Top 3):");
            var topReasons = reasonStats.getTop(3);
            int rank = 1;
            for (Map.Entry<TelemetryReason, Long> entry : topReasons) {
                System.out.println("    " + rank + ". " + entry.getKey().name() + ": " + entry.getValue());
                rank++;
            }
            System.out.println("    Total: " + reasonStats.getTotalCount());
        }

        System.out.println();
    }

    /**
     * 주기적 상태 요약 로깅 (콘솔 확인용).
     * 60초마다 자동 출력.
     */
    private void logStatusSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("\n========== [Fuse v1.1] 60s Status Summary ==========\n");

        // Tick 카운터
        sb.append("  Ticks: ").append(tickCounter).append("\n");

        // Failsoft 상태
        if (failsoftController != null && failsoftController.isInterventionDisabled()) {
            sb.append("  ⚠️  FAILSOFT: Intervention DISABLED\n");
        }

        // Panic 상태
        if (panicProtocol != null) {
            sb.append("  Panic: ").append(panicProtocol.getState())
                    .append(" (multiplier=").append(String.format("%.2f", panicProtocol.getThrottleMultiplier()))
                    .append(")\n");
        }

        // Governor 상태
        if (governor != null) {
            sb.append("  Governor: cutoffs=").append(governor.getTotalCutoffs())
                    .append(", last=").append(String.format("%.2f", governor.getLastTickMs())).append("ms\n");
        }

        // Guards 상태
        sb.append("  Guards: vehicle=")
                .append(vehicleGuard != null && vehicleGuard.isPassiveMode() ? "PASSIVE" : "normal")
                .append(", streaming=")
                .append(streamingGuard != null && streamingGuard.isYieldMode() ? "YIELD" : "normal").append("\n");

        // v1.1: Reason 통계
        if (reasonStats != null && reasonStats.getTotalCount() > 0) {
            sb.append("  Intervention Reasons (Top 3):\n");
            var topReasons = reasonStats.getTop(3);
            int rank = 1;
            for (Map.Entry<TelemetryReason, Long> entry : topReasons) {
                sb.append("    ").append(rank).append(". ").append(entry.getKey().name())
                        .append(": ").append(entry.getValue()).append("\n");
                rank++;
            }
            sb.append("    Total: ").append(reasonStats.getTotalCount()).append("\n");
        } else {
            sb.append("  Intervention Reasons: (none yet)\n");
        }

        sb.append("=====================================================\n");

        PulseLogger.info("Fuse", sb.toString());
    }

    // --- Getters ---

    public FuseOptimizer getOptimizer() {
        return optimizer;
    }

    public FuseThrottleController getThrottleController() {
        return throttleController;
    }

    public TickBudgetGovernor getGovernor() {
        return governor;
    }

    public SpikePanicProtocol getPanicProtocol() {
        return panicProtocol;
    }

    public FailsoftController getFailsoftController() {
        return failsoftController;
    }

    public ReasonStats getReasonStats() {
        return reasonStats;
    }

    public void shutdown() {
        PulseLogger.info("Fuse", "Shutting down...");

        // Cleanup hook callback
        try {
            ZombieHook.setCallback(null);
            ZombieHook.profilingEnabled = false;
        } catch (Exception ignored) {
        }

        if (optimizer != null) {
            optimizer.disable();
        }

        initialized = false;
        PulseLogger.info("Fuse", "Shutdown complete");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\governor\RollingTickStats.java =====

package com.fuse.governor;

/**
 * Rolling Window Statistics for Tick Timing.
 * 
 * 히스테리시스 기반 throttle 진입/복구 조건 판단에 사용됩니다.
 * 1초 윈도우: max 값으로 스파이크 감지
 * 5초 윈도우: avg 값으로 안정성 판단
 * 
 * @since Fuse 1.1
 */
public class RollingTickStats {

    private static final int WINDOW_1S_TICKS = 60; // 60fps 기준 1초
    private static final int WINDOW_5S_TICKS = 300; // 60fps 기준 5초

    /** 원형 버퍼 - 5초 윈도우 */
    private final double[] tickDurations;
    private int writeIndex = 0;
    private int sampleCount = 0;

    public RollingTickStats() {
        this.tickDurations = new double[WINDOW_5S_TICKS];
    }

    /**
     * 틱 시간 기록.
     * 
     * @param tickMs 이번 틱의 소요 시간 (ms)
     */
    public void record(double tickMs) {
        tickDurations[writeIndex] = tickMs;
        writeIndex = (writeIndex + 1) % WINDOW_5S_TICKS;
        if (sampleCount < WINDOW_5S_TICKS) {
            sampleCount++;
        }
    }

    /**
     * 최근 1초(60틱) 내 최대값 반환.
     * 스파이크 감지에 사용.
     */
    public double getLast1sMaxMs() {
        if (sampleCount == 0) {
            return 0.0;
        }

        double max = 0.0;
        int count = Math.min(sampleCount, WINDOW_1S_TICKS);

        for (int i = 0; i < count; i++) {
            int idx = (writeIndex - 1 - i + WINDOW_5S_TICKS) % WINDOW_5S_TICKS;
            if (tickDurations[idx] > max) {
                max = tickDurations[idx];
            }
        }
        return max;
    }

    /**
     * 최근 5초(300틱) 평균값 반환.
     * 안정성 판단에 사용.
     */
    public double getLast5sAvgMs() {
        if (sampleCount == 0) {
            return 0.0;
        }

        double sum = 0.0;
        int count = sampleCount; // 전체 샘플 사용

        for (int i = 0; i < count; i++) {
            int idx = (writeIndex - 1 - i + WINDOW_5S_TICKS) % WINDOW_5S_TICKS;
            sum += tickDurations[idx];
        }
        return sum / count;
    }

    /**
     * 통계 리셋.
     */
    public void reset() {
        writeIndex = 0;
        sampleCount = 0;
        for (int i = 0; i < tickDurations.length; i++) {
            tickDurations[i] = 0.0;
        }
    }

    /**
     * 현재 샘플 수 반환.
     */
    public int getSampleCount() {
        return sampleCount;
    }

    /**
     * 충분한 데이터가 수집되었는지 확인.
     * 최소 1초(60틱) 이상의 데이터가 있어야 유의미한 통계.
     */
    public boolean hasEnoughData() {
        return sampleCount >= WINDOW_1S_TICKS;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\governor\SpikePanicProtocol.java =====

package com.fuse.governor;

import com.fuse.telemetry.TelemetryReason;
import com.pulse.api.log.PulseLogger;

/**
 * Spike Panic Protocol.
 * 
 * 대규모 스파이크 발생 시 연쇄 프리즈를 차단하는 비상 프로토콜입니다.
 * 슬라이딩 윈도우 기반으로 스파이크를 감지하고,
 * RECOVERING 상태에서 점진적으로 복구합니다.
 * 
 * @since Fuse 1.1
 */
public class SpikePanicProtocol {

    private static final String LOG = "Fuse";

    // --- 설정값 (FuseConfig에서 로드 가능) ---
    private long spikeThresholdMs = 100;
    private long windowSizeMs = 5000; // 5초 윈도우
    private int spikeCountThreshold = 2;
    private int recoveryPhaseTicks = 30; // 각 복구 단계 30틱

    // --- 상태 ---
    public enum State {
        NORMAL,
        PANIC,
        RECOVERING
    }

    private State state = State.NORMAL;

    // 점진적 복구: 0.5 → 0.75 → 1.0
    private int recoveryPhase = 0; // 0, 1, 2 (3이면 NORMAL)
    private int recoveryTickCounter = 0;
    private int normalTickCounter = 0;

    // 슬라이딩 윈도우 카운터
    private final SlidingWindowCounter spikeCounter;

    // 텔레메트리
    private TelemetryReason lastReason = null;

    public SpikePanicProtocol() {
        this.spikeCounter = new SlidingWindowCounter(windowSizeMs);
        PulseLogger.info(LOG, "SpikePanicProtocol initialized (sliding window: "
                + windowSizeMs + "ms, threshold: " + spikeCountThreshold + " spikes)");
    }

    /**
     * 틱 시간 기록 및 상태 전이.
     * 
     * @param durationMs 이번 틱의 소요 시간 (ms)
     */
    public void recordTickDuration(long durationMs) {
        // 스파이크 감지
        if (durationMs >= spikeThresholdMs) {
            spikeCounter.recordEvent();
        }

        // 상태 머신
        switch (state) {
            case NORMAL:
                handleNormalState();
                break;
            case PANIC:
                handlePanicState(durationMs);
                break;
            case RECOVERING:
                handleRecoveringState(durationMs);
                break;
        }
    }

    private void handleNormalState() {
        int spikeCount = spikeCounter.getCountInWindow();
        if (spikeCount >= spikeCountThreshold) {
            enterPanic();
        }
    }

    private void handlePanicState(long durationMs) {
        // PANIC 상태에서는 AI 개입이 극도로 축소되므로 틱이 정상화됨
        // 일정 시간 후 RECOVERING으로 전이
        if (durationMs < spikeThresholdMs) {
            normalTickCounter++;
            if (normalTickCounter >= recoveryPhaseTicks) {
                enterRecovering();
            }
        } else {
            normalTickCounter = 0; // 스파이크 발생 시 카운터 리셋
        }
    }

    private void handleRecoveringState(long durationMs) {
        if (durationMs >= spikeThresholdMs) {
            // 복구 중 스파이크 발생 → 다시 PANIC
            enterPanic();
            return;
        }

        recoveryTickCounter++;
        if (recoveryTickCounter >= recoveryPhaseTicks) {
            recoveryPhase++;
            recoveryTickCounter = 0;

            if (recoveryPhase >= 3) {
                enterNormal();
            } else {
                lastReason = TelemetryReason.RECOVERING_GRADUAL;
                PulseLogger.debug(LOG, "SpikePanicProtocol: Recovery phase "
                        + recoveryPhase + "/3 (multiplier: " + getThrottleMultiplier() + ")");
            }
        }
    }

    private void enterPanic() {
        state = State.PANIC;
        recoveryPhase = 0;
        recoveryTickCounter = 0;
        normalTickCounter = 0;
        lastReason = TelemetryReason.PANIC_WINDOW_SPIKES;
        PulseLogger.warn(LOG, "⚠️ PANIC mode entered! "
                + spikeCounter.getCountInWindow() + " spikes in " + windowSizeMs + "ms window");
    }

    private void enterRecovering() {
        state = State.RECOVERING;
        recoveryPhase = 0;
        recoveryTickCounter = 0;
        lastReason = TelemetryReason.RECOVERING_GRADUAL;
        PulseLogger.info(LOG, "SpikePanicProtocol: Entering RECOVERING state");
    }

    private void enterNormal() {
        state = State.NORMAL;
        recoveryPhase = 0;
        recoveryTickCounter = 0;
        normalTickCounter = 0;
        lastReason = null;
        PulseLogger.info(LOG, "SpikePanicProtocol: Recovered to NORMAL state");
    }

    /**
     * 현재 상태 반환.
     */
    public State getState() {
        return state;
    }

    /**
     * Throttle 배수 반환.
     * PANIC: 0.1 (극도 축소)
     * RECOVERING: 0.5 → 0.75 → 1.0 (점진적)
     * NORMAL: 1.0
     */
    public float getThrottleMultiplier() {
        return switch (state) {
            case PANIC -> 0.1f;
            case RECOVERING -> 0.5f + (recoveryPhase * 0.25f); // 0.5, 0.75, 1.0
            case NORMAL -> 1.0f;
        };
    }

    /**
     * 마지막 텔레메트리 이유 반환.
     */
    public TelemetryReason getLastReason() {
        return lastReason;
    }

    /**
     * 상태 리셋 (디버깅/테스트용).
     */
    public void reset() {
        state = State.NORMAL;
        recoveryPhase = 0;
        recoveryTickCounter = 0;
        normalTickCounter = 0;
        spikeCounter.clear();
        lastReason = null;
    }

    // --- Inner Class: 슬라이딩 윈도우 카운터 ---

    /**
     * 슬라이딩 윈도우 기반 이벤트 카운터.
     */
    private static class SlidingWindowCounter {
        private final long windowMs;
        private final java.util.Deque<Long> timestamps = new java.util.ArrayDeque<>();

        SlidingWindowCounter(long windowMs) {
            this.windowMs = windowMs;
        }

        void recordEvent() {
            long now = System.currentTimeMillis();
            timestamps.addLast(now);
            cleanup(now);
        }

        int getCountInWindow() {
            cleanup(System.currentTimeMillis());
            return timestamps.size();
        }

        private void cleanup(long now) {
            long cutoff = now - windowMs;
            while (!timestamps.isEmpty() && timestamps.peekFirst() < cutoff) {
                timestamps.pollFirst();
            }
        }

        void clear() {
            timestamps.clear();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\governor\TickBudgetGovernor.java =====

package com.fuse.governor;

import com.fuse.telemetry.TelemetryReason;
import com.pulse.api.log.PulseLogger;

/**
 * Tick Budget Governor.
 * 
 * ZombieUpdate 계열 작업에 틱당 시간 상한을 부여합니다.
 * 컷오프 스위치 방식: 예산 초과 시 남은 작업은 다음 틱에서 자연스럽게 처리됩니다.
 * Batch Check로 System.nanoTime() 호출 비용을 최소화합니다.
 * 
 * @since Fuse 1.1
 */
public class TickBudgetGovernor {

    private static final String LOG = "Fuse";

    // --- 설정값 ---
    private double budgetMs = 16.67; // 60fps 유지선
    private double forceCutoffMs = 33.33; // 30fps 방어선
    private int batchCheckSize = 20; // N마리마다 시간 체크

    // --- 상태 ---
    private long tickStartNanos = -1;
    private int zombiesProcessedThisTick = 0;
    private double lastTickMs = 0.0;
    private boolean cutoffTriggered = false;

    // --- 통계 ---
    private long totalCutoffs = 0;
    private long totalTicks = 0;

    // 텔레메트리
    private TelemetryReason lastReason = null;

    public TickBudgetGovernor() {
        PulseLogger.info(LOG, "TickBudgetGovernor initialized (budget: "
                + budgetMs + "ms, cutoff: " + forceCutoffMs + "ms, batch: " + batchCheckSize + ")");
    }

    /**
     * 틱 시작 시 호출.
     */
    public void beginTick() {
        tickStartNanos = System.nanoTime();
        zombiesProcessedThisTick = 0;
        cutoffTriggered = false;
        lastReason = null;
    }

    /**
     * 틱 종료 시 호출.
     */
    public void endTick() {
        if (tickStartNanos > 0) {
            lastTickMs = (System.nanoTime() - tickStartNanos) / 1_000_000.0;
            totalTicks++;
        }
        tickStartNanos = -1;
    }

    /**
     * 컷오프 스위치 - 이번 틱 계속 처리 가능 여부.
     * 
     * Batch Check: batchCheckSize마다만 시간 체크하여 nanoTime() 호출 비용 최소화.
     * 
     * @return true면 계속 처리, false면 이번 틱 종료 (남은 작업은 다음 틱에서)
     */
    public boolean shouldContinueThisTick() {
        zombiesProcessedThisTick++;

        // Batch Check: N마리마다만 시간 체크
        if (zombiesProcessedThisTick % batchCheckSize != 0) {
            return !cutoffTriggered; // 이미 컷오프됐으면 false
        }

        // 시간 체크
        double elapsedMs = getElapsedMs();
        if (elapsedMs >= forceCutoffMs) {
            if (!cutoffTriggered) {
                cutoffTriggered = true;
                totalCutoffs++;
                lastReason = TelemetryReason.GOVERNOR_CUTOFF;
                if (totalCutoffs % 100 == 1) {
                    PulseLogger.debug(LOG, "Governor cutoff triggered at "
                            + String.format("%.2f", elapsedMs) + "ms (total: " + totalCutoffs + ")");
                }
            }
            return false;
        }

        return true;
    }

    /**
     * 현재 경과 시간 (ms).
     */
    public double getElapsedMs() {
        if (tickStartNanos < 0) {
            return 0.0;
        }
        return (System.nanoTime() - tickStartNanos) / 1_000_000.0;
    }

    /**
     * 마지막 틱 소요 시간 (ms).
     */
    public double getLastTickMs() {
        return lastTickMs;
    }

    /**
     * 이번 틱에서 처리된 좀비 수.
     */
    public int getZombiesProcessedThisTick() {
        return zombiesProcessedThisTick;
    }

    /**
     * 이번 틱에서 컷오프가 발생했는지.
     */
    public boolean wasCutoffTriggered() {
        return cutoffTriggered;
    }

    /**
     * 마지막 텔레메트리 이유.
     */
    public TelemetryReason getLastReason() {
        return lastReason;
    }

    // --- 통계 ---

    public long getTotalCutoffs() {
        return totalCutoffs;
    }

    public long getTotalTicks() {
        return totalTicks;
    }

    public double getCutoffRatio() {
        return totalTicks == 0 ? 0.0 : (double) totalCutoffs / totalTicks;
    }

    public void resetStats() {
        totalCutoffs = 0;
        totalTicks = 0;
    }

    // --- 설정 ---

    public void setBudgetMs(double budgetMs) {
        this.budgetMs = budgetMs;
    }

    public void setForceCutoffMs(double forceCutoffMs) {
        this.forceCutoffMs = forceCutoffMs;
    }

    public void setBatchCheckSize(int batchCheckSize) {
        this.batchCheckSize = Math.max(1, batchCheckSize);
    }

    public void printStatus() {
        PulseLogger.info(LOG, "Governor Status:");
        PulseLogger.info(LOG, "  Budget: " + budgetMs + "ms");
        PulseLogger.info(LOG, "  Force Cutoff: " + forceCutoffMs + "ms");
        PulseLogger.info(LOG, "  Batch Check Size: " + batchCheckSize);
        PulseLogger.info(LOG, "  Total Ticks: " + totalTicks);
        PulseLogger.info(LOG, "  Total Cutoffs: " + totalCutoffs + " ("
                + String.format("%.2f", getCutoffRatio() * 100) + "%)");
        PulseLogger.info(LOG, "  Last Tick: " + String.format("%.2f", lastTickMs) + "ms");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\guard\FailsoftController.java =====

package com.fuse.guard;

import com.fuse.telemetry.TelemetryReason;
import com.pulse.api.log.PulseLogger;

/**
 * Fail-soft Controller.
 * 
 * 예외 상황 발생 시 자동으로 안전한 방향(개입 비활성화)으로 전환합니다.
 * 
 * 핵심 규칙: 자동 ON ❌ / 자동 OFF만 허용 ⭕
 * shutdown() 대신 "개입만 OFF"로 모드 자체는 유지 (디버깅 용이)
 * 
 * @since Fuse 1.1
 */
public class FailsoftController {

    private static final String LOG = "Fuse";

    // --- 설정값 ---
    private int maxConsecutiveErrors = 3;

    // --- 상태 ---
    private int consecutiveErrors = 0;
    private boolean interventionDisabled = false;
    private Throwable lastError = null;
    private long lastErrorTimestamp = 0;

    // 텔레메트리
    private TelemetryReason lastReason = null;

    public FailsoftController() {
        PulseLogger.info(LOG, "FailsoftController initialized (max errors: "
                + maxConsecutiveErrors + ")");
    }

    /**
     * 성공 기록 - 에러 카운터 리셋.
     */
    public void recordSuccess() {
        if (consecutiveErrors > 0) {
            consecutiveErrors = 0;
        }
    }

    /**
     * 에러 기록.
     * 연속 N회 에러 시 개입 비활성화.
     */
    public void recordError(Throwable t) {
        consecutiveErrors++;
        lastError = t;
        lastErrorTimestamp = System.currentTimeMillis();

        PulseLogger.warn(LOG, "FailsoftController: Error recorded ("
                + consecutiveErrors + "/" + maxConsecutiveErrors + ")");

        if (t != null) {
            PulseLogger.error(LOG, "Error: " + t.getClass().getSimpleName()
                    + ": " + t.getMessage(), t);
        }

        if (consecutiveErrors >= maxConsecutiveErrors) {
            disableIntervention();
        }
    }

    /**
     * 개입 비활성화.
     * shutdown()과 달리 Fuse 모드는 유지 (상태 조회/디버깅 가능)
     */
    private void disableIntervention() {
        if (interventionDisabled) {
            return;
        }

        interventionDisabled = true;
        lastReason = TelemetryReason.FAILSOFT_ERROR;

        PulseLogger.error(LOG, "");
        PulseLogger.error(LOG, "╔═══════════════════════════════════════════════╗");
        PulseLogger.error(LOG, "║     ⚠️ FAILSOFT: Intervention Disabled        ║");
        PulseLogger.error(LOG, "║     Fuse is running in SAFE MODE              ║");
        PulseLogger.error(LOG, "║     (All throttling bypassed, vanilla only)   ║");
        PulseLogger.error(LOG, "╚═══════════════════════════════════════════════╝");
        PulseLogger.error(LOG, "");

        if (lastError != null) {
            PulseLogger.error(LOG, "Stack trace:", lastError);
        }
    }

    /**
     * 개입이 비활성화되었는지.
     */
    public boolean isInterventionDisabled() {
        return interventionDisabled;
    }

    /**
     * 마지막 텔레메트리 이유.
     */
    public TelemetryReason getLastReason() {
        return lastReason;
    }

    /**
     * 마지막 에러.
     */
    public Throwable getLastError() {
        return lastError;
    }

    /**
     * 마지막 에러 타임스탬프.
     */
    public long getLastErrorTimestamp() {
        return lastErrorTimestamp;
    }

    /**
     * 연속 에러 수.
     */
    public int getConsecutiveErrors() {
        return consecutiveErrors;
    }

    // --- 설정 ---

    public void setMaxConsecutiveErrors(int max) {
        this.maxConsecutiveErrors = Math.max(1, max);
    }

    /**
     * 수동 리셋 (관리자 명령어용).
     * 개입 재활성화는 세션 재시작 또는 명시적 명령 필요.
     */
    public void manualReset() {
        consecutiveErrors = 0;
        interventionDisabled = false;
        lastError = null;
        lastErrorTimestamp = 0;
        lastReason = null;
        PulseLogger.info(LOG, "FailsoftController manually reset");
    }

    public void printStatus() {
        PulseLogger.info(LOG, "Failsoft Status:");
        PulseLogger.info(LOG, "  Intervention Disabled: " + interventionDisabled);
        PulseLogger.info(LOG, "  Consecutive Errors: " + consecutiveErrors + "/" + maxConsecutiveErrors);
        if (lastError != null) {
            PulseLogger.info(LOG, "  Last Error: " + lastError.getClass().getSimpleName());
            PulseLogger.info(LOG, "  Error Time: " + new java.util.Date(lastErrorTimestamp));
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\guard\StreamingGuard.java =====

package com.fuse.guard;

import com.fuse.telemetry.TelemetryReason;
import com.pulse.api.log.PulseLogger;

/**
 * Streaming Guard.
 * 
 * 대규모 청크 로딩 시 CPU를 스트리밍에 양보합니다.
 * v1.1: 간접 신호 기반 (플레이어 이동 속도 + 프레임 드랍 감지)
 * TODO v1.2: WorldStream queue 직접 감지
 * 
 * @since Fuse 1.1
 */
public class StreamingGuard {

    private static final String LOG = "Fuse";

    // --- 설정값 ---
    private float playerSpeedThreshold = 15f; // 타일/초 (도보 속도 체크용)
    private long frameDropThresholdMs = 50; // 50ms 이상이면 프레임 드랍

    // --- 상태 ---
    private boolean yieldMode = false;
    private boolean enabled = true;
    private int recentDropCount = 0;
    private static final int DROP_WINDOW_TICKS = 30;
    private int tickCounter = 0;

    // 텔레메트리
    private TelemetryReason lastReason = null;

    public StreamingGuard() {
        PulseLogger.info(LOG, "StreamingGuard initialized (v1.1 indirect signals)");
    }

    /**
     * 스트리밍에 양보해야 하는지 반환.
     * true면 좀비 업데이트 예산을 0에 가깝게.
     */
    public boolean shouldYieldToStreaming() {
        if (!enabled) {
            return false;
        }

        tickCounter++;

        // 30틱마다 드랍 카운터 리셋
        if (tickCounter >= DROP_WINDOW_TICKS) {
            tickCounter = 0;
            recentDropCount = 0;
        }

        boolean wasPreviousYield = yieldMode;

        // 조건: 빠른 이동 + 최근 프레임 드랍
        boolean fastMoving = isPlayerMovingFast();
        boolean frameDropped = recentFrameDropDetected();

        yieldMode = fastMoving && frameDropped;

        // 상태 변경 시 로그
        if (yieldMode && !wasPreviousYield) {
            lastReason = TelemetryReason.GUARD_STREAMING;
            PulseLogger.debug(LOG, "StreamingGuard: YIELD mode (heavy streaming detected)");
        } else if (!yieldMode && wasPreviousYield) {
            lastReason = null;
            PulseLogger.debug(LOG, "StreamingGuard: NORMAL mode");
        }

        return yieldMode;
    }

    /**
     * 틱 시간 기록 (프레임 드랍 감지용).
     * FuseMod.onTick()에서 호출.
     */
    public void recordTickDuration(long durationMs) {
        if (durationMs >= frameDropThresholdMs) {
            recentDropCount++;
        }
    }

    /**
     * 플레이어가 빠르게 이동 중인지.
     */
    private boolean isPlayerMovingFast() {
        try {
            Class<?> isoPlayerClass = Class.forName("zombie.characters.IsoPlayer");
            Object player = isoPlayerClass.getMethod("getInstance").invoke(null);
            if (player == null) {
                return false;
            }

            // getMoveSpeed() 또는 유사한 메서드로 이동 속도 확인
            // 차량 탑승 시 차량 속도 사용
            Object vehicle = isoPlayerClass.getMethod("getVehicle").invoke(player);
            if (vehicle != null) {
                Class<?> baseVehicleClass = Class.forName("zombie.vehicles.BaseVehicle");
                Object speedObj = baseVehicleClass.getMethod("getCurrentSpeedKmHour").invoke(vehicle);
                if (speedObj instanceof Number) {
                    // 30km/h ≈ 8.3 타일/초 (rough estimate)
                    float kmh = ((Number) speedObj).floatValue();
                    return kmh > 20f; // 20km/h 이상
                }
            }

            // 도보 이동 속도 체크
            Object speedObj = isoPlayerClass.getMethod("getMoveSpeed").invoke(player);
            if (speedObj instanceof Number) {
                float speed = ((Number) speedObj).floatValue();
                return speed > playerSpeedThreshold;
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * 최근 프레임 드랍이 감지되었는지.
     */
    private boolean recentFrameDropDetected() {
        return recentDropCount >= 2; // 30틱 내 2회 이상 드랍
    }

    /**
     * 마지막 텔레메트리 이유.
     */
    public TelemetryReason getLastReason() {
        return lastReason;
    }

    /**
     * 현재 Yield 모드 상태.
     */
    public boolean isYieldMode() {
        return yieldMode;
    }

    // --- 설정 ---

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    public void setPlayerSpeedThreshold(float threshold) {
        this.playerSpeedThreshold = threshold;
    }

    public void setFrameDropThresholdMs(long threshold) {
        this.frameDropThresholdMs = threshold;
    }

    public void reset() {
        yieldMode = false;
        recentDropCount = 0;
        tickCounter = 0;
        lastReason = null;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\guard\VehicleGuard.java =====

package com.fuse.guard;

import com.fuse.telemetry.TelemetryReason;
import com.pulse.api.log.PulseLogger;

/**
 * Vehicle Guard.
 * 
 * 플레이어 차량 탑승/고속 이동 시 Fuse를 자동으로 보수화합니다.
 * 히스테리시스 적용: 진입 30km/h / 해제 20km/h (떨림 방지)
 * 
 * @since Fuse 1.1
 */
public class VehicleGuard {

    private static final String LOG = "Fuse";

    // --- 설정값 ---
    private float speedEntryKmh = 30f; // 진입 임계치
    private float speedExitKmh = 20f; // 해제 임계치

    // --- 상태 ---
    private boolean passiveMode = false;
    private boolean enabled = true;

    // 텔레메트리
    private TelemetryReason lastReason = null;

    public VehicleGuard() {
        PulseLogger.info(LOG, "VehicleGuard initialized (entry: "
                + speedEntryKmh + "km/h, exit: " + speedExitKmh + "km/h)");
    }

    /**
     * Passive 모드 여부 반환.
     * true면 Fuse가 최소 개입합니다.
     */
    public boolean shouldPassive() {
        if (!enabled) {
            return false;
        }

        if (!isPlayerInVehicle()) {
            if (passiveMode) {
                passiveMode = false;
                lastReason = null;
            }
            return false;
        }

        float speed = getVehicleSpeed();

        // 히스테리시스 적용
        if (!passiveMode && speed > speedEntryKmh) {
            passiveMode = true;
            lastReason = TelemetryReason.GUARD_VEHICLE;
            PulseLogger.debug(LOG, "VehicleGuard: PASSIVE mode (speed: "
                    + String.format("%.1f", speed) + "km/h)");
        } else if (passiveMode && speed < speedExitKmh) {
            passiveMode = false;
            lastReason = null;
            PulseLogger.debug(LOG, "VehicleGuard: NORMAL mode (speed: "
                    + String.format("%.1f", speed) + "km/h)");
        }

        return passiveMode;
    }

    /**
     * 플레이어가 차량에 탑승 중인지 확인.
     * 리플렉션으로 IsoPlayer.isSeatedInVehicle 체크.
     */
    private boolean isPlayerInVehicle() {
        try {
            // IsoPlayer.getInstance() → isSeatedInVehicle()
            Class<?> isoPlayerClass = Class.forName("zombie.characters.IsoPlayer");
            Object player = isoPlayerClass.getMethod("getInstance").invoke(null);
            if (player == null) {
                return false;
            }

            // isSeatedInVehicle() 메서드 호출
            Boolean seated = (Boolean) isoPlayerClass.getMethod("isSeatedInVehicle").invoke(player);
            return seated != null && seated;
        } catch (Exception e) {
            // 메서드가 없거나 오류 발생 시 false
            return false;
        }
    }

    /**
     * 차량 속도 계산 (km/h).
     * 리플렉션으로 BaseVehicle 접근.
     */
    private float getVehicleSpeed() {
        try {
            Class<?> isoPlayerClass = Class.forName("zombie.characters.IsoPlayer");
            Object player = isoPlayerClass.getMethod("getInstance").invoke(null);
            if (player == null) {
                return 0f;
            }

            // getVehicle() 메서드 호출
            Object vehicle = isoPlayerClass.getMethod("getVehicle").invoke(player);
            if (vehicle == null) {
                return 0f;
            }

            // getCurrentSpeedKmHour() 메서드 호출
            Class<?> baseVehicleClass = Class.forName("zombie.vehicles.BaseVehicle");
            Object speedObj = baseVehicleClass.getMethod("getCurrentSpeedKmHour").invoke(vehicle);
            if (speedObj instanceof Number) {
                return ((Number) speedObj).floatValue();
            }
            return 0f;
        } catch (Exception e) {
            return 0f;
        }
    }

    /**
     * 마지막 텔레메트리 이유.
     */
    public TelemetryReason getLastReason() {
        return lastReason;
    }

    /**
     * 현재 Passive 모드 상태.
     */
    public boolean isPassiveMode() {
        return passiveMode;
    }

    // --- 설정 ---

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    public void setSpeedEntryKmh(float speedEntryKmh) {
        this.speedEntryKmh = speedEntryKmh;
    }

    public void setSpeedExitKmh(float speedExitKmh) {
        this.speedExitKmh = speedExitKmh;
    }

    public void reset() {
        passiveMode = false;
        lastReason = null;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\hook\FuseHookAdapter.java =====

package com.fuse.hook;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.ProfilerBridge;
import com.pulse.api.profiler.ZombieHook;

/**
 * Fuse Hook Adapter - ZombieHook 콜백 구현.
 * 
 * Pulse API만 사용 (Echo 의존성 없음).
 * ProfilerBridge를 통해 데이터를 Echo로 전달.
 * 
 * Phase 1.5: WithContext 메서드로 zombie 객체 접근 가능
 * 
 * @since Fuse 0.3.0
 */
public class FuseHookAdapter implements ZombieHook.IZombieCallback {

    private static final String LOG = "Fuse";

    // 타이밍 측정용
    private long motionStartNanos = -1;
    private long perceptionStartNanos = -1;
    private long trackingStartNanos = -1;

    // 내부 통계
    private long zombieUpdateCount = 0;
    private long totalMotionMicros = 0;
    private long totalPerceptionMicros = 0;
    private long totalTrackingMicros = 0;

    // Phase 1.5: 현재 처리 중인 좀비 (Phase 2 throttling용)
    private Object currentZombie = null;

    public FuseHookAdapter() {
        PulseLogger.info(LOG, "HookAdapter initialized (Phase 1.5 - WithContext)");
    }

    // --- Phase 1.5: WithContext 오버라이드 ---

    @Override
    public void onZombieUpdateWithContext(Object zombie) {
        currentZombie = zombie;
        zombieUpdateCount++;
        ProfilerBridge.incrementZombieUpdates();

        // Phase 2: 여기서 shouldSkip(zombie) 체크 가능
        // if (throttleController.shouldSkip(zombie)) { return; }
    }

    @Override
    public void onMotionUpdateStartWithContext(Object zombie) {
        currentZombie = zombie;
        motionStartNanos = System.nanoTime();
    }

    @Override
    public void onMotionUpdateEndWithContext(Object zombie) {
        if (motionStartNanos > 0) {
            long durationMicros = (System.nanoTime() - motionStartNanos) / 1000;
            totalMotionMicros += durationMicros;
            motionStartNanos = -1;

            ProfilerBridge.recordZombieStep("MOTION_UPDATE", durationMicros);
        }
        currentZombie = null;
    }

    @Override
    public void onSoundPerceptionStartWithContext(Object zombie) {
        currentZombie = zombie;
        perceptionStartNanos = System.nanoTime();
    }

    @Override
    public void onSoundPerceptionEndWithContext(Object zombie) {
        if (perceptionStartNanos > 0) {
            long durationMicros = (System.nanoTime() - perceptionStartNanos) / 1000;
            totalPerceptionMicros += durationMicros;
            perceptionStartNanos = -1;

            ProfilerBridge.recordZombieStep("SOUND_PERCEPTION", durationMicros);
        }
    }

    @Override
    public void onTargetTrackingStartWithContext(Object zombie) {
        currentZombie = zombie;
        trackingStartNanos = System.nanoTime();
    }

    @Override
    public void onTargetTrackingEndWithContext(Object zombie) {
        if (trackingStartNanos > 0) {
            long durationMicros = (System.nanoTime() - trackingStartNanos) / 1000;
            totalTrackingMicros += durationMicros;
            trackingStartNanos = -1;

            ProfilerBridge.recordZombieStep("TARGET_TRACKING", durationMicros);
        }
    }

    // --- Original methods (delegate to WithContext) ---

    @Override
    public void onZombieUpdate() {
        onZombieUpdateWithContext(null);
    }

    @Override
    public void onMotionUpdateStart() {
        onMotionUpdateStartWithContext(null);
    }

    @Override
    public void onMotionUpdateEnd() {
        onMotionUpdateEndWithContext(null);
    }

    @Override
    public void onSoundPerceptionStart() {
        onSoundPerceptionStartWithContext(null);
    }

    @Override
    public void onSoundPerceptionEnd() {
        onSoundPerceptionEndWithContext(null);
    }

    @Override
    public void onTargetTrackingStart() {
        onTargetTrackingStartWithContext(null);
    }

    @Override
    public void onTargetTrackingEnd() {
        onTargetTrackingEndWithContext(null);
    }

    // --- Getters ---

    public Object getCurrentZombie() {
        return currentZombie;
    }

    public long getZombieUpdateCount() {
        return zombieUpdateCount;
    }

    public long getTotalMotionMicros() {
        return totalMotionMicros;
    }

    public long getTotalPerceptionMicros() {
        return totalPerceptionMicros;
    }

    public long getTotalTrackingMicros() {
        return totalTrackingMicros;
    }

    public void resetStats() {
        zombieUpdateCount = 0;
        totalMotionMicros = 0;
        totalPerceptionMicros = 0;
        totalTrackingMicros = 0;
    }

    public void printStatus() {
        PulseLogger.info(LOG, "HookAdapter Stats:");
        PulseLogger.info(LOG, "  Zombie Updates: " + zombieUpdateCount);
        PulseLogger.info(LOG, "  Motion: " + (totalMotionMicros / 1000) + "ms");
        PulseLogger.info(LOG, "  Perception: " + (totalPerceptionMicros / 1000) + "ms");
        PulseLogger.info(LOG, "  Tracking: " + (totalTrackingMicros / 1000) + "ms");
        PulseLogger.info(LOG, "  ProfilerBridge Sink: " + ProfilerBridge.hasSink());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\optimizer\FuseOptimizer.java =====

package com.fuse.optimizer;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.service.echo.IBottleneckDetector;
import com.pulse.api.service.echo.OptimizationPriority;
import com.pulse.di.PulseServiceLocator;

import java.util.*;

/**
 * Fuse 자동 최적화 컨트롤러.
 * 
 * Echo의 BottleneckDetector 분석 결과를 기반으로
 * CPU 병목에 대한 최적화 결정을 내립니다.
 * 
 * @since 0.1.0
 */
public class FuseOptimizer {

    private static final FuseOptimizer INSTANCE = new FuseOptimizer();

    // 최적화 상태
    private boolean enabled = false;
    private boolean autoOptimize = false;
    private OptimizationPriority currentTarget = null;
    private long lastAnalysisTime = 0;
    private static final long ANALYSIS_INTERVAL_MS = 5000; // 5초마다

    // 활성 최적화
    private final Set<String> activeOptimizations = new HashSet<>();

    // 통계
    private int optimizationsApplied = 0;
    private int optimizationsReverted = 0;

    public static FuseOptimizer getInstance() {
        return INSTANCE;
    }

    /**
     * 최적화 엔진 활성화
     */
    public void enable() {
        this.enabled = true;
        PulseLogger.info("Fuse", "Optimizer enabled");
    }

    /**
     * 최적화 엔진 비활성화
     */
    public void disable() {
        this.enabled = false;
        revertAllOptimizations();
        PulseLogger.info("Fuse", "Optimizer disabled");
    }

    /**
     * 자동 최적화 모드 설정
     */
    public void setAutoOptimize(boolean auto) {
        this.autoOptimize = auto;
        PulseLogger.info("Fuse", "Auto-optimize: " + (auto ? "ON" : "OFF"));
    }

    /**
     * 틱마다 호출하여 병목 분석 및 최적화 적용
     */
    public void update() {
        if (!enabled)
            return;

        long now = System.currentTimeMillis();
        if (now - lastAnalysisTime < ANALYSIS_INTERVAL_MS)
            return;
        lastAnalysisTime = now;

        // Echo BottleneckDetector에서 Fuse 타겟 조회 (SPI)
        try {
            IBottleneckDetector detector = PulseServiceLocator.getInstance().getService(IBottleneckDetector.class);
            if (detector != null) {
                currentTarget = detector.suggestFuseTarget();
            } else {
                currentTarget = null;
            }
        } catch (Exception e) {
            currentTarget = null;
        }

        if (autoOptimize && currentTarget != null && currentTarget.priority > 50) {
            applyOptimization(currentTarget);
        }
    }

    /**
     * 수동으로 최적화 적용
     */
    public void applyOptimization(OptimizationPriority target) {
        if (target == null || "NONE".equals(target.targetName))
            return;

        String optId = target.targetName;
        if (activeOptimizations.contains(optId)) {
            PulseLogger.debug("Fuse", "Optimization already active: " + optId);
            return;
        }

        // 최적화 적용 (실제 로직은 각 최적화 모듈에서 구현)
        boolean success = applyOptimizationLogic(optId);
        if (success) {
            activeOptimizations.add(optId);
            optimizationsApplied++;
            PulseLogger.info("Fuse", "Applied optimization: " + optId);
            PulseLogger.info("Fuse", "Recommendation: " + target.recommendation);
        }
    }

    /**
     * 실제 최적화 로직 (확장 포인트)
     */
    private boolean applyOptimizationLogic(String targetId) {
        switch (targetId) {
            case "ZOMBIE_AI":
                PulseLogger.info("Fuse", "Applying Zombie AI LOD optimization...");
                return true;

            case "SIMULATION":
                PulseLogger.info("Fuse", "Applying Simulation batching...");
                return true;

            case "PHYSICS":
                PulseLogger.info("Fuse", "Applying Physics LOD...");
                return true;

            case "PATHFINDING_DEEP":
                PulseLogger.info("Fuse", "Applying Pathfinding caching...");
                return true;

            case "ZOMBIE_PROCESSING":
                PulseLogger.info("Fuse", "Applying Zombie processing pooling...");
                return true;

            default:
                PulseLogger.warn("Fuse", "No optimization available for: " + targetId);
                return false;
        }
    }

    /**
     * 특정 최적화 취소
     */
    public void revertOptimization(String optId) {
        if (!activeOptimizations.contains(optId))
            return;

        // 최적화 취소 로직
        activeOptimizations.remove(optId);
        optimizationsReverted++;
        PulseLogger.info("Fuse", "Reverted optimization: " + optId);
    }

    /**
     * 모든 최적화 취소
     */
    public void revertAllOptimizations() {
        for (String optId : new ArrayList<>(activeOptimizations)) {
            revertOptimization(optId);
        }
    }

    /**
     * 현재 상태 조회
     */
    public Map<String, Object> getStatus() {
        Map<String, Object> status = new LinkedHashMap<>();
        status.put("enabled", enabled);
        status.put("auto_optimize", autoOptimize);
        status.put("active_optimizations", new ArrayList<>(activeOptimizations));
        status.put("optimizations_applied", optimizationsApplied);
        status.put("optimizations_reverted", optimizationsReverted);

        if (currentTarget != null) {
            status.put("current_target", currentTarget.toMap());
        }

        return status;
    }

    /**
     * 현재 제안 타겟 조회
     */
    public OptimizationPriority getCurrentTarget() {
        return currentTarget;
    }

    /**
     * 활성 최적화 수
     */
    public int getActiveOptimizationCount() {
        return activeOptimizations.size();
    }

    public boolean isEnabled() {
        return enabled;
    }

    public boolean isAutoOptimize() {
        return autoOptimize;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\telemetry\ReasonStats.java =====

package com.fuse.telemetry;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.LongAdder;

/**
 * Reason Statistics for Fuse Telemetry.
 * 
 * 개입 이유(TelemetryReason)별 발생 횟수를 추적합니다.
 * LongAdder 배열 기반으로 고신뢰/저복잡 설계.
 * 
 * @since Fuse 1.1
 */
public class ReasonStats {

    private final LongAdder[] counters;
    private final int reasonCount;

    public ReasonStats() {
        this.reasonCount = TelemetryReason.values().length;
        this.counters = new LongAdder[reasonCount];
        for (int i = 0; i < reasonCount; i++) {
            counters[i] = new LongAdder();
        }
    }

    /**
     * Reason 발생 카운트 증가.
     * 
     * @param reason 발생한 개입 이유
     */
    public void increment(TelemetryReason reason) {
        if (reason != null) {
            counters[reason.ordinal()].increment();
        }
    }

    /**
     * 특정 Reason의 카운트 반환.
     */
    public long getCount(TelemetryReason reason) {
        return reason != null ? counters[reason.ordinal()].sum() : 0;
    }

    /**
     * 상위 N개 Reason 반환 (출력용).
     * 호출 빈도가 낮으므로 호출 시점에만 스캔/정렬.
     * 
     * @param n 상위 N개
     * @return (Reason, Count) 리스트 (내림차순)
     */
    public List<Map.Entry<TelemetryReason, Long>> getTop(int n) {
        TelemetryReason[] reasons = TelemetryReason.values();
        List<Map.Entry<TelemetryReason, Long>> entries = new ArrayList<>(reasonCount);

        for (int i = 0; i < reasonCount; i++) {
            long count = counters[i].sum();
            if (count > 0) {
                entries.add(new AbstractMap.SimpleEntry<>(reasons[i], count));
            }
        }

        entries.sort(Comparator.<Map.Entry<TelemetryReason, Long>>comparingLong(Map.Entry::getValue).reversed());

        return entries.size() > n ? entries.subList(0, n) : entries;
    }

    /**
     * 전체 통계를 Map으로 반환 (리포트용).
     */
    public Map<String, Long> toMap() {
        Map<String, Long> map = new LinkedHashMap<>();
        TelemetryReason[] reasons = TelemetryReason.values();

        for (int i = 0; i < reasonCount; i++) {
            long count = counters[i].sum();
            if (count > 0) {
                map.put(reasons[i].name(), count);
            }
        }
        return map;
    }

    /**
     * 총 개입 횟수 반환.
     */
    public long getTotalCount() {
        long total = 0;
        for (LongAdder counter : counters) {
            total += counter.sum();
        }
        return total;
    }

    /**
     * 통계 리셋.
     */
    public void reset() {
        for (LongAdder counter : counters) {
            counter.reset();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\telemetry\TelemetryReason.java =====

package com.fuse.telemetry;

/**
 * Telemetry Reason Codes.
 * 
 * Fuse 개입 이유를 추적 가능하게 기록합니다.
 * 상세 성능 로그가 아닌 reason 코드(enum) + 간단한 카운터만 사용.
 * 
 * @since Fuse 1.1
 */
public enum TelemetryReason {

    // --- Throttle 관련 ---
    THROTTLE_WINDOW_EXCEEDED("last_1s.max > 33.33ms"),
    THROTTLE_AVG_HIGH("last_5s.avg > 20ms"),

    // --- Panic 관련 ---
    PANIC_WINDOW_SPIKES("100ms+ spikes x2 in 5s"),
    RECOVERING_GRADUAL("Gradual recovery in progress"),

    // --- Guard 관련 ---
    GUARD_VEHICLE("Vehicle guard active"),
    GUARD_STREAMING("Streaming guard active"),

    // --- Failsoft 관련 ---
    FAILSOFT_ERROR("Intervention disabled due to errors"),

    // --- Governor 관련 ---
    GOVERNOR_CUTOFF("Budget exceeded, cutoff triggered");

    public final String description;

    TelemetryReason(String description) {
        this.description = description;
    }

    @Override
    public String toString() {
        return name() + ": " + description;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\throttle\FuseStepPolicy.java =====

package com.fuse.throttle;

import com.fuse.config.FuseConfig;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.ThrottleLevel;
import com.pulse.api.profiler.ZombieHook;
import com.pulse.api.profiler.ZombieStepHook.IStepContext;
import com.pulse.api.profiler.ZombieStepHook.IZombieStepPolicy;
import com.pulse.api.profiler.ZombieStepHook.StepType;

/**
 * Fuse Step Throttle Policy.
 * 
 * ThrottleLevel과 연동하여 Step별 throttle 결정.
 * ZombieHook의 ThreadLocal 컨텍스트에서 현재 ThrottleLevel을 읽어
 * shouldExecute()로 실행 여부를 판단합니다.
 * 
 * @since Fuse 0.4.0
 * @since Fuse 0.5.0 - ThrottleLevel 연동
 */
public class FuseStepPolicy implements IZombieStepPolicy {

    private static final String LOG = "Fuse";

    // 통계
    private long perceptionSkipCount = 0;
    private long perceptionExecCount = 0;
    private long behaviorSkipCount = 0;
    private long behaviorExecCount = 0;
    private long targetSkipCount = 0;
    private long targetExecCount = 0;
    private long totalStepCalls = 0;

    public FuseStepPolicy() {
        PulseLogger.info(LOG, "StepPolicy initialized (ThrottleLevel mode)");
    }

    @Override
    public boolean shouldSkipStep(StepType stepType, float distSq, IStepContext context) {
        if (!FuseConfig.getInstance().isStepThrottlingEnabled()) {
            return false;
        }

        totalStepCalls++;

        // Context에서 필요 정보 추출
        int zombieId = context != null ? context.getIterIndex() : 0;
        int worldTick = context != null ? context.getWorldTick() : 0;

        // ZombieHook에서 현재 ThrottleLevel 조회
        ThrottleLevel level = ZombieHook.getCurrentThrottleLevel(worldTick);

        // ThrottleLevel의 shouldExecute()로 실행 여부 결정
        boolean shouldExecute = level.shouldExecute(stepType, zombieId, worldTick);
        boolean skip = !shouldExecute;

        // 통계 업데이트
        updateStats(stepType, skip);

        return skip;
    }

    private void updateStats(StepType stepType, boolean skip) {
        if (stepType == null)
            return;

        switch (stepType) {
            case PERCEPTION:
                if (skip)
                    perceptionSkipCount++;
                else
                    perceptionExecCount++;
                break;
            case BEHAVIOR:
                if (skip)
                    behaviorSkipCount++;
                else
                    behaviorExecCount++;
                break;
            case TARGET:
                if (skip)
                    targetSkipCount++;
                else
                    targetExecCount++;
                break;
            default:
                break;
        }
    }

    // --- Stats ---

    public long getPerceptionSkipCount() {
        return perceptionSkipCount;
    }

    public long getBehaviorSkipCount() {
        return behaviorSkipCount;
    }

    public long getTargetSkipCount() {
        return targetSkipCount;
    }

    public long getTotalStepCalls() {
        return totalStepCalls;
    }

    public void resetStats() {
        perceptionSkipCount = 0;
        perceptionExecCount = 0;
        behaviorSkipCount = 0;
        behaviorExecCount = 0;
        targetSkipCount = 0;
        targetExecCount = 0;
        totalStepCalls = 0;
    }

    public void printStatus() {
        PulseLogger.info(LOG, "Step Throttle Stats:");
        PulseLogger.info(LOG, "  PERCEPTION: exec=" + perceptionExecCount + " skip=" + perceptionSkipCount);
        PulseLogger.info(LOG, "  BEHAVIOR: exec=" + behaviorExecCount + " skip=" + behaviorSkipCount);
        PulseLogger.info(LOG, "  TARGET: exec=" + targetExecCount + " skip=" + targetSkipCount);
        PulseLogger.info(LOG, "  Total calls: " + totalStepCalls);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\java\com\fuse\throttle\FuseThrottleController.java =====

package com.fuse.throttle;

import com.fuse.config.FuseConfig;
import com.fuse.governor.RollingTickStats;
import com.fuse.governor.SpikePanicProtocol;
import com.fuse.governor.TickBudgetGovernor;
import com.fuse.guard.StreamingGuard;
import com.fuse.guard.VehicleGuard;
import com.fuse.telemetry.ReasonStats;
import com.fuse.telemetry.TelemetryReason;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.IZombieThrottlePolicy;
import com.pulse.api.profiler.ThrottleLevel;

/**
 * Fuse Throttle Controller.
 * 
 * Tiered 거리 기반 좀비 업데이트 throttling.
 * update()는 절대 취소하지 않고, ThrottleLevel만 반환.
 * 
 * v1.1: 윈도우 기반 히스테리시스 + Governor/Panic 연동
 * 
 * @since Fuse 0.3.0
 * @since Fuse 0.5.0 - Tiered ThrottleLevel 방식으로 전환
 * @since Fuse 1.1.0 - Window-based hysteresis + Governor/Panic integration
 */
public class FuseThrottleController implements IZombieThrottlePolicy {

    private static final String LOG = "Fuse";

    // --- v1.1 컴포넌트 ---
    private TickBudgetGovernor governor;
    private SpikePanicProtocol panicProtocol;
    private RollingTickStats stats;
    private VehicleGuard vehicleGuard;
    private StreamingGuard streamingGuard;
    private ReasonStats reasonStats;

    // --- 히스테리시스 설정 (윈도우 통계 기반) ---
    private static final double ENTRY_MAX_1S_MS = 33.33; // 진입: 1초 내 max > 33.33ms
    private static final double ENTRY_AVG_5S_MS = 20.0; // 또는: 5초 avg > 20ms
    private static final double EXIT_AVG_5S_MS = 12.0; // 복구: 5초 avg < 12ms
    private static final int EXIT_STABILITY_TICKS = 300; // 5초 유지 필요

    // --- 히스테리시스 상태 ---
    private ThrottleLevel hysteresisLevel = ThrottleLevel.FULL;
    private int stabilityCounter = 0;
    private boolean hysteresisActive = false;

    // --- 멀티플레이어 캐시 ---
    private boolean isMultiplayer = false;
    private int lastMpCheckTick = -100;

    // --- 통계 ---
    private long fullCount = 0;
    private long reducedCount = 0;
    private long lowCount = 0;
    private long minimalCount = 0;
    private long engagedUpgradeCount = 0;
    private long panicOverrideCount = 0;
    private long guardOverrideCount = 0;
    private long cutoffCount = 0;

    // 텔레메트리
    private TelemetryReason lastReason = null;

    public FuseThrottleController() {
        PulseLogger.info(LOG, "ThrottleController initialized (v1.1 with hysteresis)");
    }

    /**
     * v1.1: Governor/Panic 컴포넌트 설정.
     */
    public void setGovernor(TickBudgetGovernor governor) {
        this.governor = governor;
    }

    public void setPanicProtocol(SpikePanicProtocol panicProtocol) {
        this.panicProtocol = panicProtocol;
    }

    public void setStats(RollingTickStats stats) {
        this.stats = stats;
    }

    /**
     * v1.1: Guard 설정.
     */
    public void setGuards(VehicleGuard vehicleGuard, StreamingGuard streamingGuard) {
        this.vehicleGuard = vehicleGuard;
        this.streamingGuard = streamingGuard;
    }

    /**
     * v1.1: ReasonStats 설정.
     */
    public void setReasonStats(ReasonStats reasonStats) {
        this.reasonStats = reasonStats;
    }

    @Override
    public ThrottleLevel getThrottleLevel(float distSq, boolean isAttacking,
            boolean hasTarget, boolean recentlyEngaged) {

        // 0. Config 체크
        if (!FuseConfig.getInstance().isThrottlingEnabled()) {
            return ThrottleLevel.FULL;
        }

        // 1. Guard 체크 (차량/스트리밍)
        if (vehicleGuard != null && vehicleGuard.shouldPassive()) {
            guardOverrideCount++;
            lastReason = vehicleGuard.getLastReason();
            recordReason(lastReason);
            return ThrottleLevel.FULL; // 최소 개입
        }
        if (streamingGuard != null && streamingGuard.shouldYieldToStreaming()) {
            guardOverrideCount++;
            lastReason = streamingGuard.getLastReason();
            recordReason(lastReason);
            return ThrottleLevel.MINIMAL; // 예산 양보
        }

        // 2. Panic 체크
        if (panicProtocol != null && panicProtocol.getState() != SpikePanicProtocol.State.NORMAL) {
            panicOverrideCount++;
            lastReason = panicProtocol.getLastReason();
            recordReason(lastReason);

            // Panic/Recovering 배수 적용
            float multiplier = panicProtocol.getThrottleMultiplier();
            if (multiplier <= 0.2f) {
                return ThrottleLevel.MINIMAL; // 극도 축소
            } else if (multiplier <= 0.6f) {
                return ThrottleLevel.LOW;
            } else if (multiplier <= 0.8f) {
                return ThrottleLevel.REDUCED;
            }
            // 1.0 근처면 정상 계산으로
        }

        // 3. Governor 컷오프 체크
        if (governor != null && !governor.shouldContinueThisTick()) {
            cutoffCount++;
            lastReason = governor.getLastReason();
            recordReason(lastReason);
            return hysteresisLevel; // 현재 히스테리시스 레벨 유지
        }

        // 4. 즉시 FULL 승격 조건 (공격/타겟/최근 교전)
        if (isAttacking || hasTarget || recentlyEngaged) {
            fullCount++;
            if (recentlyEngaged && !isAttacking && !hasTarget) {
                engagedUpgradeCount++;
            }
            lastReason = null;
            return ThrottleLevel.FULL;
        }

        // 5. 거리 기반 Tiered 레벨 계산
        ThrottleLevel calculated = calculateDistanceLevel(distSq);

        // 6. 윈도우 기반 히스테리시스 적용
        ThrottleLevel final_ = applyHysteresis(calculated);

        // 통계 업데이트
        updateStats(final_);

        return final_;
    }

    /**
     * 거리 기반 ThrottleLevel 계산.
     */
    private ThrottleLevel calculateDistanceLevel(float distSq) {
        FuseConfig config = FuseConfig.getInstance();

        if (distSq < config.getNearDistSq()) {
            return ThrottleLevel.FULL;
        }
        if (distSq < config.getMediumDistSq()) {
            return ThrottleLevel.REDUCED;
        }
        if (distSq < config.getFarDistSq()) {
            return ThrottleLevel.LOW;
        }
        return ThrottleLevel.MINIMAL;
    }

    /**
     * 윈도우 통계 기반 히스테리시스 적용.
     */
    private ThrottleLevel applyHysteresis(ThrottleLevel newLevel) {
        if (stats == null || !stats.hasEnoughData()) {
            return newLevel; // 데이터 부족 시 bypass
        }

        double max1s = stats.getLast1sMaxMs();
        double avg5s = stats.getLast5sAvgMs();

        // 진입 조건: 1초 내 max > 33.33ms 또는 5초 avg > 20ms
        if (max1s > ENTRY_MAX_1S_MS || avg5s > ENTRY_AVG_5S_MS) {
            stabilityCounter = 0;
            hysteresisActive = true;
            lastReason = max1s > ENTRY_MAX_1S_MS
                    ? TelemetryReason.THROTTLE_WINDOW_EXCEEDED
                    : TelemetryReason.THROTTLE_AVG_HIGH;
            recordReason(lastReason);

            // 더 보수적인 레벨로 전환
            hysteresisLevel = getMoreConservativeLevel(hysteresisLevel);
            return hysteresisLevel;
        }

        // 복구 조건: 5초 avg < 12ms가 N초 유지
        if (avg5s < EXIT_AVG_5S_MS) {
            stabilityCounter++;
            if (stabilityCounter >= EXIT_STABILITY_TICKS) {
                hysteresisActive = false;
                hysteresisLevel = ThrottleLevel.FULL;
                lastReason = null;
                return newLevel; // 완전 복구
            }
        } else {
            stabilityCounter = 0; // 안정성 깨짐
        }

        // 히스테리시스 활성 중이면 현재 레벨 유지
        if (hysteresisActive) {
            return hysteresisLevel;
        }

        return newLevel;
    }

    /**
     * 더 보수적인 ThrottleLevel 반환.
     */
    private ThrottleLevel getMoreConservativeLevel(ThrottleLevel current) {
        return switch (current) {
            case FULL -> ThrottleLevel.REDUCED;
            case REDUCED -> ThrottleLevel.LOW;
            case LOW, MINIMAL -> ThrottleLevel.MINIMAL;
        };
    }

    private void updateStats(ThrottleLevel level) {
        switch (level) {
            case FULL -> fullCount++;
            case REDUCED -> reducedCount++;
            case LOW -> lowCount++;
            case MINIMAL -> minimalCount++;
        }
    }

    /**
     * ReasonStats에 개입 이유 기록.
     */
    private void recordReason(TelemetryReason reason) {
        if (reasonStats != null && reason != null) {
            reasonStats.increment(reason);
        }
    }

    // --- Legacy ---

    /**
     * @deprecated Tiered 방식으로 전환됨. 하위 호환용.
     */
    @Deprecated
    @SuppressWarnings("unused")
    private int getIntervalMask(float distSq) {
        FuseConfig config = FuseConfig.getInstance();
        if (distSq < config.getNearDistSq())
            return 0;
        if (distSq < config.getMediumDistSq())
            return 1;
        if (distSq < config.getFarDistSq())
            return 3;
        return 7;
    }

    @SuppressWarnings("unused")
    private boolean checkMultiplayer(int currentTick) {
        if (currentTick - lastMpCheckTick < 100) {
            return isMultiplayer;
        }
        lastMpCheckTick = currentTick;
        try {
            Class<?> gc = Class.forName("zombie.network.GameClient");
            isMultiplayer = (boolean) gc.getField("bClient").get(null);
        } catch (Throwable t) {
            isMultiplayer = false;
        }
        return isMultiplayer;
    }

    // --- Stats ---

    public long getFullCount() {
        return fullCount;
    }

    public long getReducedCount() {
        return reducedCount;
    }

    public long getLowCount() {
        return lowCount;
    }

    public long getMinimalCount() {
        return minimalCount;
    }

    public long getEngagedUpgradeCount() {
        return engagedUpgradeCount;
    }

    public long getPanicOverrideCount() {
        return panicOverrideCount;
    }

    public long getGuardOverrideCount() {
        return guardOverrideCount;
    }

    public long getCutoffCount() {
        return cutoffCount;
    }

    public long getTotalCount() {
        return fullCount + reducedCount + lowCount + minimalCount;
    }

    public TelemetryReason getLastReason() {
        return lastReason;
    }

    public boolean isHysteresisActive() {
        return hysteresisActive;
    }

    public void resetStats() {
        fullCount = 0;
        reducedCount = 0;
        lowCount = 0;
        minimalCount = 0;
        engagedUpgradeCount = 0;
        panicOverrideCount = 0;
        guardOverrideCount = 0;
        cutoffCount = 0;
        stabilityCounter = 0;
        hysteresisActive = false;
        hysteresisLevel = ThrottleLevel.FULL;
    }

    public void printStatus() {
        long total = getTotalCount();
        PulseLogger.info(LOG, "Throttle Controller Status (v1.1):");
        PulseLogger.info(LOG, "  FULL: " + fullCount + " (" + pct(fullCount, total) + "%)");
        PulseLogger.info(LOG, "  REDUCED: " + reducedCount + " (" + pct(reducedCount, total) + "%)");
        PulseLogger.info(LOG, "  LOW: " + lowCount + " (" + pct(lowCount, total) + "%)");
        PulseLogger.info(LOG, "  MINIMAL: " + minimalCount + " (" + pct(minimalCount, total) + "%)");
        PulseLogger.info(LOG, "  ---");
        PulseLogger.info(LOG, "  EngagedUpgrade: " + engagedUpgradeCount);
        PulseLogger.info(LOG, "  PanicOverride: " + panicOverrideCount);
        PulseLogger.info(LOG, "  GuardOverride: " + guardOverrideCount);
        PulseLogger.info(LOG, "  CutoffCount: " + cutoffCount);
        PulseLogger.info(LOG, "  ---");
        PulseLogger.info(LOG, "  HysteresisActive: " + hysteresisActive);
        PulseLogger.info(LOG, "  HysteresisLevel: " + hysteresisLevel);
        PulseLogger.info(LOG, "  StabilityCounter: " + stabilityCounter + "/" + EXIT_STABILITY_TICKS);
    }

    private String pct(long count, long total) {
        return total == 0 ? "0.0" : String.format("%.1f", (count * 100.0) / total);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Fuse\src\main\resources\pulse.mod.json =====

{
    "id": "fuse",
    "name": "Fuse Optimizer",
    "version": "0.3.0",
    "description": "CPU Performance Optimizer for Project Zomboid - Zombie AI and simulation throttling",
    "authors": [
        "Fuse Team"
    ],
    "entrypoint": "com.fuse.FuseMod",
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=0.8.0",
            "optional": false
        }
    ],
    "conflicts": [],
    "mixins": []
}


===== FILE: C:\Users\MW\Downloads\coding\PZ\gradle.properties =====

# Pulse Ecosystem Build Properties
# PZ Install Path - Override with environment variable PZ_INSTALL_PATH or command line -PpzInstallPath=...
pzInstallPath=C:/SteamLibrary/steamapps/common/ProjectZomboid



===== FILE: C:\Users\MW\Downloads\coding\PZ\gradle\wrapper\gradle-wrapper.properties =====

<<<<<<< HEAD
#Sat Dec 06 16:56:09 KST 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
<<<<<<< HEAD
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-bin.zip
=======
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-bin.zip
>>>>>>> pulse-history/main
=======
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.5-bin.zip
networkTimeout=10000
validateDistributionUrl=true
>>>>>>> echo-history/main
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



===== FILE: C:\Users\MW\Downloads\coding\PZ\media\lua\client\Echo\EchoProfiler.lua =====

-- Echo Profiler (Lua Side)
-- Implements Sampling Profiler using debug.sethook
-- Phase 3

EchoProfiler = {}
EchoProfiler.enabled = false
EchoProfiler.samplingRate = 1000 -- Instructions per hook
EchoProfiler.isSampling = false

-- Use a local reference for speed
local debug_sethook = debug.sethook
local debug_getinfo = debug.getinfo

function EchoProfiler.enableSampling(enable)
    if enable then
        if EchoProfiler.isSampling then return end
        print("[Echo] Lua Sampling Profiler: STARTED")
        debug_sethook(EchoProfiler.onHook, "c", EchoProfiler.samplingRate) -- 'count' hook
        EchoProfiler.isSampling = true
    else
        if not EchoProfiler.isSampling then return end
        print("[Echo] Lua Sampling Profiler: STOPPED")
        debug_sethook() -- Turn off hook
        EchoProfiler.isSampling = false
    end
end

function EchoProfiler.onHook(event)
    -- Sampling: Just capture the top function
    local info = debug_getinfo(2, "nS")
    if info and info.name and info.name ~= "" and info.source then
        -- Send to Java
        -- We perform a static call to Echo's bridge
        -- Assuming Exposed Java Method: com.echo.pulse.LuaBridge.recordSample(name, source)
        -- TODO: Implement bridge binding or native call
        -- For now, simulate or check if we can call static Java
        
        -- To avoid massive JNI overhead on every sample, we might aggregate here in Lua
        -- But for "Sampling", we want to minimize Lua side logic too.
        -- Best practice in PZ: direct call to exposed Java method is relatively fast compared to Lua logic.
    end
end

-- Check Config periodically or via Event
Events.OnTick.Add(function()
    -- This check should be cheap.
    -- Ideally, Java side triggers an event "EchoConfigChanged" to push state.
    -- For now, we rely on a global flag or Java call.
    
    -- Placeholder for config check
    -- local javaEnabled = ...
    -- if javaEnabled ~= EchoProfiler.isSampling then EchoProfiler.enableSampling(javaEnabled) end
end)

return EchoProfiler



===== FILE: C:\Users\MW\Downloads\coding\PZ\Nerve\build.gradle =====

plugins {
    id 'java'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'com.nerve'
version = '0.2.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // Pulse API dependency
    compileOnly project(':pulse-api')
    
    // Pulse Core dependency (for PulseLogger and other core utilities)
    compileOnly project(':Pulse')
    
    // PZ stubs (optional, graceful handling when missing)
    compileOnly fileTree(dir: '../Pulse/libs', include: ['pz-stubs.jar'])
}

jar {
    manifest {
        attributes(
            'Implementation-Title': 'Nerve',
            'Implementation-Version': version
        )
    }
}

shadowJar {
    archiveBaseName.set('Nerve')
    archiveClassifier.set('')
    archiveVersion.set(version)
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Nerve\settings.gradle =====

rootProject.name = 'Nerve'



===== FILE: C:\Users\MW\Downloads\coding\PZ\Nerve\src\main\java\com\nerve\guard\SlowTickGuard.java =====

package com.nerve.guard;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.spi.ITickHealthProvider;

/**
 * SlowTick Guard for Nerve.
 * 
 * SlowTick 상태일 때만 완충 모드를 활성화.
 * 
 * 핵심 철학:
 * - Nerve는 Echo를 전혀 모름 (import 없음)
 * - 오직 Pulse SPI(ITickHealthProvider)만 사용
 * - Provider가 없으면 fail-open (완충 비활성화)
 * 
 * v0.1: 기본 OFF + 보수적 스코프
 * 
 * @since Nerve 0.3.0
 */
public class SlowTickGuard {

    private static final String LOG = "Nerve";

    // --- 설정 ---
    private boolean enabled = false; // 기본 OFF
    private int spikeThreshold = 2; // N회 이상 스파이크 시 완충 진입
    @SuppressWarnings("unused") // 향후 동적 임계값에 사용 예정
    private double slowTickThresholdMs = 33.33; // SlowTick 임계값

    // --- 상태 ---
    private boolean bufferMode = false;
    private int consecutiveErrors = 0;
    private static final int MAX_ERRORS = 3;

    // --- Provider (Pulse를 통해 조회) ---
    private ITickHealthProvider healthProvider;

    public SlowTickGuard() {
        // 기본 fail-open provider 사용 (나중에 실제 provider로 교체)
        this.healthProvider = ITickHealthProvider.DEFAULT;
        PulseLogger.info(LOG, "SlowTickGuard initialized (default OFF, fail-open)");
    }

    /**
     * Provider 설정 (Pulse 레지스트리에서 조회 후 호출).
     * Nerve는 Echo를 직접 참조하지 않고, 이 메서드를 통해 provider만 받음.
     */
    public void setHealthProvider(ITickHealthProvider provider) {
        this.healthProvider = provider != null ? provider : ITickHealthProvider.DEFAULT;
        PulseLogger.debug(LOG, "SlowTickGuard: HealthProvider set to " + this.healthProvider.getId());
    }

    /**
     * 완충 모드 활성화 여부 확인.
     * SlowTick 상태일 때만 true.
     */
    public boolean shouldBuffer() {
        if (!enabled) {
            return false;
        }

        try {
            boolean isSlowTick = healthProvider.isSlowTick();
            int spikeCount = healthProvider.getRecentSpikeCount();

            boolean wasPreviousBuffer = bufferMode;

            // 진입 조건: SlowTick 또는 스파이크 임계값 초과
            if (isSlowTick || spikeCount >= spikeThreshold) {
                bufferMode = true;
            } else {
                bufferMode = false;
            }

            // 상태 변경 로그
            if (bufferMode && !wasPreviousBuffer) {
                PulseLogger.debug(LOG, "SlowTickGuard: BUFFER mode (slowTick=" + isSlowTick
                        + ", spikes=" + spikeCount + ")");
            } else if (!bufferMode && wasPreviousBuffer) {
                PulseLogger.debug(LOG, "SlowTickGuard: NORMAL mode");
            }

            // 성공 시 에러 카운터 리셋
            consecutiveErrors = 0;

            return bufferMode;
        } catch (Exception e) {
            // Fail-open: 에러 발생 시 완충 비활성화
            recordError(e);
            return false;
        }
    }

    /**
     * Fail-open 에러 핸들링.
     * 연속 N회 에러 시 자동으로 Guard 비활성화.
     */
    private void recordError(Throwable t) {
        consecutiveErrors++;
        PulseLogger.warn(LOG, "SlowTickGuard: Error (" + consecutiveErrors + "/" + MAX_ERRORS + "): "
                + t.getMessage());

        if (consecutiveErrors >= MAX_ERRORS) {
            enabled = false;
            bufferMode = false;
            PulseLogger.warn(LOG, "SlowTickGuard: AUTO-DISABLED due to consecutive errors (fail-open)");
        }
    }

    // --- 제어 API ---

    public void enable() {
        this.enabled = true;
        this.consecutiveErrors = 0;
        PulseLogger.info(LOG, "SlowTickGuard: ENABLED");
    }

    public void disable() {
        this.enabled = false;
        this.bufferMode = false;
        PulseLogger.info(LOG, "SlowTickGuard: DISABLED");
    }

    public boolean isEnabled() {
        return enabled;
    }

    public boolean isBufferMode() {
        return bufferMode;
    }

    public void setSpikeThreshold(int threshold) {
        this.spikeThreshold = Math.max(1, threshold);
    }

    public void setSlowTickThresholdMs(double thresholdMs) {
        this.slowTickThresholdMs = thresholdMs;
    }

    public void reset() {
        bufferMode = false;
        consecutiveErrors = 0;
    }

    // --- Getters for status display ---

    public String getProviderId() {
        return healthProvider != null ? healthProvider.getId() : "none";
    }

    public int getConsecutiveErrors() {
        return consecutiveErrors;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Nerve\src\main\java\com\nerve\NerveMod.java =====

package com.nerve;

import com.nerve.optimizer.NerveOptimizer;
import com.pulse.api.log.PulseLogger;

/**
 * Nerve - Network & Rendering Enhancement for Project Zomboid
 * 
 * Echo의 BottleneckDetector 분석 결과를 기반으로
 * 네트워크/렌더링 병목을 자동 최적화합니다.
 */
public class NerveMod {

    public static final String MOD_ID = "Nerve";
    public static final String VERSION = "0.2.0";
    private static final String LOG = "Nerve";

    private static NerveMod instance;
    private NerveOptimizer optimizer;
    private boolean initialized = false;

    public static NerveMod getInstance() {
        return instance;
    }

    public void init() {
        instance = this;
        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "╔═══════════════════════════════════════════════╗");
        PulseLogger.info(LOG, "║     Nerve v{} - Network & Rendering       ║", VERSION);
        PulseLogger.info(LOG, "║     \"Adapt and Accelerate\"                    ║");
        PulseLogger.info(LOG, "╚═══════════════════════════════════════════════╝");

        // 옵티마이저 초기화
        optimizer = NerveOptimizer.getInstance();
        optimizer.enable();

        // Nerve는 네트워크 품질에 따라 자동 조절 권장
        optimizer.setAutoOptimize(true);

        initialized = true;
        PulseLogger.info(LOG, "Initialization complete");
        PulseLogger.info(LOG, "Auto-optimization enabled for network quality adaptation");
    }

    /**
     * 게임 틱에서 호출
     */
    public void onTick() {
        if (!initialized)
            return;
        optimizer.update();
    }

    /** 자동 최적화 토글 */
    public void toggleAutoOptimize() {
        optimizer.toggleAutoOptimize();
    }

    /** 현재 타겟에 수동 최적화 적용 */
    public void applyCurrentTarget() {
        var target = optimizer.getStatus().get("current_target");
        if (target != null) {
            PulseLogger.info(LOG, "Applying current target optimization...");
            // 타겟에 따라 적용
        } else {
            PulseLogger.info(LOG, "No optimization target available");
        }
    }

    /** 옵티마이저 상태 출력 */
    public void printStatus() {
        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "╔═══════════════════════════════════════════════╗");
        PulseLogger.info(LOG, "║             NERVE OPTIMIZER STATUS            ║");
        PulseLogger.info(LOG, "╚═══════════════════════════════════════════════╝");

        var status = optimizer.getStatus();
        PulseLogger.info(LOG, "  Enabled:       {}", status.get("enabled"));
        PulseLogger.info(LOG, "  Auto-Optimize: {}", status.get("auto_optimize"));
        PulseLogger.info(LOG, "  Applied:       {}", status.get("optimizations_applied"));

        @SuppressWarnings("unchecked")
        var network = (java.util.Map<String, Object>) status.get("network_settings");
        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "  Network Settings:");
        PulseLogger.info(LOG, "    Packet Batch Size:   {}", network.get("packet_batch_size"));
        PulseLogger.info(LOG, "    Delta Compression:   {}", network.get("delta_compression"));
        PulseLogger.info(LOG, "    Connection Quality:  {}", network.get("connection_quality"));

        @SuppressWarnings("unchecked")
        var render = (java.util.Map<String, Object>) status.get("render_settings");
        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "  Render Settings:");
        PulseLogger.info(LOG, "    Occlusion Culling:   {}", render.get("occlusion_culling"));
        PulseLogger.info(LOG, "    DrawCall Batching:   {}", render.get("draw_call_batching"));
        PulseLogger.info(LOG, "    LOD Level:           {}", render.get("lod_level"));
        PulseLogger.info(LOG, "    Render Efficiency:   {}", render.get("render_efficiency"));
        PulseLogger.info(LOG, "");
    }

    public NerveOptimizer getOptimizer() {
        return optimizer;
    }

    public void shutdown() {
        PulseLogger.info(LOG, "Shutting down...");
        if (optimizer != null) {
            optimizer.disable();
        }
        initialized = false;
        PulseLogger.info(LOG, "Shutdown complete");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Nerve\src\main\java\com\nerve\optimizer\NerveOptimizer.java =====

package com.nerve.optimizer;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.service.echo.ConnectionQuality;
import com.pulse.api.service.echo.IBottleneckDetector;
import com.pulse.api.service.echo.INetworkMetrics;
import com.pulse.api.service.echo.IRenderMetrics;
import com.pulse.api.service.echo.OptimizationPriority;
import com.pulse.api.service.echo.RenderEfficiency;
import com.pulse.di.PulseServiceLocator;

import java.util.*;

/**
 * Nerve 네트워크/렌더링 최적화 컨트롤러.
 * 
 * Echo의 BottleneckDetector 분석 결과를 기반으로
 * 네트워크 및 렌더링 병목에 대한 최적화 결정을 내립니다.
 * 
 * @since 0.1.0
 */
public class NerveOptimizer {

    private static final String LOG = "Nerve";
    private static final NerveOptimizer INSTANCE = new NerveOptimizer();

    // 최적화 상태
    private boolean enabled = false;
    private boolean autoOptimize = false;
    private OptimizationPriority currentTarget = null;
    private long lastAnalysisTime = 0;
    private static final long ANALYSIS_INTERVAL_MS = 5000;

    // 활성 최적화
    private final Set<String> activeOptimizations = new HashSet<>();

    // 네트워크 최적화 설정
    private int packetBatchSize = 1;
    private boolean deltaCompression = false;

    // 렌더링 최적화 설정
    private boolean occlusionCulling = false;
    private boolean drawCallBatching = false;
    private int lodLevel = 0;

    // 통계
    private int optimizationsApplied = 0;

    public static NerveOptimizer getInstance() {
        return INSTANCE;
    }

    /**
     * 최적화 엔진 활성화
     */
    public void enable() {
        this.enabled = true;
        PulseLogger.info(LOG, "Optimizer enabled");
    }

    /**
     * 최적화 엔진 비활성화
     */
    public void disable() {
        this.enabled = false;
        revertAllOptimizations();
        PulseLogger.info(LOG, "Optimizer disabled");
    }

    /**
     * 자동 최적화 모드 설정
     */
    public void setAutoOptimize(boolean auto) {
        this.autoOptimize = auto;
        PulseLogger.info(LOG, "Auto-optimize: {}", auto ? "ON" : "OFF");
    }

    /**
     * 자동 최적화 모드 토글
     */
    public void toggleAutoOptimize() {
        setAutoOptimize(!autoOptimize);
    }

    /**
     * 틱마다 호출하여 병목 분석 및 최적화 적용
     */
    public void update() {
        if (!enabled)
            return;

        long now = System.currentTimeMillis();
        if (now - lastAnalysisTime < ANALYSIS_INTERVAL_MS)
            return;
        lastAnalysisTime = now;

        // Echo BottleneckDetector에서 Nerve 타겟 조회 (SPI)
        IBottleneckDetector detector = PulseServiceLocator.getInstance().getService(IBottleneckDetector.class);
        if (detector != null) {
            currentTarget = detector.suggestNerveTarget();
        } else {
            currentTarget = null;
        }

        // 네트워크 품질 기반 자동 조절
        if (autoOptimize) {
            autoAdjustNetwork();
            autoAdjustRendering();

            if (currentTarget != null && currentTarget.priority > 50) {
                applyOptimization(currentTarget);
            }
        }
    }

    /**
     * 네트워크 품질에 따른 자동 조절
     */
    private void autoAdjustNetwork() {
        INetworkMetrics metrics = PulseServiceLocator.getInstance().getService(INetworkMetrics.class);
        if (metrics == null)
            return;

        ConnectionQuality quality = metrics.getConnectionQuality();

        switch (quality) {
            case POOR:
                // 연결 품질 나쁨 → 공격적 최적화
                if (packetBatchSize < 5) {
                    packetBatchSize = 5;
                    deltaCompression = true;
                    PulseLogger.info(LOG, "Network quality POOR - enabling aggressive batching (5) and compression");
                }
                break;

            case FAIR:
                // 연결 품질 보통 → 중간 최적화
                if (packetBatchSize != 3) {
                    packetBatchSize = 3;
                    deltaCompression = true;
                    PulseLogger.info(LOG, "Network quality FAIR - moderate batching (3)");
                }
                break;

            case GOOD:
                // 연결 품질 양호 → 경량 최적화
                if (packetBatchSize != 2) {
                    packetBatchSize = 2;
                    deltaCompression = false;
                    PulseLogger.info(LOG, "Network quality GOOD - light batching (2)");
                }
                break;

            case EXCELLENT:
                // 연결 품질 최적 → 최적화 불필요
                if (packetBatchSize != 1) {
                    packetBatchSize = 1;
                    deltaCompression = false;
                    PulseLogger.debug(LOG, "Network quality EXCELLENT - no batching needed");
                }
                break;
        }
    }

    /**
     * 렌더링 성능에 따른 자동 조절
     */
    private void autoAdjustRendering() {
        IRenderMetrics metrics = PulseServiceLocator.getInstance().getService(IRenderMetrics.class);
        if (metrics == null)
            return;

        RenderEfficiency efficiency = metrics.getRenderEfficiency();
        double fps = metrics.getFps();

        if (fps < 30 || efficiency == RenderEfficiency.POOR) {
            // FPS 낮음 → 공격적 최적화
            if (lodLevel < 2) {
                lodLevel = 2;
                occlusionCulling = true;
                drawCallBatching = true;
                PulseLogger.warn(LOG, "FPS low ({}) - enabling aggressive render optimizations", (int) fps);
            }
        } else if (fps < 45 || efficiency == RenderEfficiency.FAIR) {
            // FPS 보통 → 중간 최적화
            if (lodLevel != 1) {
                lodLevel = 1;
                occlusionCulling = true;
                drawCallBatching = false;
                PulseLogger.info(LOG, "FPS moderate ({}) - enabling moderate render optimizations", (int) fps);
            }
        } else {
            // FPS 양호 → 최적화 축소
            if (lodLevel != 0) {
                lodLevel = 0;
                occlusionCulling = false;
                drawCallBatching = false;
                PulseLogger.debug(LOG, "FPS good ({}) - reducing render optimizations", (int) fps);
            }
        }
    }

    /**
     * 수동으로 최적화 적용
     */
    public void applyOptimization(OptimizationPriority target) {
        if (target == null || "NONE".equals(target.targetName))
            return;

        String optId = target.targetName;
        if (activeOptimizations.contains(optId))
            return;

        boolean success = applyOptimizationLogic(optId);
        if (success) {
            activeOptimizations.add(optId);
            optimizationsApplied++;
            PulseLogger.info(LOG, "Applied optimization: {}", optId);
            PulseLogger.info(LOG, "Recommendation: {}", target.recommendation);
        }
    }

    /**
     * 실제 최적화 로직 (확장 포인트)
     */
    private boolean applyOptimizationLogic(String targetId) {
        switch (targetId) {
            case "RENDER":
                // 렌더링 최적화: Draw Call 배칭
                drawCallBatching = true;
                PulseLogger.info(LOG, "Enabling DrawCall batching...");
                return true;

            case "RENDER_WORLD":
                // 월드 렌더링 최적화: Occlusion Culling + LOD
                occlusionCulling = true;
                lodLevel = Math.min(lodLevel + 1, 3);
                PulseLogger.info(LOG, "Enabling occlusion culling and LOD level {}", lodLevel);
                return true;

            case "NETWORK":
                // 네트워크 최적화: 패킷 배칭 + 압축
                packetBatchSize = Math.min(packetBatchSize + 2, 10);
                deltaCompression = true;
                PulseLogger.info(LOG, "Enabling packet batching ({}) and delta compression", packetBatchSize);
                return true;

            default:
                PulseLogger.debug(LOG, "No optimization available for: {}", targetId);
                return false;
        }
    }

    /**
     * 모든 최적화 취소
     */
    public void revertAllOptimizations() {
        activeOptimizations.clear();
        packetBatchSize = 1;
        deltaCompression = false;
        occlusionCulling = false;
        drawCallBatching = false;
        lodLevel = 0;
        PulseLogger.info(LOG, "All optimizations reverted");
    }

    /**
     * 현재 상태 조회
     */
    public Map<String, Object> getStatus() {
        Map<String, Object> status = new LinkedHashMap<>();
        status.put("enabled", enabled);
        status.put("auto_optimize", autoOptimize);
        status.put("active_optimizations", new ArrayList<>(activeOptimizations));
        status.put("optimizations_applied", optimizationsApplied);

        // 네트워크 설정
        Map<String, Object> network = new LinkedHashMap<>();
        network.put("packet_batch_size", packetBatchSize);
        network.put("delta_compression", deltaCompression);

        INetworkMetrics netMetrics = PulseServiceLocator.getInstance().getService(INetworkMetrics.class);
        if (netMetrics != null) {
            network.put("connection_quality", netMetrics.getConnectionQuality().name());
        }
        status.put("network_settings", network);

        // 렌더링 설정
        Map<String, Object> render = new LinkedHashMap<>();
        render.put("occlusion_culling", occlusionCulling);
        render.put("draw_call_batching", drawCallBatching);
        render.put("lod_level", lodLevel);

        IRenderMetrics renderMetrics = PulseServiceLocator.getInstance().getService(IRenderMetrics.class);
        if (renderMetrics != null) {
            render.put("render_efficiency", renderMetrics.getRenderEfficiency().name());
        }
        status.put("render_settings", render);

        if (currentTarget != null) {
            status.put("current_target", currentTarget.toMap());
        }

        return status;
    }

    // Getters
    public int getPacketBatchSize() {
        return packetBatchSize;
    }

    public boolean isDeltaCompression() {
        return deltaCompression;
    }

    public boolean isOcclusionCulling() {
        return occlusionCulling;
    }

    public boolean isDrawCallBatching() {
        return drawCallBatching;
    }

    public int getLodLevel() {
        return lodLevel;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public boolean isAutoOptimize() {
        return autoOptimize;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Nerve\src\main\java\com\nerve\optimizer\ZombieNetworkOptimizer.java =====

package com.nerve.optimizer;

import com.pulse.api.log.PulseLogger;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Zombie Network Optimizer for Nerve.
 * 
 * IsoZombie 네트워크 동기화 최적화:
 * - 패킷 배치 처리 (n개씩 묶어서 전송)
 * - 델타 압축 (변경된 필드만 전송)
 * - 우선순위 기반 전송 (근거리 좀비 우선)
 * 
 * @since Nerve 0.2.1
 */
public class ZombieNetworkOptimizer {

    private static final String LOG = "Nerve";
    private static final ZombieNetworkOptimizer INSTANCE = new ZombieNetworkOptimizer();

    /** 배치 처리 큐 */
    private final ConcurrentLinkedQueue<ZombiePacketInfo> pendingPackets = new ConcurrentLinkedQueue<>();

    /** 설정 */
    private int batchSize = 10;
    private boolean deltaCompressionEnabled = true;
    private boolean enabled = false;

    /** 통계 */
    private final AtomicLong totalPackets = new AtomicLong(0);
    private final AtomicLong batchedPackets = new AtomicLong(0);
    private final AtomicLong savedBytes = new AtomicLong(0);
    private final AtomicInteger currentBatchCount = new AtomicInteger(0);

    public static ZombieNetworkOptimizer getInstance() {
        return INSTANCE;
    }

    // --- Configuration ---

    public void enable() {
        this.enabled = true;
        PulseLogger.info(LOG, "ZombieNetworkOptimizer enabled (batch={}, delta={})",
                batchSize, deltaCompressionEnabled);
    }

    public void disable() {
        this.enabled = false;
        flushBatch();
        PulseLogger.info(LOG, "ZombieNetworkOptimizer disabled");
    }

    public void setBatchSize(int size) {
        this.batchSize = Math.max(1, Math.min(50, size));
    }

    public void setDeltaCompressionEnabled(boolean enabled) {
        this.deltaCompressionEnabled = enabled;
    }

    // --- Packet Handling ---

    /**
     * 좀비 패킷을 배치 큐에 추가
     */
    public void queuePacket(int zombieId, float x, float y, float z,
            int state, int targetId, float health) {
        if (!enabled) {
            return;
        }

        ZombiePacketInfo packet = new ZombiePacketInfo(
                zombieId, x, y, z, state, targetId, health,
                System.currentTimeMillis());

        pendingPackets.add(packet);
        totalPackets.incrementAndGet();
        currentBatchCount.incrementAndGet();

        // 배치 크기 도달 시 플러시
        if (currentBatchCount.get() >= batchSize) {
            flushBatch();
        }
    }

    /**
     * 배치 전송 (실제 네트워크 전송은 게임 API 통해)
     */
    public void flushBatch() {
        if (pendingPackets.isEmpty()) {
            return;
        }

        int count = 0;
        while (!pendingPackets.isEmpty() && count < batchSize) {
            ZombiePacketInfo packet = pendingPackets.poll();
            if (packet != null) {
                // 실제 전송 로직은 게임 네트워크 API와 통합 필요
                sendPacket(packet);
                count++;
            }
        }

        if (count > 0) {
            batchedPackets.addAndGet(count);
            currentBatchCount.set(pendingPackets.size());
            PulseLogger.debug(LOG, "Flushed {} zombie packets", count);
        }
    }

    /**
     * 개별 패킷 전송 (게임 API 통합 포인트)
     */
    private void sendPacket(ZombiePacketInfo packet) {
        // TODO: GameServer.sendZombiePacket() 통합
        // 현재는 로깅만
        if (deltaCompressionEnabled) {
            // 델타 압축 시 예상 절약 바이트
            savedBytes.addAndGet(estimateDeltaSavings(packet));
        }
    }

    /**
     * 델타 압축 시 절약 예상 바이트
     */
    private long estimateDeltaSavings(ZombiePacketInfo packet) {
        // 전체 패킷: 약 40바이트
        // 델타 패킷: 약 12바이트 (위치 변경만)
        return 28;
    }

    // --- Tick Update ---

    /**
     * 틱마다 호출 - 오래된 패킷 플러시
     */
    public void onTick() {
        if (!enabled)
            return;

        // 100ms 이상 대기한 패킷이 있으면 플러시
        long now = System.currentTimeMillis();
        ZombiePacketInfo oldest = pendingPackets.peek();
        if (oldest != null && (now - oldest.timestamp) > 100) {
            flushBatch();
        }
    }

    // --- Statistics ---

    public long getTotalPackets() {
        return totalPackets.get();
    }

    public long getBatchedPackets() {
        return batchedPackets.get();
    }

    public long getSavedBytes() {
        return savedBytes.get();
    }

    public int getPendingCount() {
        return pendingPackets.size();
    }

    public void resetStats() {
        totalPackets.set(0);
        batchedPackets.set(0);
        savedBytes.set(0);
    }

    // --- Packet Info ---

    public static class ZombiePacketInfo {
        public final int zombieId;
        public final float x, y, z;
        public final int state;
        public final int targetId;
        public final float health;
        public final long timestamp;

        public ZombiePacketInfo(int zombieId, float x, float y, float z,
                int state, int targetId, float health, long timestamp) {
            this.zombieId = zombieId;
            this.x = x;
            this.y = y;
            this.z = z;
            this.state = state;
            this.targetId = targetId;
            this.health = health;
            this.timestamp = timestamp;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\.vscode\settings.json =====

{
    "java.compile.nullAnalysis.mode": "automatic",
    "java.configuration.updateBuildConfiguration": "interactive"
}


===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\build.gradle =====

plugins {
    id 'java-library'
    id 'eclipse'
    id 'idea'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'com.pulse'
version = '0.8.0-SNAPSHOT'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven/' }
}

dependencies {
    // Pulse API (shared interfaces)
    implementation project(':pulse-api')
    
    // Mixin Core
    implementation 'org.spongepowered:mixin:0.8.5'

    // JSON (Mixin config 파싱에 필요)
    implementation 'com.google.code.gson:gson:2.10.1'

    // ASM (바이트코드 조작)
    implementation 'org.ow2.asm:asm:9.5'
    implementation 'org.ow2.asm:asm-commons:9.5'
    implementation 'org.ow2.asm:asm-tree:9.5'
    implementation 'org.ow2.asm:asm-util:9.5'
    implementation 'org.ow2.asm:asm-analysis:9.5'

    // Guava (Mixin 내부에서 사용)
    implementation 'com.google.guava:guava:32.1.2-jre'

    // Game Code (컴파일 전용 - 자동 감지)
    def pzPath = rootProject.hasProperty('ext') && rootProject.ext.has('pzGamePath') ? rootProject.ext.pzGamePath : null
    if (pzPath) {
        compileOnly files(pzPath)
        compileOnly fileTree(dir: pzPath, include: ['*.jar'])
    } else {
        logger.warn("[Pulse] Project Zomboid not found - some features may not compile")
    }

    // Testing
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testImplementation 'org.mockito:mockito-core:5.5.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.5.0'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    
    // Architecture Testing (package boundary enforcement)
    testImplementation 'com.tngtech.archunit:archunit-junit5:1.2.1'
}

test {
    useJUnitPlatform()
}

shadowJar {
    archiveBaseName.set('Pulse')
    archiveClassifier.set('')
    archiveVersion.set('')

    // 서비스 파일 병합 (중요!)
    mergeServiceFiles()

    // 중복 제외
    exclude 'META-INF/MANIFEST.MF'
    exclude 'META-INF/*.SF'
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'

    manifest {
        attributes(
            'Premain-Class': 'com.pulse.PulseAgent',
            'Agent-Class': 'com.pulse.PulseAgent',
            'Can-Retransform-Classes': 'true',
            'Can-Redefine-Classes': 'true',
            'Can-Set-Native-Method-Prefix': 'true',
            'Implementation-Title': 'Pulse',
            'Implementation-Version': project.version,
            'Multi-Release': 'true'
        )
    }
}

tasks.named('build') {
    dependsOn shadowJar
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.compilerArgs += ['-parameters']  // 메서드 파라미터 이름 유지
}

// 디버그: 종속성 트리 출력
task printDeps {
    doLast {
        configurations.runtimeClasspath.each { println it }
    }
}

// 버전 파일 생성 (PulseLauncher에서 읽기용)
task generateVersionFile {
    description = 'Generates pulse-version.txt for PulseLauncher'
    doLast {
        def versionFile = file("pulse-version.txt")
        def cleanVersion = version.toString().replace('-SNAPSHOT', '')
        versionFile.text = cleanVersion
        println "Generated pulse-version.txt: ${cleanVersion}"
    }
}

// shadowJar 빌드 시 버전 파일도 함께 생성
shadowJar.dependsOn generateVersionFile

// ═══════════════════════════════════════════════════════════════
// Dual Output: pulse-core.jar and pulse-all.jar
// For future core-loader separation
// ═══════════════════════════════════════════════════════════════

task shadowJarCore(type: com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
    description = 'Build Pulse-core.jar (without loader packages)'
    group = 'build'
    
    archiveBaseName.set('Pulse-core')
    archiveClassifier.set('')
    archiveVersion.set('')
    
    from sourceSets.main.output
    configurations = [project.configurations.runtimeClasspath]
    
    // Exclude loader packages (core should be self-sufficient)
    exclude 'com/pulse/loader/**'
    exclude 'com/pulse/ui/**'
    
    // Exclude optimization mixins (belong in Fuse, not core)
    exclude 'com/pulse/mixin/optimization/**'
    
    mergeServiceFiles()
    
    // Same META-INF exclusions as main shadowJar
    exclude 'META-INF/MANIFEST.MF'
    exclude 'META-INF/*.SF'
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'
    
    manifest {
        attributes(
            'Premain-Class': 'com.pulse.PulseAgent',
            'Agent-Class': 'com.pulse.PulseAgent',
            'Can-Retransform-Classes': 'true',
            'Can-Redefine-Classes': 'true',
            'Can-Set-Native-Method-Prefix': 'true',
            'Implementation-Title': 'Pulse Core',
            'Implementation-Version': project.version,
            'Multi-Release': 'true'
        )
    }
}

task buildAll {
    description = 'Build both pulse-all.jar and pulse-core.jar'
    group = 'build'
    dependsOn shadowJar      // Pulse.jar (all inclusive)
    dependsOn shadowJarCore  // Pulse-core.jar (core only)
}

// ═══════════════════════════════════════════════════════════════
// Architecture Test Task (run boundary tests separately)
// ═══════════════════════════════════════════════════════════════

task archTest(type: Test) {
    description = 'Run architecture boundary tests'
    group = 'verification'
    useJUnitPlatform {
        includeTags 'architecture'
    }
    filter {
        includeTestsMatching '*BoundaryTest*'
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\gradle\wrapper\gradle-wrapper.properties =====

#Sat Dec 06 16:56:09 KST 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\settings.gradle =====

// NOTE: This project is now managed by the root PZ/settings.gradle
// These includes are inherited from the root project
// rootProject.name = 'Pulse'

// First-party mods are included via root settings.gradle
// include 'first-party-mods:pulse-profiler'
// include 'first-party-mods:pulse-engine-optim'
// include 'first-party-mods:pulse-lua-optim'



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\access\AccessWidener.java =====

package com.pulse.access;

import com.pulse.api.log.PulseLogger;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 접근 확장기 (Access Widener).
 * 게임 클래스의 private/protected 멤버에 대한 접근을 제공.
 * 
 * Fabric의 Access Widener와 유사하지만 리플렉션 기반으로 런타임에 동작.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 클래스 접근
 * Class<?> clazz = AccessWidener.getClass("zombie.inventory.ItemContainer");
 * 
 * // 필드 접근
 * Object value = AccessWidener.getField(instance, "privateField");
 * AccessWidener.setField(instance, "privateField", newValue);
 * 
 * // 메서드 호출
 * Object result = AccessWidener.invoke(instance, "privateMethod", arg1, arg2);
 * 
 * // 생성자 호출
 * Object instance = AccessWidener.newInstance("zombie.SomeClass", arg1);
 * </pre>
 */
public class AccessWidener {

    private static final AccessWidener INSTANCE = new AccessWidener();
    private static final String LOG = PulseLogger.PULSE;

    // 캐시
    private final Map<String, Class<?>> classCache = new ConcurrentHashMap<>();
    private final Map<String, Field> fieldCache = new ConcurrentHashMap<>();
    private final Map<String, Method> methodCache = new ConcurrentHashMap<>();
    private final Map<String, Constructor<?>> constructorCache = new ConcurrentHashMap<>();

    // 게임 클래스로더
    private ClassLoader gameClassLoader;

    private AccessWidener() {
    }

    public static AccessWidener getInstance() {
        return INSTANCE;
    }

    /**
     * 게임 클래스로더 설정
     */
    public static void setGameClassLoader(ClassLoader loader) {
        INSTANCE.gameClassLoader = loader;
    }

    // ─────────────────────────────────────────────────────────────
    // 클래스 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * 클래스 가져오기
     */
    public static Class<?> getClass(String className) {
        return INSTANCE.loadClass(className);
    }

    private Class<?> loadClass(String className) {
        return classCache.computeIfAbsent(className, name -> {
            try {
                ClassLoader loader = gameClassLoader != null ? gameClassLoader : ClassLoader.getSystemClassLoader();
                return loader.loadClass(name);
            } catch (ClassNotFoundException e) {
                PulseLogger.error(LOG, "[Access] Class not found: {}", name);
                return null;
            }
        });
    }

    // ─────────────────────────────────────────────────────────────
    // 필드 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * 필드 값 가져오기
     */
    public static Object getField(Object instance, String fieldName) {
        return INSTANCE.getFieldValue(instance, fieldName);
    }

    /**
     * 정적 필드 값 가져오기
     */
    public static Object getStaticField(Class<?> clazz, String fieldName) {
        return INSTANCE.getFieldValue(clazz, null, fieldName);
    }

    /**
     * 정적 필드 값 가져오기 (클래스명)
     */
    public static Object getStaticField(String className, String fieldName) {
        Class<?> clazz = getClass(className);
        if (clazz == null)
            return null;
        return INSTANCE.getFieldValue(clazz, null, fieldName);
    }

    /**
     * 필드 값 설정
     */
    public static void setField(Object instance, String fieldName, Object value) {
        INSTANCE.setFieldValue(instance, fieldName, value);
    }

    /**
     * 정적 필드 값 설정
     */
    public static void setStaticField(Class<?> clazz, String fieldName, Object value) {
        INSTANCE.setFieldValue(clazz, null, fieldName, value);
    }

    private Object getFieldValue(Object instance, String fieldName) {
        if (instance == null)
            return null;
        return getFieldValue(instance.getClass(), instance, fieldName);
    }

    private Object getFieldValue(Class<?> clazz, Object instance, String fieldName) {
        Field field = findField(clazz, fieldName);
        if (field == null)
            return null;

        try {
            return field.get(instance);
        } catch (IllegalAccessException e) {
            PulseLogger.error(LOG, "[Access] Cannot access field: {}", fieldName);
            return null;
        }
    }

    private void setFieldValue(Object instance, String fieldName, Object value) {
        if (instance == null)
            return;
        setFieldValue(instance.getClass(), instance, fieldName, value);
    }

    private void setFieldValue(Class<?> clazz, Object instance, String fieldName, Object value) {
        Field field = findField(clazz, fieldName);
        if (field == null)
            return;

        try {
            // final 필드도 수정 가능하게
            if (Modifier.isFinal(field.getModifiers())) {
                Field modifiersField = Field.class.getDeclaredField("modifiers");
                modifiersField.setAccessible(true);
                modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
            }
            field.set(instance, value);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Access] Cannot set field: {}", fieldName);
        }
    }

    private Field findField(Class<?> clazz, String fieldName) {
        String key = clazz.getName() + "#" + fieldName;
        return fieldCache.computeIfAbsent(key, k -> {
            Class<?> current = clazz;
            while (current != null) {
                try {
                    Field field = current.getDeclaredField(fieldName);
                    field.setAccessible(true);
                    return field;
                } catch (NoSuchFieldException e) {
                    current = current.getSuperclass();
                }
            }
            PulseLogger.error(LOG, "[Access] Field not found: {}", fieldName);
            return null;
        });
    }

    // ─────────────────────────────────────────────────────────────
    // 메서드 호출
    // ─────────────────────────────────────────────────────────────

    /**
     * 메서드 호출
     */
    public static Object invoke(Object instance, String methodName, Object... args) {
        return INSTANCE.invokeMethod(instance, methodName, args);
    }

    /**
     * 정적 메서드 호출
     */
    public static Object invokeStatic(Class<?> clazz, String methodName, Object... args) {
        return INSTANCE.invokeMethod(clazz, null, methodName, args);
    }

    /**
     * 정적 메서드 호출 (클래스명)
     */
    public static Object invokeStatic(String className, String methodName, Object... args) {
        Class<?> clazz = getClass(className);
        if (clazz == null)
            return null;
        return INSTANCE.invokeMethod(clazz, null, methodName, args);
    }

    private Object invokeMethod(Object instance, String methodName, Object... args) {
        if (instance == null)
            return null;
        return invokeMethod(instance.getClass(), instance, methodName, args);
    }

    private Object invokeMethod(Class<?> clazz, Object instance, String methodName, Object... args) {
        Method method = findMethod(clazz, methodName, args);
        if (method == null)
            return null;

        try {
            return method.invoke(instance, args);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Access] Cannot invoke method: {}", methodName, e);
            return null;
        }
    }

    private Method findMethod(Class<?> clazz, String methodName, Object... args) {
        // 간단한 캐시 키 생성
        StringBuilder keyBuilder = new StringBuilder(clazz.getName());
        keyBuilder.append("#").append(methodName).append("(");
        for (Object arg : args) {
            if (arg != null) {
                keyBuilder.append(arg.getClass().getName()).append(",");
            } else {
                keyBuilder.append("null,");
            }
        }
        keyBuilder.append(")");
        String key = keyBuilder.toString();

        return methodCache.computeIfAbsent(key, k -> {
            Class<?> current = clazz;
            while (current != null) {
                for (Method method : current.getDeclaredMethods()) {
                    if (method.getName().equals(methodName) &&
                            isCompatible(method.getParameterTypes(), args)) {
                        method.setAccessible(true);
                        return method;
                    }
                }
                current = current.getSuperclass();
            }
            PulseLogger.error(LOG, "[Access] Method not found: {}", methodName);
            return null;
        });

    }

    private boolean isCompatible(Class<?>[] paramTypes, Object[] args) {
        if (paramTypes.length != args.length)
            return false;
        for (int i = 0; i < paramTypes.length; i++) {
            if (args[i] != null && !isAssignable(paramTypes[i], args[i].getClass())) {
                return false;
            }
        }
        return true;
    }

    private boolean isAssignable(Class<?> target, Class<?> source) {
        if (target.isAssignableFrom(source))
            return true;
        // 기본형 처리
        if (target.isPrimitive()) {
            if (target == int.class && source == Integer.class)
                return true;
            if (target == long.class && source == Long.class)
                return true;
            if (target == double.class && source == Double.class)
                return true;
            if (target == float.class && source == Float.class)
                return true;
            if (target == boolean.class && source == Boolean.class)
                return true;
            if (target == byte.class && source == Byte.class)
                return true;
            if (target == short.class && source == Short.class)
                return true;
            if (target == char.class && source == Character.class)
                return true;
        }
        return false;
    }

    // ─────────────────────────────────────────────────────────────
    // 생성자
    // ─────────────────────────────────────────────────────────────

    /**
     * 인스턴스 생성
     */
    public static Object newInstance(String className, Object... args) {
        Class<?> clazz = getClass(className);
        if (clazz == null)
            return null;
        return INSTANCE.createInstance(clazz, args);
    }

    /**
     * 인스턴스 생성
     */
    public static Object newInstance(Class<?> clazz, Object... args) {
        return INSTANCE.createInstance(clazz, args);
    }

    private Object createInstance(Class<?> clazz, Object... args) {
        try {
            if (args.length == 0) {
                Constructor<?> constructor = clazz.getDeclaredConstructor();
                constructor.setAccessible(true);
                return constructor.newInstance();
            }

            // 적합한 생성자 찾기
            for (Constructor<?> constructor : clazz.getDeclaredConstructors()) {
                if (isCompatible(constructor.getParameterTypes(), args)) {
                    constructor.setAccessible(true);
                    return constructor.newInstance(args);
                }
            }

            PulseLogger.error(LOG, "[Access] No matching constructor found");
            return null;
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Access] Cannot create instance of: {}", clazz.getName(), e);
            return null;
        }
    }

    /**
     * 캐시 비우기
     */
    public static void clearCache() {
        INSTANCE.classCache.clear();
        INSTANCE.fieldCache.clear();
        INSTANCE.methodCache.clear();
        INSTANCE.constructorCache.clear();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\adapter\lua\Build41LuaAdapter.java =====

package com.pulse.adapter.lua;

import com.pulse.api.version.GameVersion;
import com.pulse.internal.InternalLuaHook;

/**
 * Build 41 전용 Lua 시스템 어댑터.
 * 
 * Build 41의 LuaEventManager, LuaManager 클래스 구조를 기반으로 구현.
 * 
 * Build 41 Lua 특징:
 * - zombie.Lua.LuaEventManager.triggerEvent() (0~8 인자 오버로드)
 * - zombie.Lua.LuaManager.GlobalLua (글로벌 환경)
 * 
 * @since Pulse 1.4
 */
public class Build41LuaAdapter implements ILuaAdapter {

    private static final String EVENT_MANAGER_CLASS = "zombie.Lua.LuaEventManager";
    private static final String LUA_MANAGER_CLASS = "zombie.Lua.LuaManager";
    private static final int MAX_TRIGGER_EVENT_ARGS = 8;

    // 캐시된 클래스
    private Class<?> luaManagerClass;
    private Object globalLuaEnv;
    private boolean initialized = false;

    // ═══════════════════════════════════════════════════════════════
    // IVersionAdapter Implementation
    // ═══════════════════════════════════════════════════════════════

    @Override
    public int getSupportedBuild() {
        return GameVersion.BUILD_41;
    }

    @Override
    public boolean isCompatible() {
        try {
            Class.forName(EVENT_MANAGER_CLASS);
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }

    @Override
    public String getName() {
        return "Build41LuaAdapter";
    }

    // ═══════════════════════════════════════════════════════════════
    // ILuaAdapter Implementation
    // ═══════════════════════════════════════════════════════════════

    @Override
    public String getEventManagerClassName() {
        return EVENT_MANAGER_CLASS;
    }

    @Override
    public String getLuaManagerClassName() {
        return LUA_MANAGER_CLASS;
    }

    @Override
    public int getMaxTriggerEventArgs() {
        return MAX_TRIGGER_EVENT_ARGS;
    }

    @Override
    public void onEventStart(String eventName) {
        // InternalLuaHook에 위임 (기존 로직 유지)
        InternalLuaHook.fireEventStart(eventName);
    }

    @Override
    public void onEventEnd() {
        // InternalLuaHook에 위임 (기존 로직 유지)
        InternalLuaHook.fireEventEnd();
    }

    @Override
    public boolean hasGlobalLuaAccess() {
        ensureInitialized();
        return globalLuaEnv != null;
    }

    @Override
    public Object getGlobalLuaValue(String name) {
        try {
            ensureInitialized();
            if (globalLuaEnv == null)
                return null;

            // LuaManager.GlobalLua.rawget(name) 호출
            java.lang.reflect.Method rawgetMethod = globalLuaEnv.getClass().getMethod("rawget", Object.class);
            return rawgetMethod.invoke(globalLuaEnv, name);
        } catch (Throwable t) {
            return null;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Internal Helpers
    // ═══════════════════════════════════════════════════════════════

    private void ensureInitialized() {
        if (initialized)
            return;

        try {
            luaManagerClass = Class.forName(LUA_MANAGER_CLASS);

            // GlobalLua 필드 접근
            java.lang.reflect.Field globalField = luaManagerClass.getField("GlobalLua");
            globalLuaEnv = globalField.get(null);

            initialized = true;
        } catch (Throwable t) {
            System.err.println("[Pulse/Build41LuaAdapter] Init failed: " + t.getMessage());
            initialized = true; // 재시도 방지
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\adapter\lua\Build42LuaAdapter.java =====

package com.pulse.adapter.lua;

import com.pulse.api.version.GameVersion;

/**
 * Build 42+ 전용 Lua 시스템 어댑터.
 * 
 * Build 42 출시 후 구현 예정입니다.
 * 현재는 Build41LuaAdapter를 상속받아 동일하게 동작합니다.
 * 
 * Build 42에서 변경될 수 있는 사항:
 * - Lua 엔진 변경 (Kahlua → ?)
 * - 패키지 구조 변경
 * - 새로운 이벤트 시스템
 * 
 * @since Pulse 1.4
 */
public class Build42LuaAdapter extends Build41LuaAdapter {

    @Override
    public int getSupportedBuild() {
        return GameVersion.BUILD_42;
    }

    @Override
    public String getName() {
        return "Build42LuaAdapter";
    }

    @Override
    public boolean isCompatible() {
        // Build 42 전용 Lua 클래스 확인
        try {
            return false; // 아직 출시되지 않음
        } catch (Exception e) {
            return false;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\adapter\lua\ILuaAdapter.java =====

package com.pulse.adapter.lua;

import com.pulse.api.version.IVersionAdapter;

/**
 * Lua 시스템 관련 버전별 API 추상화 인터페이스.
 * 
 * LuaEventManager, LuaManager 클래스의 메서드에 접근하는
 * 표준화된 방법을 제공합니다.
 * 
 * @since Pulse 1.4
 */
public interface ILuaAdapter extends IVersionAdapter {

    // ═══════════════════════════════════════════════════════════════
    // Class Information
    // ═══════════════════════════════════════════════════════════════

    /**
     * LuaEventManager 클래스의 전체 경로 반환.
     * 
     * @return 패키지 포함 클래스명 (예: "zombie.Lua.LuaEventManager")
     */
    String getEventManagerClassName();

    /**
     * LuaManager 클래스의 전체 경로 반환.
     * 
     * @return 패키지 포함 클래스명 (예: "zombie.Lua.LuaManager")
     */
    String getLuaManagerClassName();

    // ═══════════════════════════════════════════════════════════════
    // Event System
    // ═══════════════════════════════════════════════════════════════

    /**
     * triggerEvent 메서드의 최대 인자 개수 반환.
     * 
     * Mixin에서 어떤 오버로드까지 후킹해야 하는지 결정에 사용.
     * 
     * @return 최대 인자 개수 (Build 41: 8)
     */
    int getMaxTriggerEventArgs();

    /**
     * 이벤트 시작 처리.
     * 
     * @param eventName 이벤트 이름
     */
    void onEventStart(String eventName);

    /**
     * 이벤트 종료 처리.
     */
    void onEventEnd();

    // ═══════════════════════════════════════════════════════════════
    // Lua State Access
    // ═══════════════════════════════════════════════════════════════

    /**
     * GlobalLua 환경 접근 가능 여부.
     * 
     * @return 접근 가능하면 true
     */
    boolean hasGlobalLuaAccess();

    /**
     * Lua 글로벌 변수 값 조회.
     * 
     * @param name 변수 이름
     * @return 값 (없으면 null)
     */
    Object getGlobalLuaValue(String name);
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\adapter\lua\LuaAdapterProvider.java =====

package com.pulse.adapter.lua;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.version.GameVersion;

/**
 * Lua 어댑터 제공자.
 * 
 * 현재 게임 버전에 맞는 ILuaAdapter를 반환합니다.
 * 
 * @since Pulse 1.4
 */
public final class LuaAdapterProvider {

    private static volatile ILuaAdapter instance;
    private static final Object LOCK = new Object();

    private LuaAdapterProvider() {
    }

    /**
     * 현재 게임 버전에 맞는 어댑터 반환.
     * 
     * @return ILuaAdapter 구현체
     */
    public static ILuaAdapter get() {
        if (instance == null) {
            synchronized (LOCK) {
                if (instance == null) {
                    instance = createAdapter();
                }
            }
        }
        return instance;
    }

    /**
     * 어댑터 초기화 (테스트용).
     */
    public static void reset() {
        synchronized (LOCK) {
            instance = null;
        }
    }

    /**
     * 어댑터 수동 설정 (테스트용).
     */
    public static void override(ILuaAdapter adapter) {
        synchronized (LOCK) {
            instance = adapter;
            PulseLogger.info("Pulse/LuaAdapterProvider", "Overridden with: " + adapter.getName());
        }
    }

    private static ILuaAdapter createAdapter() {
        int version = GameVersion.get();

        ILuaAdapter adapter;

        if (version >= GameVersion.BUILD_42) {
            Build42LuaAdapter b42 = new Build42LuaAdapter();
            if (b42.isCompatible()) {
                adapter = b42;
                PulseLogger.info("Pulse/LuaAdapterProvider", "Using Build42LuaAdapter");
            } else {
                adapter = new Build41LuaAdapter();
                PulseLogger.info("Pulse/LuaAdapterProvider", "Build 42 not compatible, using Build41LuaAdapter");
            }
        } else {
            adapter = new Build41LuaAdapter();
            PulseLogger.info("Pulse/LuaAdapterProvider", "Using Build41LuaAdapter");
        }

        return adapter;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\adapter\zombie\Build41ZombieAdapter.java =====

package com.pulse.adapter.zombie;

import com.pulse.api.version.GameVersion;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;

/**
 * Build 41 전용 IsoZombie 어댑터.
 * 
 * Build 41의 IsoZombie 클래스 구조를 기반으로 구현되어 있습니다.
 * classcodes/IsoZombie.txt 참고.
 * 
 * 주요 메서드:
 * - getOnlineID(): short 반환
 * - getID(): Object ID
 * - getTarget(): IsoMovingObject
 * - isAttacking(): boolean
 * - getX(), getY(), getZ(): float
 * 
 * @since Pulse 1.4
 */
public class Build41ZombieAdapter implements IZombieAdapter {

    private static final String LOG = "[Pulse/Build41ZombieAdapter]";

    // 캐시된 메서드 (성능 최적화)
    private Method methodGetOnlineID;
    private Method methodGetID;
    private Method methodGetX;
    private Method methodGetY;
    private Method methodGetZ;
    private Method methodIsAttacking;
    private Method methodGetTarget;
    private Method methodIsCrawling;
    private Method methodIsOnFloor;
    private Method methodGetHitTime;

    // 플레이어 클래스 캐시
    private Class<?> playerClass;
    private Field playersField;

    private boolean initialized = false;

    // ═══════════════════════════════════════════════════════════════
    // IVersionAdapter Implementation
    // ═══════════════════════════════════════════════════════════════

    @Override
    public int getSupportedBuild() {
        return GameVersion.BUILD_41;
    }

    @Override
    public boolean isCompatible() {
        try {
            Class.forName("zombie.characters.IsoZombie");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }

    @Override
    public String getName() {
        return "Build41ZombieAdapter";
    }

    // ═══════════════════════════════════════════════════════════════
    // IZombieAdapter Implementation
    // ═══════════════════════════════════════════════════════════════

    @Override
    public int getZombieId(Object zombie) {
        // MP first: getOnlineID()
        int onlineId = getOnlineId(zombie);
        if (onlineId > 0) {
            return onlineId;
        }

        // SP fallback: getID()
        int localId = getLocalId(zombie);
        if (localId > 0) {
            return localId;
        }

        // Final fallback
        return System.identityHashCode(zombie);
    }

    @Override
    public int getOnlineId(Object zombie) {
        try {
            ensureInitialized(zombie);
            if (methodGetOnlineID != null) {
                Object result = methodGetOnlineID.invoke(zombie);
                if (result instanceof Number) {
                    return ((Number) result).intValue();
                }
            }
        } catch (Throwable t) {
            // Silently fail
        }
        return -1;
    }

    @Override
    public int getLocalId(Object zombie) {
        try {
            ensureInitialized(zombie);
            if (methodGetID != null) {
                Object result = methodGetID.invoke(zombie);
                if (result instanceof Number) {
                    return ((Number) result).intValue();
                }
            }
        } catch (Throwable t) {
            // Silently fail
        }
        return -1;
    }

    @Override
    public float getX(Object zombie) {
        return invokeFloatMethod(zombie, methodGetX, "getX", 0f);
    }

    @Override
    public float getY(Object zombie) {
        return invokeFloatMethod(zombie, methodGetY, "getY", 0f);
    }

    @Override
    public float getZ(Object zombie) {
        return invokeFloatMethod(zombie, methodGetZ, "getZ", 0f);
    }

    @Override
    public float getDistanceSquaredToNearestPlayer(Object zombie) {
        try {
            ensureInitialized(zombie);

            float zx = getX(zombie);
            float zy = getY(zombie);

            if (playerClass == null || playersField == null) {
                return Float.MAX_VALUE;
            }

            ArrayList<?> players = (ArrayList<?>) playersField.get(null);

            if (players == null || players.isEmpty()) {
                return Float.MAX_VALUE;
            }

            float minDistSq = Float.MAX_VALUE;
            for (Object player : players) {
                if (player == null)
                    continue;

                float px = invokeFloatMethod(player, null, "getX", 0f);
                float py = invokeFloatMethod(player, null, "getY", 0f);

                float dx = zx - px;
                float dy = zy - py;
                float distSq = dx * dx + dy * dy;

                if (distSq < minDistSq) {
                    minDistSq = distSq;
                }
            }
            return minDistSq;
        } catch (Throwable t) {
            return Float.MAX_VALUE;
        }
    }

    @Override
    public boolean isAttacking(Object zombie) {
        return invokeBooleanMethod(zombie, methodIsAttacking, "isAttacking", false);
    }

    @Override
    public boolean hasTarget(Object zombie) {
        return getTarget(zombie) != null;
    }

    @Override
    public Object getTarget(Object zombie) {
        try {
            ensureInitialized(zombie);
            if (methodGetTarget != null) {
                return methodGetTarget.invoke(zombie);
            }
        } catch (Throwable t) {
            // Silently fail
        }
        return null;
    }

    @Override
    public boolean isCrawler(Object zombie) {
        return invokeBooleanMethod(zombie, methodIsCrawling, "isCrawling", false);
    }

    @Override
    public boolean isOnFloor(Object zombie) {
        return invokeBooleanMethod(zombie, methodIsOnFloor, "isOnFloor", false);
    }

    @Override
    public int getHitTime(Object zombie) {
        return invokeIntMethod(zombie, methodGetHitTime, "getHitTime", 0);
    }

    // ═══════════════════════════════════════════════════════════════
    // Internal Helpers
    // ═══════════════════════════════════════════════════════════════

    private void ensureInitialized(Object zombie) {
        if (initialized)
            return;

        try {
            Class<?> zombieClass = zombie.getClass();

            // Method 캐싱
            methodGetOnlineID = findMethod(zombieClass, "getOnlineID");
            methodGetID = findMethod(zombieClass, "getID");
            methodGetX = findMethod(zombieClass, "getX");
            methodGetY = findMethod(zombieClass, "getY");
            methodGetZ = findMethod(zombieClass, "getZ");
            methodIsAttacking = findMethod(zombieClass, "isAttacking");
            methodGetTarget = findMethod(zombieClass, "getTarget");
            methodIsCrawling = findMethod(zombieClass, "isCrawling");
            methodIsOnFloor = findMethod(zombieClass, "isOnFloor");
            methodGetHitTime = findMethod(zombieClass, "getHitTime");

            // 플레이어 클래스 캐싱
            playerClass = Class.forName("zombie.characters.IsoPlayer");
            playersField = playerClass.getField("players");

            initialized = true;
        } catch (Throwable t) {
            System.err.println(LOG + " Failed to initialize: " + t.getMessage());
        }
    }

    private Method findMethod(Class<?> clazz, String name) {
        try {
            Method m = clazz.getMethod(name);
            m.setAccessible(true);
            return m;
        } catch (NoSuchMethodException e) {
            return null;
        }
    }

    private float invokeFloatMethod(Object obj, Method cached, String methodName, float fallback) {
        try {
            Method m = cached;
            if (m == null) {
                m = obj.getClass().getMethod(methodName);
            }
            Object result = m.invoke(obj);
            if (result instanceof Number) {
                return ((Number) result).floatValue();
            }
        } catch (Throwable t) {
            // Silently fail
        }
        return fallback;
    }

    private boolean invokeBooleanMethod(Object obj, Method cached, String methodName, boolean fallback) {
        try {
            Method m = cached;
            if (m == null) {
                m = obj.getClass().getMethod(methodName);
            }
            Object result = m.invoke(obj);
            if (result instanceof Boolean) {
                return (Boolean) result;
            }
        } catch (Throwable t) {
            // Silently fail
        }
        return fallback;
    }

    private int invokeIntMethod(Object obj, Method cached, String methodName, int fallback) {
        try {
            Method m = cached;
            if (m == null) {
                m = obj.getClass().getMethod(methodName);
            }
            Object result = m.invoke(obj);
            if (result instanceof Number) {
                return ((Number) result).intValue();
            }
        } catch (Throwable t) {
            // Silently fail
        }
        return fallback;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\adapter\zombie\Build42ZombieAdapter.java =====

package com.pulse.adapter.zombie;

import com.pulse.api.version.GameVersion;

/**
 * Build 42+ 전용 IsoZombie 어댑터.
 * 
 * Build 42 출시 후 구현 예정입니다.
 * 현재는 Build41ZombieAdapter를 상속받아 동일하게 동작합니다.
 * 
 * Build 42에서 변경될 수 있는 사항:
 * - 엔진 리팩토링으로 인한 메서드 이름/시그니처 변경
 * - 새로운 최적화 API 추가
 * - 패키지 구조 변경
 * 
 * @since Pulse 1.4
 */
public class Build42ZombieAdapter extends Build41ZombieAdapter {

    @Override
    public int getSupportedBuild() {
        return GameVersion.BUILD_42;
    }

    @Override
    public String getName() {
        return "Build42ZombieAdapter";
    }

    @Override
    public boolean isCompatible() {
        // Build 42 전용 클래스 확인
        try {
            return false; // 아직 출시되지 않음
        } catch (Exception e) {
            return false;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\adapter\zombie\IZombieAdapter.java =====

package com.pulse.adapter.zombie;

import com.pulse.api.version.IVersionAdapter;

/**
 * IsoZombie 관련 버전별 API 추상화 인터페이스.
 * 
 * IsoZombie 클래스의 메서드에 접근하는 표준화된 방법을 제공합니다.
 * 각 빌드 버전별로 다른 구현을 제공하여 버전 호환성을 보장합니다.
 * 
 * 사용 예:
 * 
 * <pre>
 * IZombieAdapter adapter = ZombieAdapterProvider.get();
 * int id = adapter.getZombieId(zombieInstance);
 * float dist = adapter.getDistanceToNearestPlayer(zombieInstance);
 * </pre>
 * 
 * @since Pulse 1.4
 */
public interface IZombieAdapter extends IVersionAdapter {

    // ═══════════════════════════════════════════════════════════════
    // Zombie ID Methods
    // ═══════════════════════════════════════════════════════════════

    /**
     * 좀비의 고유 ID를 반환.
     * 
     * MP 환경에서는 서버 동기화된 ID를 반환해야 합니다.
     * 
     * @param zombie IsoZombie 인스턴스
     * @return 좀비 ID (실패 시 hashCode)
     */
    int getZombieId(Object zombie);

    /**
     * 온라인 ID 반환 (MP 전용).
     * 
     * @param zombie IsoZombie 인스턴스
     * @return 온라인 ID, 없으면 -1
     */
    int getOnlineId(Object zombie);

    /**
     * 로컬 ID 반환.
     * 
     * @param zombie IsoZombie 인스턴스
     * @return 로컬 ID
     */
    int getLocalId(Object zombie);

    // ═══════════════════════════════════════════════════════════════
    // Position & Distance Methods
    // ═══════════════════════════════════════════════════════════════

    /**
     * 좀비의 X 좌표 반환.
     */
    float getX(Object zombie);

    /**
     * 좀비의 Y 좌표 반환.
     */
    float getY(Object zombie);

    /**
     * 좀비의 Z 좌표 반환.
     */
    float getZ(Object zombie);

    /**
     * 가장 가까운 플레이어와의 거리 제곱 반환.
     * 
     * @param zombie IsoZombie 인스턴스
     * @return 거리 제곱 (플레이어 없으면 MAX_VALUE)
     */
    float getDistanceSquaredToNearestPlayer(Object zombie);

    // ═══════════════════════════════════════════════════════════════
    // State Methods
    // ═══════════════════════════════════════════════════════════════

    /**
     * 좀비가 공격 중인지 확인.
     * 
     * @param zombie IsoZombie 인스턴스
     * @return 공격 중이면 true
     */
    boolean isAttacking(Object zombie);

    /**
     * 좀비가 타겟을 가지고 있는지 확인.
     * 
     * @param zombie IsoZombie 인스턴스
     * @return 타겟이 있으면 true
     */
    boolean hasTarget(Object zombie);

    /**
     * 좀비의 현재 타겟 반환.
     * 
     * @param zombie IsoZombie 인스턴스
     * @return 타겟 객체 (IsoMovingObject), 없으면 null
     */
    Object getTarget(Object zombie);

    /**
     * 좀비가 크롤러인지 확인.
     * 
     * @param zombie IsoZombie 인스턴스
     * @return 크롤러면 true
     */
    boolean isCrawler(Object zombie);

    /**
     * 좀비가 넘어져 있는지 확인.
     * 
     * @param zombie IsoZombie 인스턴스
     * @return 바닥에 있으면 true
     */
    boolean isOnFloor(Object zombie);

    // ═══════════════════════════════════════════════════════════════
    // Engagement Methods (Fuse throttle용)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 최근 피격 여부 확인.
     * 
     * hitTime이 양수이면 최근에 피격된 것으로 판단.
     * hitTime은 피격 후 감소하는 타이머로 추정됨.
     * 
     * @param zombie IsoZombie 인스턴스
     * @return true면 최근 피격됨
     */
    default boolean isRecentlyHit(Object zombie) {
        return getHitTime(zombie) > 0;
    }

    /**
     * hitTime 값 반환.
     * 
     * IsoZombie.getHitTime() 호출.
     * 피격 후 일정 시간 동안 양수로 유지됨.
     * 
     * @param zombie IsoZombie 인스턴스
     * @return hitTime 값 (0 이하면 피격 상태 아님)
     */
    int getHitTime(Object zombie);

    /**
     * 최근 교전 여부 (통합 판정).
     * 
     * 다음 중 하나라도 true면 recentlyEngaged:
     * - isRecentlyHit() == true
     * - hasTarget() == true
     * - isAttacking() == true
     * 
     * @param zombie IsoZombie 인스턴스
     * @return true면 즉시 FULL throttle 적용
     */
    default boolean isRecentlyEngaged(Object zombie) {
        return isRecentlyHit(zombie) || hasTarget(zombie) || isAttacking(zombie);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\adapter\zombie\ZombieAdapterProvider.java =====

package com.pulse.adapter.zombie;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.version.GameVersion;

/**
 * Zombie 어댑터 제공자.
 * 
 * 현재 게임 버전에 맞는 IZombieAdapter를 반환합니다.
 * 싱글톤 패턴으로 한 번만 어댑터를 생성합니다.
 * 
 * 사용 예:
 * 
 * <pre>
 * IZombieAdapter adapter = ZombieAdapterProvider.get();
 * int zombieId = adapter.getZombieId(zombie);
 * </pre>
 * 
 * @since Pulse 1.4
 */
public final class ZombieAdapterProvider {

    private static volatile IZombieAdapter instance;
    private static final Object LOCK = new Object();

    private ZombieAdapterProvider() {
    }

    /**
     * 현재 게임 버전에 맞는 어댑터 반환.
     * 
     * @return IZombieAdapter 구현체
     */
    public static IZombieAdapter get() {
        if (instance == null) {
            synchronized (LOCK) {
                if (instance == null) {
                    instance = createAdapter();
                }
            }
        }
        return instance;
    }

    /**
     * 어댑터 초기화 (테스트용).
     */
    public static void reset() {
        synchronized (LOCK) {
            instance = null;
        }
    }

    /**
     * 어댑터 수동 설정 (테스트용).
     */
    public static void override(IZombieAdapter adapter) {
        synchronized (LOCK) {
            instance = adapter;
            PulseLogger.info("Pulse/ZombieAdapterProvider", "Overridden with: " + adapter.getName());
        }
    }

    private static IZombieAdapter createAdapter() {
        int version = GameVersion.get();

        IZombieAdapter adapter;

        if (version >= GameVersion.BUILD_42) {
            Build42ZombieAdapter b42 = new Build42ZombieAdapter();
            if (b42.isCompatible()) {
                adapter = b42;
                PulseLogger.info("Pulse/ZombieAdapterProvider", "Using Build42ZombieAdapter");
            } else {
                adapter = new Build41ZombieAdapter();
                PulseLogger.info("Pulse/ZombieAdapterProvider", "Build 42 not compatible, using Build41ZombieAdapter");
            }
        } else {
            adapter = new Build41ZombieAdapter();
            PulseLogger.info("Pulse/ZombieAdapterProvider", "Using Build41ZombieAdapter");
        }

        return adapter;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\access\GameStateAccess.java =====

package com.pulse.api.access;

import com.pulse.api.PublicAPI;
import com.pulse.api.util.ReflectionClassCache;

import java.lang.reflect.Method;

/**
 * 게임 상태(GameState) 접근 API.
 * 
 * 현재 게임이 메인 메뉴인지, 게임 중인지 확인할 수 있습니다.
 * Echo에서 세션 관리에 활용합니다.
 * 
 * @since 1.1.1
 */
@PublicAPI(since = "1.1.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class GameStateAccess {

    private GameStateAccess() {
    }

    private static final ReflectionClassCache<Object> gsmCache = new ReflectionClassCache<>(
            "zombie.gameStates.GameStateMachine");

    // 캐시된 상태 (리플렉션 비용 절감)
    private static volatile String lastStateName = null;
    private static volatile long lastCheckTime = 0;
    private static final long CACHE_DURATION_MS = 100; // 100ms 캐시

    /**
     * 클래스 참조 갱신.
     */
    public static void refresh() {
        gsmCache.refresh();
        lastStateName = null;
        lastCheckTime = 0;
    }

    /**
     * 현재 게임 상태 이름 반환.
     * 
     * @return 상태 클래스 단순 이름 (예: "MainScreenState", "IngameState") 또는 null
     */
    public static String getCurrentStateName() {
        long now = System.currentTimeMillis();
        if (lastStateName != null && (now - lastCheckTime) < CACHE_DURATION_MS) {
            return lastStateName;
        }

        try {
            Class<?> gsmClass = gsmCache.get();
            if (gsmClass == null)
                return null;

            // GameStateMachine.instance
            Method instanceMethod = gsmClass.getMethod("instance");
            Object gsm = instanceMethod.invoke(null);
            if (gsm == null)
                return null;

            // getCurrent()
            Method getCurrentMethod = gsmClass.getMethod("getCurrent");
            Object currentState = getCurrentMethod.invoke(gsm);
            if (currentState == null)
                return null;

            lastStateName = currentState.getClass().getSimpleName();
            lastCheckTime = now;
            return lastStateName;
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 현재 게임 중인지 확인.
     * 
     * IngameState일 때 true.
     * 
     * @return 게임 중이면 true
     */
    public static boolean isInGame() {
        String state = getCurrentStateName();
        return "IngameState".equals(state);
    }

    /**
     * 현재 메인 메뉴인지 확인.
     * 
     * MainScreenState일 때 true.
     * 
     * @return 메인 메뉴면 true
     */
    public static boolean isOnMainMenu() {
        String state = getCurrentStateName();
        return "MainScreenState".equals(state);
    }

    /**
     * 게임 중이거나 월드가 로드된 상태인지 확인.
     * 
     * WorldAccess.isWorldLoaded()와 함께 사용하여 더 정확한 상태 감지.
     * 
     * @return 게임 중이고 월드가 로드되었으면 true
     */
    public static boolean isInGameWithWorld() {
        return isInGame() && WorldAccess.isWorldLoaded();
    }

    /**
     * 로딩 중인지 확인.
     * 
     * LoadingQueueState일 때 true.
     * 
     * @return 로딩 중이면 true
     */
    public static boolean isLoading() {
        String state = getCurrentStateName();
        return "LoadingQueueState".equals(state);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\access\NetworkAccess.java =====

package com.pulse.api.access;

import com.pulse.PulseEnvironment;
import com.pulse.api.GameAccess;
import com.pulse.api.util.ReflectionClassCache;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * 네트워크 관련 접근 API.
 * GameAccess에서 분리된 네트워크/게임 상태 전용 유틸리티.
 * 
 * @since 1.1.0
 * @see GameAccess
 */
public final class NetworkAccess {

    private NetworkAccess() {
    }

    // ReflectionClassCache 사용으로 ensureInitialized() 패턴 제거
    private static final ReflectionClassCache<Object> gameClientCache = new ReflectionClassCache<>(
            "zombie.network.GameClient");
    private static final ReflectionClassCache<Object> gameServerCache = new ReflectionClassCache<>(
            "zombie.network.GameServer");
    private static final ReflectionClassCache<Object> coreCache = new ReflectionClassCache<>("zombie.core.Core");

    /**
     * 클래스 참조 갱신.
     */
    public static void refresh() {
        gameClientCache.refresh();
        gameServerCache.refresh();
        coreCache.refresh();
    }

    /**
     * 게임 일시정지 상태인지 확인.
     */
    public static boolean isPaused() {
        Class<?> coreClass = coreCache.get();
        if (coreClass != null) {
            try {
                Method getInstance = coreClass.getMethod("getInstance");
                Object core = getInstance.invoke(null);
                if (core != null) {
                    Method isGamePaused = coreClass.getMethod("isGamePaused");
                    Object result = isGamePaused.invoke(core);
                    if (result instanceof Boolean b) {
                        return b;
                    }
                }
            } catch (Exception e) {
                // 무시
            }
        }

        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null)
                loader = ClassLoader.getSystemClassLoader();
            Class<?> uiManagerClass = loader.loadClass("zombie.ui.UIManager");
            Field suspendField = uiManagerClass.getDeclaredField("bSuspend");
            suspendField.setAccessible(true);
            Object result = suspendField.get(null);
            if (result instanceof Boolean b) {
                return b;
            }
        } catch (Exception e) {
            // 무시
        }

        return false;
    }

    /**
     * 멀티플레이어인지 확인.
     */
    public static boolean isMultiplayer() {
        Class<?> gameClientClass = gameClientCache.get();
        if (gameClientClass != null) {
            try {
                Field bClientField = gameClientClass.getDeclaredField("bClient");
                bClientField.setAccessible(true);
                Object result = bClientField.get(null);
                if (result instanceof Boolean b && b) {
                    return true;
                }
            } catch (Exception e) {
                // 무시
            }
        }

        Class<?> gameServerClass = gameServerCache.get();
        if (gameServerClass != null) {
            try {
                Field bServerField = gameServerClass.getDeclaredField("bServer");
                bServerField.setAccessible(true);
                Object result = bServerField.get(null);
                if (result instanceof Boolean b && b) {
                    return true;
                }
            } catch (Exception e) {
                // 무시
            }
        }

        return false;
    }

    /**
     * 서버인지 확인 (멀티플레이어).
     */
    public static boolean isServer() {
        Class<?> gameServerClass = gameServerCache.get();
        if (gameServerClass != null) {
            try {
                Field bServerField = gameServerClass.getDeclaredField("bServer");
                bServerField.setAccessible(true);
                Object result = bServerField.get(null);
                if (result instanceof Boolean b) {
                    return b;
                }
            } catch (Exception e) {
                // 무시
            }
        }

        return false;
    }

    /**
     * 클라이언트인지 확인 (멀티플레이어).
     */
    public static boolean isClient() {
        Class<?> gameClientClass = gameClientCache.get();
        if (gameClientClass != null) {
            try {
                Field bClientField = gameClientClass.getDeclaredField("bClient");
                bClientField.setAccessible(true);
                Object result = bClientField.get(null);
                if (result instanceof Boolean b) {
                    return b;
                }
            } catch (Exception e) {
                // 무시
            }
        }

        return false;
    }

    /**
     * 싱글플레이어인지 확인.
     */
    public static boolean isSinglePlayer() {
        return !isMultiplayer();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\access\PlayerAccess.java =====

package com.pulse.api.access;

import com.pulse.api.GameAccess;
import com.pulse.api.util.ReflectionClassCache;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * 플레이어 관련 접근 API.
 * GameAccess에서 분리된 플레이어 전용 유틸리티.
 * 
 * @since 1.1.0
 * @see GameAccess
 */
public final class PlayerAccess {

    private PlayerAccess() {
    }

    // ReflectionClassCache 사용으로 ensureInitialized() 패턴 제거
    private static final ReflectionClassCache<Object> isoPlayerCache = new ReflectionClassCache<>(
            "zombie.characters.IsoPlayer");

    /**
     * 클래스 참조 갱신.
     */
    public static void refresh() {
        isoPlayerCache.refresh();
    }

    /**
     * 로컬 플레이어 가져오기.
     */
    public static Object getLocalPlayer() {
        Class<?> isoPlayerClass = isoPlayerCache.get();
        if (isoPlayerClass == null)
            return null;

        try {
            Method getInstance = isoPlayerClass.getMethod("getInstance");
            return getInstance.invoke(null);
        } catch (Exception e) {
            try {
                Field playersField = isoPlayerClass.getDeclaredField("players");
                playersField.setAccessible(true);
                Object players = playersField.get(null);
                if (players instanceof java.util.List<?> list && !list.isEmpty()) {
                    return list.get(0);
                }
            } catch (Exception e2) {
                // 무시
            }
            return null;
        }
    }

    /**
     * 플레이어가 살아있는지 확인.
     */
    public static boolean isPlayerAlive() {
        Object player = getLocalPlayer();
        if (player == null)
            return false;

        try {
            Method isDead = player.getClass().getMethod("isDead");
            Object result = isDead.invoke(player);
            return result instanceof Boolean b && !b;
        } catch (Exception e) {
            return true;
        }
    }

    /**
     * 플레이어 체력 가져오기.
     */
    public static float getPlayerHealth() {
        Object player = getLocalPlayer();
        if (player == null)
            return 0;

        try {
            Method getHealth = player.getClass().getMethod("getHealth");
            Object result = getHealth.invoke(player);
            if (result instanceof Number num) {
                return num.floatValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 플레이어 위치 X.
     */
    public static float getPlayerX() {
        Object player = getLocalPlayer();
        if (player == null)
            return 0;

        try {
            Method getX = player.getClass().getMethod("getX");
            Object result = getX.invoke(player);
            if (result instanceof Number num) {
                return num.floatValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 플레이어 위치 Y.
     */
    public static float getPlayerY() {
        Object player = getLocalPlayer();
        if (player == null)
            return 0;

        try {
            Method getY = player.getClass().getMethod("getY");
            Object result = getY.invoke(player);
            if (result instanceof Number num) {
                return num.floatValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 플레이어 위치 Z (층).
     */
    public static float getPlayerZ() {
        Object player = getLocalPlayer();
        if (player == null)
            return 0;

        try {
            Method getZ = player.getClass().getMethod("getZ");
            Object result = getZ.invoke(player);
            if (result instanceof Number num) {
                return num.floatValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\access\TimeAccess.java =====

package com.pulse.api.access;

import com.pulse.api.GameAccess;
import com.pulse.api.util.ReflectionClassCache;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * 시간 관련 접근 API.
 * GameAccess에서 분리된 시간 전용 유틸리티.
 * 
 * @since 1.1.0
 * @see GameAccess
 */
public final class TimeAccess {

    private TimeAccess() {
    }

    // ReflectionClassCache 사용으로 ensureInitialized() 패턴 제거
    private static final ReflectionClassCache<Object> gameTimeCache = new ReflectionClassCache<>("zombie.GameTime");

    /**
     * 클래스 참조 갱신.
     */
    public static void refresh() {
        gameTimeCache.refresh();
    }

    /**
     * GameTime 인스턴스 가져오기.
     */
    public static Object getGameTimeInstance() {
        Class<?> gameTimeClass = gameTimeCache.get();
        if (gameTimeClass == null)
            return null;

        try {
            Method getInstance = gameTimeClass.getMethod("getInstance");
            return getInstance.invoke(null);
        } catch (Exception e) {
            try {
                Field instanceField = gameTimeClass.getDeclaredField("instance");
                instanceField.setAccessible(true);
                return instanceField.get(null);
            } catch (Exception e2) {
                return null;
            }
        }
    }

    /**
     * 게임 내 시간 (시).
     */
    public static int getGameHour() {
        Object gameTime = getGameTimeInstance();
        if (gameTime == null)
            return 0;

        Class<?> gameTimeClass = gameTimeCache.get();
        try {
            Method getHour = gameTimeClass.getMethod("getHour");
            Object result = getHour.invoke(gameTime);
            if (result instanceof Number num) {
                return num.intValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 게임 내 분.
     */
    public static int getGameMinute() {
        Object gameTime = getGameTimeInstance();
        if (gameTime == null)
            return 0;

        Class<?> gameTimeClass = gameTimeCache.get();
        try {
            Method getMinutes = gameTimeClass.getMethod("getMinutes");
            Object result = getMinutes.invoke(gameTime);
            if (result instanceof Number num) {
                return num.intValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 게임 내 일수.
     */
    public static int getGameDay() {
        Object gameTime = getGameTimeInstance();
        if (gameTime == null)
            return 1;

        Class<?> gameTimeClass = gameTimeCache.get();
        try {
            Method getDay = gameTimeClass.getMethod("getDay");
            Object result = getDay.invoke(gameTime);
            if (result instanceof Number num) {
                return num.intValue();
            }
        } catch (Exception e) {
            try {
                Method getNights = gameTimeClass.getMethod("getNightsSurvived");
                Object result = getNights.invoke(gameTime);
                if (result instanceof Number num) {
                    return num.intValue() + 1;
                }
            } catch (Exception e2) {
                // 무시
            }
        }
        return 1;
    }

    /**
     * 게임 내 월.
     */
    public static int getGameMonth() {
        Object gameTime = getGameTimeInstance();
        if (gameTime == null)
            return 7;

        Class<?> gameTimeClass = gameTimeCache.get();
        try {
            Method getMonth = gameTimeClass.getMethod("getMonth");
            Object result = getMonth.invoke(gameTime);
            if (result instanceof Number num) {
                return num.intValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 7;
    }

    /**
     * 게임 내 연도.
     */
    public static int getGameYear() {
        Object gameTime = getGameTimeInstance();
        if (gameTime == null)
            return 1993;

        Class<?> gameTimeClass = gameTimeCache.get();
        try {
            Method getYear = gameTimeClass.getMethod("getYear");
            Object result = getYear.invoke(gameTime);
            if (result instanceof Number num) {
                return num.intValue();
            }
        } catch (Exception e) {
            // 무시
        }
        return 1993;
    }

    /**
     * 밤인지 확인.
     */
    public static boolean isNight() {
        int hour = getGameHour();
        return hour < 6 || hour >= 21;
    }

    /**
     * 낮인지 확인.
     */
    public static boolean isDay() {
        return !isNight();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\access\WorldAccess.java =====

package com.pulse.api.access;

import com.pulse.api.GameAccess;
import com.pulse.api.util.ReflectionClassCache;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * 월드 관련 접근 API.
 * GameAccess에서 분리된 월드 전용 유틸리티.
 * 
 * @since 1.1.0
 * @see GameAccess
 */
public final class WorldAccess {

    private WorldAccess() {
    }

    // ReflectionClassCache 사용으로 ensureInitialized() 패턴 제거
    private static final ReflectionClassCache<Object> isoWorldCache = new ReflectionClassCache<>("zombie.iso.IsoWorld");

    /**
     * 클래스 참조 갱신.
     */
    public static void refresh() {
        isoWorldCache.refresh();
    }

    /**
     * IsoWorld 인스턴스 가져오기.
     */
    public static Object getIsoWorldInstance() {
        Class<?> isoWorldClass = isoWorldCache.get();
        if (isoWorldClass == null)
            return null;

        try {
            Field instanceField = isoWorldClass.getDeclaredField("instance");
            instanceField.setAccessible(true);
            return instanceField.get(null);
        } catch (Exception e) {
            try {
                Method getInstance = isoWorldClass.getMethod("getInstance");
                return getInstance.invoke(null);
            } catch (Exception e2) {
                return null;
            }
        }
    }

    /**
     * 현재 월드가 로드되었는지 확인.
     * 
     * IsoWorld 인스턴스가 있고 Cell이 존재하는 경우에만 true.
     * 메인 메뉴에서는 IsoWorld 인스턴스가 있어도 Cell이 없으므로 false 반환.
     * 
     * @since 1.1.1 - Cell 존재 여부 추가 확인
     */
    public static boolean isWorldLoaded() {
        Object world = getIsoWorldInstance();
        if (world == null)
            return false;

        // Cell이 없으면 실제 월드가 로드된 것이 아님 (메인 메뉴일 수 있음)
        return getCurrentCell() != null;
    }

    /**
     * 현재 월드 이름.
     */
    public static String getWorldName() {
        Object world = getIsoWorldInstance();
        if (world == null)
            return "";

        Class<?> isoWorldClass = isoWorldCache.get();
        if (isoWorldClass == null)
            return "";

        try {
            Method getWorld = isoWorldClass.getMethod("getWorld");
            Object result = getWorld.invoke(world);
            return result != null ? result.toString() : "";
        } catch (Exception e) {
            return "";
        }
    }

    /**
     * 특정 좌표의 IsoGridSquare 가져오기.
     */
    public static Object getSquare(int x, int y, int z) {
        Object world = getIsoWorldInstance();
        if (world == null)
            return null;

        Class<?> isoWorldClass = isoWorldCache.get();
        if (isoWorldClass == null)
            return null;

        try {
            Object cell = isoWorldClass.getMethod("getCell").invoke(world);
            if (cell == null)
                return null;
            Method getGridSquare = cell.getClass().getMethod("getGridSquare", int.class, int.class, int.class);
            return getGridSquare.invoke(cell, x, y, z);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 현재 IsoCell 가져오기.
     */
    public static Object getCurrentCell() {
        Object world = getIsoWorldInstance();
        if (world == null)
            return null;

        Class<?> isoWorldClass = isoWorldCache.get();
        if (isoWorldClass == null)
            return null;

        try {
            return isoWorldClass.getMethod("getCell").invoke(world);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 로드된 청크(Cell) 개수.
     */
    public static int getLoadedCellCount() {
        Object cell = getCurrentCell();
        if (cell == null)
            return 0;
        try {
            Method getChunkList = cell.getClass().getMethod("getChunkList");
            Object list = getChunkList.invoke(cell);
            if (list instanceof java.util.List<?> l) {
                return l.size();
            }
        } catch (Exception e) {
            // ignore
        }
        return 0;
    }

    /**
     * 전체 엔티티 개수 (좀비 포함).
     */
    public static int getTotalEntityCount() {
        Object cell = getCurrentCell();
        if (cell == null)
            return 0;
        try {
            Method getObjectList = cell.getClass().getMethod("getObjectList");
            Object list = getObjectList.invoke(cell);
            if (list instanceof java.util.List<?> l) {
                return l.size();
            }
        } catch (Exception e) {
            // ignore
        }
        return 0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\access\ZombieAccess.java =====

package com.pulse.api.access;

import com.pulse.api.GameAccess;
import com.pulse.api.util.ReflectionClassCache;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

/**
 * 좀비 관련 접근 API.
 * GameAccess에서 분리된 좀비 전용 유틸리티.
 * 
 * @since 1.1.0
 * @see GameAccess
 */
public final class ZombieAccess {

    private ZombieAccess() {
    }

    private static final ReflectionClassCache<Object> isoWorldCache = new ReflectionClassCache<>("zombie.iso.IsoWorld");

    public static void refresh() {
        isoWorldCache.refresh();
    }

    /**
     * 특정 위치 주변의 좀비 목록 가져오기
     */
    public static List<Object> getNearbyZombies(float x, float y, float radius) {
        List<Object> result = new ArrayList<>();

        try {
            Object world = WorldAccess.getIsoWorldInstance();
            if (world == null)
                return result;

            Class<?> isoWorldClass = isoWorldCache.get();
            if (isoWorldClass == null)
                return result;

            Method getCellMethod = isoWorldClass.getMethod("getCell");
            Object cell = getCellMethod.invoke(world);
            if (cell == null)
                return result;

            Method getZombieListMethod = cell.getClass().getMethod("getZombieList");
            Object zombieList = getZombieListMethod.invoke(cell);

            if (zombieList instanceof List<?> list) {
                for (Object zombie : list) {
                    if (zombie == null)
                        continue;
                    try {
                        Method getX = zombie.getClass().getMethod("getX");
                        Method getY = zombie.getClass().getMethod("getY");
                        float zx = ((Number) getX.invoke(zombie)).floatValue();
                        float zy = ((Number) getY.invoke(zombie)).floatValue();

                        float dx = zx - x;
                        float dy = zy - y;
                        if (dx * dx + dy * dy <= radius * radius) {
                            result.add(zombie);
                        }
                    } catch (Exception e) {
                        // 개별 좀비 처리 실패 무시
                    }
                }
            }
        } catch (Exception e) {
            // 무시
        }

        return result;
    }

    /**
     * 현재 셀의 모든 좀비 목록 가져오기
     */
    public static List<Object> getAllZombies() {
        List<Object> result = new ArrayList<>();

        try {
            Object world = WorldAccess.getIsoWorldInstance();
            if (world == null)
                return result;

            Class<?> isoWorldClass = isoWorldCache.get();
            if (isoWorldClass == null)
                return result;

            Method getCellMethod = isoWorldClass.getMethod("getCell");
            Object cell = getCellMethod.invoke(world);
            if (cell == null)
                return result;

            Method getZombieListMethod = cell.getClass().getMethod("getZombieList");
            Object zombieList = getZombieListMethod.invoke(cell);

            if (zombieList instanceof List<?> list) {
                for (Object zombie : list) {
                    if (zombie != null) {
                        result.add(zombie);
                    }
                }
            }
        } catch (Exception e) {
            // 무시
        }

        return result;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\CapabilityFlags.java =====

package com.pulse.api;

import com.pulse.api.log.PulseLogger;

import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Pulse 기능 지원 여부 체크 API.
 * Fuse/Nerve 등 모드가 런타임에 Pulse 버전과 기능 지원 여부를 확인할 수 있습니다.
 * 
 * <pre>
 * // 사용 예시
 * if (CapabilityFlags.supports(CapabilityFlags.LUA_BUDGET)) {
 *     // LuaBudgetManager 사용 가능
 *     LuaBudgetManager.getInstance().setBudget("mymod.tick", 5000);
 * }
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1")
public final class CapabilityFlags {
    private static final String LOG = PulseLogger.PULSE;

    // ═══════════════════════════════════════════════════════════════
    // 기본 제공 기능 상수
    // ═══════════════════════════════════════════════════════════════

    /** OptimizationPoint 시스템 지원 */
    public static final String OPTIMIZATION_POINT = "PULSE_OPTIMIZATION_POINT";

    /** LuaBridge V2 (확장 API) 지원 */
    public static final String LUA_BRIDGE_V2 = "LUA_BRIDGE_V2";

    /** Mixin Injection Validator 지원 */
    public static final String MIXIN_VALIDATOR = "MIXIN_INJECTION_VALIDATOR";

    /** Lua Budget Manager 지원 */
    public static final String LUA_BUDGET = "LUA_BUDGET_MANAGER";

    /** SafeGameAccess 지원 */
    public static final String SAFE_GAME_ACCESS = "SAFE_GAME_ACCESS";

    /** Echo 프로파일러 통합 */
    public static final String ECHO_INTEGRATION = "ECHO_INTEGRATION";

    /** DevMode 지원 */
    public static final String DEV_MODE = "DEV_MODE";

    // ═══════════════════════════════════════════════════════════════
    // v1.1.0 새 기능 상수 (Fuse/Nerve 지원)
    // ═══════════════════════════════════════════════════════════════

    /** Side API 지원 */
    public static final String SIDE_API = "SIDE_API";

    /** Silent Mode 지원 */
    public static final String SILENT_MODE = "SILENT_MODE";

    /** ProfilerScope 지원 */
    public static final String PROFILER_SCOPE = "PROFILER_SCOPE";

    /** Fail-soft 정책 지원 */
    public static final String FAILSOFT = "FAILSOFT_POLICY";

    /** 버전 호환성 API 지원 */
    public static final String VERSION_COMPAT = "VERSION_COMPATIBILITY";

    /** FeatureFlags 지원 */
    public static final String FEATURE_FLAGS = "FEATURE_FLAGS";

    // ═══════════════════════════════════════════════════════════════
    // 내부 상태
    // ═══════════════════════════════════════════════════════════════

    private static final Set<String> capabilities = ConcurrentHashMap.newKeySet();
    private static volatile boolean initialized = false;

    private CapabilityFlags() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // 초기화
    // ═══════════════════════════════════════════════════════════════

    /**
     * 기능 플래그 초기화 (Pulse 시작 시 자동 호출).
     */
    @InternalAPI
    public static void initialize() {
        if (initialized)
            return;

        // 1.0.1에서 지원하는 모든 기능 등록
        register(OPTIMIZATION_POINT);
        register(LUA_BRIDGE_V2);
        register(MIXIN_VALIDATOR);
        register(LUA_BUDGET);
        register(SAFE_GAME_ACCESS);
        register(DEV_MODE);

        // 1.1.0 추가 기능 (Fuse/Nerve 지원)
        register(SIDE_API);
        register(SILENT_MODE);
        register(PROFILER_SCOPE);
        register(FAILSOFT);
        register(VERSION_COMPAT);
        register(FEATURE_FLAGS);

        // Echo는 별도 모드로 로드되므로 여기서는 등록하지 않음
        // Echo가 로드되면 Echo에서 ECHO_INTEGRATION을 등록

        initialized = true;
        initialized = true;
        PulseLogger.info(LOG, "CapabilityFlags initialized: {} capabilities", capabilities.size());
    }

    // ═══════════════════════════════════════════════════════════════
    // 공개 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 기능 지원 여부 확인.
     * 
     * @param capability 기능 이름 (예: "PULSE_OPTIMIZATION_POINT")
     * @return 지원하면 true
     */
    public static boolean supports(String capability) {
        if (!initialized)
            initialize();
        return capabilities.contains(capability);
    }

    /**
     * 여러 기능이 모두 지원되는지 확인.
     * 
     * @param requiredCapabilities 필요한 기능 목록
     * @return 모두 지원하면 true
     */
    public static boolean supportsAll(String... requiredCapabilities) {
        for (String cap : requiredCapabilities) {
            if (!supports(cap))
                return false;
        }
        return true;
    }

    /**
     * 여러 기능 중 하나라도 지원되는지 확인.
     * 
     * @param capabilities 기능 목록
     * @return 하나라도 지원하면 true
     */
    public static boolean supportsAny(String... capabilities) {
        for (String cap : capabilities) {
            if (supports(cap))
                return true;
        }
        return false;
    }

    /**
     * 지원되는 모든 기능 목록 반환.
     * 
     * @return 불변 Set
     */
    public static Set<String> getAllCapabilities() {
        if (!initialized)
            initialize();
        return Collections.unmodifiableSet(capabilities);
    }

    /**
     * 지원되는 기능 수.
     * 
     * @return 기능 수
     */
    public static int count() {
        if (!initialized)
            initialize();
        return capabilities.size();
    }

    // ═══════════════════════════════════════════════════════════════
    // 내부 API (모드 사용 불가)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 기능 등록 (내부용).
     * 
     * @param capability 기능 이름
     */
    @InternalAPI
    public static void register(String capability) {
        if (capability != null && !capability.isEmpty()) {
            capabilities.add(capability);
        }
    }

    /**
     * 기능 등록 해제 (내부용).
     * 
     * @param capability 기능 이름
     */
    @InternalAPI
    public static void unregister(String capability) {
        capabilities.remove(capability);
    }

    /**
     * 디버그 출력.
     */
    public static void printCapabilities() {
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "  Pulse Capabilities ({})", capabilities.size());
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        for (String cap : capabilities) {
            PulseLogger.info(LOG, "  ✓ {}", cap);
        }
        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\DevMode.java =====

package com.pulse.api;

import com.pulse.api.log.PulseLogger;

/**
 * Pulse DevMode 관리자.
 * 개발 모드 플래그를 관리하고 디버그 기능을 제어.
 * 
 * 활성화 방법:
 * 1. JVM 옵션: -DPulse.devMode=true
 * 2. 코드에서: DevMode.enable()
 * 
 * DevMode가 활성화되면:
 * - 상세한 Mixin 진단 로그 출력
 * - 이벤트 예외 세부 정보 출력
 * - 의존성 문제 추가 정보 출력
 */
public final class DevMode {

    private static final String LOG = PulseLogger.PULSE;

    private static boolean enabled = false;
    private static boolean initialized = false;

    private DevMode() {
    } // 인스턴스화 방지

    // ─────────────────────────────────────────────────────────────
    // 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 시스템 프로퍼티에서 DevMode 상태 초기화
     */
    public static void initialize() {
        if (initialized)
            return;

        // 시스템 프로퍼티 확인
        String devModeProp = System.getProperty("Pulse.devMode", "false");
        enabled = "true".equalsIgnoreCase(devModeProp) || "1".equals(devModeProp);

        if (enabled) {
            PulseLogger.info(LOG, "═══════════════════════════════════════");
            PulseLogger.info(LOG, "DEVELOPER MODE ENABLED");
            PulseLogger.info(LOG, "Additional diagnostics will be shown");
            PulseLogger.info(LOG, "═══════════════════════════════════════");
        }

        initialized = true;
    }

    // ─────────────────────────────────────────────────────────────
    // 상태 관리
    // ─────────────────────────────────────────────────────────────

    /**
     * DevMode 활성화 여부 확인
     */
    public static boolean isEnabled() {
        if (!initialized) {
            initialize();
        }
        return enabled;
    }

    /**
     * DevMode 활성화
     */
    public static void enable() {
        enabled = true;
        if (!initialized) {
            initialized = true;
            initialized = true;
            PulseLogger.info(LOG, "[DevMode] Developer mode enabled programmatically");
        }
    }

    /**
     * DevMode 비활성화
     */
    public static void disable() {
        enabled = false;
    }

    // ─────────────────────────────────────────────────────────────
    // 편의 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * DevMode일 때만 로그 출력
     */
    public static void log(String tag, String message) {
        if (isEnabled()) {
            PulseLogger.info(LOG, "[Debug/{}] {}", tag, message);
        }
    }

    /**
     * DevMode일 때만 실행할 작업
     */
    public static void ifEnabled(Runnable action) {
        if (isEnabled()) {
            action.run();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\dto\OptimizerStatus.java =====

package com.pulse.api.dto;

/**
 * Optimizer 상태 DTO.
 * 
 * <p>
 * Fuse, Nerve 등 최적화 모듈의 상태를 표현합니다.
 * </p>
 * 
 * @param enabled           활성화 여부
 * @param autoOptimize      자동 최적화 활성화 여부
 * @param optimizationLevel 최적화 레벨 (0-10)
 * @param lastUpdateMs      마지막 업데이트 시간 (epoch ms)
 * 
 * @since Pulse 1.6
 */
public record OptimizerStatus(
        boolean enabled,
        boolean autoOptimize,
        int optimizationLevel,
        long lastUpdateMs) {
    /**
     * 비활성화 상태 생성.
     */
    public static OptimizerStatus disabled() {
        return new OptimizerStatus(false, false, 0, 0);
    }

    /**
     * 기본 활성화 상태 생성.
     */
    public static OptimizerStatus defaultEnabled() {
        return new OptimizerStatus(true, true, 5, System.currentTimeMillis());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\dto\TickTiming.java =====

package com.pulse.api.dto;

/**
 * 틱 타이밍 DTO.
 * 
 * <p>
 * 게임 틱의 타이밍 정보를 표현합니다.
 * </p>
 * 
 * @param tickNumber    틱 번호
 * @param durationNanos 틱 처리 시간 (나노초)
 * @param deltaTime     이전 틱과의 시간 차이 (초)
 * 
 * @since Pulse 1.6
 */
public record TickTiming(
        long tickNumber,
        long durationNanos,
        float deltaTime) {
    /**
     * 밀리초 단위 duration 반환.
     */
    public double durationMs() {
        return durationNanos / 1_000_000.0;
    }

    /**
     * FPS 추정값 반환.
     */
    public float estimatedFps() {
        return deltaTime > 0 ? 1.0f / deltaTime : 0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\exception\ConfigurationException.java =====

package com.pulse.api.exception;

/**
 * 설정 관련 예외.
 * 
 * 잘못된 설정값, 설정 파일 파싱 오류 등에 사용.
 */
public class ConfigurationException extends PulseException {

    public ConfigurationException(String message) {
        super(message);
    }

    public ConfigurationException(String message, Throwable cause) {
        super(message, cause);
    }

    /**
     * 잘못된 설정값 예외 생성
     */
    public static ConfigurationException invalidValue(String key, Object value, String reason) {
        return new ConfigurationException(
                String.format("Invalid configuration value for '%s': %s. %s", key, value, reason));
    }

    /**
     * 누락된 필수 설정 예외 생성
     */
    public static ConfigurationException missingRequired(String key) {
        return new ConfigurationException(
                String.format("Required configuration key '%s' is missing.", key));
    }

    /**
     * 설정 파일 파싱 오류
     */
    public static ConfigurationException parseError(String file, Throwable cause) {
        return new ConfigurationException(
                String.format("Failed to parse configuration file: %s", file), cause);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\exception\InitializationException.java =====

package com.pulse.api.exception;

/**
 * 초기화 관련 예외.
 * 
 * 모듈 초기화 실패, 의존성 로드 실패, 환경 설정 오류 등에 사용.
 * 
 * @since 1.1.0
 */
public class InitializationException extends PulseException {

    private final String component;
    private final InitPhase phase;

    /**
     * 초기화 단계
     */
    public enum InitPhase {
        /** 의존성 로드 */
        DEPENDENCY_LOAD,
        /** 설정 읽기 */
        CONFIG_READ,
        /** 서비스 등록 */
        SERVICE_REGISTRATION,
        /** Mixin 적용 */
        MIXIN_APPLY,
        /** 모듈 시작 */
        MODULE_START,
        /** 기타 */
        OTHER
    }

    public InitializationException(String message) {
        super(message);
        this.component = null;
        this.phase = InitPhase.OTHER;
    }

    public InitializationException(String message, Throwable cause) {
        super(message, cause);
        this.component = null;
        this.phase = InitPhase.OTHER;
    }

    public InitializationException(String message, String component, InitPhase phase) {
        super(message);
        this.component = component;
        this.phase = phase;
    }

    public InitializationException(String message, String component, InitPhase phase, Throwable cause) {
        super(message, cause);
        this.component = component;
        this.phase = phase;
    }

    public String getComponent() {
        return component;
    }

    public InitPhase getPhase() {
        return phase;
    }

    // --- 팩토리 메서드 ---

    /**
     * 모듈 초기화 실패
     */
    public static InitializationException moduleStartFailed(String moduleName, Throwable cause) {
        return new InitializationException(
                String.format("Failed to start module '%s': %s", moduleName, cause.getMessage()),
                moduleName, InitPhase.MODULE_START, cause);
    }

    /**
     * 의존성 로드 실패
     */
    public static InitializationException dependencyLoadFailed(String dependency, Throwable cause) {
        return new InitializationException(
                String.format("Failed to load dependency '%s': %s", dependency, cause.getMessage()),
                dependency, InitPhase.DEPENDENCY_LOAD, cause);
    }

    /**
     * 설정 읽기 실패
     */
    public static InitializationException configReadFailed(String configFile, Throwable cause) {
        return new InitializationException(
                String.format("Failed to read configuration '%s': %s", configFile, cause.getMessage()),
                configFile, InitPhase.CONFIG_READ, cause);
    }

    /**
     * 서비스 등록 실패
     */
    public static InitializationException serviceRegistrationFailed(Class<?> serviceClass, Throwable cause) {
        return new InitializationException(
                String.format("Failed to register service '%s': %s", serviceClass.getName(), cause.getMessage()),
                serviceClass.getName(), InitPhase.SERVICE_REGISTRATION, cause);
    }

    /**
     * 필수 의존성 누락
     */
    public static InitializationException missingDependency(String moduleName, String dependency) {
        return new InitializationException(
                String.format("Module '%s' requires '%s' but it was not found", moduleName, dependency),
                moduleName, InitPhase.DEPENDENCY_LOAD);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\exception\InjectionException.java =====

package com.pulse.api.exception;

/**
 * 의존성 주입 관련 예외.
 * 
 * 서비스 등록/조회 실패, 순환 의존성 등에 사용.
 */
public class InjectionException extends PulseException {

    public InjectionException(String message) {
        super(message);
    }

    public InjectionException(String message, Throwable cause) {
        super(message, cause);
    }

    /**
     * 서비스 찾을 수 없음
     */
    public static InjectionException serviceNotFound(Class<?> serviceType) {
        return new InjectionException(
                String.format("Service not found: %s. Register it via PulseServiceLocator.", serviceType.getName()));
    }

    /**
     * 순환 의존성 감지
     */
    public static InjectionException circularDependency(Class<?> serviceType) {
        return new InjectionException(
                String.format("Circular dependency detected while resolving: %s", serviceType.getName()));
    }

    /**
     * 서비스 인스턴스화 실패
     */
    public static InjectionException instantiationFailed(Class<?> serviceType, Throwable cause) {
        return new InjectionException(
                String.format("Failed to instantiate service: %s", serviceType.getName()), cause);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\exception\LuaInitializationException.java =====

package com.pulse.api.exception;

/**
 * Lua 초기화 실패 예외.
 * Lua 스크립트 로드 또는 초기화 중 오류 발생 시 throw됩니다.
 * 
 * @since 1.1.0
 */
public class LuaInitializationException extends PulseException {

    private final String scriptPath;

    public LuaInitializationException(String message) {
        super(message);
        this.scriptPath = null;
    }

    public LuaInitializationException(String message, String scriptPath) {
        super(message + " [script: " + scriptPath + "]");
        this.scriptPath = scriptPath;
    }

    public LuaInitializationException(String message, Throwable cause) {
        super(message, cause);
        this.scriptPath = null;
    }

    public LuaInitializationException(String message, String scriptPath, Throwable cause) {
        super(message + " [script: " + scriptPath + "]", cause);
        this.scriptPath = scriptPath;
    }

    public String getScriptPath() {
        return scriptPath;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\exception\LuaInteropException.java =====

package com.pulse.api.exception;

/**
 * Lua 상호 운용 예외.
 * 
 * Lua 스크립트 실행 오류, 타입 변환 실패 등에 사용.
 */
public class LuaInteropException extends PulseException {

    private final String luaScript;
    private final int lineNumber;

    public LuaInteropException(String message) {
        super(message);
        this.luaScript = null;
        this.lineNumber = -1;
    }

    public LuaInteropException(String message, Throwable cause) {
        super(message, cause);
        this.luaScript = null;
        this.lineNumber = -1;
    }

    public LuaInteropException(String message, String luaScript, int lineNumber) {
        super(message);
        this.luaScript = luaScript;
        this.lineNumber = lineNumber;
    }

    public LuaInteropException(String message, String luaScript, int lineNumber, Throwable cause) {
        super(message, cause);
        this.luaScript = luaScript;
        this.lineNumber = lineNumber;
    }

    public String getLuaScript() {
        return luaScript;
    }

    public int getLineNumber() {
        return lineNumber;
    }

    /**
     * 스크립트 실행 오류
     */
    public static LuaInteropException executionError(String script, int line, Throwable cause) {
        return new LuaInteropException(
                String.format("Lua execution error at line %d: %s", line, cause.getMessage()),
                script, line, cause);
    }

    /**
     * 타입 변환 오류
     */
    public static LuaInteropException typeConversionError(String expectedType, Object actualValue) {
        return new LuaInteropException(
                String.format("Failed to convert Lua value to %s. Got: %s",
                        expectedType, actualValue != null ? actualValue.getClass().getSimpleName() : "nil"));
    }

    /**
     * 함수 찾을 수 없음
     */
    public static LuaInteropException functionNotFound(String functionName) {
        return new LuaInteropException(
                String.format("Lua function not found: %s", functionName));
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\exception\MixinApplyException.java =====

package com.pulse.api.exception;

/**
 * Mixin 적용 관련 예외.
 * 
 * Mixin 주입 실패, 대상 클래스 찾기 실패, 바이트코드 조작 오류 등에 사용.
 */
public class MixinApplyException extends PulseException {

    private final String mixinClass;
    private final String targetClass;

    public MixinApplyException(String message) {
        super(message);
        this.mixinClass = null;
        this.targetClass = null;
    }

    public MixinApplyException(String message, Throwable cause) {
        super(message, cause);
        this.mixinClass = null;
        this.targetClass = null;
    }

    public MixinApplyException(String message, String mixinClass, String targetClass) {
        super(message);
        this.mixinClass = mixinClass;
        this.targetClass = targetClass;
    }

    public MixinApplyException(String message, String mixinClass, String targetClass, Throwable cause) {
        super(message, cause);
        this.mixinClass = mixinClass;
        this.targetClass = targetClass;
    }

    public String getMixinClass() {
        return mixinClass;
    }

    public String getTargetClass() {
        return targetClass;
    }

    /**
     * 대상 클래스 찾기 실패
     */
    public static MixinApplyException targetNotFound(String mixinClass, String targetClass) {
        return new MixinApplyException(
                String.format("Mixin target class not found: %s (from mixin: %s)", targetClass, mixinClass),
                mixinClass, targetClass);
    }

    /**
     * 주입 실패
     */
    public static MixinApplyException injectionFailed(String mixinClass, String targetClass, Throwable cause) {
        return new MixinApplyException(
                String.format("Failed to inject mixin %s into %s: %s", mixinClass, targetClass, cause.getMessage()),
                mixinClass, targetClass, cause);
    }

    /**
     * 메서드 시그니처 불일치
     */
    public static MixinApplyException signatureMismatch(String mixinClass, String methodName, String expected,
            String actual) {
        return new MixinApplyException(
                String.format("Method signature mismatch in mixin %s.%s. Expected: %s, Got: %s",
                        mixinClass, methodName, expected, actual),
                mixinClass, null);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\exception\ModLoadException.java =====

package com.pulse.api.exception;

/**
 * 모드 로딩 관련 예외.
 * 
 * <p>
 * 모드 로드 실패, 의존성 해결 실패, 초기화 실패 등의 상황에서 발생합니다.
 * </p>
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * try {
 *     loadMod(modInfo);
 * } catch (ModLoadException e) {
 *     // 해당 모드만 비활성화하고 계속 진행
 *     logger.warn("Mod load failed, disabling: {}", modInfo.getId(), e);
 *     disableMod(modInfo);
 * }
 * }</pre>
 * 
 * @since Pulse 2.0
 */
public class ModLoadException extends PulseException {

    private final String modId;

    public ModLoadException(String message) {
        super(message);
        this.modId = null;
    }

    public ModLoadException(String modId, String message) {
        super(String.format("Mod '%s': %s", modId, message));
        this.modId = modId;
    }

    public ModLoadException(String modId, String message, Throwable cause) {
        super(String.format("Mod '%s': %s", modId, message), cause);
        this.modId = modId;
    }

    /**
     * 실패한 모드의 ID를 반환합니다.
     * 
     * @return 모드 ID (알 수 없는 경우 null)
     */
    public String getModId() {
        return modId;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\exception\NetworkException.java =====

package com.pulse.api.exception;

/**
 * Exception thrown when a network operation fails.
 *
 * @since 1.1.0
 */
public class NetworkException extends PulseException {

    public NetworkException(String message) {
        super(message);
    }

    public NetworkException(String message, Throwable cause) {
        super(message, cause);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\exception\PulseException.java =====

package com.pulse.api.exception;

/**
 * Pulse 예외 계층의 루트 클래스.
 * 모든 Pulse 관련 예외는 이 클래스를 상속합니다.
 * 
 * @since 1.1.0
 */
public class PulseException extends RuntimeException {

    public PulseException(String message) {
        super(message);
    }

    public PulseException(String message, Throwable cause) {
        super(message, cause);
    }

    public PulseException(Throwable cause) {
        super(cause);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\exception\ReflectionException.java =====

package com.pulse.api.exception;

/**
 * Exception thrown when a reflection operation fails.
 *
 * @since 1.1.0
 */
public class ReflectionException extends PulseException {

    public ReflectionException(String message) {
        super(message);
    }

    public ReflectionException(String message, Throwable cause) {
        super(message, cause);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\Experimental.java =====

package com.pulse.api;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 실험적 기능 마커.
 * 이 어노테이션이 붙은 API는 실험적이며 언제든 변경될 수 있음.
 * 
 * 사용 예:
 * 
 * <pre>
 * &#64;Experimental("Hot reload may cause memory leaks")
 * public void hotReload() { ... }
 * </pre>
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD })
public @interface Experimental {

    /**
     * 실험적인 이유 또는 주의사항.
     */
    String value() default "";

    /**
     * 안정화 예정 버전.
     */
    String targetVersion() default "";
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\FailsoftPolicy.java =====

package com.pulse.api;

import com.pulse.api.mixin.MixinInjectionValidator;
import com.pulse.debug.CrashReporter;

/**
 * Fail-soft 정책 시스템.
 * Mixin 실패, Lua 예산 초과 등의 오류가 발생해도 게임을 크래시하지 않고
 * 해당 기능만 비활성화합니다.
 * 
 * <pre>
 * // 사용 예시
 * try {
 *     // 위험한 작업
 * } catch (Exception e) {
 *     FailsoftPolicy.handle(FailsoftAction.WARN_AND_CONTINUE, "MyMod", e);
 * }
 * 
 * // Mixin 실패 처리
 * FailsoftPolicy.handleMixinFailure("com.mymod.mixin.MyMixin", "zombie.SomeClass", error);
 * </pre>
 * 
 * @since 1.1.0
 */
@PublicAPI(since = "1.1.0")
public final class FailsoftPolicy {

    private FailsoftPolicy() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // Fail-soft 액션 enum
    // ═══════════════════════════════════════════════════════════════

    /**
     * Fail-soft 액션 타입.
     */
    public enum FailsoftAction {
        /**
         * 실패한 Mixin만 비활성화, 게임 계속.
         */
        DISABLE_MIXIN_ONLY,

        /**
         * 경고 로그 후 계속 실행.
         */
        WARN_AND_CONTINUE,

        /**
         * 해당 기능 스킵, 크래시 없음.
         */
        SKIP_FEATURE,

        /**
         * 전체 기능 모듈 비활성화.
         */
        DISABLE_FEATURE,

        /**
         * 페이즈 시퀀스 오류 (v0.9 Fuse/Nerve 지원).
         */
        PHASE_SEQUENCE_ERROR,

        /**
         * 안전하지 않은 월드 상태 접근 (v0.9 Fuse/Nerve 지원).
         */
        UNSAFE_WORLDSTATE_ACCESS
    }

    // ═══════════════════════════════════════════════════════════════
    // 핵심 핸들러
    // ═══════════════════════════════════════════════════════════════

    /**
     * Fail-soft 액션 수행.
     * 
     * @param action 수행할 액션
     * @param source 오류 발생 소스 (클래스명, 모드ID 등)
     * @param error  발생한 예외 (null 가능)
     */
    public static void handle(FailsoftAction action, String source, Throwable error) {
        String message = error != null ? error.getMessage() : "Unknown error";

        switch (action) {
            case DISABLE_MIXIN_ONLY:
                MixinInjectionValidator.disableMixin(source);
                Pulse.warn("pulse", "[Failsoft] Mixin disabled: " + source);
                break;

            case WARN_AND_CONTINUE:
                Pulse.warn("pulse", "[Failsoft] " + source + ": " + message);
                break;

            case SKIP_FEATURE:
                FeatureFlags.disable(source);
                Pulse.warn("pulse", "[Failsoft] Feature skipped: " + source);
                break;

            case DISABLE_FEATURE:
                FeatureFlags.disableModule(source);
                Pulse.warn("pulse", "[Failsoft] Feature module disabled: " + source);
                break;

            case PHASE_SEQUENCE_ERROR:
                Pulse.warn("pulse", "[Failsoft] Phase sequence error: " + source + " - " + message);
                break;

            case UNSAFE_WORLDSTATE_ACCESS:
                Pulse.warn("pulse", "[Failsoft] Unsafe worldstate access: " + source + " - " + message);
                break;
        }

        // CrashReporter에 이벤트 기록
        CrashReporter.recordEvent(
                CrashReporter.EVENT_FAILSOFT_TRIGGERED,
                source,
                action.name() + ": " + message);

        // DevMode에서는 스택트레이스 출력
        if (DevMode.isEnabled() && error != null) {
            error.printStackTrace();
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // 특화 핸들러
    // ═══════════════════════════════════════════════════════════════

    /**
     * Mixin 실패 처리.
     * 해당 Mixin만 비활성화하고 게임 계속.
     * 
     * @param mixinClass  Mixin 클래스 전체 경로
     * @param targetClass 대상 클래스 전체 경로
     * @param error       발생한 예외
     */
    public static void handleMixinFailure(String mixinClass, String targetClass, Throwable error) {
        MixinInjectionValidator.recordFailure(mixinClass, targetClass,
                error != null ? error.getMessage() : "Unknown mixin error");
        MixinInjectionValidator.disableMixin(mixinClass);

        Pulse.error("pulse", "[Failsoft/Mixin] " + mixinClass + " → " + targetClass + " FAILED");

        CrashReporter.recordEvent(
                CrashReporter.EVENT_MIXIN_FAILURE,
                mixinClass,
                "Target: " + targetClass + ", Error: " + (error != null ? error.getMessage() : "Unknown"));

        if (DevMode.isEnabled() && error != null) {
            error.printStackTrace();
        }
    }

    /**
     * Lua 예산 초과 처리.
     * 경고만 남기고 계속 실행.
     * 
     * @param contextId    컨텍스트 ID
     * @param actualMicros 실제 사용 시간 (마이크로초)
     * @param budgetMicros 설정된 예산 (마이크로초)
     */
    public static void handleLuaBudgetExceeded(String contextId, long actualMicros, long budgetMicros) {
        double actualMs = actualMicros / 1000.0;
        double budgetMs = budgetMicros / 1000.0;

        Pulse.warn("pulse", String.format(
                "[Failsoft/Lua] Budget exceeded: %s (%.2fms / %.2fms)",
                contextId, actualMs, budgetMs));

        CrashReporter.recordEvent(
                CrashReporter.EVENT_LUA_BUDGET_EXCEEDED,
                contextId,
                String.format("%.2fms / %.2fms (%.0f%% over)",
                        actualMs, budgetMs, ((actualMs - budgetMs) / budgetMs) * 100));
    }

    /**
     * ClassNotFound 처리.
     * 해당 기능만 스킵.
     * 
     * @param className 찾지 못한 클래스명
     * @param feature   관련 기능명
     */
    public static void handleClassNotFound(String className, String feature) {
        FeatureFlags.disable(feature);

        Pulse.warn("pulse", "[Failsoft/Class] " + className + " not found, disabling: " + feature);

        CrashReporter.recordEvent(
                "CLASS_NOT_FOUND",
                feature,
                "Missing class: " + className);
    }

    /**
     * 시그니처 미스매치 처리.
     * 해당 기능 비활성화.
     * 
     * @param className  클래스명
     * @param methodName 메서드명
     * @param feature    관련 기능명
     * @param expected   예상 시그니처
     * @param actual     실제 시그니처
     */
    public static void handleSignatureMismatch(String className, String methodName,
            String feature, String expected, String actual) {
        FeatureFlags.disable(feature);

        Pulse.warn("pulse", String.format(
                "[Failsoft/Signature] %s.%s mismatch, disabling: %s",
                className, methodName, feature));

        CrashReporter.recordEvent(
                "SIGNATURE_MISMATCH",
                feature,
                String.format("%s.%s: expected %s, got %s", className, methodName, expected, actual));
    }

    // ═══════════════════════════════════════════════════════════════
    // v0.9 Fuse/Nerve 전용 핸들러
    // ═══════════════════════════════════════════════════════════════

    /**
     * 페이즈 시퀀스 오류 처리 (v0.9 Fuse/Nerve).
     * 페이즈 순서가 예상과 다를 때 호출.
     * 
     * @param phase    현재 페이즈
     * @param expected 예상된 페이즈
     * @param actual   실제 페이즈
     */
    public static void handlePhaseSequenceError(String phase, String expected, String actual) {
        Pulse.warn("pulse", String.format(
                "[Failsoft/Phase] Sequence error in '%s': expected '%s', got '%s'",
                phase, expected, actual));

        CrashReporter.recordEvent(
                "PHASE_SEQUENCE_ERROR",
                phase,
                String.format("Expected: %s, Actual: %s", expected, actual));
    }

    /**
     * 안전하지 않은 월드 상태 접근 처리 (v0.9 Fuse/Nerve).
     * 월드 초기화 전이나 언로드 후 월드 상태에 접근할 때 호출.
     * 
     * @param context   컨텍스트 (어떤 모듈/기능에서 발생했는지)
     * @param operation 시도한 작업
     */
    public static void handleUnsafeWorldstateAccess(String context, String operation) {
        Pulse.warn("pulse", String.format(
                "[Failsoft/Worldstate] Unsafe access in '%s': %s",
                context, operation));

        CrashReporter.recordEvent(
                "UNSAFE_WORLDSTATE_ACCESS",
                context,
                "Operation: " + operation);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\FeatureFlags.java =====

package com.pulse.api;

import com.pulse.api.log.PulseLogger;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 런타임 기능 플래그 시스템.
 * 개별 기능을 런타임에 활성화/비활성화할 수 있습니다.
 * Fail-soft 정책에서 실패한 기능을 비활성화하는 데 사용됩니다.
 * 
 * <pre>
 * // 사용 예시
 * if (FeatureFlags.isEnabled(FeatureFlags.MIXIN_SYSTEM)) {
 *     // Mixin 시스템 사용
 * }
 * 
 * // 기능 비활성화
 * FeatureFlags.disable("mymod.feature");
 * </pre>
 * 
 * @since 1.1.0
 */
@PublicAPI(since = "1.1.0")
public final class FeatureFlags {

    private static final String LOG = PulseLogger.PULSE;

    // ═══════════════════════════════════════════════════════════════
    // 표준 기능 ID
    // ═══════════════════════════════════════════════════════════════

    /** Mixin 시스템 */
    public static final String MIXIN_SYSTEM = "pulse.mixin";

    /** Lua Budget 관리 */
    public static final String LUA_BUDGET = "pulse.lua.budget";

    /** 프로파일러 */
    public static final String PROFILER = "pulse.profiler";

    /** Silent Mode */
    public static final String SILENT_MODE = "pulse.silent";

    /** Safe Game Access */
    public static final String SAFE_ACCESS = "pulse.safe_access";

    /** 네트워크 기능 */
    public static final String NETWORKING = "pulse.network";

    /** 최적화 포인트 시스템 */
    public static final String OPTIMIZATION_POINTS = "pulse.optimization";

    // ═══════════════════════════════════════════════════════════════
    // 내부 상태
    // ═══════════════════════════════════════════════════════════════

    // 비활성화된 기능 목록 (기본은 모두 활성)
    private static final Set<String> disabledFlags = ConcurrentHashMap.newKeySet();

    // 비활성화 사유
    private static final Map<String, String> disableReasons = new ConcurrentHashMap<>();

    private FeatureFlags() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // 조회 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 기능이 활성화되어 있는지 확인.
     * 
     * @param featureId 기능 ID
     * @return 활성화되어 있으면 true
     */
    public static boolean isEnabled(String featureId) {
        if (featureId == null || featureId.isEmpty()) {
            return false;
        }
        return !disabledFlags.contains(featureId);
    }

    /**
     * 기능이 비활성화되어 있는지 확인.
     * 
     * @param featureId 기능 ID
     * @return 비활성화되어 있으면 true
     */
    public static boolean isDisabled(String featureId) {
        return !isEnabled(featureId);
    }

    /**
     * 비활성화 사유 조회.
     * 
     * @param featureId 기능 ID
     * @return 비활성화 사유 (없으면 null)
     */
    public static String getDisableReason(String featureId) {
        return disableReasons.get(featureId);
    }

    // ═══════════════════════════════════════════════════════════════
    // 설정 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 기능 활성화.
     * 
     * @param featureId 기능 ID
     */
    public static void enable(String featureId) {
        if (featureId != null && !featureId.isEmpty()) {
            disabledFlags.remove(featureId);
            disableReasons.remove(featureId);
            Pulse.log("pulse", "[FeatureFlags] Enabled: " + featureId);
        }
    }

    /**
     * 기능 비활성화.
     * 
     * @param featureId 기능 ID
     */
    public static void disable(String featureId) {
        disable(featureId, "Disabled by FeatureFlags.disable()");
    }

    /**
     * 기능 비활성화 (사유 포함).
     * 
     * @param featureId 기능 ID
     * @param reason    비활성화 사유
     */
    public static void disable(String featureId, String reason) {
        if (featureId != null && !featureId.isEmpty()) {
            disabledFlags.add(featureId);
            disableReasons.put(featureId, reason != null ? reason : "Unknown");
            Pulse.warn("pulse", "[FeatureFlags] Disabled: " + featureId + " (" + reason + ")");
        }
    }

    /**
     * 모듈 prefix로 시작하는 모든 기능 비활성화.
     * 예: disableModule("mymod") → "mymod.feature1", "mymod.feature2" 모두 비활성화
     * 
     * @param modulePrefix 모듈 prefix
     */
    public static void disableModule(String modulePrefix) {
        disableModule(modulePrefix, "Module disabled by FeatureFlags.disableModule()");
    }

    /**
     * 모듈 prefix로 시작하는 모든 기능 비활성화 (사유 포함).
     * 
     * @param modulePrefix 모듈 prefix
     * @param reason       비활성화 사유
     */
    public static void disableModule(String modulePrefix, String reason) {
        if (modulePrefix == null || modulePrefix.isEmpty()) {
            return;
        }

        // 해당 모듈 자체도 비활성화
        disable(modulePrefix, reason);

        // prefix로 시작하는 모든 기능 비활성화
        // (이미 등록된 것들만 - 새로 등록되는 것은 isEnabled에서 체크)
        for (String featureId : disabledFlags) {
            if (featureId.startsWith(modulePrefix + ".")) {
                disable(featureId, reason);
            }
        }

        Pulse.warn("pulse", "[FeatureFlags] Module disabled: " + modulePrefix);
    }

    // ═══════════════════════════════════════════════════════════════
    // 조회
    // ═══════════════════════════════════════════════════════════════

    /**
     * 모든 비활성화된 기능 목록 반환.
     * 
     * @return 불변 Set
     */
    public static Set<String> getDisabledFeatures() {
        return Collections.unmodifiableSet(disabledFlags);
    }

    /**
     * 비활성화된 기능 수.
     * 
     * @return 비활성화된 기능 수
     */
    public static int getDisabledCount() {
        return disabledFlags.size();
    }

    /**
     * 모든 플래그 초기화 (테스트용).
     */
    @InternalAPI
    public static void reset() {
        disabledFlags.clear();
        disableReasons.clear();
    }

    /**
     * 디버그 출력.
     */
    public static void printStatus() {
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "  FeatureFlags Status");
        PulseLogger.info(LOG, "═══════════════════════════════════════");

        if (disabledFlags.isEmpty()) {
            PulseLogger.info(LOG, "  All features enabled");
        } else {
            PulseLogger.info(LOG, "  Disabled features ({}):", disabledFlags.size());
            for (String featureId : disabledFlags) {
                String reason = disableReasons.getOrDefault(featureId, "Unknown");
                PulseLogger.info(LOG, "    ✗ {} - {}", featureId, reason);
            }
        }

        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\GameAccess.java =====

package com.pulse.api;

import com.pulse.api.access.*;
import com.pulse.api.util.ReflectionUtil;

/**
 * 게임 내부 접근 API.
 * 리플렉션을 사용하여 게임 코드에 접근.
 * 게임 버전 변경에 유연하게 대응 가능.
 * 
 * <p>
 * <strong>Migration Notice (v1.1.0):</strong>
 * </p>
 * <p>
 * 이 클래스의 메서드들은 다음 클래스들로 분리되었습니다.
 * v1.3.0에서 deprecated 메서드들이 제거될 예정입니다.
 * </p>
 * <ul>
 * <li>{@link WorldAccess} - 월드 관련</li>
 * <li>{@link PlayerAccess} - 플레이어 관련</li>
 * <li>{@link TimeAccess} - 시간 관련</li>
 * <li>{@link NetworkAccess} - 네트워크 상태</li>
 * <li>{@link ZombieAccess} - 좀비 관련</li>
 * <li>{@link ReflectionUtil} - 리플렉션 유틸리티</li>
 * </ul>
 * 
 * @deprecated Use specific Access classes instead.
 */
@Deprecated(since = "1.1.0", forRemoval = true)
public final class GameAccess {

    private GameAccess() {
    }

    /**
     * @deprecated Use specific Access classes' refresh() method.
     */
    @Deprecated(since = "1.1.0", forRemoval = true)
    public static void ensureInitialized() {
        refresh();
    }

    /**
     * @deprecated Use specific Access classes' refresh() method.
     */
    @Deprecated(since = "1.1.0", forRemoval = true)
    public static void refresh() {
        WorldAccess.refresh();
        PlayerAccess.refresh();
        TimeAccess.refresh();
        NetworkAccess.refresh();
        ZombieAccess.refresh();
    }

    // ─────────────────────────────────────────────────────────────
    // WorldAccess
    // ─────────────────────────────────────────────────────────────

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static Object getIsoWorldInstance() {
        return WorldAccess.getIsoWorldInstance();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static boolean isWorldLoaded() {
        return WorldAccess.isWorldLoaded();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static String getWorldName() {
        return WorldAccess.getWorldName();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static int getLoadedCellCount() {
        return WorldAccess.getLoadedCellCount();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static int getTotalEntityCount() {
        return WorldAccess.getTotalEntityCount();
    }

    // ─────────────────────────────────────────────────────────────
    // PlayerAccess
    // ─────────────────────────────────────────────────────────────

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static Object getLocalPlayer() {
        return PlayerAccess.getLocalPlayer();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static boolean isPlayerAlive() {
        return PlayerAccess.isPlayerAlive();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static float getPlayerHealth() {
        return PlayerAccess.getPlayerHealth();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static float getPlayerX() {
        return PlayerAccess.getPlayerX();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static float getPlayerY() {
        return PlayerAccess.getPlayerY();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static float getPlayerZ() {
        return PlayerAccess.getPlayerZ();
    }

    // ─────────────────────────────────────────────────────────────
    // TimeAccess
    // ─────────────────────────────────────────────────────────────

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static Object getGameTimeInstance() {
        return TimeAccess.getGameTimeInstance();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static int getGameHour() {
        return TimeAccess.getGameHour();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static int getGameMinute() {
        return TimeAccess.getGameMinute();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static int getGameDay() {
        return TimeAccess.getGameDay();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static int getGameMonth() {
        return TimeAccess.getGameMonth();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static int getGameYear() {
        return TimeAccess.getGameYear();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static boolean isNight() {
        return TimeAccess.isNight();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static boolean isDay() {
        return TimeAccess.isDay();
    }

    // ─────────────────────────────────────────────────────────────
    // NetworkAccess
    // ─────────────────────────────────────────────────────────────

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static boolean isPaused() {
        return NetworkAccess.isPaused();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static boolean isMultiplayer() {
        return NetworkAccess.isMultiplayer();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static boolean isServer() {
        return NetworkAccess.isServer();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static boolean isClient() {
        return NetworkAccess.isClient();
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static boolean isSinglePlayer() {
        return NetworkAccess.isSinglePlayer();
    }

    // ─────────────────────────────────────────────────────────────
    // ReflectionUtil
    // ─────────────────────────────────────────────────────────────

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static Object getStaticField(String className, String fieldName) {
        return ReflectionUtil.getStaticField(className, fieldName);
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static Object invokeStaticMethod(String className, String methodName, Object... args) {
        return ReflectionUtil.invokeStaticMethod(className, methodName, args);
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static Class<?> getGameClass(String className) {
        return ReflectionUtil.getGameClass(className);
    }

    // ─────────────────────────────────────────────────────────────
    // ZombieAccess
    // ─────────────────────────────────────────────────────────────

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static java.util.List<Object> getNearbyZombies(float x, float y, float radius) {
        return ZombieAccess.getNearbyZombies(x, y, radius);
    }

    @Deprecated(since = "1.1.0", forRemoval = true)
    public static java.util.List<Object> getAllZombies() {
        return ZombieAccess.getAllZombies();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\IMC.java =====

package com.pulse.api;

import com.pulse.api.log.PulseLogger;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 모드 간 통신 API (Inter-Mod Communication).
 * 서비스 로케이터 패턴 기반.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 서비스 등록
 * IMC.registerService("mymod:inventory_api", MyInventoryAPI.class, () -> new MyInventoryAPI());
 * 
 * // 서비스 사용
 * MyInventoryAPI api = IMC.getService("mymod:inventory_api", MyInventoryAPI.class);
 * if (api != null) {
 *     api.doSomething();
 * }
 * 
 * // 메시지 전송
 * IMC.sendMessage("othermod", "config_changed", myConfigData);
 * </pre>
 */
@PublicAPI(since = "1.0.0")
public class IMC {

    private static final IMC INSTANCE = new IMC();
    private static final String LOG = PulseLogger.PULSE;

    // 등록된 서비스
    private final Map<String, ServiceRegistration<?>> services = new ConcurrentHashMap<>();

    // 메시지 리스너
    private final Map<String, Map<String, MessageHandler>> messageHandlers = new ConcurrentHashMap<>();

    private IMC() {
    }

    // ─────────────────────────────────────────────────────────────
    // 서비스 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 서비스 등록.
     * 
     * @param id      서비스 식별자 (예: "mymod:my_api")
     * @param type    서비스 인터페이스/클래스
     * @param factory 서비스 인스턴스 생성자
     */
    public static <T> void registerService(String id, Class<T> type, Supplier<T> factory) {
        INSTANCE.services.put(id, new ServiceRegistration<>(type, factory));
        PulseLogger.info(LOG, "[IMC] Registered service: {}", id);
    }

    /**
     * 서비스 조회.
     * 
     * @param id   서비스 식별자
     * @param type 예상되는 타입
     * @return 서비스 인스턴스 또는 null
     */
    @SuppressWarnings("unchecked")
    public static <T> T getService(String id, Class<T> type) {
        ServiceRegistration<?> reg = INSTANCE.services.get(id);
        if (reg == null) {
            return null;
        }
        if (!type.isAssignableFrom(reg.type)) {
            PulseLogger.error(LOG, "[IMC] Service type mismatch: {}", id);
            return null;
        }
        return (T) reg.getInstance();
    }

    /**
     * 서비스 존재 여부 확인.
     */
    public static boolean hasService(String id) {
        return INSTANCE.services.containsKey(id);
    }

    /**
     * 서비스 등록 해제.
     */
    public static void unregisterService(String id) {
        INSTANCE.services.remove(id);
    }

    // ─────────────────────────────────────────────────────────────
    // 메시지 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 다른 모드에 메시지 전송.
     * 
     * @param targetModId 대상 모드 ID
     * @param messageType 메시지 타입
     * @param data        메시지 데이터
     */
    public static void sendMessage(String targetModId, String messageType, Object data) {
        Map<String, MessageHandler> handlers = INSTANCE.messageHandlers.get(targetModId);
        if (handlers == null) {
            return; // 수신자 없음
        }

        MessageHandler handler = handlers.get(messageType);
        if (handler == null) {
            handler = handlers.get("*"); // 와일드카드 핸들러
        }

        if (handler != null) {
            try {
                handler.handle(messageType, data);
            } catch (Exception e) {
                PulseLogger.error(LOG, "[IMC] Error handling message: {}", e.getMessage());
            }
        }
    }

    /**
     * 메시지 핸들러 등록.
     * 
     * @param modId       자신의 모드 ID
     * @param messageType 수신할 메시지 타입 ("*" = 모든 메시지)
     * @param handler     핸들러
     */
    public static void registerHandler(String modId, String messageType, MessageHandler handler) {
        INSTANCE.messageHandlers
                .computeIfAbsent(modId, k -> new ConcurrentHashMap<>())
                .put(messageType, handler);
    }

    /**
     * 등록된 모든 서비스 ID 조회.
     */
    public static java.util.Set<String> getRegisteredServices() {
        return java.util.Collections.unmodifiableSet(INSTANCE.services.keySet());
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface MessageHandler {
        void handle(String messageType, Object data);
    }

    private static class ServiceRegistration<T> {
        final Class<T> type;
        final Supplier<T> factory;
        private T instance;

        ServiceRegistration(Class<T> type, Supplier<T> factory) {
            this.type = type;
            this.factory = factory;
        }

        synchronized T getInstance() {
            if (instance == null) {
                instance = factory.get();
            }
            return instance;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\InternalAPI.java =====

package com.pulse.api;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 내부 API 마커.
 * 이 어노테이션이 붙은 클래스/메서드는 내부 구현용.
 * 
 * - 언제든 변경/제거 가능
 * - 외부 모드에서 사용 금지
 * - 문서화 대상 아님
 * 
 * 사용 예:
 * 
 * <pre>
 * @InternalAPI
 * public class MixinHelper { ... }
 * </pre>
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PACKAGE })
public @interface InternalAPI {

    /**
     * 내부 API 사용 이유 (선택적 문서화).
     */
    String reason() default "";
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\log\ModuleLogger.java =====

package com.pulse.api.log;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.function.Supplier;

/**
 * 모듈별 로거 구현체.
 * 
 * 각 모듈(Pulse, Echo, Fuse, Nerve)에서 독립적인 로그 레벨을 설정할 수 있습니다.
 * 
 * @since 1.1.0
 */
public class ModuleLogger implements PulseLoggerInterface {

    private static final DateTimeFormatter TIME_FORMAT = DateTimeFormatter.ofPattern("HH:mm:ss.SSS");

    private final String moduleName;
    private volatile PulseLogLevel currentLevel;

    /**
     * 모듈 로거 생성.
     * 
     * @param moduleName 모듈 이름 (예: "Pulse", "Echo")
     */
    public ModuleLogger(String moduleName) {
        this(moduleName, PulseLogLevel.INFO);
    }

    /**
     * 모듈 로거 생성 (레벨 지정).
     * 
     * @param moduleName 모듈 이름
     * @param level      초기 로그 레벨
     */
    public ModuleLogger(String moduleName, PulseLogLevel level) {
        this.moduleName = moduleName;
        this.currentLevel = level;
    }

    /**
     * 로그 레벨 설정.
     */
    public void setLevel(PulseLogLevel level) {
        this.currentLevel = level;
    }

    /**
     * 현재 로그 레벨 조회.
     */
    public PulseLogLevel getLevel() {
        return currentLevel;
    }

    @Override
    public boolean isEnabled(PulseLogLevel level) {
        return level.isEnabled(currentLevel);
    }

    @Override
    public void log(PulseLogLevel level, String message) {
        if (!isEnabled(level))
            return;
        output(level, message);
    }

    @Override
    public void log(PulseLogLevel level, Supplier<String> messageSupplier) {
        if (!isEnabled(level))
            return;
        output(level, messageSupplier.get());
    }

    @Override
    public void log(PulseLogLevel level, String format, Object... args) {
        if (!isEnabled(level))
            return;
        output(level, formatMessage(format, args));
    }

    @Override
    public void log(PulseLogLevel level, String message, Throwable throwable) {
        if (!isEnabled(level))
            return;
        output(level, message + "\n" + getStackTrace(throwable));
    }

    private void output(PulseLogLevel level, String message) {
        String timestamp = LocalDateTime.now().format(TIME_FORMAT);
        String formattedMessage = String.format("[%s] [%s/%s] %s",
                timestamp, moduleName, level.name(), message);

        if (level.getLevel() >= PulseLogLevel.WARN.getLevel()) {
            System.err.println(formattedMessage);
        } else {
            System.out.println(formattedMessage);
        }
    }

    /**
     * SLF4J 스타일 {} 플레이스홀더 포맷팅.
     */
    private String formatMessage(String format, Object... args) {
        if (args == null || args.length == 0) {
            return format;
        }

        StringBuilder result = new StringBuilder();
        int argIndex = 0;
        int i = 0;

        while (i < format.length()) {
            if (i < format.length() - 1 && format.charAt(i) == '{' && format.charAt(i + 1) == '}') {
                if (argIndex < args.length) {
                    result.append(args[argIndex++]);
                } else {
                    result.append("{}");
                }
                i += 2;
            } else {
                result.append(format.charAt(i));
                i++;
            }
        }

        return result.toString();
    }

    private String getStackTrace(Throwable throwable) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        throwable.printStackTrace(pw);
        return sw.toString();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\log\PulseLogger.java =====

package com.pulse.api.log;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * Pulse 로깅 파사드.
 * 
 * 모든 모듈에서 정적 메서드로 로깅을 수행할 수 있습니다.
 * 내부적으로 모듈별 로거를 관리합니다.
 * 
 * <p>
 * 사용 예시:
 * </p>
 * 
 * <pre>
 * // 기본 로깅
 * PulseLogger.info("Pulse", "Initialization complete");
 * 
 * // 포맷 문자열
 * PulseLogger.debug("Echo", "Tick {} took {}ms", tickNumber, duration);
 * 
 * // Lazy evaluation (성능 최적화)
 * PulseLogger.debug("Pulse", () -> "Heavy computation: " + expensiveCall());
 * </pre>
 * 
 * @since 1.1.0
 */
public final class PulseLogger {

    private static final Map<String, ModuleLogger> LOGGERS = new ConcurrentHashMap<>();

    /** 전역 기본 로그 레벨 */
    private static volatile PulseLogLevel globalLevel = PulseLogLevel.INFO;

    private PulseLogger() {
    }

    // --- 로거 관리---

    /**
     * 모듈별 로거를 가져오거나 생성합니다.
     */
    public static ModuleLogger getLogger(String moduleName) {
        return LOGGERS.computeIfAbsent(moduleName, name -> new ModuleLogger(name, globalLevel));
    }

    /**
     * 전역 로그 레벨 설정.
     * 이미 생성된 로거에도 적용됩니다.
     */
    public static void setGlobalLevel(PulseLogLevel level) {
        globalLevel = level;
        LOGGERS.values().forEach(logger -> logger.setLevel(level));
    }

    /**
     * 특정 모듈의 로그 레벨만 변경.
     */
    public static void setModuleLevel(String moduleName, PulseLogLevel level) {
        getLogger(moduleName).setLevel(level);
    }

    /**
     * 현재 전역 로그 레벨.
     */
    public static PulseLogLevel getGlobalLevel() {
        return globalLevel;
    }

    // --- 정적 로깅 메서드---

    public static void trace(String module, String message) {
        getLogger(module).trace(message);
    }

    public static void trace(String module, Supplier<String> messageSupplier) {
        getLogger(module).trace(messageSupplier);
    }

    public static void trace(String module, String format, Object... args) {
        getLogger(module).trace(format, args);
    }

    public static void debug(String module, String message) {
        getLogger(module).debug(message);
    }

    public static void debug(String module, Supplier<String> messageSupplier) {
        getLogger(module).debug(messageSupplier);
    }

    public static void debug(String module, String format, Object... args) {
        getLogger(module).debug(format, args);
    }

    public static void info(String module, String message) {
        getLogger(module).info(message);
    }

    public static void info(String module, String format, Object... args) {
        getLogger(module).info(format, args);
    }

    public static void warn(String module, String message) {
        getLogger(module).warn(message);
    }

    public static void warn(String module, String format, Object... args) {
        getLogger(module).warn(format, args);
    }

    public static void warn(String module, String message, Throwable t) {
        getLogger(module).warn(message, t);
    }

    public static void error(String module, String message) {
        getLogger(module).error(message);
    }

    public static void error(String module, String format, Object... args) {
        getLogger(module).error(format, args);
    }

    public static void error(String module, String message, Throwable t) {
        getLogger(module).error(message, t);
    }

    // --- 모듈별 상수---

    /** Pulse 코어 모듈 */
    public static final String PULSE = "Pulse";

    /** Echo 프로파일러 모듈 */
    public static final String ECHO = "Echo";

    /** Fuse 최적화 모듈 */
    public static final String FUSE = "Fuse";

    /** Nerve 모니터링 모듈 */
    public static final String NERVE = "Nerve";

    // --- 디버그 전용 헬퍼---

    /**
     * 디버그 레벨이 활성화되어 있는지 확인.
     * 무거운 로그 메시지 생성 전 체크용.
     */
    public static boolean isDebugEnabled(String module) {
        return getLogger(module).isEnabled(PulseLogLevel.DEBUG);
    }

    /**
     * 트레이스 레벨이 활성화되어 있는지 확인.
     */
    public static boolean isTraceEnabled(String module) {
        return getLogger(module).isEnabled(PulseLogLevel.TRACE);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\log\PulseLoggerInterface.java =====

package com.pulse.api.log;

import java.util.function.Supplier;

/**
 * Pulse 로거 인터페이스.
 * 
 * 경량 래퍼로 SLF4J 의존성 없이 로깅 기능을 제공합니다.
 * 향후 필요시 MDC 컨텍스트 확장 가능한 구조입니다.
 * 
 * @since 1.1.0
 */
public interface PulseLoggerInterface {

    /**
     * 로그 메시지를 출력합니다.
     */
    void log(PulseLogLevel level, String message);

    /**
     * 로그 메시지를 lazy evaluation으로 출력합니다.
     * 레벨이 비활성화되어 있으면 Supplier가 실행되지 않아 성능에 유리합니다.
     */
    void log(PulseLogLevel level, Supplier<String> messageSupplier);

    /**
     * 포맷 문자열로 로그 출력.
     */
    void log(PulseLogLevel level, String format, Object... args);

    /**
     * 예외와 함께 로그 출력.
     */
    void log(PulseLogLevel level, String message, Throwable throwable);

    /**
     * 해당 로그 레벨이 활성화되어 있는지 확인.
     */
    boolean isEnabled(PulseLogLevel level);

    // --- 편의 메서드---

    default void trace(String message) {
        log(PulseLogLevel.TRACE, message);
    }

    default void trace(Supplier<String> messageSupplier) {
        log(PulseLogLevel.TRACE, messageSupplier);
    }

    default void trace(String format, Object... args) {
        log(PulseLogLevel.TRACE, format, args);
    }

    default void debug(String message) {
        log(PulseLogLevel.DEBUG, message);
    }

    default void debug(Supplier<String> messageSupplier) {
        log(PulseLogLevel.DEBUG, messageSupplier);
    }

    default void debug(String format, Object... args) {
        log(PulseLogLevel.DEBUG, format, args);
    }

    default void info(String message) {
        log(PulseLogLevel.INFO, message);
    }

    default void info(String format, Object... args) {
        log(PulseLogLevel.INFO, format, args);
    }

    default void warn(String message) {
        log(PulseLogLevel.WARN, message);
    }

    default void warn(String format, Object... args) {
        log(PulseLogLevel.WARN, format, args);
    }

    default void warn(String message, Throwable throwable) {
        log(PulseLogLevel.WARN, message, throwable);
    }

    default void error(String message) {
        log(PulseLogLevel.ERROR, message);
    }

    default void error(String format, Object... args) {
        log(PulseLogLevel.ERROR, format, args);
    }

    default void error(String message, Throwable throwable) {
        log(PulseLogLevel.ERROR, message, throwable);
    }

    // --- 향후 MDC 컨텍스트 확장용 (Phase 1에서는 미구현)---
    // default void setContext(String key, String value) {}
    // default void clearContext() {}
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\log\PulseLogLevel.java =====

package com.pulse.api.log;

/**
 * Pulse 로깅 레벨 정의.
 * 
 * 릴리즈 빌드에서는 INFO 이상만 출력됩니다.
 */
public enum PulseLogLevel {
    /** 가장 상세한 디버그 정보 */
    TRACE(0),
    /** 개발 디버깅용 */
    DEBUG(1),
    /** 일반 정보 */
    INFO(2),
    /** 경고 */
    WARN(3),
    /** 오류 */
    ERROR(4);

    private final int level;

    PulseLogLevel(int level) {
        this.level = level;
    }

    public int getLevel() {
        return level;
    }

    public boolean isEnabled(PulseLogLevel currentLevel) {
        return this.level >= currentLevel.level;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\lua\LuaBudgetManager.java =====

package com.pulse.api.lua;

import com.pulse.api.InternalAPI;
import com.pulse.api.PublicAPI;
import com.pulse.api.log.PulseLogger;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Lua 실행 시간 Budget 관리자.
 * Nerve같은 Lua 최적화 모드가 Lua 실행 시간을 제어할 수 있습니다.
 * 
 * <pre>
 * // 사용 예시
 * LuaBudgetManager budget = LuaBudgetManager.getInstance();
 * 
 * // 틱당 5ms 예산 설정
 * budget.setBudget("nerve.tick", 5000); // 마이크로초
 * 
 * // Fallback 핸들러 등록
 * budget.setFallbackHandler("nerve.tick", () -> {
 *     System.out.println("Budget exceeded, skipping non-critical tasks");
 * });
 * 
 * // 실행
 * try (LuaExecutionContext ctx = budget.beginExecution("nerve.tick")) {
 *     while (ctx.hasRemainingBudget()) {
 *         // Lua 작업 수행
 *         luaBridge.call("SomeFunction");
 *         ctx.checkpoint();
 *     }
 * }
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class LuaBudgetManager {

    private static final LuaBudgetManager INSTANCE = new LuaBudgetManager();
    private static final String LOG = PulseLogger.PULSE;

    // ═══════════════════════════════════════════════════════════════
    // 표준 컨텍스트 ID 상수 (v1.1.0)
    // ═══════════════════════════════════════════════════════════════

    /** OnTick 이벤트 컨텍스트 */
    public static final String CTX_ON_TICK = "lua.event.OnTick";

    /** OnPlayerUpdate 이벤트 컨텍스트 */
    public static final String CTX_ON_PLAYER_UPDATE = "lua.event.OnPlayerUpdate";

    /** OnGameTimeTick 이벤트 컨텍스트 */
    public static final String CTX_ON_GAME_TIME_TICK = "lua.event.OnGameTimeTick";

    /** OnContainerUpdate 이벤트 컨텍스트 */
    public static final String CTX_ON_CONTAINER_UPDATE = "lua.event.OnContainerUpdate";

    /** OnZombieDead 이벤트 컨텍스트 */
    public static final String CTX_ON_ZOMBIE_DEAD = "lua.event.OnZombieDead";

    /** OnRenderTick 이벤트 컨텍스트 */
    public static final String CTX_ON_RENDER_TICK = "lua.event.OnRenderTick";

    // ═══════════════════════════════════════════════════════════════
    // Fast-path 토글 (Nerve 활성화 전에는 오버헤드 최소화)
    // ═══════════════════════════════════════════════════════════════

    private static volatile boolean budgetEnforcementEnabled = false;

    /**
     * Budget 강제 적용 활성화 여부.
     * Nerve가 로드되면 true로 설정됨.
     * 
     * @return 활성화되어 있으면 true
     */
    public static boolean isBudgetEnforcementEnabled() {
        return budgetEnforcementEnabled;
    }

    /**
     * Budget 강제 적용 활성화/비활성화.
     * 
     * @param enabled 활성화 여부
     */
    public static void enableBudgetEnforcement(boolean enabled) {
        budgetEnforcementEnabled = enabled;
        PulseLogger.info(LOG, "[LuaBudgetManager] Budget enforcement: {}", (enabled ? "ENABLED" : "DISABLED"));
    }

    /**
     * 모드별 컨텍스트 ID 생성 헬퍼.
     * 
     * @param modId     모드 ID
     * @param eventName 이벤트 이름
     * @return 컨텍스트 ID (예: "lua.mod.mymod.OnTick")
     */
    public static String modContext(String modId, String eventName) {
        return "lua.mod." + modId + "." + eventName;
    }

    // ═══════════════════════════════════════════════════════════════
    // 내부 상태
    // ═══════════════════════════════════════════════════════════════

    // 컨텍스트별 설정
    private final Map<String, BudgetConfig> configs = new ConcurrentHashMap<>();

    // 컨텍스트별 통계
    private final Map<String, LuaBudgetStats> stats = new ConcurrentHashMap<>();

    private LuaBudgetManager() {
    }

    /**
     * 싱글톤 인스턴스 반환.
     */
    public static LuaBudgetManager getInstance() {
        return INSTANCE;
    }

    // ═══════════════════════════════════════════════════════════════
    // Budget 설정
    // ═══════════════════════════════════════════════════════════════

    /**
     * Budget 설정.
     * 
     * @param contextId    컨텍스트 ID (예: "nerve.tick", "mymod.update")
     * @param budgetMicros 예산 (마이크로초)
     */
    public void setBudget(String contextId, long budgetMicros) {
        configs.computeIfAbsent(contextId, k -> new BudgetConfig()).budgetMicros = budgetMicros;

        // 통계도 초기화
        stats.computeIfAbsent(contextId, k -> new LuaBudgetStats());
    }

    /**
     * Budget 조회.
     * 
     * @param contextId 컨텍스트 ID
     * @return 설정된 예산 (마이크로초), 없으면 -1
     */
    public long getBudget(String contextId) {
        BudgetConfig config = configs.get(contextId);
        return config != null ? config.budgetMicros : -1;
    }

    /**
     * 남은 Budget 조회.
     * 활성 컨텍스트가 없으면 전체 budget 반환.
     * 
     * @param contextId 컨텍스트 ID
     * @return 남은 예산 (마이크로초)
     */
    public long getRemainingBudget(String contextId) {
        BudgetConfig config = configs.get(contextId);
        if (config == null)
            return -1;

        if (config.activeContext != null) {
            return config.activeContext.getRemainingMicros();
        }
        return config.budgetMicros;
    }

    // ═══════════════════════════════════════════════════════════════
    // 실행 컨텍스트
    // ═══════════════════════════════════════════════════════════════

    /**
     * 실행 컨텍스트 시작.
     * try-with-resources로 사용 권장.
     * 
     * @param contextId 컨텍스트 ID
     * @return 실행 컨텍스트
     */
    public LuaExecutionContext beginExecution(String contextId) {
        BudgetConfig config = configs.computeIfAbsent(contextId, k -> {
            BudgetConfig c = new BudgetConfig();
            c.budgetMicros = 10_000; // 기본 10ms
            return c;
        });

        LuaExecutionContext ctx = new LuaExecutionContext(
                contextId, config.budgetMicros, this);

        config.activeContext = ctx;
        return ctx;
    }

    /**
     * 컨텍스트 종료 (내부용).
     */
    @InternalAPI
    void endExecution(LuaExecutionContext ctx) {
        BudgetConfig config = configs.get(ctx.getContextId());
        if (config != null) {
            config.activeContext = null;

            // 통계 업데이트
            updateStats(ctx);

            // 예산 초과 시 fallback 호출
            if (ctx.getElapsedMicros() > config.budgetMicros && config.fallbackHandler != null) {
                try {
                    config.fallbackHandler.run();
                } catch (Exception e) {
                    PulseLogger.error(LOG, "[LuaBudgetManager] Fallback failed: {}", e.getMessage());
                }
            }
        }
    }

    private void updateStats(LuaExecutionContext ctx) {
        LuaBudgetStats stat = stats.computeIfAbsent(ctx.getContextId(), k -> new LuaBudgetStats());

        long elapsed = ctx.getElapsedMicros();
        stat.totalExecutions++;
        stat.totalMicros += elapsed;
        stat.avgExecutionMicros = stat.totalMicros / stat.totalExecutions;

        if (elapsed > stat.maxExecutionMicros) {
            stat.maxExecutionMicros = elapsed;
        }

        if (elapsed > getBudget(ctx.getContextId())) {
            stat.budgetExceededCount++;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Fallback 핸들러
    // ═══════════════════════════════════════════════════════════════

    /**
     * Fallback 핸들러 설정.
     * Budget 초과 시 호출됨.
     * 
     * @param contextId 컨텍스트 ID
     * @param handler   핸들러
     */
    public void setFallbackHandler(String contextId, Runnable handler) {
        configs.computeIfAbsent(contextId, k -> new BudgetConfig()).fallbackHandler = handler;
    }

    /**
     * Fallback 핸들러 제거.
     * 
     * @param contextId 컨텍스트 ID
     */
    public void removeFallbackHandler(String contextId) {
        BudgetConfig config = configs.get(contextId);
        if (config != null) {
            config.fallbackHandler = null;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // 통계
    // ═══════════════════════════════════════════════════════════════

    /**
     * 통계 조회.
     * 
     * @param contextId 컨텍스트 ID
     * @return 통계 객체 (없으면 빈 통계)
     */
    public LuaBudgetStats getStats(String contextId) {
        return stats.getOrDefault(contextId, new LuaBudgetStats());
    }

    /**
     * 통계 초기화.
     * 
     * @param contextId 컨텍스트 ID
     */
    public void resetStats(String contextId) {
        stats.put(contextId, new LuaBudgetStats());
    }

    /**
     * 모든 통계 초기화.
     */
    public void resetAllStats() {
        stats.clear();
    }

    /**
     * 등록된 모든 컨텍스트 ID 조회.
     */
    public java.util.Set<String> getContextIds() {
        return java.util.Collections.unmodifiableSet(configs.keySet());
    }

    // ═══════════════════════════════════════════════════════════════
    // 리포트
    // ═══════════════════════════════════════════════════════════════

    /**
     * 전체 Budget 상태 리포트 출력.
     */
    public void printReport() {
        PulseLogger.info(LOG, "═══════════════════════════════════════════════");
        PulseLogger.info(LOG, "  Lua Budget Report");
        PulseLogger.info(LOG, "═══════════════════════════════════════════════");

        for (String contextId : configs.keySet()) {
            BudgetConfig config = configs.get(contextId);
            LuaBudgetStats stat = stats.getOrDefault(contextId, new LuaBudgetStats());

            PulseLogger.info(LOG, "  [{}]", contextId);
            PulseLogger.info(LOG, "    Budget: {}ms", String.format("%.2f", config.budgetMicros / 1000.0));
            PulseLogger.info(LOG, "    Executions: {} (exceeded: {})",
                    stat.totalExecutions, stat.budgetExceededCount);
            PulseLogger.info(LOG, "    Avg: {}ms, Max: {}ms",
                    String.format("%.2f", stat.avgExecutionMicros / 1000.0),
                    String.format("%.2f", stat.maxExecutionMicros / 1000.0));
        }

        PulseLogger.info(LOG, "═══════════════════════════════════════════════");
    }

    // ═══════════════════════════════════════════════════════════════
    // 내부 클래스
    // ═══════════════════════════════════════════════════════════════

    private static class BudgetConfig {
        long budgetMicros = 10_000; // 기본 10ms
        Runnable fallbackHandler;
        LuaExecutionContext activeContext;
    }

    /**
     * Lua Budget 통계.
     */
    @PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
    public static class LuaBudgetStats {
        public long totalExecutions = 0;
        public long budgetExceededCount = 0;
        public long avgExecutionMicros = 0;
        public long maxExecutionMicros = 0;
        public long totalMicros = 0;

        @Override
        public String toString() {
            return String.format("LuaBudgetStats[executions=%d, exceeded=%d, avg=%.2fms, max=%.2fms]",
                    totalExecutions, budgetExceededCount,
                    avgExecutionMicros / 1000.0, maxExecutionMicros / 1000.0);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\lua\LuaExecutionContext.java =====

package com.pulse.api.lua;

import com.pulse.api.PublicAPI;

/**
 * Lua 실행 컨텍스트.
 * try-with-resources 패턴을 지원하여 자동으로 budget 정산.
 * 
 * <pre>
 * // 사용 예시
 * LuaBudgetManager budget = LuaBudgetManager.getInstance();
 * 
 * try (LuaExecutionContext ctx = budget.beginExecution("mymod.update")) {
 *     while (ctx.hasRemainingBudget()) {
 *         doSomeLuaWork();
 *         ctx.checkpoint(); // 중간 체크
 *     }
 * } // 자동으로 정산됨
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class LuaExecutionContext implements AutoCloseable {

    private final String contextId;
    private final long budgetMicros;
    private final long startNanos;
    private final LuaBudgetManager manager;

    private volatile long lastCheckpointNanos;
    private volatile int checkpointCount = 0;
    private volatile boolean closed = false;

    /**
     * 컨텍스트 생성 (LuaBudgetManager 내부용).
     */
    LuaExecutionContext(String contextId, long budgetMicros, LuaBudgetManager manager) {
        this.contextId = contextId;
        this.budgetMicros = budgetMicros;
        this.manager = manager;
        this.startNanos = System.nanoTime();
        this.lastCheckpointNanos = startNanos;
    }

    /**
     * 컨텍스트 ID 반환.
     */
    public String getContextId() {
        return contextId;
    }

    /**
     * 설정된 Budget 반환 (마이크로초).
     */
    public long getBudgetMicros() {
        return budgetMicros;
    }

    /**
     * 경과 시간 반환 (마이크로초).
     */
    public long getElapsedMicros() {
        return (System.nanoTime() - startNanos) / 1000;
    }

    /**
     * 남은 Budget 반환 (마이크로초).
     * 음수면 이미 초과됨.
     */
    public long getRemainingMicros() {
        return budgetMicros - getElapsedMicros();
    }

    /**
     * 남은 Budget이 있는지 확인.
     * 
     * @return Budget이 남아있으면 true
     */
    public boolean hasRemainingBudget() {
        return getRemainingMicros() > 0;
    }

    /**
     * Budget 초과 여부 확인.
     * 
     * @return 초과했으면 true
     */
    public boolean isOverBudget() {
        return getRemainingMicros() < 0;
    }

    /**
     * 중간 체크포인트.
     * 긴 작업 중간에 호출하여 budget 상태 업데이트.
     * 
     * @return 남은 budget이 있으면 true
     */
    public boolean checkpoint() {
        lastCheckpointNanos = System.nanoTime();
        checkpointCount++;
        return hasRemainingBudget();
    }

    /**
     * 마지막 체크포인트 이후 경과 시간 (마이크로초).
     */
    public long getMicrosSinceLastCheckpoint() {
        return (System.nanoTime() - lastCheckpointNanos) / 1000;
    }

    /**
     * 체크포인트 호출 횟수.
     */
    public int getCheckpointCount() {
        return checkpointCount;
    }

    /**
     * 컨텍스트가 아직 활성 상태인지 확인.
     */
    public boolean isActive() {
        return !closed;
    }

    /**
     * 특정 작업에 필요한 budget이 남아있는지 확인.
     * 
     * @param requiredMicros 필요한 시간 (마이크로초)
     * @return 충분한 budget이 있으면 true
     */
    public boolean hasBudgetFor(long requiredMicros) {
        return getRemainingMicros() >= requiredMicros;
    }

    /**
     * Budget의 X% 이상 남았는지 확인.
     * 
     * @param percentRemaining 남아야 할 비율 (0.0 ~ 1.0)
     * @return 충분히 남았으면 true
     */
    public boolean hasPercentRemaining(double percentRemaining) {
        long required = (long) (budgetMicros * percentRemaining);
        return getRemainingMicros() >= required;
    }

    /**
     * 경과 시간의 비율 (0.0 ~ 1.0+).
     * 1.0 이상이면 budget 초과.
     */
    public double getElapsedRatio() {
        return (double) getElapsedMicros() / budgetMicros;
    }

    /**
     * 컨텍스트 종료.
     * AutoCloseable 구현으로 try-with-resources 지원.
     */
    @Override
    public void close() {
        if (!closed) {
            closed = true;
            manager.endExecution(this);
        }
    }

    @Override
    public String toString() {
        return String.format("LuaExecutionContext[%s, elapsed=%.2fms/%.2fms, remaining=%.2fms]",
                contextId,
                getElapsedMicros() / 1000.0,
                budgetMicros / 1000.0,
                getRemainingMicros() / 1000.0);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\mixin\InjectionListener.java =====

package com.pulse.api.mixin;

import com.pulse.api.PublicAPI;
import com.pulse.api.log.PulseLogger;

/**
 * Mixin 인젝션 이벤트 리스너 인터페이스.
 * 
 * <pre>
 * // 사용 예시
 * MixinInjectionValidator.addListener(new InjectionListener() {
 *     &#64;Override
 *     public void onInjectionSuccess(String mixinClass, String targetClass, long timeMs) {
 *         System.out.println("Mixin applied: " + mixinClass + " in " + timeMs + "ms");
 *     }
 * 
 *     &#64;Override
 *     public void onInjectionFailed(String mixinClass, String targetClass, String reason) {
 *         System.err.println("Mixin failed: " + mixinClass + " - " + reason);
 *     }
 * });
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public interface InjectionListener {
    String LOG = PulseLogger.PULSE;

    /**
     * Mixin 인젝션 성공 시 호출.
     * 
     * @param mixinClass  Mixin 클래스 전체 경로
     * @param targetClass 대상 클래스 전체 경로
     * @param timeMs      인젝션에 걸린 시간 (밀리초)
     */
    void onInjectionSuccess(String mixinClass, String targetClass, long timeMs);

    /**
     * Mixin 인젝션 실패 시 호출.
     * 
     * @param mixinClass  Mixin 클래스 전체 경로
     * @param targetClass 대상 클래스 전체 경로
     * @param reason      실패 사유
     */
    void onInjectionFailed(String mixinClass, String targetClass, String reason);

    // ═══════════════════════════════════════════════════════════════
    // 기본 구현 제공
    // ═══════════════════════════════════════════════════════════════

    /**
     * 성공만 로깅하는 리스너.
     */
    static InjectionListener successLogger() {
        return new InjectionListener() {
            @Override
            public void onInjectionSuccess(String mixinClass, String targetClass, long timeMs) {
                PulseLogger.info(LOG, "[Mixin] ✓ {} → {} ({}ms)", mixinClass, targetClass, timeMs);
            }

            @Override
            public void onInjectionFailed(String mixinClass, String targetClass, String reason) {
                // 무시
            }
        };
    }

    /**
     * 실패만 로깅하는 리스너.
     */
    static InjectionListener failureLogger() {
        return new InjectionListener() {
            @Override
            public void onInjectionSuccess(String mixinClass, String targetClass, long timeMs) {
                // 무시
            }

            @Override
            public void onInjectionFailed(String mixinClass, String targetClass, String reason) {
                PulseLogger.error(LOG, "[Mixin] ✗ {} → {}: {}", mixinClass, targetClass, reason);
            }
        };
    }

    /**
     * 모든 이벤트 로깅하는 리스너.
     */
    static InjectionListener fullLogger() {
        return new InjectionListener() {
            @Override
            public void onInjectionSuccess(String mixinClass, String targetClass, long timeMs) {
                PulseLogger.info(LOG, "[Mixin] ✓ {} → {} ({}ms)", mixinClass, targetClass, timeMs);
            }

            @Override
            public void onInjectionFailed(String mixinClass, String targetClass, String reason) {
                PulseLogger.error(LOG, "[Mixin] ✗ {} → {}: {}", mixinClass, targetClass, reason);
            }
        };
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\mixin\MixinInjectionValidator.java =====

package com.pulse.api.mixin;

import com.pulse.api.InternalAPI;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.PublicAPI;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Mixin 인젝션 검증 API.
 * Fuse/Nerve가 Mixin 인젝션 성공/실패를 확인하고 대응할 수 있습니다.
 * 
 * <pre>
 * // 사용 예시
 * InjectionResult result = MixinInjectionValidator.validateInjection(
 *         "com.fuse.mixin.ZombieAIMixin",
 *         "zombie.ai.ZombieAI");
 * 
 * if (!result.isSuccess()) {
 *     System.out.println("Mixin failed: " + result.getFailureReason());
 * }
 * 
 * // 콜백 등록
 * MixinInjectionValidator.onInjectionComplete(result -> {
 *     if (!result.isSuccess()) {
 *         Pulse.warn("Mixin failed: " + result.getMixinClass());
 *     }
 * });
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class MixinInjectionValidator {

    // 인젝션 결과 저장
    private static final String LOG = PulseLogger.PULSE;
    private static final Map<String, InjectionResult> results = new ConcurrentHashMap<>();

    // 비활성화된 Mixin 목록 (Fail-soft용)
    private static final Set<String> disabledMixins = ConcurrentHashMap.newKeySet();

    // 콜백 리스너
    private static final List<Consumer<InjectionResult>> callbacks = new CopyOnWriteArrayList<>();
    private static final List<InjectionListener> listeners = new CopyOnWriteArrayList<>();

    private MixinInjectionValidator() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // Mixin 비활성화 (Fail-soft용)
    // ═══════════════════════════════════════════════════════════════

    /**
     * Mixin 비활성화.
     * 실패한 Mixin을 다시 적용하지 않도록 표시.
     * 
     * @param mixinClass Mixin 클래스 전체 경로
     */
    public static void disableMixin(String mixinClass) {
        if (mixinClass != null && !mixinClass.isEmpty()) {
            disabledMixins.add(mixinClass);
            PulseLogger.info(LOG, "[MixinInjectionValidator] Mixin disabled: {}", mixinClass);
        }
    }

    /**
     * Mixin이 비활성화되어 있는지 확인.
     * 
     * @param mixinClass Mixin 클래스 전체 경로
     * @return 비활성화되어 있으면 true
     */
    public static boolean isMixinDisabled(String mixinClass) {
        return mixinClass != null && disabledMixins.contains(mixinClass);
    }

    /**
     * 비활성화된 Mixin 목록 반환.
     * 
     * @return 불변 Set
     */
    public static Set<String> getDisabledMixins() {
        return java.util.Collections.unmodifiableSet(disabledMixins);
    }

    /**
     * 비활성화된 Mixin 수.
     * 
     * @return 비활성화된 Mixin 수
     */
    public static int getDisabledCount() {
        return disabledMixins.size();
    }

    // ═══════════════════════════════════════════════════════════════
    // 결과 기록 (내부용)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 성공한 인젝션 기록.
     */
    @InternalAPI
    public static void recordSuccess(String mixinClass, String targetClass, long timeMs) {
        InjectionResult result = new InjectionResult(mixinClass, targetClass, true, null, timeMs);
        results.put(createKey(mixinClass, targetClass), result);
        notifyListeners(result);
    }

    /**
     * 실패한 인젝션 기록.
     */
    @InternalAPI
    public static void recordFailure(String mixinClass, String targetClass, String reason) {
        InjectionResult result = new InjectionResult(mixinClass, targetClass, false, reason, 0);
        results.put(createKey(mixinClass, targetClass), result);
        notifyListeners(result);
    }

    private static String createKey(String mixinClass, String targetClass) {
        return mixinClass + "->" + targetClass;
    }

    private static void notifyListeners(InjectionResult result) {
        // Consumer callbacks
        for (Consumer<InjectionResult> callback : callbacks) {
            try {
                callback.accept(result);
            } catch (Exception e) {
                PulseLogger.error(LOG, "[MixinInjectionValidator] Callback failed: {}", e.getMessage());
            }
        }

        // Listener callbacks
        for (InjectionListener listener : listeners) {
            try {
                if (result.isSuccess()) {
                    listener.onInjectionSuccess(result.getMixinClass(),
                            result.getTargetClass(), result.getInjectionTimeMs());
                } else {
                    listener.onInjectionFailed(result.getMixinClass(),
                            result.getTargetClass(), result.getFailureReason());
                }
            } catch (Exception e) {
                PulseLogger.error(LOG, "[MixinInjectionValidator] Listener failed: {}", e.getMessage());
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // 조회 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 특정 Mixin 인젝션 결과 조회.
     * 
     * @param mixinClass  Mixin 클래스 전체 경로
     * @param targetClass 대상 클래스 전체 경로
     * @return 인젝션 결과 (없으면 null)
     */
    public static InjectionResult validateInjection(String mixinClass, String targetClass) {
        return results.get(createKey(mixinClass, targetClass));
    }

    /**
     * 특정 Mixin 인젝션 결과 조회 (Optional).
     */
    public static Optional<InjectionResult> findInjection(String mixinClass, String targetClass) {
        return Optional.ofNullable(validateInjection(mixinClass, targetClass));
    }

    /**
     * 모든 인젝션 결과 조회.
     * 
     * @return 불변 리스트
     */
    public static List<InjectionResult> getAllResults() {
        return Collections.unmodifiableList(new ArrayList<>(results.values()));
    }

    /**
     * 성공한 인젝션만 조회.
     * 
     * @return 성공한 인젝션 리스트
     */
    public static List<InjectionResult> getSuccessfulInjections() {
        return results.values().stream()
                .filter(InjectionResult::isSuccess)
                .collect(Collectors.toList());
    }

    /**
     * 실패한 인젝션만 조회.
     * 
     * @return 실패한 인젝션 리스트
     */
    public static List<InjectionResult> getFailedInjections() {
        return results.values().stream()
                .filter(r -> !r.isSuccess())
                .collect(Collectors.toList());
    }

    /**
     * 특정 타깃에 대한 모든 인젝션 조회.
     * 
     * @param targetClass 대상 클래스
     * @return 해당 타깃의 모든 인젝션 결과
     */
    public static List<InjectionResult> getInjectionsForTarget(String targetClass) {
        return results.values().stream()
                .filter(r -> r.getTargetClass().equals(targetClass))
                .collect(Collectors.toList());
    }

    /**
     * 전체 인젝션 수.
     */
    public static int getTotalCount() {
        return results.size();
    }

    /**
     * 성공한 인젝션 수.
     */
    public static int getSuccessCount() {
        return (int) results.values().stream().filter(InjectionResult::isSuccess).count();
    }

    /**
     * 실패한 인젝션 수.
     */
    public static int getFailureCount() {
        return (int) results.values().stream().filter(r -> !r.isSuccess()).count();
    }

    // ═══════════════════════════════════════════════════════════════
    // 콜백 등록
    // ═══════════════════════════════════════════════════════════════

    /**
     * 인젝션 완료 시 콜백 등록.
     * 
     * @param callback 콜백 함수
     */
    public static void onInjectionComplete(Consumer<InjectionResult> callback) {
        if (callback != null) {
            callbacks.add(callback);
        }
    }

    /**
     * 인젝션 리스너 등록.
     * 
     * @param listener 리스너
     */
    public static void addListener(InjectionListener listener) {
        if (listener != null) {
            listeners.add(listener);
        }
    }

    /**
     * 인젝션 리스너 제거.
     * 
     * @param listener 리스너
     */
    public static void removeListener(InjectionListener listener) {
        listeners.remove(listener);
    }

    // ═══════════════════════════════════════════════════════════════
    // 리포트
    // ═══════════════════════════════════════════════════════════════

    /**
     * 인젝션 상태 리포트 출력.
     */
    public static void printReport() {
        PulseLogger.info(LOG, "═══════════════════════════════════════════════");
        PulseLogger.info(LOG, "  Mixin Injection Report");
        PulseLogger.info(LOG, "═══════════════════════════════════════════════");
        PulseLogger.info(LOG, "  Total: {} | Success: {} | Failed: {}",
                getTotalCount(), getSuccessCount(), getFailureCount());
        PulseLogger.info(LOG, "───────────────────────────────────────────────");

        // 실패한 것들 먼저 출력
        List<InjectionResult> failures = getFailedInjections();
        if (!failures.isEmpty()) {
            PulseLogger.info(LOG, "  ✗ Failed Injections:");
            for (InjectionResult r : failures) {
                PulseLogger.info(LOG, "    - {} → {}", r.getMixinClass(), r.getTargetClass());
                PulseLogger.info(LOG, "      Reason: {}", r.getFailureReason());
            }
        }

        PulseLogger.info(LOG, "═══════════════════════════════════════════════");
    }

    // ═══════════════════════════════════════════════════════════════
    // 결과 클래스
    // ═══════════════════════════════════════════════════════════════

    /**
     * Mixin 인젝션 결과.
     */
    @PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
    public static final class InjectionResult {
        private final String mixinClass;
        private final String targetClass;
        private final boolean success;
        private final String failureReason;
        private final long injectionTimeMs;
        private final long timestamp;

        InjectionResult(String mixinClass, String targetClass, boolean success,
                String failureReason, long injectionTimeMs) {
            this.mixinClass = mixinClass;
            this.targetClass = targetClass;
            this.success = success;
            this.failureReason = failureReason;
            this.injectionTimeMs = injectionTimeMs;
            this.timestamp = System.currentTimeMillis();
        }

        public String getMixinClass() {
            return mixinClass;
        }

        public String getTargetClass() {
            return targetClass;
        }

        public boolean isSuccess() {
            return success;
        }

        public String getFailureReason() {
            return failureReason;
        }

        public long getInjectionTimeMs() {
            return injectionTimeMs;
        }

        public long getTimestamp() {
            return timestamp;
        }

        @Override
        public String toString() {
            if (success) {
                return String.format("InjectionResult[%s → %s, OK, %dms]",
                        mixinClass, targetClass, injectionTimeMs);
            } else {
                return String.format("InjectionResult[%s → %s, FAILED: %s]",
                        mixinClass, targetClass, failureReason);
            }
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\ModLogger.java =====

package com.pulse.api;

import com.pulse.api.log.PulseLogger;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 모드별 로거.
 * 각 모드는 자신만의 로거를 사용하여 [Mod/{modId}] prefix로 로그 출력.
 * 
 * 사용 예:
 * ModLogger logger = ModLogger.getLogger("mymod");
 * logger.info("Mod initialized!");
 * // 출력: [Mod/mymod] Mod initialized!
 */
public class ModLogger {

    private static final Map<String, ModLogger> LOGGERS = new ConcurrentHashMap<>();

    private final String modId;
    private final String prefix;

    private ModLogger(String modId) {
        this.modId = modId;
        this.prefix = "Mod/" + modId;
    }

    // ─────────────────────────────────────────────────────────────
    // 팩토리 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드별 로거 가져오기 (캐싱됨)
     */
    public static ModLogger getLogger(String modId) {
        return LOGGERS.computeIfAbsent(modId, ModLogger::new);
    }

    // ─────────────────────────────────────────────────────────────
    // 로깅 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * INFO 레벨 로그
     */
    public void info(String message) {
        PulseLogger.info(prefix, message);
    }

    /**
     * INFO 레벨 로그 (포맷팅)
     */
    public void info(String format, Object... args) {
        PulseLogger.info(prefix, String.format(format, args));
    }

    /**
     * DEBUG 레벨 로그 (DevMode일 때만)
     */
    public void debug(String message) {
        if (DevMode.isEnabled()) {
            PulseLogger.debug(prefix, message);
        }
    }

    /**
     * DEBUG 레벨 로그 (포맷팅, DevMode일 때만)
     */
    public void debug(String format, Object... args) {
        if (DevMode.isEnabled()) {
            PulseLogger.debug(prefix, String.format(format, args));
        }
    }

    /**
     * WARN 레벨 로그
     */
    public void warn(String message) {
        PulseLogger.warn(prefix, message);
    }

    /**
     * WARN 레벨 로그 (포맷팅)
     */
    public void warn(String format, Object... args) {
        PulseLogger.warn(prefix, String.format(format, args));
    }

    /**
     * ERROR 레벨 로그
     */
    public void error(String message) {
        PulseLogger.error(prefix, message);
    }

    /**
     * ERROR 레벨 로그 (예외 포함)
     */
    public void error(String message, Throwable t) {
        PulseLogger.error(prefix, message, t);
    }

    /**
     * ERROR 레벨 로그 (포맷팅)
     */
    public void error(String format, Object... args) {
        PulseLogger.error(prefix, String.format(format, args));
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public String getModId() {
        return modId;
    }

    public String getPrefix() {
        return prefix;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\optimization\OptimizationPoint.java =====

package com.pulse.api.optimization;

import com.pulse.api.PublicAPI;
import java.util.Optional;

/**
 * 최적화 지점 정의.
 * 각 포인트는 Mixin 타깃 클래스와 Echo 프로파일러 라벨 prefix와 연결됩니다.
 * 
 * <p>
 * Tier 1 (Base): 핵심 병목 영역 - 7개
 * </p>
 * <p>
 * Tier 2 (Platform Extension): Pulse 생태계 확장용 - 3개
 * </p>
 * 
 * <pre>
 * // 사용 예시
 * OptimizationPoint point = OptimizationPoint.ZOMBIE_AI_UPDATE;
 * String target = point.getMixinTarget(); // "zombie.ai.ZombieAI"
 * String prefix = point.getEchoPrefix(); // "zombie.ai"
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public enum OptimizationPoint {

    // ═══════════════════════════════════════════════════════════════
    // Tier 1: Base - 핵심 병목 영역 (7개)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 메인 게임 틱 루프.
     * 전체 프레임 시간의 병목점을 파악하는 데 사용.
     */
    TICK_LOOP("zombie.gameStates.IngameState", "update", "tick", 1),

    /**
     * 좀비 AI 업데이트.
     * AI 경로 탐색 및 상태 머신 처리.
     */
    ZOMBIE_AI_UPDATE("zombie.ai.ZombieAI", "update", "zombie.ai", 1),

    /**
     * 청크 스트리밍.
     * 월드 청크 로드/언로드 처리.
     */
    CHUNK_STREAMING("zombie.iso.IsoChunkGrid", "loadChunk", "chunk", 1),

    /**
     * Lua 이벤트 시스템.
     * Lua 모드의 이벤트 핸들러 호출.
     */
    LUA_EVENT("zombie.Lua.LuaEventManager", "triggerEvent", "lua.event", 1),

    /**
     * 네트워크 패킷 처리.
     * 클라이언트-서버 통신.
     */
    NETWORK_PACKET("zombie.network.GameClient", "processPacket", "network", 1),

    /**
     * 경로 탐색.
     * A* 알고리즘 기반 경로 계산.
     */
    PATHFINDING("zombie.ai.astar.AStarPathFinder", "findPath", "pathfind", 1),

    /**
     * 메인 렌더링.
     * 화면 렌더링 파이프라인.
     */
    RENDER_MAIN("zombie.core.Core", "render", "render", 1),

    // ═══════════════════════════════════════════════════════════════
    // Tier 2: Platform Extension - Pulse 생태계 확장 (3개)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 인벤토리 업데이트.
     * 컨테이너, 아이템 정렬/스캔/트랜잭션 처리.
     * 멀티플레이어에서 병목이 자주 발생하는 영역.
     */
    INVENTORY_UPDATE("zombie.inventory.InventoryContainer", "update", "inventory", 2),

    /**
     * 차량 업데이트.
     * 차량 물리 연산, 충돌 처리, tick-based update.
     */
    VEHICLE_UPDATE("zombie.vehicles.BaseVehicle", "update", "vehicle", 2),

    /**
     * 애니메이션 업데이트.
     * 모델 업데이트, 스킨, 애니메이션 처리.
     */
    ANIMATION_UPDATE("zombie.core.skinnedmodel.ModelManager", "updateAnimation", "animation", 2);

    // ═══════════════════════════════════════════════════════════════
    // 필드 및 메서드
    // ═══════════════════════════════════════════════════════════════

    private final String mixinTarget;
    private final String targetMethod;
    private final String echoPrefix;
    private final int tier;

    OptimizationPoint(String mixinTarget, String targetMethod, String echoPrefix, int tier) {
        this.mixinTarget = mixinTarget;
        this.targetMethod = targetMethod;
        this.echoPrefix = echoPrefix;
        this.tier = tier;
    }

    /**
     * Mixin 대상 클래스의 전체 경로 반환.
     * 
     * @return Mixin 대상 클래스 (예: "zombie.ai.ZombieAI")
     */
    public String getMixinTarget() {
        return mixinTarget;
    }

    /**
     * Mixin 대상 메서드 이름 반환.
     * 
     * @return 대상 메서드명 (예: "update")
     */
    public String getTargetMethod() {
        return targetMethod;
    }

    /**
     * Echo 프로파일러 라벨 prefix 반환.
     * 
     * @return Echo 라벨 prefix (예: "zombie.ai")
     */
    public String getEchoPrefix() {
        return echoPrefix;
    }

    /**
     * Tier 레벨 반환.
     * 
     * @return 1 = Base, 2 = Platform Extension
     */
    public int getTier() {
        return tier;
    }

    /**
     * Echo 프로파일러용 전체 라벨 반환.
     * prefix + "." + targetMethod 형식.
     * 
     * @return 전체 Echo 라벨 (예: "zombie.ai.update")
     */
    public String getEchoLabel() {
        return echoPrefix + "." + targetMethod;
    }

    /**
     * Echo 라벨 생성 헬퍼 (커스텀 suffix 사용).
     * 
     * @param suffix 라벨 suffix (예: "start", "end")
     * @return 전체 라벨 (예: "zombie.ai.start")
     */
    public String createEchoLabel(String suffix) {
        return echoPrefix + "." + suffix;
    }

    /**
     * ID로 OptimizationPoint 찾기.
     * 
     * @param id enum 이름 (예: "ZOMBIE_AI_UPDATE")
     * @return Optional containing the point, or empty if not found
     */
    public static Optional<OptimizationPoint> byId(String id) {
        try {
            return Optional.of(valueOf(id.toUpperCase()));
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
    }

    /**
     * Mixin 타깃으로 OptimizationPoint 찾기.
     * 
     * @param mixinTarget Mixin 대상 클래스 전체 경로
     * @return Optional containing the point, or empty if not found
     */
    public static Optional<OptimizationPoint> byMixinTarget(String mixinTarget) {
        for (OptimizationPoint point : values()) {
            if (point.mixinTarget.equals(mixinTarget)) {
                return Optional.of(point);
            }
        }
        return Optional.empty();
    }

    /**
     * Echo prefix로 OptimizationPoint 찾기.
     * 
     * @param prefix Echo 라벨 prefix
     * @return Optional containing the point, or empty if not found
     */
    public static Optional<OptimizationPoint> byEchoPrefix(String prefix) {
        for (OptimizationPoint point : values()) {
            if (point.echoPrefix.equals(prefix)) {
                return Optional.of(point);
            }
        }
        return Optional.empty();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\optimization\OptimizationPointRegistry.java =====

package com.pulse.api.optimization;

import com.pulse.api.InternalAPI;
import com.pulse.api.PublicAPI;
import com.pulse.api.log.PulseLogger;

import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

/**
 * OptimizationPoint 레지스트리.
 * 기본 제공 포인트와 모드가 커스텀 등록한 포인트를 관리합니다.
 * 
 * <pre>
 * // 커스텀 포인트 등록
 * OptimizationPointRegistry.register("MY_CUSTOM_POINT",
 *         "com.mymod.MyClass", "mymod.custom");
 * 
 * // 포인트 조회
 * OptimizationPointInfo info = OptimizationPointRegistry.get("ZOMBIE_AI_UPDATE");
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class OptimizationPointRegistry {

    // 커스텀 등록된 포인트
    private static final Map<String, OptimizationPointInfo> customPoints = new ConcurrentHashMap<>();
    private static final String LOG = PulseLogger.PULSE;

    // 초기화 플래그
    private static volatile boolean initialized = false;

    private OptimizationPointRegistry() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // 초기화
    // ═══════════════════════════════════════════════════════════════

    /**
     * 레지스트리 초기화 (Pulse 시작 시 자동 호출).
     */
    @InternalAPI
    public static void initialize() {
        if (initialized)
            return;

        // 기본 OptimizationPoint들을 등록
        for (OptimizationPoint point : OptimizationPoint.values()) {
            customPoints.put(point.name(), new OptimizationPointInfo(
                    point.name(),
                    point.getMixinTarget(),
                    point.getEchoPrefix(),
                    point.getTier(),
                    true // built-in
            ));
        }

        initialized = true;
        PulseLogger.info(LOG, "OptimizationPointRegistry initialized with {} built-in points",
                OptimizationPoint.values().length);
    }

    // ═══════════════════════════════════════════════════════════════
    // 등록 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 커스텀 OptimizationPoint 등록.
     * 
     * @param id          고유 식별자 (대문자 권장, 예: "MY_CUSTOM_POINT")
     * @param mixinTarget Mixin 대상 클래스 전체 경로
     * @param echoPrefix  Echo 프로파일러 라벨 prefix
     * @return 등록 성공 여부 (이미 존재하면 false)
     */
    public static boolean register(String id, String mixinTarget, String echoPrefix) {
        return register(id, mixinTarget, echoPrefix, 3); // Tier 3 = custom
    }

    /**
     * 커스텀 OptimizationPoint 등록 (Tier 지정).
     * 
     * @param id          고유 식별자
     * @param mixinTarget Mixin 대상 클래스 전체 경로
     * @param echoPrefix  Echo 프로파일러 라벨 prefix
     * @param tier        Tier 레벨 (3 이상 권장)
     * @return 등록 성공 여부
     */
    public static boolean register(String id, String mixinTarget, String echoPrefix, int tier) {
        if (id == null || id.isEmpty())
            return false;
        if (mixinTarget == null || mixinTarget.isEmpty())
            return false;
        if (echoPrefix == null || echoPrefix.isEmpty())
            return false;

        String normalizedId = id.toUpperCase();

        if (customPoints.containsKey(normalizedId)) {
            PulseLogger.warn(LOG, "OptimizationPoint already exists: {}", normalizedId);
            return false;
        }

        customPoints.put(normalizedId, new OptimizationPointInfo(
                normalizedId, mixinTarget, echoPrefix, tier, false));

        PulseLogger.info(LOG, "Registered custom OptimizationPoint: {}", normalizedId);
        return true;
    }

    // ═══════════════════════════════════════════════════════════════
    // 조회 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * ID로 OptimizationPointInfo 조회.
     * 
     * @param id 포인트 ID
     * @return OptimizationPointInfo or null if not found
     */
    public static OptimizationPointInfo get(String id) {
        if (!initialized)
            initialize();
        return customPoints.get(id.toUpperCase());
    }

    /**
     * ID로 OptimizationPointInfo 조회 (Optional 반환).
     * 
     * @param id 포인트 ID
     * @return Optional containing the info
     */
    public static Optional<OptimizationPointInfo> find(String id) {
        return Optional.ofNullable(get(id));
    }

    /**
     * 모든 등록된 포인트 반환.
     * 
     * @return 불변 컬렉션
     */
    public static Collection<OptimizationPointInfo> getAll() {
        if (!initialized)
            initialize();
        return Collections.unmodifiableCollection(customPoints.values());
    }

    /**
     * 등록 여부 확인.
     * 
     * @param id 포인트 ID
     * @return 등록되어 있으면 true
     */
    public static boolean isRegistered(String id) {
        if (!initialized)
            initialize();
        return customPoints.containsKey(id.toUpperCase());
    }

    /**
     * 등록된 포인트 수.
     * 
     * @return 전체 포인트 수 (built-in + custom)
     */
    public static int size() {
        if (!initialized)
            initialize();
        return customPoints.size();
    }

    /**
     * Mixin 타깃으로 포인트 찾기.
     * 
     * @param mixinTarget Mixin 대상 클래스
     * @return Optional containing the info
     */
    public static Optional<OptimizationPointInfo> findByMixinTarget(String mixinTarget) {
        if (!initialized)
            initialize();
        return customPoints.values().stream()
                .filter(info -> info.getMixinTarget().equals(mixinTarget))
                .findFirst();
    }

    /**
     * Echo prefix로 포인트 찾기.
     * 
     * @param echoPrefix Echo 라벨 prefix
     * @return Optional containing the info
     */
    public static Optional<OptimizationPointInfo> findByEchoPrefix(String echoPrefix) {
        if (!initialized)
            initialize();
        return customPoints.values().stream()
                .filter(info -> info.getEchoPrefix().equals(echoPrefix))
                .findFirst();
    }

    // ═══════════════════════════════════════════════════════════════
    // 정보 클래스
    // ═══════════════════════════════════════════════════════════════

    /**
     * OptimizationPoint 정보를 담는 불변 객체.
     */
    @PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
    public static final class OptimizationPointInfo {
        private final String id;
        private final String mixinTarget;
        private final String echoPrefix;
        private final int tier;
        private final boolean builtIn;

        OptimizationPointInfo(String id, String mixinTarget, String echoPrefix,
                int tier, boolean builtIn) {
            this.id = id;
            this.mixinTarget = mixinTarget;
            this.echoPrefix = echoPrefix;
            this.tier = tier;
            this.builtIn = builtIn;
        }

        public String getId() {
            return id;
        }

        public String getMixinTarget() {
            return mixinTarget;
        }

        public String getEchoPrefix() {
            return echoPrefix;
        }

        public int getTier() {
            return tier;
        }

        public boolean isBuiltIn() {
            return builtIn;
        }

        /**
         * Echo 라벨 생성.
         */
        public String createEchoLabel(String suffix) {
            return echoPrefix + "." + suffix;
        }

        @Override
        public String toString() {
            return String.format("OptimizationPoint[%s, tier=%d, target=%s, echo=%s]",
                    id, tier, mixinTarget, echoPrefix);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\optimization\ProfilerScope.java =====

package com.pulse.api.optimization;

import com.pulse.api.PublicAPI;
import com.pulse.api.FeatureFlags;

/**
 * 프로파일러 스코프.
 * Echo 프로파일러와 연동되는 AutoCloseable 스코프.
 * Echo가 로드되지 않았을 때도 안전하게 no-op으로 동작합니다.
 * 
 * <pre>
 * // 사용 예시 - try-with-resources
 * try (ProfilerScope scope = ProfilerScope.begin(OptimizationPoint.ZOMBIE_AI_UPDATE)) {
 *     // 측정할 코드
 * }
 * // 자동으로 종료됨
 * 
 * // 커스텀 라벨 사용
 * try (ProfilerScope scope = ProfilerScope.begin("mymod.custom.operation")) {
 *     // 측정할 코드
 * }
 * </pre>
 * 
 * @since 1.1.0
 */
@PublicAPI(since = "1.1.0")
public final class ProfilerScope implements AutoCloseable {

    // No-op 싱글톤 (Echo 없을 때 사용)
    private static final ProfilerScope NO_OP = new ProfilerScope(null, null, false);

    // Echo 프로파일러 사용 가능 여부 캐시
    private static volatile Boolean echoAvailable = null;

    private final OptimizationPoint point;
    private final String label;
    private final long startNanos;
    private final boolean active;

    // ═══════════════════════════════════════════════════════════════
    // 생성자 (private)
    // ═══════════════════════════════════════════════════════════════

    private ProfilerScope(OptimizationPoint point, String label, boolean active) {
        this.point = point;
        this.label = label;
        this.active = active;
        this.startNanos = active ? System.nanoTime() : 0;

        if (active && label != null) {
            pushEchoScope(label);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // 팩토리 메서드
    // ═══════════════════════════════════════════════════════════════

    /**
     * OptimizationPoint로 스코프 시작.
     * Echo가 없으면 no-op 스코프 반환.
     * 
     * @param point OptimizationPoint
     * @return ProfilerScope (자동 닫힘)
     */
    public static ProfilerScope begin(OptimizationPoint point) {
        if (!isProfilerAvailable()) {
            return NO_OP;
        }

        String echoLabel = point.getEchoLabel();
        return new ProfilerScope(point, echoLabel, true);
    }

    /**
     * 커스텀 라벨로 스코프 시작.
     * Echo가 없으면 no-op 스코프 반환.
     * 
     * @param label 프로파일러 라벨
     * @return ProfilerScope (자동 닫힘)
     */
    public static ProfilerScope begin(String label) {
        if (!isProfilerAvailable()) {
            return NO_OP;
        }

        return new ProfilerScope(null, label, true);
    }

    // ═══════════════════════════════════════════════════════════════
    // 상태 조회
    // ═══════════════════════════════════════════════════════════════

    /**
     * 경과 시간 (마이크로초).
     * 비활성 스코프는 0 반환.
     * 
     * @return 경과 마이크로초
     */
    public long getElapsedMicros() {
        if (!active) {
            return 0;
        }
        return (System.nanoTime() - startNanos) / 1000;
    }

    /**
     * 경과 시간 (밀리초).
     * 
     * @return 경과 밀리초
     */
    public double getElapsedMillis() {
        return getElapsedMicros() / 1000.0;
    }

    /**
     * 스코프가 활성 상태인지 확인.
     * 
     * @return 활성이면 true
     */
    public boolean isActive() {
        return active;
    }

    /**
     * 연결된 OptimizationPoint 반환.
     * 
     * @return OptimizationPoint (없으면 null)
     */
    public OptimizationPoint getPoint() {
        return point;
    }

    /**
     * 프로파일러 라벨 반환.
     * 
     * @return 라벨 문자열
     */
    public String getLabel() {
        return label;
    }

    // ═══════════════════════════════════════════════════════════════
    // AutoCloseable 구현
    // ═══════════════════════════════════════════════════════════════

    /**
     * 스코프 종료.
     * active=false면 no-op.
     */
    @Override
    public void close() {
        if (active && label != null) {
            popEchoScope(label);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Echo 프로파일러 연동
    // ═══════════════════════════════════════════════════════════════

    /**
     * Echo 프로파일러 사용 가능 여부 확인.
     * 
     * @return Echo가 로드되어 있으면 true
     */
    public static boolean isProfilerAvailable() {
        // 기능이 비활성화되어 있으면 false
        if (!FeatureFlags.isEnabled(FeatureFlags.PROFILER)) {
            return false;
        }

        // 캐시된 결과 사용
        if (echoAvailable != null) {
            return echoAvailable;
        }

        // Echo 클래스 존재 여부 확인
        try {
            Class.forName("com.pulse.echo.EchoProfiler");
            echoAvailable = true;
        } catch (ClassNotFoundException e) {
            echoAvailable = false;
        }

        return echoAvailable;
    }

    /**
     * 프로파일러 가용성 캐시 초기화 (테스트용).
     */
    public static void resetCache() {
        echoAvailable = null;
    }

    // ═══════════════════════════════════════════════════════════════
    // Echo 내부 연동 메서드
    // ═══════════════════════════════════════════════════════════════

    private static void pushEchoScope(String label) {
        try {
            // Echo가 있으면 EchoProfiler.push(label) 호출
            Class<?> echoClass = Class.forName("com.pulse.echo.EchoProfiler");
            java.lang.reflect.Method pushMethod = echoClass.getMethod("push", String.class);
            pushMethod.invoke(null, label);
        } catch (Exception e) {
            // Echo 없음 - 무시
        }
    }

    private static void popEchoScope(String label) {
        try {
            // Echo가 있으면 EchoProfiler.pop() 호출
            Class<?> echoClass = Class.forName("com.pulse.echo.EchoProfiler");
            java.lang.reflect.Method popMethod = echoClass.getMethod("pop");
            popMethod.invoke(null);
        } catch (Exception e) {
            // Echo 없음 - 무시
        }
    }

    @Override
    public String toString() {
        if (!active) {
            return "ProfilerScope[NO_OP]";
        }
        return String.format("ProfilerScope[%s, %.3fms]", label, getElapsedMillis());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\package-info.java =====

/**
 * Pulse Public API.
 * 
 * <p>
 * 이 패키지는 Pulse의 공개 API를 포함합니다. 외부 모드에서 안전하게 사용할 수 있습니다.
 * </p>
 * 
 * <h2>주요 클래스</h2>
 * <ul>
 * <li>{@link com.pulse.api.Pulse} - 메인 API 파사드</li>
 * <li>{@link com.pulse.api.GameAccess} - 게임 내부 접근 (deprecated, use access/
 * package)</li>
 * <li>{@link com.pulse.api.SafeGameAccess} - 안전한 게임 데이터 접근</li>
 * <li>{@link com.pulse.api.PulseMetrics} - 성능 메트릭 수집</li>
 * <li>{@link com.pulse.api.PulseEvents} - 이벤트 시스템 파사드</li>
 * <li>{@link com.pulse.api.PulseLog} - 로깅 파사드</li>
 * </ul>
 * 
 * <h2>하위 패키지</h2>
 * <ul>
 * <li>{@code access} - 세부 게임 데이터 접근 (World, Player, Time, Network, Zombie)</li>
 * <li>{@code exception} - Pulse 예외 계층</li>
 * <li>{@code log} - 로깅 시스템</li>
 * <li>{@code lua} - Lua 상호운용</li>
 * <li>{@code util} - 유틸리티 클래스</li>
 * </ul>
 * 
 * <h2>안정성</h2>
 * <ul>
 * <li>{@link com.pulse.api.PublicAPI} - 안정적인 공개 API 표시</li>
 * <li>{@link com.pulse.api.InternalAPI} - 내부 API (변경 가능)</li>
 * <li>{@link com.pulse.api.Experimental} - 실험적 기능 표시</li>
 * </ul>
 * 
 * @since 1.0
 */
package com.pulse.api;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\IsoGridHook.java =====

package com.pulse.api.profiler;

/**
 * IsoGrid Hooks for Echo.
 * 
 * Allows Echo to receive IsoGrid-level timing events from Pulse mixins.
 * 
 * @since Pulse 1.1
 */
public class IsoGridHook {

    /**
     * 상세 프로파일링 활성화 플래그.
     * Mixin에서 이 값을 체크하여 성능 오버헤드를 최소화합니다.
     */
    public static volatile boolean enabled = false;

    public interface IIsoGridCallback {
        void onRecalcPropertiesStart();

        void onRecalcPropertiesEnd();

        void onFloorUpdateStart();

        void onFloorUpdateEnd();

        void onLightingUpdateStart();

        void onLightingUpdateEnd();

        void onWeatherImpactStart();

        void onWeatherImpactEnd();
    }

    private static IIsoGridCallback callback;

    public static void setCallback(IIsoGridCallback cb) {
        callback = cb;
    }

    public static void clearCallback() {
        callback = null;
    }

    public static void onRecalcPropertiesStart() {
        if (callback != null) {
            callback.onRecalcPropertiesStart();
        }
    }

    public static void onRecalcPropertiesEnd() {
        if (callback != null) {
            callback.onRecalcPropertiesEnd();
        }
    }

    public static void onFloorUpdateStart() {
        if (callback != null) {
            callback.onFloorUpdateStart();
        }
    }

    public static void onFloorUpdateEnd() {
        if (callback != null) {
            callback.onFloorUpdateEnd();
        }
    }

    public static void onLightingUpdateStart() {
        if (callback != null) {
            callback.onLightingUpdateStart();
        }
    }

    public static void onLightingUpdateEnd() {
        if (callback != null) {
            callback.onLightingUpdateEnd();
        }
    }

    public static void onWeatherImpactStart() {
        if (callback != null) {
            callback.onWeatherImpactStart();
        }
    }

    public static void onWeatherImpactEnd() {
        if (callback != null) {
            callback.onWeatherImpactEnd();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\IZombieContext.java =====

package com.pulse.api.profiler;

/**
 * Zombie Context Interface.
 * 
 * 좀비 상태 정보를 Pulse API로 추상화.
 * Fuse가 PZ 클래스를 직접 참조하지 않도록 함.
 * 
 * @since Pulse 1.2 / Phase 2
 */
public interface IZombieContext {

    /**
     * 가장 가까운 플레이어까지의 거리 제곱.
     * 제곱근 연산 회피를 위해 squared distance 사용.
     */
    float getDistanceSquaredToPlayer();

    /**
     * 좀비가 현재 공격 중인지.
     */
    boolean isAttacking();

    /**
     * 좀비에게 타겟이 있는지.
     */
    boolean hasTarget();

    /**
     * 좀비 iteration index (순회 순서).
     * deterministic skip 계산용.
     */
    int getIterationIndex();

    /**
     * 현재 월드 틱.
     */
    int getWorldTick();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\IZombieThrottlePolicy.java =====

package com.pulse.api.profiler;

/**
 * Throttle Policy Interface.
 * 
 * Tiered throttle 방식: update() 취소 없이 ThrottleLevel 반환.
 * 
 * @since Pulse 1.2
 * @since Pulse 1.5 - ThrottleLevel 기반으로 변경
 */
public interface IZombieThrottlePolicy {

    /**
     * 좀비의 throttle 레벨 결정.
     * 
     * update()는 절대 취소되지 않으며, 반환된 ThrottleLevel에 따라
     * AI Step들만 선택적으로 throttle됩니다.
     * 
     * @param distSq          플레이어까지 거리 제곱
     * @param isAttacking     공격 중 여부
     * @param hasTarget       타겟 있음 여부
     * @param recentlyEngaged 최근 60틱 내 교전 여부 (피격/사운드 감지)
     * @return ThrottleLevel (FULL/REDUCED/LOW/MINIMAL)
     */
    ThrottleLevel getThrottleLevel(float distSq, boolean isAttacking,
            boolean hasTarget, boolean recentlyEngaged);

    /**
     * 레거시 호환용 (deprecated).
     * 기존 코드 호환을 위해 유지, 내부적으로 getThrottleLevel() 호출.
     * 
     * @deprecated Use getThrottleLevel() instead
     */
    @Deprecated
    default boolean shouldSkipFast(float distSq, boolean isAttacking, boolean hasTarget,
            int iterIndex, int worldTick) {
        // 레거시: FULL이 아니면 skip으로 간주 (하위 호환)
        ThrottleLevel level = getThrottleLevel(distSq, isAttacking, hasTarget, false);
        return level != ThrottleLevel.FULL;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\PathfindingHook.java =====

package com.pulse.api.profiler;

/**
 * Pathfinding Hooks for Echo.
 * 
 * Allows Echo to receive pathfinding-level timing events from Pulse mixins.
 * 
 * @since Pulse 1.1
 */
public class PathfindingHook {

    /**
     * 경로탐색 프로파일링 활성화 플래그.
     * Mixin에서 이 값을 체크하여 성능 오버헤드를 최소화합니다.
     */
    public static volatile boolean enabled = false;

    public interface IPathfindingCallback {
        void onLosCalculationStart();

        void onLosCalculationEnd();

        void onGridSearchStart();

        void onGridSearchEnd();

        void onPathRequest();
    }

    private static IPathfindingCallback callback;

    public static void setCallback(IPathfindingCallback cb) {
        callback = cb;
    }

    public static void clearCallback() {
        callback = null;
    }

    public static void onLosCalculationStart() {
        if (callback != null) {
            callback.onLosCalculationStart();
        }
    }

    public static void onLosCalculationEnd() {
        if (callback != null) {
            callback.onLosCalculationEnd();
        }
    }

    public static void onGridSearchStart() {
        if (callback != null) {
            callback.onGridSearchStart();
        }
    }

    public static void onGridSearchEnd() {
        if (callback != null) {
            callback.onGridSearchEnd();
        }
    }

    public static void onPathRequest() {
        if (callback != null) {
            callback.onPathRequest();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\ProfilerBridge.java =====

package com.pulse.api.profiler;

import com.pulse.api.log.PulseLogger;

/**
 * Profiler Bridge - Pulse 경유 profiler 데이터 전달.
 * 
 * Fuse가 이 Bridge를 통해 데이터를 보내면,
 * Echo가 등록한 ProfilerSink로 전달됨.
 * 
 * Failsoft: Sink가 없으면 noop.
 * 
 * @since Pulse 1.1
 */
public final class ProfilerBridge {

    private static ProfilerSink sink;

    private ProfilerBridge() {
    }

    /**
     * Sink 등록 (Echo 초기화 시 호출).
     */
    public static void setSink(ProfilerSink s) {
        sink = s;
        if (s != null) {
            PulseLogger.info("Pulse", "ProfilerSink registered");
        }
    }

    /**
     * Sink 해제.
     */
    public static void clearSink() {
        sink = null;
    }

    /**
     * Sink 등록 여부.
     */
    public static boolean hasSink() {
        return sink != null;
    }

    /**
     * 좀비 step 타이밍 기록 (Fuse에서 호출).
     * 
     * @param step           Step 이름
     * @param durationMicros 소요 시간 (microseconds)
     */
    public static void recordZombieStep(String step, long durationMicros) {
        if (sink != null) {
            try {
                sink.recordZombieStep(step, durationMicros);
            } catch (Throwable t) {
                // Failsoft: 무시하고 게임 진행
            }
        }
    }

    /**
     * 좀비 업데이트 카운트 증가 (Fuse에서 호출).
     */
    public static void incrementZombieUpdates() {
        if (sink != null) {
            try {
                sink.incrementZombieUpdates();
            } catch (Throwable t) {
                // Failsoft
            }
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\ProfilerSink.java =====

package com.pulse.api.profiler;

/**
 * Profiler Sink Interface.
 * 
 * Pulse 경유로 profiler 데이터를 전달하기 위한 인터페이스.
 * Echo가 구현하여 등록하면, Fuse가 ProfilerBridge를 통해 데이터를 전달함.
 * 
 * Hub and Spoke 패턴: Fuse → Pulse → Echo (직접 의존 없음)
 * 
 * @since Pulse 1.1
 */
public interface ProfilerSink {

    /**
     * 좀비 step 타이밍 기록.
     * 
     * @param step           Step 이름 (MOTION_UPDATE, SOUND_PERCEPTION,
     *                       TARGET_TRACKING)
     * @param durationMicros 소요 시간 (microseconds)
     */
    void recordZombieStep(String step, long durationMicros);

    /**
     * 좀비 업데이트 카운트 증가.
     */
    void incrementZombieUpdates();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\SubProfilerHook.java =====

package com.pulse.api.profiler;

/**
 * SubProfiler Hooks for Echo.
 * 
 * Allows Echo to receive sub-profiler timing events from Pulse mixins.
 * 
 * @since Pulse 1.1
 */
public class SubProfilerHook {

    public interface ISubProfilerCallback {
        long start(String label);

        void end(String label, long startTime);
    }

    private static ISubProfilerCallback callback;

    public static void setCallback(ISubProfilerCallback cb) {
        callback = cb;
    }

    public static void clearCallback() {
        callback = null;
    }

    public static long start(String label) {
        if (callback != null) {
            return callback.start(label);
        }
        return -1;
    }

    public static void end(String label, long startTime) {
        if (callback != null) {
            callback.end(label, startTime);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\ThrottleLevel.java =====

package com.pulse.api.profiler;

import com.pulse.api.profiler.ZombieStepHook.StepType;

/**
 * Throttle Level for Tiered Zombie Optimization.
 * 
 * 각 레벨은 Step별 interval을 정의합니다.
 * interval=1이면 매 틱 실행, 2면 2틱마다 실행.
 * 
 * @since Pulse 1.5
 */
public enum ThrottleLevel {
    /**
     * 풀 업데이트 - 모든 Step 매 틱 실행.
     * 근거리 또는 공격/타겟/최근 교전 시 적용.
     */
    FULL(1, 1, 1),

    /**
     * 경량 업데이트 - PERCEPTION만 2틱.
     * 중거리 (20-40타일) 적용.
     */
    REDUCED(2, 1, 1),

    /**
     * 최소 업데이트 - PERCEPTION 4틱, BEHAVIOR 2틱.
     * 원거리 (40-80타일) 적용.
     */
    LOW(4, 2, 1),

    /**
     * 휴면 업데이트 - 공격적 throttle.
     * 초원거리 (80타일+) 적용.
     */
    MINIMAL(8, 4, 2);

    /** PERCEPTION step 실행 간격 (틱) */
    public final int perceptionInterval;

    /** BEHAVIOR step 실행 간격 (틱) */
    public final int behaviorInterval;

    /** TARGET step 실행 간격 (틱) */
    public final int targetInterval;

    ThrottleLevel(int perception, int behavior, int target) {
        this.perceptionInterval = perception;
        this.behaviorInterval = behavior;
        this.targetInterval = target;
    }

    /**
     * 주어진 Step이 이번 틱에 실행되어야 하는지 판단.
     * 
     * (zombieId + worldTick) % interval == 0 이면 실행.
     * 
     * @param type      Step 유형
     * @param zombieId  좀비 고유 ID (분산용)
     * @param worldTick 현재 월드 틱
     * @return true면 실행, false면 스킵
     */
    public boolean shouldExecute(StepType type, int zombieId, int worldTick) {
        int interval = getIntervalFor(type);
        if (interval <= 1) {
            return true; // 매 틱 실행
        }
        return ((zombieId + worldTick) % interval) == 0;
    }

    /**
     * Step 유형별 interval 반환.
     */
    public int getIntervalFor(StepType type) {
        if (type == null)
            return 1;

        switch (type) {
            case PERCEPTION:
                return perceptionInterval;
            case BEHAVIOR:
                return behaviorInterval;
            case TARGET:
                return targetInterval;
            case MOTION:
            case COLLISION:
            default:
                return 1; // 항상 실행
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\TickPhaseHook.java =====

package com.pulse.api.profiler;

import com.pulse.api.Pulse;

/**
 * Tick Phase Hooks for Echo.
 * 
 * Allows Echo to receive phase-level timing events from Pulse mixins.
 * 
 * @since Pulse 1.1
 * @since Pulse 0.9 - Added phase validation and predefined phases
 */
public class TickPhaseHook {

    // ═══════════════════════════════════════════════════════════════
    // Predefined Phase Constants (for Fuse/Nerve integration)
    // ═══════════════════════════════════════════════════════════════

    public static final String PHASE_WORLD_UPDATE = "world_update";
    public static final String PHASE_PLAYER_UPDATE = "player_update";
    public static final String PHASE_ZOMBIE_UPDATE = "zombie_update";
    public static final String PHASE_GRID_UPDATE = "grid_update";
    public static final String PHASE_CHUNK_UPDATE = "chunk_update";
    public static final String PHASE_PATHFINDING = "pathfinding";
    public static final String PHASE_LOS_CHECK = "los_check";
    public static final String PHASE_RENDER = "render";

    // v0.9: Additional phases for Echo TickPhaseProfiler mapping
    public static final String PHASE_AI_UPDATE = "ai_update";
    public static final String PHASE_PHYSICS_UPDATE = "physics_update";
    public static final String PHASE_RENDER_PREP = "render_prep";
    public static final String PHASE_ISOGRID_UPDATE = "isogrid_update";

    // ═══════════════════════════════════════════════════════════════
    // Phase Tracking for Validation
    // ═══════════════════════════════════════════════════════════════

    private static String currentPhase = null;
    private static long currentPhaseStart = -1;

    // Rate-limit for warnings (max 5 warnings per session)
    private static int autoCloseWarningCount = 0;
    private static final int MAX_AUTO_CLOSE_WARNINGS = 5;

    public interface ITickPhaseCallback {
        long startPhase(String phase);

        void endPhase(String phase, long startTime);

        void onTickComplete();
    }

    private static volatile ITickPhaseCallback callback;
    private static volatile boolean installed = false;

    // ═══════════════════════════════════════════════════════════════
    // Bootstrap Activation (explicit install)
    // ═══════════════════════════════════════════════════════════════

    /**
     * Install TickPhaseHook (called by PulseCoreBootstrap).
     * 
     * <p>
     * This provides explicit activation instead of relying on static
     * initialization.
     * Safe to call multiple times (idempotent).
     * </p>
     * 
     * @return true if successfully installed, false if already installed
     */
    public static boolean install() {
        if (installed) {
            return false;
        }

        // Reset state for clean start
        resetWarnings();
        currentPhase = null;
        currentPhaseStart = -1;

        installed = true;
        Pulse.log("pulse", "[TickPhaseHook] Installed and ready");
        return true;
    }

    /**
     * Check if TickPhaseHook has been installed by Bootstrap.
     */
    public static boolean isInstalled() {
        return installed;
    }

    /**
     * Uninstall TickPhaseHook (for testing/cleanup).
     */
    public static void uninstall() {
        clearCallback();
        resetWarnings();
        installed = false;
    }

    public static void setCallback(ITickPhaseCallback cb) {
        callback = cb;
    }

    public static void clearCallback() {
        callback = null;
    }

    // Use AtomicInteger for thread safety if needed, though usually on main thread
    private static int phaseErrorCount = 0;

    /**
     * Start a phase. Auto-closes any unclosed previous phase.
     * 
     * @param phase Phase name (use PHASE_* constants when possible)
     * @return Start time in nanoseconds
     */
    public static long startPhase(String phase) {
        // Auto-close unclosed phase (with rate-limited warning)
        if (currentPhase != null) {
            phaseErrorCount++; // Increment error count
            if (autoCloseWarningCount < MAX_AUTO_CLOSE_WARNINGS) {
                autoCloseWarningCount++;
                Pulse.warn("pulse", "[TickPhaseHook] Auto-closing unclosed phase: " + currentPhase
                        + " (warning " + autoCloseWarningCount + "/" + MAX_AUTO_CLOSE_WARNINGS + ")");
            }
            endPhase(currentPhase, currentPhaseStart);
        }

        currentPhase = phase;
        currentPhaseStart = System.nanoTime();

        if (callback != null) {
            return callback.startPhase(phase);
        }
        return currentPhaseStart;
    }

    /**
     * End a phase. Validates phase matches current phase.
     * 
     * @param phase     Phase name
     * @param startTime Start time from startPhase()
     */
    public static void endPhase(String phase, long startTime) {
        // Validate phase matches
        if (currentPhase != null && !currentPhase.equals(phase)) {
            phaseErrorCount++; // Increment error count
            Pulse.warn("pulse", "[TickPhaseHook] Phase mismatch: ending '" + phase
                    + "' but current is '" + currentPhase + "'");
        }

        currentPhase = null;
        currentPhaseStart = -1;

        if (callback != null) {
            callback.endPhase(phase, startTime);
        }
    }

    /**
     * Called when a complete tick finishes.
     */
    public static void onTickComplete() {
        // Auto-close any unclosed phase at tick end
        if (currentPhase != null) {
            phaseErrorCount++; // Increment error count
            if (autoCloseWarningCount < MAX_AUTO_CLOSE_WARNINGS) {
                autoCloseWarningCount++;
                Pulse.warn("pulse", "[TickPhaseHook] Phase '" + currentPhase
                        + "' not closed before tick complete");
            }
            endPhase(currentPhase, currentPhaseStart);
        }

        if (callback != null) {
            callback.onTickComplete();
        }
    }

    /**
     * Get current active phase (for debugging)
     */
    public static String getCurrentPhase() {
        return currentPhase;
    }

    /**
     * Get total phase errors (mismatches + unclosed phases)
     */
    public static int getPhaseErrorCount() {
        return phaseErrorCount;
    }

    /**
     * Reset warning counter (for testing)
     */
    public static void resetWarnings() {
        autoCloseWarningCount = 0;
        phaseErrorCount = 0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\ZombieContextProvider.java =====

package com.pulse.api.profiler;

/**
 * Zombie Context Provider.
 * 
 * IsoZombie 객체에서 IZombieContext를 생성.
 * Mixin에서 호출하여 컨텍스트를 제공.
 * 
 * @since Pulse 1.2 / Phase 2
 */
public class ZombieContextProvider {

    private static int currentIterationIndex = 0;
    private static int worldTick = 0;

    /**
     * 현재 iteration index 증가 및 반환.
     */
    public static int nextIterationIndex() {
        return currentIterationIndex++;
    }

    /**
     * 틱 시작 시 iteration index 리셋.
     */
    public static void resetIterationIndex() {
        currentIterationIndex = 0;
    }

    /**
     * 월드 틱 업데이트.
     */
    public static void setWorldTick(int tick) {
        worldTick = tick;
    }

    public static int getWorldTick() {
        return worldTick;
    }

    /**
     * IsoZombie에서 Context 생성.
     * PZ 클래스에 대한 리플렉션으로 의존성 분리.
     */
    public static IZombieContext createContext(Object zombie) {
        if (zombie == null)
            return null;

        int index = nextIterationIndex();
        int tick = worldTick;

        try {
            // 리플렉션으로 PZ 클래스 메서드 호출
            Class<?> zombieClass = zombie.getClass();

            // getDistanceSq - 플레이어까지 거리
            float distSq = getDistanceToNearestPlayer(zombie, zombieClass);

            // isAttacking
            boolean attacking = invokeBoolean(zombie, zombieClass, "isAttacking", false);

            // getTarget
            Object target = invokeObject(zombie, zombieClass, "getTarget");
            boolean hasTarget = target != null;

            return new ZombieContext(distSq, attacking, hasTarget, index, tick);
        } catch (Throwable t) {
            // Failsoft: 에러 시 안전한 기본값 (스킵 안함)
            return new ZombieContext(0f, true, true, index, tick);
        }
    }

    private static float getDistanceToNearestPlayer(Object zombie, Class<?> zombieClass) {
        try {
            // zombie.getX(), getY() 가져오기
            float zx = invokeFloat(zombie, zombieClass, "getX", 0f);
            float zy = invokeFloat(zombie, zombieClass, "getY", 0f);

            // IsoPlayer.players 순회하여 가장 가까운 플레이어 찾기
            Class<?> playerClass = Class.forName("zombie.characters.IsoPlayer");
            java.lang.reflect.Field playersField = playerClass.getField("players");
            Object playersArray = playersField.get(null);

            if (playersArray == null)
                return Float.MAX_VALUE;

            // ArrayList<IsoPlayer>
            java.util.ArrayList<?> players = (java.util.ArrayList<?>) playersArray;

            float minDistSq = Float.MAX_VALUE;
            for (Object player : players) {
                if (player == null)
                    continue;
                float px = invokeFloat(player, player.getClass(), "getX", 0f);
                float py = invokeFloat(player, player.getClass(), "getY", 0f);
                float dx = zx - px;
                float dy = zy - py;
                float distSq = dx * dx + dy * dy;
                if (distSq < minDistSq) {
                    minDistSq = distSq;
                }
            }
            return minDistSq;
        } catch (Throwable t) {
            return Float.MAX_VALUE; // 에러 시 멀리있다고 가정
        }
    }

    private static boolean invokeBoolean(Object obj, Class<?> clazz, String method, boolean def) {
        try {
            return (boolean) clazz.getMethod(method).invoke(obj);
        } catch (Throwable t) {
            return def;
        }
    }

    private static float invokeFloat(Object obj, Class<?> clazz, String method, float def) {
        try {
            return (float) clazz.getMethod(method).invoke(obj);
        } catch (Throwable t) {
            return def;
        }
    }

    private static Object invokeObject(Object obj, Class<?> clazz, String method) {
        try {
            return clazz.getMethod(method).invoke(obj);
        } catch (Throwable t) {
            return null;
        }
    }

    /**
     * 내부 Context 구현.
     */
    private static class ZombieContext implements IZombieContext {
        private final float distSq;
        private final boolean attacking;
        private final boolean hasTarget;
        private final int index;
        private final int tick;

        ZombieContext(float distSq, boolean attacking, boolean hasTarget, int index, int tick) {
            this.distSq = distSq;
            this.attacking = attacking;
            this.hasTarget = hasTarget;
            this.index = index;
            this.tick = tick;
        }

        @Override
        public float getDistanceSquaredToPlayer() {
            return distSq;
        }

        @Override
        public boolean isAttacking() {
            return attacking;
        }

        @Override
        public boolean hasTarget() {
            return hasTarget;
        }

        @Override
        public int getIterationIndex() {
            return index;
        }

        @Override
        public int getWorldTick() {
            return tick;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\ZombieHook.java =====

package com.pulse.api.profiler;

import com.pulse.api.log.PulseLogger;

/**
 * Zombie Hooks for Echo/Fuse.
 * 
 * Phase 2 Optimized: 리플렉션 제거, 경량화
 * Phase 3: Tiered throttle + ThreadLocal 컨텍스트
 * 
 * @since Pulse 1.2
 * @since Pulse 1.5 - ThrottleLevel 기반 Tiered throttle
 */
public class ZombieHook {

    /** Enable detailed profiling (계측 오버헤드 있음) */
    public static boolean profilingEnabled = false;

    /** Throttle policy (Fuse) */
    private static IZombieThrottlePolicy throttlePolicy;

    /** Profiling callback */
    private static IZombieCallback callback;

    // =================================================================
    // ThreadLocal ThrottleLevel Context (Stale 방지 포함)
    // =================================================================

    /** ThreadLocal 컨텍스트 (level + 설정 틱) */
    private static final ThreadLocal<ThrottleLevelContext> currentContext = new ThreadLocal<>();

    /** 컨텍스트 레코드 - level과 설정 틱을 함께 저장 */
    private static class ThrottleLevelContext {
        final ThrottleLevel level;
        final long setTick;

        ThrottleLevelContext(ThrottleLevel level, long setTick) {
            this.level = level;
            this.setTick = setTick;
        }
    }

    /**
     * 현재 좀비의 ThrottleLevel 설정 (Mixin update HEAD에서 호출).
     * 
     * @param level     ThrottleLevel
     * @param worldTick 현재 월드 틱 (stale 감지용)
     */
    public static void setCurrentThrottleLevel(ThrottleLevel level, long worldTick) {
        currentContext.set(new ThrottleLevelContext(level, worldTick));
    }

    /**
     * 현재 ThrottleLevel 조회 (Step hook에서 호출).
     * 
     * Stale 방지: 1틱 이상 지난 컨텍스트는 FULL로 폴백.
     * 
     * @param worldTick 현재 월드 틱
     * @return ThrottleLevel (stale이거나 null이면 FULL)
     */
    public static ThrottleLevel getCurrentThrottleLevel(long worldTick) {
        ThrottleLevelContext ctx = currentContext.get();
        if (ctx == null) {
            return ThrottleLevel.FULL;
        }

        // 1틱 이상 지났으면 stale → FULL 폴백
        if (worldTick - ctx.setTick > 1) {
            currentContext.remove();
            return ThrottleLevel.FULL;
        }
        return ctx.level;
    }

    /**
     * ThrottleLevel 컨텍스트 정리 (Mixin update RETURN에서 호출).
     */
    public static void clearCurrentThrottleLevel() {
        currentContext.remove();
    }

    // =================================================================
    // Registration
    // =================================================================

    public static void setCallback(IZombieCallback cb) {
        callback = cb;
    }

    public static void clearCallback() {
        callback = null;
    }

    public static void setThrottlePolicy(IZombieThrottlePolicy policy) {
        throttlePolicy = policy;
        if (policy != null) {
            PulseLogger.info("Pulse", "ZombieThrottlePolicy registered (Tiered mode)");
        }
    }

    public static void clearThrottlePolicy() {
        throttlePolicy = null;
    }

    // =================================================================
    // ThrottleLevel API (신규)
    // =================================================================

    /**
     * ThrottleLevel 조회 (Mixin에서 호출).
     * 
     * @param distSq          플레이어까지 거리 제곱
     * @param isAttacking     공격 중 여부
     * @param hasTarget       타겟 있음 여부
     * @param recentlyEngaged 최근 60틱 내 교전 여부
     * @return ThrottleLevel (policy 없으면 FULL)
     */
    public static ThrottleLevel getThrottleLevel(float distSq, boolean isAttacking,
            boolean hasTarget, boolean recentlyEngaged) {
        if (throttlePolicy == null) {
            return ThrottleLevel.FULL;
        }

        try {
            return throttlePolicy.getThrottleLevel(distSq, isAttacking, hasTarget, recentlyEngaged);
        } catch (Throwable t) {
            return ThrottleLevel.FULL;
        }
    }

    // =================================================================
    // Legacy API (Deprecated - 하위 호환용)
    // =================================================================

    /**
     * @deprecated Use getThrottleLevel() instead
     */
    @Deprecated
    public static boolean shouldSkipFast(float distSq, boolean isAttacking, boolean hasTarget,
            int iterIndex, int worldTick) {
        ThrottleLevel level = getThrottleLevel(distSq, isAttacking, hasTarget, false);
        return level != ThrottleLevel.FULL;
    }

    // --- Profiling (조건부) ---

    public static void onZombieUpdate(Object zombie) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onZombieUpdateWithContext(zombie);
            } catch (Throwable t) {
            }
        }
    }

    public static void onMotionUpdateStart(Object zombie) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onMotionUpdateStartWithContext(zombie);
            } catch (Throwable t) {
            }
        }
    }

    public static void onMotionUpdateEnd(Object zombie) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onMotionUpdateEndWithContext(zombie);
            } catch (Throwable t) {
            }
        }
    }

    // --- Phase 2: New Zombie Event Hooks ---

    public static void onZombieSpotted(Object zombie, Object target, boolean forced) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onZombieSpottedWithContext(zombie, target, forced);
            } catch (Throwable t) {
            }
        }
    }

    public static void onZombieHit(Object zombie, Object attacker, float damage) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onZombieHitWithContext(zombie, attacker, damage);
            } catch (Throwable t) {
            }
        }
    }

    public static void onZombieKill(Object zombie, Object killer) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onZombieKillWithContext(zombie, killer);
            } catch (Throwable t) {
            }
        }
    }

    // Legacy - disabled
    public static void onZombieUpdate() {
    }

    public static void onMotionUpdateStart() {
    }

    public static void onMotionUpdateEnd() {
    }

    public static void onSoundPerceptionStart() {
    }

    public static void onSoundPerceptionEnd() {
    }

    public static void onTargetTrackingStart() {
    }

    public static void onTargetTrackingEnd() {
    }

    public static void onSoundPerceptionStart(Object z) {
    }

    public static void onSoundPerceptionEnd(Object z) {
    }

    public static void onTargetTrackingStart(Object z) {
    }

    public static void onTargetTrackingEnd(Object z) {
    }

    // --- Callback Interface ---

    public interface IZombieCallback {
        default void onZombieUpdate() {
        }

        default void onMotionUpdateStart() {
        }

        default void onMotionUpdateEnd() {
        }

        default void onSoundPerceptionStart() {
        }

        default void onSoundPerceptionEnd() {
        }

        default void onTargetTrackingStart() {
        }

        default void onTargetTrackingEnd() {
        }

        default void onZombieUpdateWithContext(Object zombie) {
            onZombieUpdate();
        }

        default void onMotionUpdateStartWithContext(Object zombie) {
            onMotionUpdateStart();
        }

        default void onMotionUpdateEndWithContext(Object zombie) {
            onMotionUpdateEnd();
        }

        default void onSoundPerceptionStartWithContext(Object zombie) {
            onSoundPerceptionStart();
        }

        default void onSoundPerceptionEndWithContext(Object zombie) {
            onSoundPerceptionEnd();
        }

        default void onTargetTrackingStartWithContext(Object zombie) {
            onTargetTrackingStart();
        }

        default void onTargetTrackingEndWithContext(Object zombie) {
            onTargetTrackingEnd();
        }

        // Phase 2: New Event Hooks
        default void onZombieSpotted(Object target, boolean forced) {
        }

        default void onZombieSpottedWithContext(Object zombie, Object target, boolean forced) {
            onZombieSpotted(target, forced);
        }

        default void onZombieHit(Object attacker, float damage) {
        }

        default void onZombieHitWithContext(Object zombie, Object attacker, float damage) {
            onZombieHit(attacker, damage);
        }

        default void onZombieKill(Object killer) {
        }

        default void onZombieKillWithContext(Object zombie, Object killer) {
            onZombieKill(killer);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\profiler\ZombieStepHook.java =====

package com.pulse.api.profiler;

import com.pulse.api.log.PulseLogger;

/**
 * Zombie Step Hook - Step-level throttling API.
 * 
 * Pulse provides hooks for individual zombie AI steps.
 * Fuse/other modules can implement throttle policies.
 * 
 * @since Pulse 1.3
 */
public class ZombieStepHook {

    /** Step types for throttling */
    public enum StepType {
        MOTION, // 이동 (skip 불가)
        PERCEPTION, // 인지 (throttle 가능)
        BEHAVIOR, // 행동 결정 (throttle 가능)
        TARGET, // 타겟 추적 (throttle 가능)
        COLLISION // 충돌 (skip 불가)
    }

    /** Throttle policy (Fuse에서 구현) */
    private static IZombieStepPolicy stepPolicy;

    // --- Registration ---

    public static void setStepPolicy(IZombieStepPolicy policy) {
        stepPolicy = policy;
        if (policy != null) {
            PulseLogger.info("Pulse", "ZombieStepPolicy registered: " + policy.getClass().getSimpleName());
        }
    }

    public static void clearStepPolicy() {
        stepPolicy = null;
    }

    // --- Step Throttle Check ---

    /**
     * Check if a specific step should be skipped.
     * Called from Mixin before each step execution.
     * 
     * @param stepType Step type
     * @param distSq   Distance squared to nearest player
     * @param context  Additional context (zombie state)
     * @return true to skip this step
     */
    public static boolean shouldSkipStep(StepType stepType, float distSq, IStepContext context) {
        if (stepPolicy == null)
            return false;

        // MOTION and COLLISION are never skipped
        if (stepType == StepType.MOTION || stepType == StepType.COLLISION) {
            return false;
        }

        try {
            return stepPolicy.shouldSkipStep(stepType, distSq, context);
        } catch (Throwable t) {
            return false;
        }
    }

    /**
     * Convenience method without context.
     */
    public static boolean shouldSkipStep(StepType stepType, float distSq) {
        return shouldSkipStep(stepType, distSq, null);
    }

    // --- Interfaces ---

    /**
     * Step throttle policy interface.
     * Implemented by Fuse or other optimization modules.
     */
    public interface IZombieStepPolicy {
        /**
         * Determine if a step should be skipped.
         * 
         * @param stepType Step type
         * @param distSq   Distance squared to player
         * @param context  Zombie context (nullable)
         * @return true to skip
         */
        boolean shouldSkipStep(StepType stepType, float distSq, IStepContext context);
    }

    /**
     * Step context for additional decision making.
     */
    public interface IStepContext {
        int getIterIndex();

        int getWorldTick();

        boolean isAttacking();

        boolean hasTarget();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PublicAPI.java =====

package com.pulse.api;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 공개 API 마커.
 * 이 어노테이션이 붙은 클래스/메서드는 안정적인 공개 API로 간주됨.
 * 
 * - 시맨틱 버저닝 준수 (breaking change = major version)
 * - Deprecation 정책 적용 (최소 1 major version 유지)
 * - 문서화 의무
 * 
 * 사용 예:
 * 
 * <pre>
 * @PublicAPI(since = "1.0.0")
 * public class EventBus { ... }
 * </pre>
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR })
public @interface PublicAPI {

    /**
     * API가 도입된 버전.
     */
    String since() default "1.0.0";

    /**
     * API 상태.
     */
    Status status() default Status.STABLE;

    public enum Status {
        STABLE, // 안정 - 프로덕션 사용 가능
        EXPERIMENTAL, // 실험적 - 변경 가능
        BETA // 베타 - 대부분 안정, 마이너 변경 가능
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\Pulse.java =====

package com.pulse.api;

import com.pulse.api.log.PulseLogger;
import com.pulse.PulseEnvironment;
import com.pulse.event.EventBus;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModLoader;
import com.pulse.service.ProviderRegistry;
import com.pulse.api.spi.IProviderRegistry;

import java.nio.file.Path;
import java.util.Collection;
import java.util.Optional;

/**
 * Pulse API 메인 진입점.
 * 모드 개발자가 사용하는 안정적인 API.
 * 
 * 사용 예:
 * if (Pulse.isModLoaded("othermod")) {
 * // othermod와 연동
 * }
 */
public final class Pulse {

    private static final String LOG = PulseLogger.PULSE;

    private Pulse() {
    } // 인스턴스화 방지

    // ─────────────────────────────────────────────────────────────
    // 버전 정보
    // ─────────────────────────────────────────────────────────────

    public static final String VERSION = "0.8.0";
    public static final String NAME = "Pulse";
    public static final int API_VERSION = 1;

    /**
     * Pulse 버전 반환
     */
    public static String getVersion() {
        return VERSION;
    }

    /**
     * API 버전 반환 (호환성 체크용)
     */
    public static int getApiVersion() {
        return API_VERSION;
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 관련
    // ─────────────────────────────────────────────────────────────

    /**
     * 특정 모드가 로드되었는지 확인
     */
    public static boolean isModLoaded(String modId) {
        return ModLoader.getInstance().isModLoaded(modId);
    }

    /**
     * 모드 컨테이너 가져오기
     */
    public static Optional<ModContainer> getMod(String modId) {
        return Optional.ofNullable(ModLoader.getInstance().getMod(modId));
    }

    /**
     * 로드된 모든 모드 목록
     */
    public static Collection<ModContainer> getAllMods() {
        return ModLoader.getInstance().getAllMods();
    }

    /**
     * 로드된 모드 수
     */
    public static int getModCount() {
        return ModLoader.getInstance().getModCount();
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 시스템
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 버스 접근
     */
    public static EventBus getEventBus() {
        return PulseServices.eventBus();
    }

    // ─────────────────────────────────────────────────────────────
    // SPI (Service Provider Interface)
    // ─────────────────────────────────────────────────────────────

    /**
     * 프로바이더 레지스트리 접근.
     * 모든 SPI 프로바이더를 등록하고 조회할 수 있음.
     * 
     * 사용 예:
     * Pulse.getProviderRegistry().register(myProfiler);
     * Pulse.getProviderRegistry().getProvider(IProfilerProvider.class);
     */
    public static IProviderRegistry getProviderRegistry() {
        return ProviderRegistry.getInstance();
    }

    /**
     * 특정 타입의 프로바이더가 있는지 확인
     */
    public static <T extends com.pulse.api.spi.IProvider> boolean hasProvider(Class<T> type) {
        return ProviderRegistry.getInstance().hasProvider(type);
    }

    // ─────────────────────────────────────────────────────────────
    // 환경 정보
    // ─────────────────────────────────────────────────────────────

    /**
     * Pulse이 완전히 초기화되었는지 확인
     */
    public static boolean isInitialized() {
        return PulseEnvironment.isInitialized();
    }

    /**
     * 게임 디렉토리 경로
     */
    public static Path getGameDirectory() {
        return Path.of(System.getProperty("user.dir"));
    }

    /**
     * mods 디렉토리 경로
     */
    public static Path getModsDirectory() {
        return ModLoader.getInstance().getModsDirectory();
    }

    /**
     * 설정 디렉토리 경로
     */
    public static Path getConfigDirectory() {
        return getGameDirectory().resolve(PulseConstants.CONFIG_DIR_NAME);
    }

    // ─────────────────────────────────────────────────────────────
    // Side API (v1.1.0)
    // ─────────────────────────────────────────────────────────────

    private static volatile PulseSide currentSide = PulseSide.UNKNOWN;

    /**
     * 현재 실행 사이드 반환.
     * 
     * @return 현재 사이드 (CLIENT, DEDICATED_SERVER, INTEGRATED_SERVER, UNKNOWN)
     */
    public static PulseSide getSide() {
        if (currentSide == PulseSide.UNKNOWN) {
            currentSide = detectSide();
        }
        return currentSide;
    }

    /**
     * 클라이언트 환경인지 확인.
     * 싱글플레이어(INTEGRATED_SERVER)도 클라이언트 역할을 포함.
     * 
     * @return 클라이언트면 true
     */
    public static boolean isClient() {
        return getSide().isClient();
    }

    /**
     * 서버 환경인지 확인.
     * 싱글플레이어(INTEGRATED_SERVER)도 서버 역할을 포함.
     * 
     * @return 서버면 true
     */
    public static boolean isServer() {
        return getSide().isServer();
    }

    /**
     * 데디케이티드 서버인지 확인.
     * 
     * @return 데디케이티드 서버면 true
     */
    public static boolean isDedicatedServer() {
        return getSide().isDedicated();
    }

    /**
     * 사이드 설정 (내부용).
     * 
     * @param side 설정할 사이드
     */
    @InternalAPI
    public static void setSide(PulseSide side) {
        if (side != null) {
            currentSide = side;
            PulseLogger.debug(LOG, "Side set to: {}", side);
        }
    }

    /**
     * 사이드 자동 감지.
     */
    private static PulseSide detectSide() {
        try {
            // GameServer 클래스 로드 시도
            Class<?> gameServerClass = Class.forName("zombie.network.GameServer");
            java.lang.reflect.Field bServerField = gameServerClass.getDeclaredField("bServer");
            bServerField.setAccessible(true);
            boolean isServer = bServerField.getBoolean(null);

            if (isServer) {
                // 서버 모드 - 헤드리스인지 확인
                try {
                    Class<?> gameWindowClass = Class.forName("zombie.GameWindow");
                    java.lang.reflect.Field bNoRenderField = gameWindowClass.getDeclaredField("bNoRender");
                    bNoRenderField.setAccessible(true);
                    boolean noRender = bNoRenderField.getBoolean(null);

                    return noRender ? PulseSide.DEDICATED_SERVER : PulseSide.INTEGRATED_SERVER;
                } catch (Exception e) {
                    // 렌더링 체크 실패 - 아마도 데디케이티드
                    return PulseSide.DEDICATED_SERVER;
                }
            } else {
                // 클라이언트 모드
                return PulseSide.CLIENT;
            }
        } catch (ClassNotFoundException e) {
            // 게임 클래스 로드 전 - 나중에 다시 감지
            return PulseSide.UNKNOWN;
        } catch (Exception e) {
            PulseLogger.warn(LOG, "Side detection failed: {}", e.getMessage());
            return PulseSide.UNKNOWN;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // DevMode
    // ─────────────────────────────────────────────────────────────

    /**
     * DevMode 활성화 여부 확인
     */
    public static boolean isDevMode() {
        return DevMode.isEnabled();
    }

    /**
     * DevMode 활성화
     */
    public static void enableDevMode() {
        DevMode.enable();
    }

    // ─────────────────────────────────────────────────────────────
    // 로깅 (PulseLogger로 위임)
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드별 로거 가져오기
     */
    public static ModLogger getLogger(String modId) {
        return ModLogger.getLogger(modId);
    }

    /**
     * Pulse 로그 출력
     */
    public static void log(String message) {
        PulseLogger.info(LOG, message);
    }

    /**
     * 모드 로그 출력 (modId prefix 포함)
     */
    public static void log(String modId, String message) {
        PulseLogger.info(modId, message);
    }

    /**
     * Pulse 경고 출력
     */
    public static void warn(String message) {
        PulseLogger.warn(LOG, message);
    }

    /**
     * 모드 경고 출력
     */
    public static void warn(String modId, String message) {
        PulseLogger.warn(modId, message);
    }

    /**
     * Pulse 에러 출력
     */
    public static void error(String message) {
        PulseLogger.error(LOG, message);
    }

    /**
     * 모드 에러 출력
     */
    public static void error(String modId, String message) {
        PulseLogger.error(modId, message);
    }

    /**
     * Pulse 에러 출력 (예외 포함)
     */
    public static void error(String message, Throwable t) {
        PulseLogger.error(LOG, "{}: {}", message, t.getMessage());
        t.printStackTrace();
    }

    /**
     * 모드 에러 출력 (예외 포함)
     */
    public static void error(String modId, String message, Throwable t) {
        PulseLogger.error(modId, "{}: {}", message, t.getMessage());
        t.printStackTrace();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PulseConstants.java =====

package com.pulse.api;

/**
 * Pulse 전역 상수.
 * 매직 넘버 대신 이 상수들을 사용하세요.
 * 
 * @since 1.1.0
 */
public final class PulseConstants {

    private PulseConstants() {
    }

    // ═══════════════════════════════════════════════════════════════
    // 파일 경로
    // ═══════════════════════════════════════════════════════════════

    /** 모드 디렉토리명 */
    public static final String MODS_DIR_NAME = "mods";

    /** 설정 디렉토리명 */
    public static final String CONFIG_DIR_NAME = "config";

    // ═══════════════════════════════════════════════════════════════
    // 타이밍 상수 (밀리초)
    // ═══════════════════════════════════════════════════════════════

    /** 기본 틱 간격 (ms) - 60 FPS 기준 */
    public static final long TICK_INTERVAL_MS = 16;

    /** 틱 타임아웃 (ms) - 이 시간 초과 시 프리즈로 간주 */
    public static final long TICK_TIMEOUT_MS = 3000;

    /** Fallback 틱 체크 간격 (ms) */
    public static final long FALLBACK_CHECK_INTERVAL_MS = 5000;

    /** Rate Limiting 정리 임계값 (ms) */
    public static final long RATE_LIMIT_CLEANUP_THRESHOLD_MS = 60_000;

    /** 프로파일러 분석 간격 (ms) */
    public static final long PROFILER_ANALYSIS_INTERVAL_MS = 5000;

    // ═══════════════════════════════════════════════════════════════
    // 스파이크/성능 임계값 (마이크로초)
    // ═══════════════════════════════════════════════════════════════

    /** 스파이크 감지 임계값 (μs) - 33ms 초과 시 스파이크 */
    public static final long SPIKE_THRESHOLD_MICROS = 33_000;

    /** 프리즈 감지 임계값 (μs) - 100ms 초과 시 프리즈 */
    public static final long FREEZE_THRESHOLD_MICROS = 100_000;

    /** 심각한 프리즈 임계값 (μs) - 500ms 초과 */
    public static final long SEVERE_FREEZE_THRESHOLD_MICROS = 500_000;

    // ═══════════════════════════════════════════════════════════════
    // 품질 점수
    // ═══════════════════════════════════════════════════════════════

    /** 최소 샘플 수 (품질 점수 계산용) */
    public static final int MIN_SAMPLES_FOR_QUALITY = 100;

    /** 최소 세션 시간 (초) */
    public static final int MIN_SESSION_SECONDS = 30;

    // ═══════════════════════════════════════════════════════════════
    // 캐시/풀 크기
    // ═══════════════════════════════════════════════════════════════

    /** ProfilingScope 풀 크기 */
    public static final int PROFILING_SCOPE_POOL_SIZE = 16;

    /** 스파이크 로그 최대 항목 수 */
    public static final int MAX_SPIKE_LOG_ENTRIES = 1000;

    /** 콜 스택 로그 최대 항목 수 */
    public static final int MAX_CALL_STACK_ENTRIES = 50;

    // ═══════════════════════════════════════════════════════════════
    // 버전 정보
    // ═══════════════════════════════════════════════════════════════

    /** Pulse 버전 */
    public static final String PULSE_VERSION = "1.1.0";

    /** Echo 버전 */
    public static final String ECHO_VERSION = "1.1.0";

    /** Fuse 버전 */
    public static final String FUSE_VERSION = "0.2.0";

    /** Nerve 버전 */
    public static final String NERVE_VERSION = "0.1.0";
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PulseDiagnostics.java =====

package com.pulse.api;

import com.pulse.diagnostics.HotspotMap;
import com.pulse.diagnostics.PulseThreadGuard;
import com.pulse.diagnostics.PulseTickContext;
import com.pulse.mixin.PulseErrorHandler;

import java.util.List;
import java.util.Map;

/**
 * Pulse 진단 API.
 * 
 * 외부 모드에서 Pulse의 진단 정보에 접근할 수 있도록 하는 Facade입니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // 현재 틱 컨텍스트
 * int zombies = PulseDiagnostics.getZombieUpdateCount();
 * boolean mp = PulseDiagnostics.isMultiplayer();
 * 
 * // 핫스팟 분석
 * var hotspots = PulseDiagnostics.getTopHotspots(10);
 * 
 * // Mixin 오류 조회
 * int errors = PulseDiagnostics.getMixinErrorCount();
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class PulseDiagnostics {

    private PulseDiagnostics() {
    }

    // ─────────────────────────────────────────────────────────────
    // Tick Context
    // ─────────────────────────────────────────────────────────────

    /**
     * 현재 틱 번호
     */
    public static long getCurrentTick() {
        return PulseTickContext.get().getCurrentTick();
    }

    /**
     * 멀티플레이어 여부
     */
    public static boolean isMultiplayer() {
        return PulseTickContext.get().isMultiplayer();
    }

    /**
     * 이번 틱의 좀비 업데이트 수
     */
    public static int getZombieUpdateCount() {
        return PulseTickContext.get().getZombieUpdateCount();
    }

    /**
     * 이번 틱의 청크 로드 수
     */
    public static int getChunkLoadCount() {
        return PulseTickContext.get().getChunkLoadCount();
    }

    /**
     * 이번 틱의 청크 언로드 수
     */
    public static int getChunkUnloadCount() {
        return PulseTickContext.get().getChunkUnloadCount();
    }

    /**
     * 현재 플레이어 수 (MP)
     */
    public static int getPlayerCount() {
        return PulseTickContext.get().getPlayerCount();
    }

    /**
     * 이번 틱의 차량 업데이트 수
     */
    public static int getVehicleUpdateCount() {
        return PulseTickContext.get().getVehicleUpdateCount();
    }

    /**
     * 틱 컨텍스트 스냅샷
     */
    public static String getTickSnapshot() {
        return PulseTickContext.get().getSnapshot();
    }

    // ─────────────────────────────────────────────────────────────
    // Thread Guard
    // ─────────────────────────────────────────────────────────────

    /**
     * 현재 메인 게임 스레드 여부
     */
    public static boolean isMainThread() {
        return PulseThreadGuard.isMainThread();
    }

    /**
     * 메인 스레드 아닌 경우 경고
     */
    public static void assertMainThread(String context) {
        PulseThreadGuard.assertMainThread(context);
    }

    // ─────────────────────────────────────────────────────────────
    // Hotspot Map
    // ─────────────────────────────────────────────────────────────

    /**
     * 함수 실행 시간 기록
     */
    public static void recordTiming(String function, long nanos) {
        HotspotMap.record(function, nanos);
    }

    /**
     * 상위 N개 핫스팟 조회
     */
    public static List<HotspotMap.HotspotEntry> getTopHotspots(int n) {
        return HotspotMap.getTopHotspots(n);
    }

    /**
     * 모든 핫스팟 통계
     */
    public static Map<String, HotspotMap.TimingStats> getAllHotspots() {
        return HotspotMap.getAll();
    }

    /**
     * 핫스팟 통계 초기화
     */
    public static void resetHotspots() {
        HotspotMap.reset();
    }

    // ─────────────────────────────────────────────────────────────
    // Mixin Errors
    // ─────────────────────────────────────────────────────────────

    /**
     * Mixin 오류 총 개수
     */
    public static int getMixinErrorCount() {
        return PulseErrorHandler.getTotalErrorCount();
    }

    /**
     * Mixin별 오류 개수
     */
    public static Map<String, Integer> getMixinErrorCounts() {
        return PulseErrorHandler.getErrorCounts();
    }

    /**
     * 최근 Mixin 오류 목록
     */
    public static List<PulseErrorHandler.MixinError> getRecentMixinErrors() {
        return PulseErrorHandler.getRecentErrors();
    }

    /**
     * Mixin 오류 기록 초기화
     */
    public static void clearMixinErrors() {
        PulseErrorHandler.clearErrors();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PulseEnvironment.java =====

package com.pulse.api;

import com.pulse.runtime.PulseReflection;
import com.pulse.runtime.PulseRuntime;

/**
 * Pulse 환경 정보 API.
 * 
 * 게임 버전, 런타임 환경 등의 정보를 제공합니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // 게임 버전 확인
 * if (PulseEnvironment.isB42()) {
 *     // B42 전용 로직
 * }
 * 
 * // Pulse 버전
 * String version = PulseEnvironment.getPulseVersion();
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class PulseEnvironment {

    private static final String PULSE_VERSION = "1.2.0";

    private PulseEnvironment() {
    }

    // ─────────────────────────────────────────────────────────────
    // Pulse 정보
    // ─────────────────────────────────────────────────────────────

    /**
     * Pulse 버전
     */
    public static String getPulseVersion() {
        return PULSE_VERSION;
    }

    // ─────────────────────────────────────────────────────────────
    // 게임 버전
    // ─────────────────────────────────────────────────────────────

    /**
     * 게임 버전 (B41/B42/UNKNOWN)
     */
    public static PulseRuntime.Version getGameVersion() {
        return PulseRuntime.getVersion();
    }

    /**
     * 게임 버전 문자열
     */
    public static String getGameVersionString() {
        return PulseRuntime.getVersionString();
    }

    /**
     * B41 여부
     */
    public static boolean isB41() {
        return PulseRuntime.isB41();
    }

    /**
     * B42 여부
     */
    public static boolean isB42() {
        return PulseRuntime.isB42();
    }

    // ─────────────────────────────────────────────────────────────
    // 런타임 환경
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 버전
     */
    public static String getJavaVersion() {
        return System.getProperty("java.version");
    }

    /**
     * OS 이름
     */
    public static String getOsName() {
        return System.getProperty("os.name");
    }

    /**
     * 서버 환경 여부
     */
    public static boolean isDedicatedServer() {
        // zombie.network.GameServer 클래스의 bServer 필드 확인
        Object bServer = PulseReflection.findField("zombie.network.GameServer", "bServer");
        return Boolean.TRUE.equals(bServer);
    }

    /**
     * 클라이언트 환경 여부
     */
    public static boolean isClient() {
        return !isDedicatedServer();
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 게임 클래스 존재 여부 확인
     */
    public static boolean classExists(String className) {
        return PulseReflection.classExists(className);
    }

    /**
     * 게임 메서드 존재 여부 확인
     */
    public static boolean methodExists(String className, String methodName) {
        return PulseReflection.methodExists(className, methodName);
    }

    /**
     * 환경 정보 요약
     */
    public static String getSummary() {
        return String.format(
                "Pulse %s | Game %s | Java %s | %s",
                PULSE_VERSION, getGameVersionString(), getJavaVersion(), getOsName());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PulseEvents.java =====

package com.pulse.api;

import com.pulse.event.Event;
import com.pulse.event.EventBus;
import com.pulse.event.EventListener;
import com.pulse.event.EventPriority;

/**
 * Pulse 이벤트 API.
 * 
 * 외부 모드에서 Pulse 이벤트를 쉽게 구독/발행할 수 있도록 하는 Facade입니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * import com.pulse.api.PulseEvents;
 * import com.pulse.event.lifecycle.GameTickEvent;
 * 
 * // 이벤트 구독
 * PulseEvents.on(GameTickEvent.class, event -> {
 *     System.out.println("Tick: " + event.getTick());
 * });
 * 
 * // 우선순위 지정 구독
 * PulseEvents.on(GameTickEvent.class, event -> { ... }, PulseEvents.HIGHEST);
 * 
 * // 이벤트 발행
 * PulseEvents.fire(new MyCustomEvent());
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class PulseEvents {

    // 우선순위 상수
    public static final EventPriority HIGHEST = EventPriority.HIGHEST;
    public static final EventPriority HIGH = EventPriority.HIGH;
    public static final EventPriority NORMAL = EventPriority.NORMAL;
    public static final EventPriority LOW = EventPriority.LOW;
    public static final EventPriority LOWEST = EventPriority.LOWEST;

    private PulseEvents() {
    }

    /**
     * 이벤트 구독 (기본 우선순위)
     * 
     * @param eventType 이벤트 클래스
     * @param listener  리스너
     */
    public static <T extends Event> void on(Class<T> eventType, EventListener<T> listener) {
        EventBus.subscribe(eventType, listener);
    }

    /**
     * 이벤트 구독 (우선순위 지정)
     */
    public static <T extends Event> void on(Class<T> eventType, EventListener<T> listener,
            EventPriority priority) {
        EventBus.subscribe(eventType, listener, priority);
    }

    /**
     * 이벤트 구독 (modId 지정)
     */
    public static <T extends Event> void on(Class<T> eventType, EventListener<T> listener,
            String modId) {
        EventBus.subscribe(eventType, listener, modId);
    }

    /**
     * 이벤트 구독 (우선순위 + modId)
     */
    public static <T extends Event> void on(Class<T> eventType, EventListener<T> listener,
            EventPriority priority, String modId) {
        EventBus.subscribe(eventType, listener, priority, modId);
    }

    /**
     * 이벤트 구독 해제
     */
    public static <T extends Event> void off(Class<T> eventType, EventListener<T> listener) {
        EventBus.unsubscribe(eventType, listener);
    }

    /**
     * 이벤트 발행
     */
    public static <T extends Event> void fire(T event) {
        EventBus.post(event);
    }

    /**
     * 특정 이벤트 리스너 수 조회
     */
    public static int listenerCount(Class<? extends Event> eventType) {
        return PulseServices.eventBus().getListenerCount(eventType);
    }

    /**
     * 모드의 모든 리스너 해제
     */
    public static int unsubscribeAll(String modId) {
        return EventBus.unsubscribeAll(modId);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PulseLog.java =====

package com.pulse.api;

import java.io.PrintStream;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Pulse 로깅 API.
 * 
 * 모드에서 일관된 로그 형식을 사용할 수 있도록 합니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * PulseLog.info("MyMod", "Initialization complete");
 * PulseLog.warn("MyMod", "Config file not found, using defaults");
 * PulseLog.error("MyMod", "Failed to load", exception);
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class PulseLog {

    private static final DateTimeFormatter TIME_FORMAT = DateTimeFormatter.ofPattern("HH:mm:ss");

    private static volatile boolean includeTimestamp = true;
    private static volatile boolean debugEnabled = false;
    private static PrintStream out = System.out;
    private static PrintStream err = System.err;

    private PulseLog() {
    }

    /**
     * INFO 레벨 로그
     */
    public static void info(String tag, String message) {
        log("INFO", tag, message);
    }

    /**
     * 포맷 문자열을 사용한 INFO 로그
     */
    public static void info(String tag, String format, Object... args) {
        log("INFO", tag, String.format(format, args));
    }

    /**
     * DEBUG 레벨 로그 (debugEnabled = true일 때만 출력)
     */
    public static void debug(String tag, String message) {
        if (debugEnabled) {
            log("DEBUG", tag, message);
        }
    }

    /**
     * DEBUG 로그 (포맷)
     */
    public static void debug(String tag, String format, Object... args) {
        if (debugEnabled) {
            log("DEBUG", tag, String.format(format, args));
        }
    }

    /**
     * WARN 레벨 로그
     */
    public static void warn(String tag, String message) {
        log("WARN", tag, message);
    }

    /**
     * WARN 로그 (포맷)
     */
    public static void warn(String tag, String format, Object... args) {
        log("WARN", tag, String.format(format, args));
    }

    /**
     * ERROR 레벨 로그
     */
    public static void error(String tag, String message) {
        logError("ERROR", tag, message, null);
    }

    /**
     * ERROR 로그 (예외 포함)
     */
    public static void error(String tag, String message, Throwable t) {
        logError("ERROR", tag, message, t);
    }

    /**
     * ERROR 로그 (포맷)
     */
    public static void error(String tag, String format, Object... args) {
        logError("ERROR", tag, String.format(format, args), null);
    }

    // ─────────────────────────────────────────────────────────────
    // 설정
    // ─────────────────────────────────────────────────────────────

    /**
     * 디버그 로그 활성화
     */
    public static void setDebugEnabled(boolean enabled) {
        debugEnabled = enabled;
    }

    /**
     * 타임스탬프 포함 여부
     */
    public static void setIncludeTimestamp(boolean include) {
        includeTimestamp = include;
    }

    /**
     * 출력 스트림 변경
     */
    public static void setOutput(PrintStream out, PrintStream err) {
        PulseLog.out = out != null ? out : System.out;
        PulseLog.err = err != null ? err : System.err;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 구현
    // ─────────────────────────────────────────────────────────────

    private static void log(String level, String tag, String message) {
        String formatted = formatMessage(level, tag, message);
        out.println(formatted);
    }

    private static void logError(String level, String tag, String message, Throwable t) {
        String formatted = formatMessage(level, tag, message);
        err.println(formatted);
        if (t != null) {
            t.printStackTrace(err);
        }
    }

    private static String formatMessage(String level, String tag, String message) {
        StringBuilder sb = new StringBuilder();

        if (includeTimestamp) {
            sb.append("[").append(LocalDateTime.now().format(TIME_FORMAT)).append("] ");
        }

        sb.append("[").append(level).append("] ");
        sb.append("[").append(tag).append("] ");
        sb.append(message);

        return sb.toString();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PulseLogger.java =====

package com.pulse.api;

import com.pulse.debug.CrashReporter;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Pulse 통합 로거.
 * 모든 Pulse 모드에서 일관된 로깅 API를 제공합니다.
 * 
 * <pre>
 * // 사용 예시
 * PulseLogger.info("mymod", "Initialized successfully");
 * PulseLogger.warn("mymod", "Config not found, using defaults");
 * PulseLogger.error("mymod", "Critical error occurred", exception);
 * 
 * // Rate Limiting (v1.1.0)
 * PulseLogger.infoRateLimited("tick_log", "Processing tick", 5000);
 * </pre>
 * 
 * @since 1.1.0
 */
@PublicAPI(since = "1.1.0")
public final class PulseLogger {

    private PulseLogger() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // 로그 레벨 제어 (v1.1.0)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 로그 레벨.
     */
    public enum LogLevel {
        TRACE(0), DEBUG(1), INFO(2), WARN(3), ERROR(4), OFF(5);

        public final int priority;

        LogLevel(int priority) {
            this.priority = priority;
        }
    }

    private static volatile LogLevel currentLevel = LogLevel.INFO;

    /**
     * 현재 로그 레벨 설정.
     * 
     * @param level 로그 레벨
     */
    public static void setLevel(LogLevel level) {
        currentLevel = level;
        info("Pulse", "Log level set to: " + level.name());
    }

    /**
     * 현재 로그 레벨 조회.
     */
    public static LogLevel getLevel() {
        return currentLevel;
    }

    private static boolean shouldLog(LogLevel level) {
        return level.priority >= currentLevel.priority;
    }

    // ═══════════════════════════════════════════════════════════════
    // Rate Limiting (v1.1.0)
    // ═══════════════════════════════════════════════════════════════

    private static final Map<String, Long> lastLogTime = new ConcurrentHashMap<>();
    private static final long CLEANUP_THRESHOLD_MS = 60_000; // 1분

    /**
     * Rate Limited 정보 로그.
     * 지정된 간격 내에는 동일 태그의 로그가 무시됩니다.
     * 
     * @param tag        로그 태그 (중복 방지 키)
     * @param message    메시지
     * @param intervalMs 최소 로그 간격 (밀리초)
     */
    public static void infoRateLimited(String tag, String message, long intervalMs) {
        long now = System.currentTimeMillis();

        // 주기적 정리 (1% 확률)
        if (ThreadLocalRandom.current().nextInt(100) == 0) {
            lastLogTime.entrySet().removeIf(e -> now - e.getValue() > CLEANUP_THRESHOLD_MS);
        }

        Long last = lastLogTime.get(tag);
        if (last == null || now - last >= intervalMs) {
            lastLogTime.put(tag, now);
            info("Pulse", message);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // 기본 로깅
    // ═══════════════════════════════════════════════════════════════

    /**
     * 트레이스 로그 (가장 상세한 레벨).
     * 
     * @param modId   모드 ID
     * @param message 메시지
     */
    public static void trace(String modId, String message) {
        if (!shouldLog(LogLevel.TRACE))
            return;
        String formatted = formatLog(modId, "TRACE", message);
        System.out.println(formatted);
        CrashReporter.addLogLine(formatted);
    }

    /**
     * 정보 로그.
     * 
     * @param modId   모드 ID
     * @param message 메시지
     */
    public static void info(String modId, String message) {
        if (!shouldLog(LogLevel.INFO))
            return;
        String formatted = formatLog(modId, "INFO", message);
        System.out.println(formatted);
        CrashReporter.addLogLine(formatted);
    }

    /**
     * 경고 로그.
     * 
     * @param modId   모드 ID
     * @param message 메시지
     */
    public static void warn(String modId, String message) {
        if (!shouldLog(LogLevel.WARN))
            return;
        String formatted = formatLog(modId, "WARN", message);
        System.out.println(formatted);
        CrashReporter.addLogLine(formatted);
    }

    /**
     * 에러 로그.
     * 
     * @param modId   모드 ID
     * @param message 메시지
     */
    public static void error(String modId, String message) {
        String formatted = formatLog(modId, "ERROR", message);
        System.err.println(formatted);
        CrashReporter.addLogLine(formatted);
    }

    /**
     * 에러 로그 (예외 포함).
     * 
     * @param modId   모드 ID
     * @param message 메시지
     * @param t       예외
     */
    public static void error(String modId, String message, Throwable t) {
        String formatted = formatLog(modId, "ERROR", message);
        System.err.println(formatted);
        CrashReporter.addLogLine(formatted);

        if (t != null) {
            CrashReporter.addLogLine("  Exception: " + t.getClass().getName() + ": " + t.getMessage());
            if (DevMode.isEnabled()) {
                t.printStackTrace();
            }
        }
    }

    /**
     * 디버그 로그 (DevMode에서만 출력).
     * 
     * @param modId   모드 ID
     * @param message 메시지
     */
    public static void debug(String modId, String message) {
        if (!shouldLog(LogLevel.DEBUG))
            return;
        if (!DevMode.isEnabled())
            return;

        String formatted = formatLog(modId, "DEBUG", message);
        System.out.println(formatted);
        CrashReporter.addLogLine(formatted);
    }

    // ═══════════════════════════════════════════════════════════════
    // 구조화된 이벤트 로깅 (CrashReporter 연동)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 구조화된 이벤트 기록.
     * CrashReporter에 이벤트로 기록됨.
     * 
     * @param eventType 이벤트 타입
     * @param source    발생 소스
     * @param message   메시지
     */
    public static void event(String eventType, String source, String message) {
        CrashReporter.recordEvent(eventType, source, message);
    }

    /**
     * Mixin 실패 이벤트 기록.
     * 
     * @param mixinClass  Mixin 클래스
     * @param targetClass 대상 클래스
     * @param error       오류 메시지
     */
    public static void mixinFailed(String mixinClass, String targetClass, String error) {
        CrashReporter.recordEvent(
                CrashReporter.EVENT_MIXIN_FAILURE,
                mixinClass,
                "Target: " + targetClass + ", Error: " + error);
    }

    /**
     * Lua 예산 초과 이벤트 기록.
     * 
     * @param contextId    컨텍스트 ID
     * @param actualMicros 실제 사용 시간
     * @param budgetMicros 예산 시간
     */
    public static void luaBudgetExceeded(String contextId, long actualMicros, long budgetMicros) {
        double actualMs = actualMicros / 1000.0;
        double budgetMs = budgetMicros / 1000.0;

        CrashReporter.recordEvent(
                CrashReporter.EVENT_LUA_BUDGET_EXCEEDED,
                contextId,
                String.format("%.2fms / %.2fms", actualMs, budgetMs));
    }

    // ═══════════════════════════════════════════════════════════════
    // 내부 헬퍼
    // ═══════════════════════════════════════════════════════════════

    private static String formatLog(String modId, String level, String message) {
        return String.format("[%s/%s] %s", modId, level, message);
    }

    /**
     * Pulse 기본 로거 (modId = "Pulse").
     * 
     * @param message 메시지
     */
    public static void pulse(String message) {
        info("Pulse", message);
    }

    /**
     * Pulse 경고 (modId = "Pulse").
     * 
     * @param message 메시지
     */
    public static void pulseWarn(String message) {
        warn("Pulse", message);
    }

    /**
     * Pulse 에러 (modId = "Pulse").
     * 
     * @param message 메시지
     * @param t       예외
     */
    public static void pulseError(String message, Throwable t) {
        error("Pulse", message, t);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PulseMetrics.java =====

package com.pulse.api;

/**
 * Pulse 메트릭 정적 접근 클래스.
 * 
 * Echo의 PulseMetricsAdapter가 reflection으로 이 클래스를 찾습니다.
 * 게임 상태에서 성능 메트릭을 수집하여 제공합니다.
 * 
 * @since 1.0.1
 */
public final class PulseMetrics {

    // Smoothing factors
    private static final double SMOOTHING_FACTOR = 0.1;

    // Frame/Tick tracking
    private static long lastFrameNanos = System.nanoTime();
    private static long lastTickNanos = System.nanoTime();
    private static volatile double frameTimeMs = 16.67;
    private static volatile double tickTimeMs = 16.67;
    private static volatile double fps = 60.0;
    private static volatile double tps = 60.0;

    // Rolling averages
    private static volatile double avgTickTimeMs = 16.67;
    private static volatile double maxTickTimeMs = 16.67;

    private PulseMetrics() {
        // Utility class
    }

    // --- Public API (Echo PulseMetricsAdapter에서 reflection으로 호출) ---

    /**
     * 현재 FPS
     */
    public static double getFps() {
        return fps;
    }

    /**
     * 현재 프레임 시간 (밀리초)
     */
    public static double getFrameTimeMs() {
        return frameTimeMs;
    }

    /**
     * 현재 틱 시간 (밀리초)
     */
    public static double getTickTimeMs() {
        return tickTimeMs;
    }

    /**
     * 평균 틱 시간 (밀리초)
     */
    public static double getAverageTickTimeMs() {
        return avgTickTimeMs;
    }

    /**
     * 최대 틱 시간 (밀리초)
     */
    public static double getMaxTickTimeMs() {
        return maxTickTimeMs;
    }

    /**
     * TPS (Ticks Per Second)
     */
    public static double getTps() {
        return tps;
    }

    // --- Internal Update Methods (Pulse Mixin에서 호출) ---

    /**
     * 프레임 시작 시 호출.
     * Pulse Mixin에서 호출됩니다.
     */
    @InternalAPI
    public static void onFrameStart() {
        long now = System.nanoTime();
        double deltaMs = (now - lastFrameNanos) / 1_000_000.0;
        lastFrameNanos = now;

        // Exponential smoothing
        frameTimeMs = frameTimeMs * (1 - SMOOTHING_FACTOR) + deltaMs * SMOOTHING_FACTOR;

        // FPS calculation
        if (frameTimeMs > 0) {
            fps = 1000.0 / frameTimeMs;
        }
    }

    /**
     * 틱 종료 시 호출.
     * Pulse Mixin에서 호출됩니다.
     */
    @InternalAPI
    public static void onTickEnd(long tickDurationNanos) {
        double deltaMs = tickDurationNanos / 1_000_000.0;

        // Exponential smoothing
        tickTimeMs = tickTimeMs * (1 - SMOOTHING_FACTOR) + deltaMs * SMOOTHING_FACTOR;

        // TPS calculation
        if (tickTimeMs > 0) {
            tps = 1000.0 / tickTimeMs;
        }

        // Update rolling stats
        avgTickTimeMs = tickTimeMs; // Could be enhanced with proper rolling average
        if (deltaMs > maxTickTimeMs) {
            maxTickTimeMs = deltaMs;
        }
    }

    /**
     * 틱 시작 시 호출.
     * 내부 타이밍 추적용.
     */
    @InternalAPI
    public static void onTickStart() {
        lastTickNanos = System.nanoTime();
    }

    /**
     * 현재 진행 중인 틱 시간 계산.
     */
    @InternalAPI
    public static long getCurrentTickDurationNanos() {
        return System.nanoTime() - lastTickNanos;
    }

    // --- IPulseMetrics 누락 메서드 구현 (Phase 0) ---

    /**
     * 현재 로드된 청크 수
     * Echo 및 다른 모듈에서 성능 상관관계 분석에 사용
     */
    public static int getLoadedChunkCount() {
        return com.pulse.api.access.WorldAccess.getLoadedCellCount();
    }

    /**
     * 현재 엔티티 수 (좀비 + NPC + 차량)
     * Echo 및 다른 모듈에서 성능 상관관계 분석에 사용
     */
    public static int getEntityCount() {
        return com.pulse.api.access.WorldAccess.getTotalEntityCount();
    }

    /**
     * 현재 사용 중인 메모리 (MB)
     */
    public static long getUsedMemoryMB() {
        Runtime rt = Runtime.getRuntime();
        return (rt.totalMemory() - rt.freeMemory()) / (1024 * 1024);
    }

    /**
     * 최대 할당 가능 메모리 (MB)
     */
    public static long getMaxMemoryMB() {
        return Runtime.getRuntime().maxMemory() / (1024 * 1024);
    }

    /**
     * 최대 틱 시간 리셋 (주기적으로 호출)
     */
    @InternalAPI
    public static void resetMaxTickTime() {
        maxTickTimeMs = tickTimeMs;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PulseServices.java =====

package com.pulse.api;

import com.pulse.event.EventBus;
import com.pulse.handler.KahluaCallExtractor;
import com.pulse.handler.WorldTickHandler;
import com.pulse.lifecycle.LifecycleManager;
import com.pulse.scheduler.PulseScheduler;

/**
 * Pulse 핵심 서비스에 대한 타입 안전한 파사드.
 * 
 * <p>
 * 직접 getInstance() 호출 대신 이 클래스를 통해 서비스에 접근합니다.
 * IDE 자동완성 지원, 타입 안전성, 내부 구현 캡슐화를 제공합니다.
 * </p>
 * 
 * <h3>사용 예시:</h3>
 * 
 * <pre>
 * // Before
 * EventBus.getInstance().post(event);
 * PulseScheduler.getInstance().tick();
 * 
 * // After
 * PulseServices.eventBus().post(event);
 * PulseServices.scheduler().tick();
 * </pre>
 * 
 * <h3>테스트 시:</h3>
 * 
 * <pre>
 * // PulseServiceLocator에 Mock 등록
 * PulseServiceLocator.getInstance().registerService(EventBus.class, mockEventBus);
 * 
 * // PulseServices.eventBus()가 mockEventBus 반환
 * </pre>
 * 
 * @since Pulse 1.6
 */
public final class PulseServices {

    private PulseServices() {
        // Utility class
    }

    // ═══════════════════════════════════════════════════════════════
    // Core Services
    // ═══════════════════════════════════════════════════════════════

    /**
     * 이벤트 버스 접근.
     * 
     * @return EventBus 싱글톤 인스턴스
     */
    public static EventBus eventBus() {
        return EventBus.getInstance();
    }

    /**
     * 스케줄러 접근.
     * 
     * @return PulseScheduler 싱글톤 인스턴스
     */
    public static PulseScheduler scheduler() {
        return PulseScheduler.getInstance();
    }

    /**
     * 라이프사이클 매니저 접근.
     * 
     * @return LifecycleManager 싱글톤 인스턴스
     */
    public static LifecycleManager lifecycle() {
        return LifecycleManager.getInstance();
    }

    // ═══════════════════════════════════════════════════════════════
    // Handler Services (Phase 4)
    // ═══════════════════════════════════════════════════════════════

    /**
     * Kahlua 호출 추출기 접근.
     * 
     * @return KahluaCallExtractor 싱글톤 인스턴스
     */
    public static KahluaCallExtractor kahluaExtractor() {
        return KahluaCallExtractor.getInstance();
    }

    /**
     * 월드 틱 핸들러 접근.
     * 
     * @return WorldTickHandler 싱글톤 인스턴스
     */
    public static WorldTickHandler worldTick() {
        return WorldTickHandler.getInstance();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PulseSide.java =====

package com.pulse.api;

/**
 * Pulse 실행 환경 사이드.
 * 클라이언트/서버 구분을 위한 enum.
 * 
 * <pre>
 * // 사용 예시
 * if (Pulse.getSide().isClient()) {
 *     // 클라이언트 전용 코드
 * }
 * 
 * if (Pulse.isDedicatedServer()) {
 *     // 데디케이티드 서버 전용 코드
 * }
 * </pre>
 * 
 * @since 1.1.0
 */
@PublicAPI(since = "1.1.0")
public enum PulseSide {

    /**
     * 클라이언트 (싱글플레이어가 아닌 순수 클라이언트).
     */
    CLIENT,

    /**
     * 데디케이티드 서버 (헤드리스).
     */
    DEDICATED_SERVER,

    /**
     * 통합 서버 (싱글플레이어 또는 호스트+플레이).
     */
    INTEGRATED_SERVER,

    /**
     * 아직 감지되지 않음.
     */
    UNKNOWN;

    /**
     * 클라이언트 환경인지 확인.
     * INTEGRATED_SERVER도 클라이언트 역할을 포함.
     * 
     * @return 클라이언트면 true
     */
    public boolean isClient() {
        return this == CLIENT || this == INTEGRATED_SERVER;
    }

    /**
     * 서버 환경인지 확인.
     * INTEGRATED_SERVER도 서버 역할을 포함.
     * 
     * @return 서버면 true
     */
    public boolean isServer() {
        return this == DEDICATED_SERVER || this == INTEGRATED_SERVER;
    }

    /**
     * 데디케이티드(헤드리스) 서버인지 확인.
     * 
     * @return 데디케이티드 서버면 true
     */
    public boolean isDedicated() {
        return this == DEDICATED_SERVER;
    }

    /**
     * 싱글플레이어 또는 호스트 모드인지 확인.
     * 
     * @return 통합 서버면 true
     */
    public boolean isIntegrated() {
        return this == INTEGRATED_SERVER;
    }

    /**
     * 사이드가 아직 감지되지 않았는지 확인.
     * 
     * @return 알 수 없으면 true
     */
    public boolean isUnknown() {
        return this == UNKNOWN;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\PulseStableAPI.java =====

package com.pulse.api;

/**
 * Pulse Stable API v1 Reference
 * 
 * This class documents the stable public API that Echo, Fuse, and Nerve
 * can safely depend on. These APIs are guaranteed to maintain backward
 * compatibility within major versions.
 * 
 * <h2>Stable APIs (v1.0)</h2>
 * 
 * <h3>1. EventBus</h3>
 * <ul>
 * <li>{@link com.pulse.event.EventBus#post(Object)} - Post an event to all
 * subscribers</li>
 * <li>{@link com.pulse.event.EventBus#subscribe(Class, java.util.function.Consumer, String)}
 * - Subscribe to events</li>
 * <li>{@link com.pulse.event.EventBus#unsubscribe(Class, String)} - Unsubscribe
 * from events</li>
 * </ul>
 * 
 * <h3>2. TickPhaseHook</h3>
 * <ul>
 * <li>{@link com.pulse.api.profiler.TickPhaseHook#startPhase(String)} - Start
 * timing a phase</li>
 * <li>{@link com.pulse.api.profiler.TickPhaseHook#endPhase(String, long)} - End
 * timing a phase</li>
 * <li>{@link com.pulse.api.profiler.TickPhaseHook#onTickComplete()} - Called
 * when tick finishes</li>
 * <li>Phase constants: PHASE_WORLD_UPDATE, PHASE_AI_UPDATE, etc.</li>
 * </ul>
 * 
 * <h3>3. PulseHookRegistry</h3>
 * <ul>
 * <li>{@link com.pulse.hook.PulseHookRegistry#register} - Register a hook
 * callback</li>
 * <li>{@link com.pulse.hook.PulseHookRegistry#unregister} - Unregister a
 * callback</li>
 * <li>{@link com.pulse.hook.PulseHookRegistry#broadcast} - Broadcast to all
 * callbacks</li>
 * <li>Priority constants: PRIORITY_LOWEST to PRIORITY_HIGHEST</li>
 * </ul>
 * 
 * <h3>4. LuaBudgetManager</h3>
 * <ul>
 * <li>{@link com.pulse.runtime.LuaBudgetManager#checkBudget} - Check if Lua
 * execution is within budget</li>
 * <li>{@link com.pulse.runtime.LuaBudgetManager#recordUsage} - Record Lua
 * execution time</li>
 * </ul>
 * 
 * <h3>5. FailsoftPolicy</h3>
 * <ul>
 * <li>{@link com.pulse.api.FailsoftPolicy#handle} - Handle an error with
 * fail-soft action</li>
 * <li>{@link com.pulse.api.FailsoftPolicy#handlePhaseSequenceError} - Handle
 * phase sequence violations</li>
 * <li>{@link com.pulse.api.FailsoftPolicy#handleUnsafeWorldstateAccess} -
 * Handle unsafe world access</li>
 * </ul>
 * 
 * <h3>6. Logging</h3>
 * <ul>
 * <li>{@link Pulse#info(String, String)} - Log info message</li>
 * <li>{@link Pulse#warn(String, String)} - Log warning message</li>
 * <li>{@link Pulse#error(String, String)} - Log error message</li>
 * </ul>
 * 
 * <h3>7. Utilities (v0.9+)</h3>
 * <ul>
 * <li>{@link com.pulse.api.util.PulseExceptionFormatter#format} - Format
 * exceptions for mods</li>
 * <li>{@link com.pulse.api.util.PulseExceptionFormatter#oneLiner} - One-line
 * exception summary</li>
 * </ul>
 * 
 * <h2>Internal APIs (Not Stable)</h2>
 * <p>
 * The following packages are internal and may change without notice:
 * </p>
 * <ul>
 * <li>com.pulse.mixin.* - Mixin implementations</li>
 * <li>com.pulse.scheduler.* - Internal scheduler</li>
 * <li>com.pulse.compat.* - Version compatibility</li>
 * </ul>
 * 
 * @since Pulse 0.9
 * @version 1.0
 */
public final class PulseStableAPI {

    /** API Version */
    public static final String API_VERSION = "1.0";

    /** Minimum compatible Pulse version */
    public static final String MIN_PULSE_VERSION = "0.9.0";

    private PulseStableAPI() {
        // Documentation class only
    }

    /**
     * Check if the current Pulse version supports the stable API.
     * 
     * @return true if stable API is available
     */
    public static boolean isAvailable() {
        try {
            // Check key classes exist
            Class.forName("com.pulse.event.EventBus");
            Class.forName("com.pulse.api.profiler.TickPhaseHook");
            Class.forName("com.pulse.hook.PulseHookRegistry");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }

    /**
     * Get stable API version.
     */
    public static String getVersion() {
        return API_VERSION;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\SafeGameAccess.java =====

package com.pulse.api;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.access.ZombieAccess;
import com.pulse.api.util.ReflectionUtil;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * Thread-safe하고 fallback을 제공하는 게임 객체 접근 API.
 * 안전한 리플렉션 wrapper로 예외 발생 시 fallback 값을 반환합니다.
 * 
 * <pre>
 * // 사용 예시 - 안전한 좀비 체력 조회
 * float health = SafeGameAccess.withZombie(zombie, z -> {
 *     Method getHealth = z.getClass().getMethod("getHealth");
 *     return (Float) getHealth.invoke(z);
 * }, 100.0f); // fallback 값
 * 
 * // 메인 스레드에서 실행
 * SafeGameAccess.runOnMainThread(() -> {
 *     // 게임 상태 변경
 * });
 * </pre>
 * 
 * @since 1.0.1
 */
@PublicAPI(since = "1.0.1", status = PublicAPI.Status.EXPERIMENTAL)
public final class SafeGameAccess {

    // 메인 스레드 관련
    private static final String LOG = PulseLogger.PULSE;
    private static volatile Thread mainThread = null;
    private static final ConcurrentLinkedQueue<Runnable> mainThreadQueue = new ConcurrentLinkedQueue<>();
    private static final AtomicBoolean processingQueue = new AtomicBoolean(false);

    private SafeGameAccess() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // 메인 스레드 설정 (Pulse 내부용)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 메인 스레드 설정 (PulseAgent에서 호출).
     */
    @InternalAPI
    public static void setMainThread(Thread thread) {
        mainThread = thread;
    }

    /**
     * 현재 메인 스레드에서 실행 중인지 확인.
     */
    public static boolean isOnMainThread() {
        return mainThread != null && Thread.currentThread() == mainThread;
    }

    // ═══════════════════════════════════════════════════════════════
    // Zombie 관련 안전 접근
    // ═══════════════════════════════════════════════════════════════

    /**
     * 좀비 객체에 안전하게 접근.
     * 
     * @param zombie   좀비 객체 (IsoZombie)
     * @param accessor 접근자 함수
     * @param fallback 실패 시 반환값
     * @return 접근 결과 또는 fallback
     */
    public static <T> T withZombie(Object zombie, Function<Object, T> accessor, T fallback) {
        if (zombie == null)
            return fallback;
        try {
            return accessor.apply(zombie);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                PulseLogger.error(LOG, "[SafeGameAccess] Zombie access failed: {}", e.getMessage());
            }
            return fallback;
        }
    }

    /**
     * 주변 좀비 목록 안전 조회.
     * 
     * @param x      중심 X 좌표
     * @param y      중심 Y 좌표
     * @param radius 반경
     * @return 좀비 리스트 Optional
     */
    public static Optional<List<Object>> getNearbyZombiesSafe(float x, float y, float radius) {
        try {
            List<Object> zombies = ZombieAccess.getNearbyZombies(x, y, radius);
            return Optional.ofNullable(zombies);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                PulseLogger.error(LOG, "[SafeGameAccess] getNearbyZombies failed: {}", e.getMessage());
            }
            return Optional.empty();
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Chunk 관련 안전 접근
    // ═══════════════════════════════════════════════════════════════

    /**
     * 청크 객체에 안전하게 접근.
     * 
     * @param chunk    청크 객체 (IsoChunk)
     * @param accessor 접근자 함수
     * @param fallback 실패 시 반환값
     * @return 접근 결과 또는 fallback
     */
    public static <T> T withChunk(Object chunk, Function<Object, T> accessor, T fallback) {
        if (chunk == null)
            return fallback;
        try {
            return accessor.apply(chunk);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                PulseLogger.error(LOG, "[SafeGameAccess] Chunk access failed: {}", e.getMessage());
            }
            return fallback;
        }
    }

    /**
     * 월드 좌표로 청크 안전 조회.
     * 
     * @param wx 월드 X 좌표
     * @param wy 월드 Y 좌표
     * @return 청크 Optional
     */
    public static Optional<Object> getChunkSafe(int wx, int wy) {
        try {
            Object world = getIsoWorldInstanceInternal();
            if (world == null)
                return Optional.empty();

            // IsoWorld.CurrentCell.getChunk(wx, wy)
            Method getCellMethod = world.getClass().getMethod("getCell");
            Object cell = getCellMethod.invoke(world);
            if (cell == null)
                return Optional.empty();

            Method getChunkMethod = cell.getClass().getMethod("getChunk", int.class, int.class);
            Object chunk = getChunkMethod.invoke(cell, wx, wy);
            return Optional.ofNullable(chunk);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                PulseLogger.error(LOG, "[SafeGameAccess] getChunk failed: {}", e.getMessage());
            }
            return Optional.empty();
        }
    }

    /**
     * 내부용 IsoWorld 인스턴스 조회 (리플렉션).
     */
    private static Object getIsoWorldInstanceInternal() {
        try {
            Object world = ReflectionUtil.getStaticField("zombie.iso.IsoWorld", "instance");
            if (world != null)
                return world;

            // 대안: 클래스 직접 로드 시도
            Class<?> isoWorldClass = ReflectionUtil.getGameClass("zombie.iso.IsoWorld");
            if (isoWorldClass != null) {
                java.lang.reflect.Field instanceField = isoWorldClass.getDeclaredField("instance");
                instanceField.setAccessible(true);
                return instanceField.get(null);
            }
        } catch (Exception e) {
            // ignore
        }
        return null;
    }

    // ═══════════════════════════════════════════════════════════════
    // AI 관련 안전 접근
    // ═══════════════════════════════════════════════════════════════

    /**
     * AI 객체에 안전하게 접근.
     * 
     * @param ai       AI 객체
     * @param accessor 접근자 함수
     * @param fallback 실패 시 반환값
     * @return 접근 결과 또는 fallback
     */
    public static <T> T withAI(Object ai, Function<Object, T> accessor, T fallback) {
        if (ai == null)
            return fallback;
        try {
            return accessor.apply(ai);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                PulseLogger.error(LOG, "[SafeGameAccess] AI access failed: {}", e.getMessage());
            }
            return fallback;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Lua 관련 안전 접근
    // ═══════════════════════════════════════════════════════════════

    /**
     * Lua 상태에 안전하게 접근.
     * 
     * @param accessor 접근자 함수
     * @param fallback 실패 시 반환값
     * @return 접근 결과 또는 fallback
     */
    public static <T> T withLuaState(Function<Object, T> accessor, T fallback) {
        try {
            // LuaManager.GlobalEnvironment 접근
            Object luaEnv = ReflectionUtil.getStaticField("se.krka.kahlua.vm.LuaState", "instance");
            if (luaEnv == null) {
                // 대체 경로
                Object platform = ReflectionUtil.getStaticField("se.krka.kahlua.j2se.J2SEPlatform", "instance");
                if (platform != null) {
                    Method newEnvMethod = platform.getClass().getMethod("newEnvironment");
                    luaEnv = newEnvMethod.invoke(platform);
                }
            }

            if (luaEnv != null) {
                return accessor.apply(luaEnv);
            }
            return fallback;
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                PulseLogger.error(LOG, "[SafeGameAccess] Lua state access failed: {}", e.getMessage());
            }
            return fallback;
        }
    }

    /**
     * Lua 호출이 스레드 안전한지 확인.
     * PZ의 Lua는 기본적으로 메인 스레드에서만 호출 가능.
     * 
     * @return 현재 스레드에서 Lua 호출이 안전하면 true
     */
    public static boolean isLuaThreadSafe() {
        return isOnMainThread();
    }

    // ═══════════════════════════════════════════════════════════════
    // 스레드 안전 실행
    // ═══════════════════════════════════════════════════════════════

    /**
     * 메인 스레드에서 실행.
     * 이미 메인 스레드에 있다면 즉시 실행,
     * 아니면 큐에 추가되어 다음 틱에 실행.
     * 
     * @param action 실행할 액션
     */
    public static void runOnMainThread(Runnable action) {
        if (action == null)
            return;

        if (isOnMainThread()) {
            try {
                action.run();
            } catch (Exception e) {
                PulseLogger.error(LOG, "[SafeGameAccess] Main thread action failed: {}", e.getMessage());
                if (DevMode.isEnabled()) {
                    e.printStackTrace();
                }
            }
        } else {
            mainThreadQueue.offer(action);
        }
    }

    /**
     * 메인 스레드에서 실행하고 결과 반환 (CompletableFuture).
     * 
     * @param action 실행할 작업
     * @return CompletableFuture with result
     */
    public static <T> CompletableFuture<T> callOnMainThread(Supplier<T> action) {
        CompletableFuture<T> future = new CompletableFuture<>();

        runOnMainThread(() -> {
            try {
                T result = action.get();
                future.complete(result);
            } catch (Exception e) {
                future.completeExceptionally(e);
            }
        });

        return future;
    }

    /**
     * 큐에 있는 모든 액션 처리 (게임 틱에서 호출).
     */
    @InternalAPI
    public static void processMainThreadQueue() {
        if (!processingQueue.compareAndSet(false, true))
            return;

        try {
            Runnable action;
            int processed = 0;
            while ((action = mainThreadQueue.poll()) != null && processed < 100) {
                try {
                    action.run();
                } catch (Exception e) {
                    PulseLogger.error(LOG, "[SafeGameAccess] Queued action failed: {}", e.getMessage());
                }
                processed++;
            }
        } finally {
            processingQueue.set(false);
        }
    }

    /**
     * 큐 크기 반환.
     */
    public static int getQueueSize() {
        return mainThreadQueue.size();
    }

    // ═══════════════════════════════════════════════════════════════
    // 범용 안전 접근
    // ═══════════════════════════════════════════════════════════════

    /**
     * 임의 객체에 안전하게 accessor 적용.
     * 
     * @param target   대상 객체
     * @param accessor 접근자 함수
     * @param fallback 실패 시 반환값
     * @return 결과 또는 fallback
     */
    public static <T, R> R safely(T target, Function<T, R> accessor, R fallback) {
        if (target == null)
            return fallback;
        try {
            return accessor.apply(target);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                PulseLogger.error(LOG, "[SafeGameAccess] Safe access failed: {}", e.getMessage());
            }
            return fallback;
        }
    }

    /**
     * 안전하게 메서드 호출.
     * 
     * @param target     대상 객체
     * @param methodName 메서드 이름
     * @param fallback   실패 시 반환값
     * @param args       인자들
     * @return 결과 또는 fallback
     */
    @SuppressWarnings("unchecked")
    public static <T> T safeInvoke(Object target, String methodName, T fallback, Object... args) {
        if (target == null)
            return fallback;
        try {
            Class<?>[] paramTypes = new Class<?>[args.length];
            for (int i = 0; i < args.length; i++) {
                paramTypes[i] = args[i] != null ? args[i].getClass() : Object.class;
            }

            Method method = target.getClass().getMethod(methodName, paramTypes);
            return (T) method.invoke(target, args);
        } catch (Exception e) {
            if (DevMode.isEnabled()) {
                PulseLogger.error(LOG, "[SafeGameAccess] safeInvoke({}) failed: {}", methodName, e.getMessage());
            }
            return fallback;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\service\echo\ConnectionQuality.java =====

package com.pulse.api.service.echo;

public enum ConnectionQuality {
    EXCELLENT("Excellent - Low latency, no packet loss"),
    GOOD("Good - Minor latency or occasional packet loss"),
    FAIR("Fair - Noticeable latency or packet loss"),
    POOR("Poor - High latency and significant packet loss");

    private final String description;

    ConnectionQuality(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\service\echo\IBottleneckDetector.java =====

package com.pulse.api.service.echo;

public interface IBottleneckDetector {
    OptimizationPriority suggestNerveTarget();

    OptimizationPriority suggestFuseTarget();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\service\echo\INetworkMetrics.java =====

package com.pulse.api.service.echo;

public interface INetworkMetrics {
    ConnectionQuality getConnectionQuality();

    double getPacketLossRate();

    double getAvgPingMs();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\service\echo\IRenderMetrics.java =====

package com.pulse.api.service.echo;

public interface IRenderMetrics {
    RenderEfficiency getRenderEfficiency();

    double getFps();

    double getAvgFrameTimeMs();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\service\echo\OptimizationPriority.java =====

package com.pulse.api.service.echo;

import java.util.LinkedHashMap;
import java.util.Map;

public class OptimizationPriority {
    public final String targetName;
    public final String displayName;
    public final int priority;
    public final String recommendation;

    public OptimizationPriority(String targetName, String displayName, int priority, String recommendation) {
        this.targetName = targetName;
        this.displayName = displayName;
        this.priority = priority;
        this.recommendation = recommendation;
    }

    public Map<String, Object> toMap() {
        Map<String, Object> map = new LinkedHashMap<>();
        map.put("target", targetName);
        map.put("display_name", displayName);
        map.put("priority", priority);
        map.put("recommendation", recommendation);
        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\service\echo\RenderEfficiency.java =====

package com.pulse.api.service.echo;

public enum RenderEfficiency {
    EXCELLENT("Optimal batching and low draw calls"),
    GOOD("Good performance with minor optimization opportunities"),
    FAIR("Noticeable inefficiencies, consider optimization"),
    POOR("High draw calls or poor batching efficiency");

    private final String description;

    RenderEfficiency(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\SilentMode.java =====

package com.pulse.api;

import com.pulse.api.log.PulseLogger;

/**
 * Silent Mode 관리자.
 * 리모트(서버/클라이언트)에 Pulse가 없을 때 네트워크 기능을 조용히 비활성화합니다.
 * 
 * <pre>
 * // 사용 예시 - 핸드셰이크 수신 시
 * SilentMode.onHandshakeReceived(remotHasPulse);
 * 
 * // 네트워크 패킷 전송 전 확인
 * if (!SilentMode.shouldSuppressNetworking()) {
 *     NetworkManager.send(packet);
 * }
 * </pre>
 * 
 * @since 1.1.0
 */
@PublicAPI(since = "1.1.0")
public final class SilentMode {

    private static final String LOG = PulseLogger.PULSE;
    private static volatile boolean enabled = false;
    private static volatile boolean remotePulseDetected = false;
    private static volatile boolean handshakeCompleted = false;

    private SilentMode() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // 핸드셰이크 연동
    // ═══════════════════════════════════════════════════════════════

    /**
     * 핸드셰이크 수신 시 호출.
     * HandshakeHandler에서 자동 호출됨.
     * 
     * @param remoteHasPulse 리모트에 Pulse가 있으면 true
     */
    public static void onHandshakeReceived(boolean remoteHasPulse) {
        remotePulseDetected = remoteHasPulse;
        handshakeCompleted = true;

        if (!remoteHasPulse) {
            enabled = true;
            Pulse.log("pulse", "[SilentMode] Enabled - remote does not have Pulse");
        } else {
            enabled = false;
            Pulse.log("pulse", "[SilentMode] Disabled - remote has Pulse");
        }
    }

    /**
     * 핸드셰이크 리셋 (연결 종료 시).
     */
    public static void reset() {
        enabled = false;
        remotePulseDetected = false;
        handshakeCompleted = false;
    }

    // ═══════════════════════════════════════════════════════════════
    // 상태 조회
    // ═══════════════════════════════════════════════════════════════

    /**
     * 리모트에 Pulse가 있는지 확인.
     * 핸드셰이크 완료 전에는 false 반환.
     * 
     * @return 리모트에 Pulse가 있으면 true
     */
    public static boolean isRemotePulseEnabled() {
        return remotePulseDetected;
    }

    /**
     * Silent Mode가 활성화되어 있는지 확인.
     * 
     * @return 활성화되어 있으면 true
     */
    public static boolean isEnabled() {
        return enabled;
    }

    /**
     * 핸드셰이크가 완료되었는지 확인.
     * 
     * @return 완료되었으면 true
     */
    public static boolean isHandshakeCompleted() {
        return handshakeCompleted;
    }

    /**
     * Silent Mode 수동 설정.
     * 
     * @param state 활성화 여부
     */
    public static void setEnabled(boolean state) {
        enabled = state;
        if (state) {
            Pulse.log("pulse", "[SilentMode] Manually enabled");
        } else {
            Pulse.log("pulse", "[SilentMode] Manually disabled");
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // 네트워크 제어
    // ═══════════════════════════════════════════════════════════════

    /**
     * Pulse 네트워크 기능을 억제해야 하는지 확인.
     * Silent Mode가 활성화되어 있으면 true.
     * 
     * @return 네트워크 기능 억제 필요 시 true
     */
    public static boolean shouldSuppressNetworking() {
        return enabled;
    }

    /**
     * Pulse 패킷 전송 가능 여부 확인.
     * Silent Mode가 비활성화되어 있으면 true.
     * 
     * @return 패킷 전송 가능 시 true
     */
    public static boolean canSendPulsePackets() {
        return !enabled && handshakeCompleted && remotePulseDetected;
    }

    /**
     * 네트워크 기능 사용 전 체크.
     * Silent Mode면 경고 로그 남기고 false 반환.
     * 
     * @param feature 기능 이름 (로깅용)
     * @return 기능 사용 가능 시 true
     */
    public static boolean checkNetworkFeature(String feature) {
        if (enabled) {
            if (DevMode.isEnabled()) {
                Pulse.warn("pulse", "[SilentMode] Feature suppressed: " + feature);
            }
            return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════
    // 디버그
    // ═══════════════════════════════════════════════════════════════

    /**
     * 상태 정보 출력.
     */
    public static void printStatus() {
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "  SilentMode Status");
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "  Enabled: {}", enabled);
        PulseLogger.info(LOG, "  Remote Pulse: {}", remotePulseDetected);
        PulseLogger.info(LOG, "  Handshake Done: {}", handshakeCompleted);
        PulseLogger.info(LOG, "  Can Send Packets: {}", canSendPulsePackets());
        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\spi\IProfilerProvider.java =====

package com.pulse.api.spi;

/**
 * SPI interface for profiler providers.
 * 
 * Allows external modules like Echo to integrate with Pulse's profiling system.
 * 
 * @since Pulse 1.0
 */
public interface IProfilerProvider extends IProvider {

    /**
     * Called at the start of each game tick.
     */
    void onTickStart();

    /**
     * Called at the end of each game tick.
     * 
     * @param tickTimeNanos Time taken by the tick in nanoseconds
     */
    void onTickEnd(long tickTimeNanos);

    /**
     * Called at the start of each frame.
     */
    void onFrameStart();

    /**
     * Called at the end of each frame.
     * 
     * @param frameTimeNanos Time taken by the frame in nanoseconds
     */
    void onFrameEnd(long frameTimeNanos);

    /**
     * Get the current FPS.
     */
    double getCurrentFps();

    /**
     * Get the average tick time in milliseconds.
     */
    double getAverageTickTimeMs();

    /**
     * Get the average frame time in milliseconds.
     */
    double getAverageFrameTimeMs();

    /**
     * Start profiling.
     */
    void startProfiling();

    /**
     * Stop profiling.
     */
    void stopProfiling();

    /**
     * Check if profiling is active.
     */
    boolean isProfiling();

    /**
     * Reset all profiling data.
     */
    void resetData();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\spi\IProvider.java =====

package com.pulse.api.spi;

/**
 * Base interface for all Pulse SPI providers.
 * 
 * @since Pulse 1.0
 */
public interface IProvider {

    /**
     * Get the unique identifier for this provider.
     */
    String getId();

    /**
     * Get the display name of this provider.
     */
    String getName();

    /**
     * Get the version of this provider.
     */
    String getVersion();

    /**
     * Get the description of this provider.
     */
    String getDescription();

    /**
     * Get the priority of this provider.
     * Higher priority providers are loaded first.
     * 
     * @return Priority constant from {@link Priority}
     */
    int getPriority();

    /**
     * Called when the provider is initialized.
     */
    void onInitialize();

    /**
     * Called when the provider is shut down.
     */
    void onShutdown();

    /**
     * Check if the provider is enabled.
     */
    boolean isEnabled();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\spi\Priority.java =====

package com.pulse.api.spi;

/**
 * Priority constants for SPI providers.
 * 
 * @since Pulse 1.0
 */
public final class Priority {

    private Priority() {
    } // Utility class

    /**
     * Lowest priority (loaded last).
     */
    public static final int LOWEST = 0;

    /**
     * Low priority.
     */
    public static final int LOW = 25;

    /**
     * Normal priority (default).
     */
    public static final int NORMAL = 50;

    /**
     * High priority.
     */
    public static final int HIGH = 75;

    /**
     * Highest priority (loaded first).
     */
    public static final int HIGHEST = 100;
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\TickContract.java =====

package com.pulse.api;

/**
 * Tick timing contract constants.
 * 
 * Defines timing thresholds and validation parameters for tick events.
 * Used by Echo's PulseContractVerifier to validate Pulse tick events.
 * 
 * @since Pulse 1.1
 */
public final class TickContract {

    private TickContract() {
    } // Utility class

    /**
     * Contract version for compatibility checking.
     */
    public static final String VERSION = "1.0";

    /**
     * Maximum reasonable delta time in milliseconds.
     * DeltaTime above this is considered a potential stall or lag spike.
     */
    public static final float MAX_REASONABLE_DELTA_MS = 500.0f;

    /**
     * Maximum absolute delta time in milliseconds.
     * DeltaTime above this is considered invalid.
     */
    public static final float MAX_ABSOLUTE_DELTA_MS = 5000.0f;

    /**
     * Threshold in nanoseconds below which two events are considered duplicates.
     * Default: 100 microseconds (100,000 nanoseconds).
     */
    public static final long DUPLICATE_THRESHOLD_NS = 100_000L;

    /**
     * Time in milliseconds after which tick missing fallback activates.
     * Default: 3000ms (3 seconds).
     */
    public static final long FALLBACK_ACTIVATION_DELAY_MS = 3000L;

    /**
     * Target tick time in milliseconds (60 TPS = 16.67ms).
     */
    public static final float TARGET_TICK_MS = 16.67f;

    /**
     * Maximum acceptable tick time before warning (in milliseconds).
     */
    public static final float WARNING_TICK_MS = 50.0f;

    /**
     * Critical tick time threshold (in milliseconds).
     */
    public static final float CRITICAL_TICK_MS = 100.0f;

    /**
     * Target tick rate (ticks per second).
     * Default: 60 TPS.
     */
    public static final int TARGET_TICK_RATE = 60;
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\ui\UIConstants.java =====

package com.pulse.api.ui;

/**
 * UI 관련 상수.
 * 
 * UI 마법 상수들을 중앙에서 관리합니다.
 * 
 * @since 1.1.0
 */
public final class UIConstants {

    private UIConstants() {
    }

    // --- 색상 (RGBA)---

    /** 기본 배경색 - 반투명 검정 */
    public static final float[] BG_DEFAULT = { 0f, 0f, 0f, 0.7f };

    /** 기본 텍스트 색상 - 흰색 */
    public static final float[] TEXT_DEFAULT = { 1f, 1f, 1f, 1f };

    /** 경고 색상 - 노랑 */
    public static final float[] TEXT_WARNING = { 1f, 1f, 0f, 1f };

    /** 오류 색상 - 빨강 */
    public static final float[] TEXT_ERROR = { 1f, 0.2f, 0.2f, 1f };

    /** 성공 색상 - 초록 */
    public static final float[] TEXT_SUCCESS = { 0.2f, 1f, 0.2f, 1f };

    /** 정보 색상 - 파랑 */
    public static final float[] TEXT_INFO = { 0.4f, 0.6f, 1f, 1f };

    /** 디버그 색상 - 회색 */
    public static final float[] TEXT_DEBUG = { 0.7f, 0.7f, 0.7f, 1f };

    // --- HUD 위치---

    /** HUD 기본 오프셋 X */
    public static final int HUD_OFFSET_X = 10;

    /** HUD 기본 오프셋 Y */
    public static final int HUD_OFFSET_Y = 10;

    /** HUD 줄 간격 */
    public static final int HUD_LINE_HEIGHT = 16;

    /** HUD 패딩 */
    public static final int HUD_PADDING = 5;

    // --- 폰트---

    /** 기본 폰트 크기 */
    public static final int FONT_SIZE_DEFAULT = 12;

    /** 큰 폰트 크기 */
    public static final int FONT_SIZE_LARGE = 16;

    /** 작은 폰트 크기 */
    public static final int FONT_SIZE_SMALL = 10;

    // --- 애니메이션---

    /** 페이드 인 시간 (ms) */
    public static final int FADE_IN_MS = 200;

    /** 페이드 아웃 시간 (ms) */
    public static final int FADE_OUT_MS = 300;

    /** 알림 표시 시간 (ms) */
    public static final int NOTIFICATION_DURATION_MS = 3000;

    // --- 성능 표시 임계값---

    /** FPS 경고 임계값 */
    public static final int FPS_WARNING_THRESHOLD = 30;

    /** FPS 위험 임계값 */
    public static final int FPS_CRITICAL_THRESHOLD = 15;

    /** 틱 경고 임계값 (ms) */
    public static final float TICK_WARNING_THRESHOLD_MS = 20f;

    /** 틱 위험 임계값 (ms) */
    public static final float TICK_CRITICAL_THRESHOLD_MS = 50f;

    // --- 그래프---

    /** 그래프 너비 */
    public static final int GRAPH_WIDTH = 200;

    /** 그래프 높이 */
    public static final int GRAPH_HEIGHT = 60;

    /** 그래프 히스토리 크기 */
    public static final int GRAPH_HISTORY_SIZE = 100;
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\util\GameClassRegistry.java =====

package com.pulse.api.util;

/**
 * 게임 클래스 이름 레지스트리.
 * 
 * 리플렉션에서 사용하는 게임 클래스 이름들을 중앙 관리합니다.
 * 하드코딩된 문자열 대신 이 상수들을 사용하세요.
 * 
 * @since 1.1.0
 */
public final class GameClassRegistry {

    private GameClassRegistry() {
    }

    // --- IsoWorld 관련---

    /** zombie.iso.IsoWorld */
    public static final String ISO_WORLD = "zombie.iso.IsoWorld";

    /** zombie.iso.IsoCell */
    public static final String ISO_CELL = "zombie.iso.IsoCell";

    /** zombie.iso.IsoGridSquare */
    public static final String ISO_GRID_SQUARE = "zombie.iso.IsoGridSquare";

    /** zombie.iso.IsoChunk */
    public static final String ISO_CHUNK = "zombie.iso.IsoChunk";

    // --- Character 관련---

    /** zombie.characters.IsoPlayer */
    public static final String ISO_PLAYER = "zombie.characters.IsoPlayer";

    /** zombie.characters.IsoZombie */
    public static final String ISO_ZOMBIE = "zombie.characters.IsoZombie";

    /** zombie.characters.IsoGameCharacter */
    public static final String ISO_GAME_CHARACTER = "zombie.characters.IsoGameCharacter";

    /** zombie.characters.IsoLivingCharacter */
    public static final String ISO_LIVING_CHARACTER = "zombie.characters.IsoLivingCharacter";

    // --- Core 관련---

    /** zombie.GameTime */
    public static final String GAME_TIME = "zombie.GameTime";

    /** zombie.GameWindow */
    public static final String GAME_WINDOW = "zombie.GameWindow";

    /** zombie.core.Core */
    public static final String CORE = "zombie.core.Core";

    // --- Network 관련---

    /** zombie.network.GameClient */
    public static final String GAME_CLIENT = "zombie.network.GameClient";

    /** zombie.network.GameServer */
    public static final String GAME_SERVER = "zombie.network.GameServer";

    // --- UI 관련---

    /** zombie.ui.UIManager */
    public static final String UI_MANAGER = "zombie.ui.UIManager";

    // --- Pathfinding 관련---

    /** zombie.ai.astar.Mover */
    public static final String ASTAR_MOVER = "zombie.ai.astar.Mover";

    /** zombie.ai.states.ZombiePathFindState */
    public static final String ZOMBIE_PATHFIND_STATE = "zombie.ai.states.ZombiePathFindState";

    // --- Lua 관련---

    /** se.krka.kahlua.vm.KahluaTable */
    public static final String KAHLUA_TABLE = "se.krka.kahlua.vm.KahluaTable";

    /** zombie.Lua.LuaManager */
    public static final String LUA_MANAGER = "zombie.Lua.LuaManager";
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\util\PulseExceptionFormatter.java =====

package com.pulse.api.util;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * Exception StackTrace 축약기
 * 
 * 긴 스택 트레이스를 mod 개발자에게 유용한 형태로 축약합니다.
 * - modId 기반 필터링: 해당 mod 관련 프레임만 표시
 * - 상위 N줄 제한: 너무 긴 스택 트레이스 방지
 * - 컨텍스트 유지: 원인 체인 포함
 * 
 * @since Pulse 0.9 (Phase 4 DX)
 */
public final class PulseExceptionFormatter {

    private static final int DEFAULT_MAX_LINES = 10;

    // 항상 포함할 패키지 접두어
    private static final Set<String> ALWAYS_INCLUDE = new HashSet<>(Arrays.asList(
            "com.pulse.",
            "com.echo.",
            "com.fuse.",
            "com.nerve."));

    // 제외할 패키지 (너무 많은 프레임 방지)
    private static final Set<String> EXCLUDE_PACKAGES = new HashSet<>(Arrays.asList(
            "java.lang.reflect.",
            "sun.reflect.",
            "jdk.internal.",
            "org.objectweb.asm."));

    private PulseExceptionFormatter() {
        // Utility class
    }

    /**
     * 스택 트레이스를 축약된 문자열로 변환
     * 
     * @param throwable 예외
     * @return 축약된 스택 트레이스 문자열
     */
    public static String format(Throwable throwable) {
        return format(throwable, null, DEFAULT_MAX_LINES);
    }

    /**
     * 스택 트레이스를 modId 기준으로 필터링하여 축약
     * 
     * @param throwable 예외
     * @param modId     우선 표시할 mod ID (예: "echo", "fuse")
     * @return 축약된 스택 트레이스 문자열
     */
    public static String format(Throwable throwable, String modId) {
        return format(throwable, modId, DEFAULT_MAX_LINES);
    }

    /**
     * 스택 트레이스를 modId 기준으로 필터링하여 축약
     * 
     * @param throwable 예외
     * @param modId     우선 표시할 mod ID (null이면 전체)
     * @param maxLines  최대 표시 줄 수
     * @return 축약된 스택 트레이스 문자열
     */
    public static String format(Throwable throwable, String modId, int maxLines) {
        if (throwable == null) {
            return "[null exception]";
        }

        StringBuilder sb = new StringBuilder();

        // 예외 타입과 메시지
        sb.append(throwable.getClass().getSimpleName())
                .append(": ")
                .append(throwable.getMessage() != null ? throwable.getMessage() : "(no message)")
                .append("\n");

        // 스택 트레이스 필터링
        StackTraceElement[] frames = throwable.getStackTrace();
        int printed = 0;
        int skipped = 0;
        String modPackage = modId != null ? "com." + modId + "." : null;

        for (StackTraceElement frame : frames) {
            String className = frame.getClassName();

            // 제외 패키지 체크
            if (shouldExclude(className)) {
                skipped++;
                continue;
            }

            // modId 기반 우선순위 또는 항상 포함 패키지
            boolean isRelevant = shouldInclude(className) ||
                    (modPackage != null && className.startsWith(modPackage));

            if (isRelevant || printed < 3) { // 최소 3줄은 항상 표시
                if (printed < maxLines) {
                    sb.append("    at ").append(formatFrame(frame)).append("\n");
                    printed++;
                }
            } else {
                skipped++;
            }
        }

        // 생략된 프레임 수 표시
        if (skipped > 0) {
            sb.append("    ... ").append(skipped).append(" more frames\n");
        }

        // Cause 체인 처리 (재귀)
        Throwable cause = throwable.getCause();
        if (cause != null && cause != throwable) {
            sb.append("Caused by: ");
            sb.append(format(cause, modId, Math.max(3, maxLines / 2)));
        }

        return sb.toString();
    }

    /**
     * 스택 프레임을 간결하게 포맷
     */
    private static String formatFrame(StackTraceElement frame) {
        String className = frame.getClassName();

        // 긴 클래스 이름 축약
        int lastDot = className.lastIndexOf('.');
        if (lastDot > 0 && className.length() > 50) {
            String pkg = className.substring(0, lastDot);
            String simpleName = className.substring(lastDot + 1);

            // 패키지를 축약 (예: com.echo.measure -> c.e.measure)
            String[] parts = pkg.split("\\.");
            StringBuilder abbrev = new StringBuilder();
            for (int i = 0; i < parts.length - 1 && i < 3; i++) {
                abbrev.append(parts[i].charAt(0)).append(".");
            }
            if (parts.length > 0) {
                abbrev.append(parts[parts.length - 1]);
            }
            className = abbrev + "." + simpleName;
        }

        String location = frame.getFileName() != null
                ? frame.getFileName() + ":" + frame.getLineNumber()
                : "Unknown Source";

        return className + "." + frame.getMethodName() + "(" + location + ")";
    }

    private static boolean shouldInclude(String className) {
        for (String prefix : ALWAYS_INCLUDE) {
            if (className.startsWith(prefix)) {
                return true;
            }
        }
        return false;
    }

    private static boolean shouldExclude(String className) {
        for (String prefix : EXCLUDE_PACKAGES) {
            if (className.startsWith(prefix)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 일반적인 로그 출력용 한 줄 요약
     */
    public static String oneLiner(Throwable throwable) {
        if (throwable == null) {
            return "[null]";
        }

        StackTraceElement[] frames = throwable.getStackTrace();
        String location = frames.length > 0
                ? frames[0].getFileName() + ":" + frames[0].getLineNumber()
                : "?";

        return throwable.getClass().getSimpleName() + ": "
                + (throwable.getMessage() != null ? throwable.getMessage() : "(no message)")
                + " @ " + location;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\util\ReflectionCache.java =====

package com.pulse.api.util;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

import com.pulse.api.exception.ReflectionException;

/**
 * 리플렉션 캐시.
 * Method/Field/Class 조회 결과를 캐싱하여 반복적인 리플렉션 호출 성능을 개선합니다.
 * 
 * <p>
 * Thread-safe: ConcurrentHashMap + computeIfAbsent로 원자성 보장
 * </p>
 * 
 * <h2>API 패턴</h2>
 * <ul>
 * <li>{@code findXxx()} - Optional 반환 (권장)</li>
 * <li>{@code getXxxOrThrow()} - 실패 시 ReflectionException</li>
 * <li>{@code getXxxOrNull()} - 실패 시 null (레거시 호환)</li>
 * </ul>
 * 
 * @since 1.1.0
 * @since 2.0.0 - Optional API 추가, PulseReflection 통합
 */
public final class ReflectionCache {

    private ReflectionCache() {
    }

    // Method 캐시: "className.methodName(paramTypes...)" → Method
    private static final Map<String, Method> METHOD_CACHE = new ConcurrentHashMap<>();

    // Field 캐시: "className.fieldName" → Field
    private static final Map<String, Field> FIELD_CACHE = new ConcurrentHashMap<>();

    // Class 캐시: className → Class
    private static final Map<String, Class<?>> CLASS_CACHE = new ConcurrentHashMap<>();

    /**
     * 캐시된 Method 조회.
     * 
     * @param cls    대상 클래스
     * @param name   메서드 이름
     * @param params 파라미터 타입
     * @return Method 객체
     * @throws NoSuchMethodException 메서드가 없으면 발생
     */
    public static Method getMethod(Class<?> cls, String name, Class<?>... params)
            throws NoSuchMethodException {
        String key = buildMethodKey(cls, name, params);

        // computeIfAbsent로 원자적 조회/삽입 보장
        Method cached = METHOD_CACHE.computeIfAbsent(key, k -> {
            try {
                Method m = cls.getMethod(name, params);
                m.setAccessible(true);
                return m;
            } catch (NoSuchMethodException e) {
                return null; // 예외를 값으로 저장 불가, null 반환
            }
        });

        if (cached == null) {
            throw new NoSuchMethodException(cls.getName() + "." + name);
        }
        return cached;
    }

    /**
     * 캐시된 Method 조회 (예외 발생).
     */
    public static Method getMethodOrThrow(Class<?> cls, String name, Class<?>... params) {
        try {
            return getMethod(cls, name, params);
        } catch (NoSuchMethodException e) {
            throw new ReflectionException("Method not found: " + cls.getName() + "." + name, e);
        }
    }

    /**
     * 캐시된 Method 조회 (Optional 스타일).
     */
    public static Method getMethodOrNull(Class<?> cls, String name, Class<?>... params) {
        try {
            return getMethod(cls, name, params);
        } catch (NoSuchMethodException e) {
            return null;
        }
    }

    /**
     * 캐시된 Method 조회 (Optional 반환 - 권장).
     * 
     * @param cls    대상 클래스
     * @param name   메서드 이름
     * @param params 파라미터 타입
     * @return Optional로 감싼 Method
     */
    public static Optional<Method> findMethod(Class<?> cls, String name, Class<?>... params) {
        return Optional.ofNullable(getMethodOrNull(cls, name, params));
    }

    /**
     * 캐시된 Field 조회.
     *
     * @param cls  대상 클래스
     * @param name 필드 이름
     * @return Field 객체
     * @throws NoSuchFieldException 필드가 없으면 발생
     */
    public static Field getField(Class<?> cls, String name) throws NoSuchFieldException {
        String key = cls.getName() + "." + name;

        Field cached = FIELD_CACHE.computeIfAbsent(key, k -> {
            try {
                Field f = cls.getDeclaredField(name);
                f.setAccessible(true);
                return f;
            } catch (NoSuchFieldException e) {
                return null;
            }
        });

        if (cached == null) {
            throw new NoSuchFieldException(cls.getName() + "." + name);
        }
        return cached;
    }

    public static Field getFieldOrThrow(Class<?> cls, String name) {
        try {
            return getField(cls, name);
        } catch (NoSuchFieldException e) {
            throw new ReflectionException("Field not found: " + cls.getName() + "." + name, e);
        }
    }

    /**
     * 캐시된 Class 조회.
     * 
     * @param className 클래스 전체 경로
     * @param loader    클래스 로더
     * @return Class 객체
     * @throws ClassNotFoundException 클래스가 없으면 발생
     */
    public static Class<?> getClass(String className, ClassLoader loader)
            throws ClassNotFoundException {
        Class<?> cached = CLASS_CACHE.computeIfAbsent(className, k -> {
            try {
                return loader.loadClass(className);
            } catch (ClassNotFoundException e) {
                return null;
            }
        });

        if (cached == null) {
            throw new ClassNotFoundException(className);
        }
        return cached;
    }

    /**
     * 캐시된 Class 조회 (예외 발생).
     */
    public static Class<?> getClassOrThrow(String className, ClassLoader loader) {
        try {
            return getClass(className, loader);
        } catch (ClassNotFoundException e) {
            throw new ReflectionException("Class not found: " + className, e);
        }
    }

    /**
     * 캐시된 Class 조회 (Optional 스타일).
     */
    public static Class<?> getClassOrNull(String className, ClassLoader loader) {
        try {
            return getClass(className, loader);
        } catch (ClassNotFoundException e) {
            return null;
        }
    }

    /**
     * 캐시 통계 (디버깅용).
     */
    public static int getMethodCacheSize() {
        return METHOD_CACHE.size();
    }

    public static int getClassCacheSize() {
        return CLASS_CACHE.size();
    }

    public static int getFieldCacheSize() {
        return FIELD_CACHE.size();
    }

    /**
     * 캐시 전체 초기화.
     */
    public static void clearAll() {
        METHOD_CACHE.clear();
        FIELD_CACHE.clear();
        CLASS_CACHE.clear();
    }

    private static String buildMethodKey(Class<?> cls, String name, Class<?>... params) {
        StringBuilder sb = new StringBuilder();
        sb.append(cls.getName()).append('.').append(name).append('(');
        for (int i = 0; i < params.length; i++) {
            if (i > 0)
                sb.append(',');
            sb.append(params[i].getName());
        }
        sb.append(')');
        return sb.toString();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\util\ReflectionClassCache.java =====

package com.pulse.api.util;

import com.pulse.PulseEnvironment;

import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Reflection 클래스 캐시 유틸리티.
 * 
 * 게임 클래스를 lazy loading으로 캐시하며, thread-safe한 구현입니다.
 * Double-checked locking 패턴으로 성능과 안전성을 모두 확보합니다.
 * 
 * <p>
 * 사용 예시:
 * </p>
 * 
 * <pre>
 * private static final ReflectionClassCache&lt;Object&gt; isoWorldCache = new ReflectionClassCache&lt;&gt;("zombie.iso.IsoWorld");
 * 
 * Class&lt;?&gt; worldClass = isoWorldCache.get();
 * if (worldClass != null) {
 *     // 클래스 사용
 * }
 * </pre>
 * 
 * @param <T> 캐시할 클래스 타입
 * @since 1.1.0
 */
public class ReflectionClassCache<T> {

    private final String className;
    private volatile Class<T> cachedClass;
    private final AtomicBoolean initialized = new AtomicBoolean(false);

    /**
     * 캐시 생성.
     * 
     * @param className 로드할 클래스의 완전한 이름 (예: "zombie.iso.IsoWorld")
     */
    public ReflectionClassCache(String className) {
        this.className = className;
    }

    /**
     * 캐시된 클래스를 반환합니다.
     * 첫 호출 시 lazy loading으로 클래스를 로드합니다.
     * 
     * @return 로드된 클래스, 로드 실패 시 null
     */
    @SuppressWarnings("unchecked")
    public Class<T> get() {
        if (!initialized.get()) {
            synchronized (this) {
                if (!initialized.get()) {
                    cachedClass = (Class<T>) loadClass();
                    initialized.set(true);
                }
            }
        }
        return cachedClass;
    }

    /**
     * 클래스를 Optional로 반환합니다.
     * NPE 방지용.
     * 
     * @return Optional로 감싼 클래스
     */
    public Optional<Class<T>> getOptional() {
        return Optional.ofNullable(get());
    }

    /**
     * 클래스를 반환하거나 예외를 던집니다.
     * 
     * @return 로드된 클래스
     * @throws IllegalStateException 클래스 로드 실패 시
     */
    public Class<T> getOrThrow() {
        Class<T> result = get();
        if (result == null) {
            throw new IllegalStateException("Failed to load class: " + className);
        }
        return result;
    }

    /**
     * 캐시를 갱신합니다.
     * 게임 클래스 로더가 변경된 경우 호출하세요.
     */
    public void refresh() {
        synchronized (this) {
            initialized.set(false);
            cachedClass = null;
        }
    }

    /**
     * 캐시가 초기화되었는지 확인.
     */
    public boolean isInitialized() {
        return initialized.get();
    }

    /**
     * 클래스가 성공적으로 로드되었는지 확인.
     */
    public boolean isLoaded() {
        return initialized.get() && cachedClass != null;
    }

    /**
     * 대상 클래스 이름.
     */
    public String getClassName() {
        return className;
    }

    private Class<?> loadClass() {
        ClassLoader loader = PulseEnvironment.getGameClassLoader();
        if (loader == null) {
            loader = ClassLoader.getSystemClassLoader();
        }
        try {
            return loader.loadClass(className);
        } catch (ClassNotFoundException e) {
            // 게임 클래스 로드 실패는 정상적인 상황일 수 있음
            // (예: 게임 시작 전 접근)
            return null;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\util\ReflectionUtil.java =====

package com.pulse.api.util;

import com.pulse.PulseEnvironment;

import com.pulse.api.exception.ReflectionException;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * 리플렉션 유틸리티.
 * GameAccess에서 분리된 범용 리플렉션 기능.
 * 
 * @since 1.1.0
 */
public final class ReflectionUtil {

    private ReflectionUtil() {
    }

    /**
     * 리플렉션으로 정적 필드 값 가져오기
     */
    public static Object getStaticField(String className, String fieldName) {
        try {
            Class<?> clazz = ReflectionCache.getClassOrThrow(className, getLoader());
            Field field = ReflectionCache.getFieldOrThrow(clazz, fieldName);
            return field.get(null);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 리플렉션으로 정적 메서드 호출
     */
    public static Object invokeStaticMethod(String className, String methodName, Object... args) {
        try {
            Class<?> clazz = ReflectionCache.getClassOrThrow(className, getLoader());
            Class<?>[] argTypes = getArgTypes(args);
            Method method = ReflectionCache.getMethodOrThrow(clazz, methodName, argTypes);
            return method.invoke(null, args);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 게임 클래스 로드
     */
    public static Class<?> getGameClass(String className) {
        return ReflectionCache.getClassOrNull(className, getLoader());
    }

    /**
     * 리플렉션으로 정적 필드 값 가져오기 (예외 발생)
     * 
     * @throws com.pulse.api.exception.PulseException 실패 시
     */
    public static Object getStaticFieldOrThrow(String className, String fieldName) {
        try {
            Class<?> clazz = ReflectionCache.getClassOrThrow(className, getLoader());
            Field field = ReflectionCache.getFieldOrThrow(clazz, fieldName);
            return field.get(null);
        } catch (Exception e) {
            throw new ReflectionException("Failed to get static field: " + className + "." + fieldName, e);
        }
    }

    /**
     * 리플렉션으로 정적 메서드 호출 (예외 발생)
     * 
     * @throws com.pulse.api.exception.PulseException 실패 시
     */
    public static Object invokeStaticMethodOrThrow(String className, String methodName, Object... args) {
        try {
            Class<?> clazz = ReflectionCache.getClassOrThrow(className, getLoader());
            Class<?>[] argTypes = getArgTypes(args);
            Method method = ReflectionCache.getMethodOrThrow(clazz, methodName, argTypes);
            return method.invoke(null, args);
        } catch (Exception e) {
            throw new ReflectionException("Failed to invoke static method: " + className + "." + methodName, e);
        }
    }

    /**
     * 게임 클래스 로드 (예외 발생)
     * 
     * @throws com.pulse.api.exception.PulseException 실패 시
     */
    public static Class<?> getGameClassOrThrow(String className) {
        try {
            return ReflectionCache.getClassOrThrow(className, getLoader());
        } catch (Exception e) {
            throw new ReflectionException("Game class not found: " + className, e);
        }
    }

    private static ClassLoader getLoader() {
        ClassLoader loader = PulseEnvironment.getGameClassLoader();
        return loader != null ? loader : ClassLoader.getSystemClassLoader();
    }

    private static Class<?>[] getArgTypes(Object... args) {
        if (args == null || args.length == 0) {
            return new Class<?>[0];
        }
        Class<?>[] argTypes = new Class<?>[args.length];
        for (int i = 0; i < args.length; i++) {
            argTypes[i] = args[i] != null ? args[i].getClass() : Object.class;
        }
        return argTypes;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\util\SafeInitializer.java =====

package com.pulse.api.util;

import com.pulse.api.exception.InitializationException;
import com.pulse.api.log.PulseLogger;

import java.util.Optional;
import java.util.concurrent.Callable;
import java.util.function.Supplier;

/**
 * 안전한 초기화 유틸리티.
 * 
 * 초기화 코드의 예외를 graceful하게 처리하고,
 * 실패 시 로깅 및 대체 값 반환을 지원합니다.
 * 
 * <pre>
 * // 예외 발생 시 기본값 반환
 * String value = SafeInitializer.tryGet(() -> config.getValue(), "default");
 * 
 * // 예외 발생 시 로깅만
 * SafeInitializer.tryRun("Pulse", "Loading config", () -> loadConfig());
 * 
 * // 예외 발생 시 Optional.empty()
 * Optional&lt;Service&gt; service = SafeInitializer.tryGetOptional(() -> loadService());
 * </pre>
 * 
 * @since 1.1.0
 */
public final class SafeInitializer {

    private SafeInitializer() {
    }

    /**
     * 초기화 로직 실행. 예외 발생 시 로깅 후 무시.
     * 
     * @param module    모듈명 (로깅용)
     * @param operation 작업명 (로깅용)
     * @param runnable  실행할 로직
     * @return 성공 여부
     */
    public static boolean tryRun(String module, String operation, Runnable runnable) {
        try {
            runnable.run();
            return true;
        } catch (Exception e) {
            PulseLogger.warn(module, "Failed to {}: {}", operation, e.getMessage());
            return false;
        }
    }

    /**
     * 초기화 로직 실행 (자세한 예외 로깅).
     * 
     * @param module    모듈명
     * @param operation 작업명
     * @param runnable  실행할 로직
     * @param verbose   true면 스택 트레이스도 출력
     * @return 성공 여부
     */
    public static boolean tryRun(String module, String operation, Runnable runnable, boolean verbose) {
        try {
            runnable.run();
            return true;
        } catch (Exception e) {
            if (verbose) {
                PulseLogger.error(module, "Failed to {}: {}", operation, e.getMessage(), e);
            } else {
                PulseLogger.warn(module, "Failed to {}: {}", operation, e.getMessage());
            }
            return false;
        }
    }

    /**
     * 값 반환 초기화. 예외 시 기본값 반환.
     * 
     * @param supplier     값 공급자
     * @param defaultValue 기본값
     * @param <T>          반환 타입
     * @return 결과 또는 기본값
     */
    public static <T> T tryGet(Supplier<T> supplier, T defaultValue) {
        try {
            T result = supplier.get();
            return result != null ? result : defaultValue;
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 값 반환 초기화 (로깅 포함). 예외 시 기본값 반환.
     * 
     * @param module       모듈명
     * @param operation    작업명
     * @param supplier     값 공급자
     * @param defaultValue 기본값
     * @param <T>          반환 타입
     * @return 결과 또는 기본값
     */
    public static <T> T tryGet(String module, String operation, Supplier<T> supplier, T defaultValue) {
        try {
            T result = supplier.get();
            return result != null ? result : defaultValue;
        } catch (Exception e) {
            PulseLogger.warn(module, "Failed to {}, using default: {}", operation, e.getMessage());
            return defaultValue;
        }
    }

    /**
     * Optional 반환 초기화. 예외 시 Optional.empty().
     * 
     * @param supplier 값 공급자
     * @param <T>      반환 타입
     * @return Optional 결과
     */
    public static <T> Optional<T> tryGetOptional(Supplier<T> supplier) {
        try {
            return Optional.ofNullable(supplier.get());
        } catch (Exception e) {
            return Optional.empty();
        }
    }

    /**
     * Optional 반환 초기화 (로깅 포함).
     * 
     * @param module    모듈명
     * @param operation 작업명
     * @param supplier  값 공급자
     * @param <T>       반환 타입
     * @return Optional 결과
     */
    public static <T> Optional<T> tryGetOptional(String module, String operation, Supplier<T> supplier) {
        try {
            return Optional.ofNullable(supplier.get());
        } catch (Exception e) {
            PulseLogger.debug(module, "Optional {} failed: {}", operation, e.getMessage());
            return Optional.empty();
        }
    }

    /**
     * Callable 실행. 예외 시 InitializationException으로 래핑.
     * 
     * @param component 컴포넌트명
     * @param phase     초기화 단계
     * @param callable  실행할 로직
     * @param <T>       반환 타입
     * @return 결과
     * @throws InitializationException 초기화 실패 시
     */
    public static <T> T requireOrThrow(String component, InitializationException.InitPhase phase,
            Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw new InitializationException(
                    String.format("Failed to initialize %s: %s", component, e.getMessage()),
                    component, phase, e);
        }
    }

    /**
     * 조건 검증. 조건 불충족 시 예외 발생.
     * 
     * @param condition    검증할 조건
     * @param errorMessage 오류 메시지
     * @throws InitializationException 조건 불충족 시
     */
    public static void requireCondition(boolean condition, String errorMessage) {
        if (!condition) {
            throw new InitializationException(errorMessage);
        }
    }

    /**
     * null 아닌 값 검증.
     * 
     * @param value        검증할 값
     * @param errorMessage 오류 메시지
     * @param <T>          값 타입
     * @return 검증된 값
     * @throws InitializationException 값이 null인 경우
     */
    public static <T> T requireNonNull(T value, String errorMessage) {
        if (value == null) {
            throw new InitializationException(errorMessage);
        }
        return value;
    }

    /**
     * 여러 초기화 작업 순차 실행. 하나라도 실패 시 중단.
     * 
     * @param module 모듈명
     * @param tasks  실행할 작업 배열
     * @return 모든 작업 성공 여부
     */
    public static boolean tryRunAll(String module, InitTask... tasks) {
        for (InitTask task : tasks) {
            if (!tryRun(module, task.name, task.runnable)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 초기화 작업 정의
     */
    public static class InitTask {
        public final String name;
        public final Runnable runnable;

        public InitTask(String name, Runnable runnable) {
            this.name = name;
            this.runnable = runnable;
        }

        public static InitTask of(String name, Runnable runnable) {
            return new InitTask(name, runnable);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\util\TopNCollector.java =====

package com.pulse.api.util;

import java.util.*;
import java.util.function.ToDoubleFunction;
import java.util.function.ToLongFunction;

/**
 * Top N 컬렉션 유틸리티.
 * 
 * <p>
 * 컬렉션에서 상위/하위 N개 항목을 효율적으로 추출합니다.
 * </p>
 * 
 * <h3>사용 예시:</h3>
 * 
 * <pre>
 * // Long 값 기준 상위 10개
 * List&lt;LuaFunctionStats&gt; top = TopNCollector.topNByLong(
 *         stats, LuaFunctionStats::getTotalMicros, 10);
 * 
 * // Double 값 기준 상위 5개
 * List&lt;Entry&gt; top = TopNCollector.topNByDouble(
 *         entries, Entry::getAvgMs, 5);
 * </pre>
 * 
 * @since Pulse 1.6
 */
public final class TopNCollector {

    private TopNCollector() {
        // Utility class
    }

    // ═══════════════════════════════════════════════════════════════
    // Generic Top N
    // ═══════════════════════════════════════════════════════════════

    /**
     * 컬렉션에서 상위 N개 항목 추출.
     * 
     * @param items      원본 컬렉션
     * @param comparator 정렬 기준 (내림차순으로 정의해야 함)
     * @param n          추출할 개수
     * @return 상위 N개 항목 리스트
     */
    public static <T> List<T> topN(Collection<T> items,
            Comparator<T> comparator,
            int n) {
        if (items == null || items.isEmpty() || n <= 0) {
            return Collections.emptyList();
        }

        return items.stream()
                .sorted(comparator)
                .limit(n)
                .toList();
    }

    // ═══════════════════════════════════════════════════════════════
    // Convenience Methods
    // ═══════════════════════════════════════════════════════════════

    /**
     * Long 값 기준 상위 N개 추출 (내림차순).
     * 
     * @param items     원본 컬렉션
     * @param extractor long 값 추출 함수
     * @param n         추출할 개수
     * @return 상위 N개 항목
     */
    public static <T> List<T> topNByLong(Collection<T> items,
            ToLongFunction<T> extractor,
            int n) {
        return topN(items,
                Comparator.comparingLong(extractor).reversed(),
                n);
    }

    /**
     * Double 값 기준 상위 N개 추출 (내림차순).
     * 
     * @param items     원본 컬렉션
     * @param extractor double 값 추출 함수
     * @param n         추출할 개수
     * @return 상위 N개 항목
     */
    public static <T> List<T> topNByDouble(Collection<T> items,
            ToDoubleFunction<T> extractor,
            int n) {
        return topN(items,
                Comparator.comparingDouble(extractor).reversed(),
                n);
    }

    /**
     * Int 값 기준 상위 N개 추출 (내림차순).
     * 
     * @param items     원본 컬렉션
     * @param extractor int 값 추출 함수
     * @param n         추출할 개수
     * @return 상위 N개 항목
     */
    public static <T> List<T> topNByInt(Collection<T> items,
            java.util.function.ToIntFunction<T> extractor,
            int n) {
        return topN(items,
                Comparator.comparingInt(extractor).reversed(),
                n);
    }

    // ═══════════════════════════════════════════════════════════════
    // Bottom N (오름차순)
    // ═══════════════════════════════════════════════════════════════

    /**
     * Long 값 기준 하위 N개 추출 (오름차순).
     */
    public static <T> List<T> bottomNByLong(Collection<T> items,
            ToLongFunction<T> extractor,
            int n) {
        return topN(items,
                Comparator.comparingLong(extractor),
                n);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\api\VersionCompatibility.java =====

package com.pulse.api;

import com.pulse.api.log.PulseLogger;

/**
 * 버전 호환성 검사 유틸리티.
 * Pulse API 버전과 게임 버전 호환성을 확인합니다.
 * 
 * <pre>
 * // 사용 예시
 * if (VersionCompatibility.isCompatible(2)) {
 *     // API v2 이상 필요한 기능 사용
 * }
 * 
 * if (!VersionCompatibility.isGameVersionCompatible()) {
 *     Pulse.warn("mymod", "Game version too old!");
 * }
 * </pre>
 * 
 * @since 1.1.0
 */
@PublicAPI(since = "1.1.0")
public final class VersionCompatibility {

    private static final String LOG = PulseLogger.PULSE;

    // ═══════════════════════════════════════════════════════════════
    // 버전 상수
    // ═══════════════════════════════════════════════════════════════

    /** Pulse API 버전 (정수) */
    public static final int PULSE_API_VERSION = 1;

    /** Pulse 버전 문자열 */
    public static final String PULSE_VERSION = "0.8.0";

    /** 최소 지원 PZ 버전 */
    public static final String MIN_GAME_VERSION = "41.78";

    /** 최대 테스트된 PZ 버전 */
    public static final String MAX_TESTED_GAME_VERSION = "41.78.16";

    // 캐시된 게임 버전
    private static volatile String cachedGameVersion = null;
    private static volatile Boolean cachedGameCompatible = null;

    private VersionCompatibility() {
    } // 인스턴스화 방지

    // ═══════════════════════════════════════════════════════════════
    // API 호환성
    // ═══════════════════════════════════════════════════════════════

    /**
     * 요청한 API 버전이 호환되는지 확인.
     * 
     * @param requiredApiVersion 필요한 API 버전
     * @return 호환되면 true
     */
    public static boolean isCompatible(int requiredApiVersion) {
        return PULSE_API_VERSION >= requiredApiVersion;
    }

    /**
     * 현재 Pulse API 버전 반환.
     * 
     * @return API 버전 정수
     */
    public static int getApiVersion() {
        return PULSE_API_VERSION;
    }

    /**
     * 현재 Pulse 버전 문자열 반환.
     * 
     * @return 버전 문자열 (예: "1.1.0")
     */
    public static String getPulseVersion() {
        return PULSE_VERSION;
    }

    // ═══════════════════════════════════════════════════════════════
    // 게임 버전 호환성
    // ═══════════════════════════════════════════════════════════════

    /**
     * 현재 게임 버전이 호환되는지 확인.
     * 
     * @return 호환되면 true
     */
    public static boolean isGameVersionCompatible() {
        if (cachedGameCompatible != null) {
            return cachedGameCompatible;
        }

        String gameVersion = getGameVersion();
        if (gameVersion == null || gameVersion.isEmpty()) {
            cachedGameCompatible = true; // 버전 확인 불가 시 호환으로 간주
            return true;
        }

        cachedGameCompatible = compareVersions(gameVersion, MIN_GAME_VERSION) >= 0;
        return cachedGameCompatible;
    }

    /**
     * 현재 게임 버전 문자열 반환.
     * 
     * @return 게임 버전 또는 "Unknown"
     */
    public static String getGameVersion() {
        if (cachedGameVersion != null) {
            return cachedGameVersion;
        }

        try {
            // Core.GameVersion 접근 시도
            Class<?> coreClass = Class.forName("zombie.core.Core");
            java.lang.reflect.Field versionField = coreClass.getDeclaredField("GameVersion");
            versionField.setAccessible(true);
            Object version = versionField.get(null);

            if (version != null) {
                cachedGameVersion = version.toString();
                return cachedGameVersion;
            }
        } catch (Exception e) {
            // 무시 - 게임 클래스 로드 전
        }

        // 대안: 시스템 프로퍼티
        String propVersion = System.getProperty("zomboid.version");
        if (propVersion != null) {
            cachedGameVersion = propVersion;
            return cachedGameVersion;
        }

        cachedGameVersion = "Unknown";
        return cachedGameVersion;
    }

    /**
     * 특정 Pulse 기능이 사용 가능한지 확인.
     * CapabilityFlags와 연동.
     * 
     * @param featureId 기능 ID
     * @return 사용 가능하면 true
     */
    public static boolean hasFeature(String featureId) {
        return CapabilityFlags.supports(featureId) && FeatureFlags.isEnabled(featureId);
    }

    // ═══════════════════════════════════════════════════════════════
    // 버전 비교 유틸리티
    // ═══════════════════════════════════════════════════════════════

    /**
     * 버전 문자열 비교.
     * 
     * @param v1 버전 1
     * @param v2 버전 2
     * @return v1 > v2 면 양수, v1 < v2 면 음수, 같으면 0
     */
    public static int compareVersions(String v1, String v2) {
        if (v1 == null || v2 == null) {
            return 0;
        }

        String[] parts1 = v1.split("\\.");
        String[] parts2 = v2.split("\\.");

        int maxLength = Math.max(parts1.length, parts2.length);

        for (int i = 0; i < maxLength; i++) {
            int num1 = i < parts1.length ? parseVersionPart(parts1[i]) : 0;
            int num2 = i < parts2.length ? parseVersionPart(parts2[i]) : 0;

            if (num1 != num2) {
                return num1 - num2;
            }
        }

        return 0;
    }

    private static int parseVersionPart(String part) {
        try {
            // 숫자가 아닌 문자 제거 (예: "78b" → "78")
            String numOnly = part.replaceAll("[^0-9]", "");
            return numOnly.isEmpty() ? 0 : Integer.parseInt(numOnly);
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    /**
     * 디버그 정보 출력.
     */
    public static void printInfo() {
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "  Version Compatibility Info");
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "  Pulse Version: {}", PULSE_VERSION);
        PulseLogger.info(LOG, "  API Version: {}", PULSE_API_VERSION);
        PulseLogger.info(LOG, "  Game Version: {}", getGameVersion());
        PulseLogger.info(LOG, "  Min Supported: {}", MIN_GAME_VERSION);
        PulseLogger.info(LOG, "  Max Tested: {}", MAX_TESTED_GAME_VERSION);
        PulseLogger.info(LOG, "  Compatible: {}", isGameVersionCompatible());
        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\attachment\AttachmentType.java =====

package com.pulse.attachment;

import com.pulse.api.log.PulseLogger;

import com.pulse.registry.Identifier;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 데이터 첨부 타입.
 * 게임 객체에 커스텀 데이터를 첨부하기 위한 타입 정의.
 * 
 * NeoForge의 Data Attachment와 유사한 개념.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 첨부 타입 정의
 * public static final AttachmentType<MyData> MY_DATA = AttachmentType.builder("mymod", "my_data", MyData::new)
 *         .persistent() // NBT 저장
 *         .copyOnDeath() // 사망 시 복사
 *         .build();
 * 
 * // 데이터 접근
 * MyData data = DataAttachments.get(entity, MY_DATA);
 * data.setValue(42);
 * </pre>
 * 
 * @param <T> 첨부 데이터 타입
 */
public class AttachmentType<T> {

    private final Identifier id;
    private final Supplier<T> defaultFactory;
    private final boolean persistent;
    private final boolean copyOnDeath;
    private final Serializer<T> serializer;

    // 등록된 모든 첨부 타입
    private static final Map<Identifier, AttachmentType<?>> REGISTRY = new ConcurrentHashMap<>();
    private static final String LOG = PulseLogger.PULSE;

    private AttachmentType(Identifier id, Supplier<T> defaultFactory,
            boolean persistent, boolean copyOnDeath,
            Serializer<T> serializer) {
        this.id = id;
        this.defaultFactory = defaultFactory;
        this.persistent = persistent;
        this.copyOnDeath = copyOnDeath;
        this.serializer = serializer;

        REGISTRY.put(id, this);
    }

    /**
     * 빌더 생성
     */
    public static <T> Builder<T> builder(String modId, String name, Supplier<T> defaultFactory) {
        return new Builder<>(Identifier.of(modId, name), defaultFactory);
    }

    /**
     * ID로 첨부 타입 가져오기
     */
    @SuppressWarnings("unchecked")
    public static <T> AttachmentType<T> get(Identifier id) {
        return (AttachmentType<T>) REGISTRY.get(id);
    }

    /**
     * 모든 등록된 첨부 타입
     */
    public static Collection<AttachmentType<?>> getAll() {
        return Collections.unmodifiableCollection(REGISTRY.values());
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public Identifier getId() {
        return id;
    }

    public Supplier<T> getDefaultFactory() {
        return defaultFactory;
    }

    public boolean isPersistent() {
        return persistent;
    }

    public boolean isCopyOnDeath() {
        return copyOnDeath;
    }

    public Serializer<T> getSerializer() {
        return serializer;
    }

    /**
     * 기본값 생성
     */
    public T createDefault() {
        return defaultFactory.get();
    }

    // ─────────────────────────────────────────────────────────────
    // 빌더
    // ─────────────────────────────────────────────────────────────

    public static class Builder<T> {
        private final Identifier id;
        private final Supplier<T> defaultFactory;
        private boolean persistent = false;
        private boolean copyOnDeath = false;
        private Serializer<T> serializer = null;

        private Builder(Identifier id, Supplier<T> defaultFactory) {
            this.id = id;
            this.defaultFactory = defaultFactory;
        }

        /**
         * 영구 저장 활성화
         */
        public Builder<T> persistent() {
            this.persistent = true;
            return this;
        }

        /**
         * 사망 시 복사
         */
        public Builder<T> copyOnDeath() {
            this.copyOnDeath = true;
            return this;
        }

        /**
         * 커스텀 직렬화기 설정
         */
        public Builder<T> serializer(Serializer<T> serializer) {
            this.serializer = serializer;
            return this;
        }

        public AttachmentType<T> build() {
            AttachmentType<T> type = new AttachmentType<>(
                    id, defaultFactory, persistent, copyOnDeath, serializer);
            PulseLogger.info(LOG, "[Attachment] Registered: {}", id);
            return type;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 직렬화 인터페이스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface Serializer<T> {
        /**
         * 객체를 Map으로 직렬화
         */
        Map<String, Object> serialize(T value);

        /**
         * Map에서 객체 복원
         */
        default T deserialize(Map<String, Object> data, Supplier<T> factory) {
            // 기본 구현: 팩토리로 새 객체 생성
            return factory.get();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\attachment\DataAttachments.java =====

package com.pulse.attachment;

import com.google.gson.*;
import com.pulse.api.log.PulseLogger;
import com.pulse.registry.Identifier;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 데이터 첨부 관리자.
 * 게임 객체에 커스텀 데이터를 첨부하고 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 엔티티에 데이터 첨부
 * MyData data = DataAttachments.get(entity, MY_DATA);
 * 
 * // 데이터 설정
 * DataAttachments.set(entity, MY_DATA, newData);
 * 
 * // 데이터 제거
 * DataAttachments.remove(entity, MY_DATA);
 * 
 * // 존재 여부 확인
 * if (DataAttachments.has(entity, MY_DATA)) { ... }
 * 
 * // 영구 데이터 저장
 * DataAttachments.save(entity, "player_data.json");
 * 
 * // 영구 데이터 로드
 * DataAttachments.load(entity, "player_data.json");
 * </pre>
 */
public class DataAttachments {

    private static final DataAttachments INSTANCE = new DataAttachments();
    private static final String LOG = PulseLogger.PULSE;

    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .serializeNulls()
            .create();

    // 객체별 첨부 데이터
    // WeakHashMap을 사용하여 객체가 GC되면 자동으로 정리
    private final Map<Object, Map<AttachmentType<?>, Object>> attachments = Collections
            .synchronizedMap(new WeakHashMap<>());

    // 영구 저장용 디렉토리
    private Path saveDirectory;

    private DataAttachments() {
        String gameDir = System.getProperty("user.dir");
        this.saveDirectory = Paths.get(gameDir, "Pulse", "attachments");
    }

    public static DataAttachments getInstance() {
        return INSTANCE;
    }

    /**
     * 저장 디렉토리 설정
     */
    public static void setSaveDirectory(Path directory) {
        INSTANCE.saveDirectory = directory;
    }

    public static Path getSaveDirectory() {
        return INSTANCE.saveDirectory;
    }

    // ─────────────────────────────────────────────────────────────
    // 데이터 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * 첨부 데이터 가져오기 (없으면 생성)
     */
    public static <T> T get(Object holder, AttachmentType<T> type) {
        return INSTANCE.getData(holder, type);
    }

    /**
     * 첨부 데이터 가져오기 (Optional)
     */
    public static <T> Optional<T> getOptional(Object holder, AttachmentType<T> type) {
        return INSTANCE.getDataOptional(holder, type);
    }

    /**
     * 첨부 데이터 설정
     */
    public static <T> void set(Object holder, AttachmentType<T> type, T value) {
        INSTANCE.setData(holder, type, value);
    }

    /**
     * 첨부 데이터 제거
     */
    public static <T> void remove(Object holder, AttachmentType<T> type) {
        INSTANCE.removeData(holder, type);
    }

    /**
     * 첨부 데이터 존재 여부
     */
    public static <T> boolean has(Object holder, AttachmentType<T> type) {
        return INSTANCE.hasData(holder, type);
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 구현
    // ─────────────────────────────────────────────────────────────

    @SuppressWarnings("unchecked")
    private <T> T getData(Object holder, AttachmentType<T> type) {
        Map<AttachmentType<?>, Object> holderData = attachments.computeIfAbsent(
                holder, k -> new ConcurrentHashMap<>());

        return (T) holderData.computeIfAbsent(type, t -> type.createDefault());
    }

    @SuppressWarnings("unchecked")
    private <T> Optional<T> getDataOptional(Object holder, AttachmentType<T> type) {
        Map<AttachmentType<?>, Object> holderData = attachments.get(holder);
        if (holderData == null)
            return Optional.empty();
        return Optional.ofNullable((T) holderData.get(type));
    }

    private <T> void setData(Object holder, AttachmentType<T> type, T value) {
        Map<AttachmentType<?>, Object> holderData = attachments.computeIfAbsent(
                holder, k -> new ConcurrentHashMap<>());
        holderData.put(type, value);
    }

    private <T> void removeData(Object holder, AttachmentType<T> type) {
        Map<AttachmentType<?>, Object> holderData = attachments.get(holder);
        if (holderData != null) {
            holderData.remove(type);
        }
    }

    private <T> boolean hasData(Object holder, AttachmentType<T> type) {
        Map<AttachmentType<?>, Object> holderData = attachments.get(holder);
        return holderData != null && holderData.containsKey(type);
    }

    // ─────────────────────────────────────────────────────────────
    // 복사/이전
    // ─────────────────────────────────────────────────────────────

    /**
     * 한 객체에서 다른 객체로 모든 첨부 데이터 복사
     */
    public static void copyAll(Object from, Object to) {
        INSTANCE.copyAllData(from, to);
    }

    /**
     * copyOnDeath가 설정된 첨부 데이터만 복사 (사망 시 사용)
     */
    public static void copyOnDeath(Object from, Object to) {
        INSTANCE.copyDeathData(from, to);
    }

    private void copyAllData(Object from, Object to) {
        Map<AttachmentType<?>, Object> fromData = attachments.get(from);
        if (fromData == null || fromData.isEmpty())
            return;

        Map<AttachmentType<?>, Object> toData = attachments.computeIfAbsent(
                to, k -> new ConcurrentHashMap<>());
        toData.putAll(fromData);
    }

    private void copyDeathData(Object from, Object to) {
        Map<AttachmentType<?>, Object> fromData = attachments.get(from);
        if (fromData == null || fromData.isEmpty())
            return;

        Map<AttachmentType<?>, Object> toData = attachments.computeIfAbsent(
                to, k -> new ConcurrentHashMap<>());

        for (Map.Entry<AttachmentType<?>, Object> entry : fromData.entrySet()) {
            if (entry.getKey().isCopyOnDeath()) {
                toData.put(entry.getKey(), entry.getValue());
            }
        }
    }

    /**
     * 객체의 모든 첨부 데이터 제거
     */
    public static void clearAll(Object holder) {
        INSTANCE.attachments.remove(holder);
    }

    /**
     * 첨부 데이터 통계
     */
    public static int getAttachmentCount() {
        return INSTANCE.attachments.size();
    }

    // ─────────────────────────────────────────────────────────────
    // 직렬화/역직렬화
    // ─────────────────────────────────────────────────────────────

    /**
     * 객체의 영구 첨부 데이터를 JSON 파일로 저장.
     * 
     * @param holder   데이터 홀더 객체
     * @param filename 저장할 파일명 (예: "player_123.json")
     * @return 저장 성공 여부
     */
    public static boolean save(Object holder, String filename) {
        return INSTANCE.saveToFile(holder, filename);
    }

    /**
     * JSON 파일에서 영구 첨부 데이터를 로드.
     * 
     * @param holder   데이터 홀더 객체
     * @param filename 로드할 파일명
     * @return 로드 성공 여부
     */
    public static boolean load(Object holder, String filename) {
        return INSTANCE.loadFromFile(holder, filename);
    }

    /**
     * 모든 영구 첨부 데이터를 저장.
     * 각 객체는 hashCode 기반 파일명으로 저장됨.
     */
    public static void saveAll() {
        INSTANCE.saveAllPersistent();
    }

    @SuppressWarnings("unchecked")
    private boolean saveToFile(Object holder, String filename) {
        Map<AttachmentType<?>, Object> holderData = attachments.get(holder);
        if (holderData == null || holderData.isEmpty()) {
            return true; // 저장할 데이터 없음
        }

        try {
            // 디렉토리 생성
            Files.createDirectories(saveDirectory);

            Path filePath = saveDirectory.resolve(filename);

            // 영구 저장 가능한 데이터만 필터링
            JsonObject root = new JsonObject();
            root.addProperty("_version", "1.0");
            root.addProperty("_timestamp", System.currentTimeMillis());

            JsonObject dataObj = new JsonObject();

            for (Map.Entry<AttachmentType<?>, Object> entry : holderData.entrySet()) {
                AttachmentType<?> type = entry.getKey();

                if (!type.isPersistent()) {
                    continue;
                }

                Object value = entry.getValue();
                String key = type.getId().toString();

                // 직렬화
                AttachmentType.Serializer<Object> serializer = (AttachmentType.Serializer<Object>) type.getSerializer();

                if (serializer != null) {
                    // 커스텀 직렬화기 사용
                    Map<String, Object> serialized = serializer.serialize(value);
                    dataObj.add(key, GSON.toJsonTree(serialized));
                } else {
                    // 기본 GSON 직렬화
                    dataObj.add(key, GSON.toJsonTree(value));
                }
            }

            root.add("data", dataObj);

            // 파일에 쓰기
            String json = GSON.toJson(root);
            Files.writeString(filePath, json, StandardCharsets.UTF_8);

            Files.writeString(filePath, json, StandardCharsets.UTF_8);

            PulseLogger.info(LOG, "[Attachment] Saved: {}", filePath.getFileName());
            return true;

        } catch (Exception e) {
            PulseLogger.error(LOG, "[Attachment] Failed to save: {}", filename, e);
            return false;
        }
    }

    @SuppressWarnings("unchecked")
    private boolean loadFromFile(Object holder, String filename) {
        Path filePath = saveDirectory.resolve(filename);

        if (!Files.exists(filePath)) {
            return true; // 파일 없음 = 새 데이터
        }

        try {
            String json = Files.readString(filePath, StandardCharsets.UTF_8);
            JsonObject root = JsonParser.parseString(json).getAsJsonObject();

            if (!root.has("data")) {
                return true;
            }

            JsonObject dataObj = root.getAsJsonObject("data");

            Map<AttachmentType<?>, Object> holderData = attachments.computeIfAbsent(
                    holder, k -> new ConcurrentHashMap<>());

            for (String key : dataObj.keySet()) {
                Identifier id = Identifier.parse(key);
                AttachmentType<?> type = AttachmentType.get(id);

                if (type == null) {
                    PulseLogger.error(LOG, "[Attachment] Unknown type: {}", key);
                    continue;
                }

                JsonElement element = dataObj.get(key);

                AttachmentType.Serializer<Object> serializer = (AttachmentType.Serializer<Object>) type.getSerializer();

                Object value;
                if (serializer != null) {
                    // 커스텀 역직렬화
                    Map<String, Object> map = GSON.fromJson(element, Map.class);
                    value = serializer.deserialize(map, (java.util.function.Supplier<Object>) type.getDefaultFactory());
                } else {
                    // GSON으로 직접 역직렬화 시도
                    // 기본 팩토리로 새 객체 생성 후 필드 복사
                    value = type.createDefault();
                    if (element.isJsonObject()) {
                        // 리플렉션으로 필드 복사
                        copyJsonToObject(element.getAsJsonObject(), value);
                    }
                }

                holderData.put(type, value);
            }

            PulseLogger.info(LOG, "[Attachment] Loaded: {}", filePath.getFileName());
            return true;

        } catch (Exception e) {
            PulseLogger.error(LOG, "[Attachment] Failed to load: {}", filename, e);
            return false;
        }
    }

    private void copyJsonToObject(JsonObject json, Object target) {
        try {
            for (java.lang.reflect.Field field : target.getClass().getDeclaredFields()) {
                if (java.lang.reflect.Modifier.isStatic(field.getModifiers())) {
                    continue;
                }

                String fieldName = field.getName();
                if (!json.has(fieldName)) {
                    continue;
                }

                field.setAccessible(true);
                JsonElement element = json.get(fieldName);

                Class<?> fieldType = field.getType();
                Object value = GSON.fromJson(element, fieldType);
                field.set(target, value);
            }
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Attachment] Failed to copy JSON to object: {}", e.getMessage());
        }
    }

    private void saveAllPersistent() {
        int saved = 0;
        for (Map.Entry<Object, Map<AttachmentType<?>, Object>> entry : attachments.entrySet()) {
            Object holder = entry.getKey();

            // holder의 고유 식별자 생성
            String filename = "holder_" + System.identityHashCode(holder) + ".json";

            if (saveToFile(holder, filename)) {
                saved++;
            }
        }
        PulseLogger.info(LOG, "[Attachment] Saved {} holder(s)", saved);
    }

    /**
     * 특정 파일 삭제
     */
    public static boolean delete(String filename) {
        try {
            Path filePath = INSTANCE.saveDirectory.resolve(filename);
            return Files.deleteIfExists(filePath);
        } catch (IOException e) {
            return false;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bindings\Build41EngineBindings.java =====

package com.pulse.bindings;

import com.pulse.adapter.lua.Build41LuaAdapter;
import com.pulse.adapter.lua.ILuaAdapter;
import com.pulse.adapter.zombie.Build41ZombieAdapter;
import com.pulse.adapter.zombie.IZombieAdapter;

/**
 * Build 41 engine bindings implementation.
 * 
 * <p>
 * Wraps existing B41 adapters in the new bindings interface.
 * </p>
 * 
 * @since Pulse 0.9
 */
final class Build41EngineBindings implements EngineBindings {

    private final int gameBuild;
    private final Build41LuaBindings luaBindings;
    private final Build41ZombieBindings zombieBindings;

    Build41EngineBindings(int gameBuild) {
        this.gameBuild = gameBuild;
        this.luaBindings = new Build41LuaBindings();
        this.zombieBindings = new Build41ZombieBindings();
    }

    @Override
    public ILuaBindings lua() {
        return luaBindings;
    }

    @Override
    public IZombieBindings zombie() {
        return zombieBindings;
    }

    @Override
    public int getGameBuild() {
        return gameBuild;
    }

    // ═══════════════════════════════════════════════════════════════
    // Build 41 Lua Bindings
    // ═══════════════════════════════════════════════════════════════

    private static class Build41LuaBindings implements ILuaBindings {

        private final ILuaAdapter adapter = new Build41LuaAdapter();

        @Override
        public String getEventManagerClassName() {
            return adapter.getEventManagerClassName();
        }

        @Override
        public String getLuaManagerClassName() {
            return adapter.getLuaManagerClassName();
        }

        @Override
        public int getMaxTriggerEventArgs() {
            return adapter.getMaxTriggerEventArgs();
        }

        @Override
        public void onEventStart(String eventName) {
            adapter.onEventStart(eventName);
        }

        @Override
        public void onEventEnd() {
            adapter.onEventEnd();
        }

        @Override
        public boolean hasGlobalLuaAccess() {
            return adapter.hasGlobalLuaAccess();
        }

        @Override
        public Object getGlobalLuaValue(String name) {
            return adapter.getGlobalLuaValue(name);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Build 41 Zombie Bindings
    // ═══════════════════════════════════════════════════════════════

    private static class Build41ZombieBindings implements IZombieBindings {

        private final IZombieAdapter adapter = new Build41ZombieAdapter();

        @Override
        public int getZombieId(Object zombie) {
            return adapter.getZombieId(zombie);
        }

        @Override
        public int getOnlineId(Object zombie) {
            return adapter.getOnlineId(zombie);
        }

        @Override
        public int getLocalId(Object zombie) {
            return adapter.getLocalId(zombie);
        }

        @Override
        public float getX(Object zombie) {
            return adapter.getX(zombie);
        }

        @Override
        public float getY(Object zombie) {
            return adapter.getY(zombie);
        }

        @Override
        public float getZ(Object zombie) {
            return adapter.getZ(zombie);
        }

        @Override
        public float getDistanceSquaredToNearestPlayer(Object zombie) {
            return adapter.getDistanceSquaredToNearestPlayer(zombie);
        }

        @Override
        public boolean isAttacking(Object zombie) {
            return adapter.isAttacking(zombie);
        }

        @Override
        public boolean hasTarget(Object zombie) {
            return adapter.hasTarget(zombie);
        }

        @Override
        public Object getTarget(Object zombie) {
            return adapter.getTarget(zombie);
        }

        @Override
        public boolean isCrawler(Object zombie) {
            return adapter.isCrawler(zombie);
        }

        @Override
        public boolean isOnFloor(Object zombie) {
            return adapter.isOnFloor(zombie);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bindings\Build42EngineBindings.java =====

package com.pulse.bindings;

import com.pulse.adapter.lua.Build42LuaAdapter;
import com.pulse.adapter.lua.ILuaAdapter;
import com.pulse.adapter.zombie.Build42ZombieAdapter;
import com.pulse.adapter.zombie.IZombieAdapter;

/**
 * Build 42 engine bindings implementation.
 * 
 * <p>
 * Wraps existing B42 adapters in the new bindings interface.
 * </p>
 * 
 * @since Pulse 0.9
 */
final class Build42EngineBindings implements EngineBindings {

    private final int gameBuild;
    private final Build42LuaBindings luaBindings;
    private final Build42ZombieBindings zombieBindings;

    Build42EngineBindings(int gameBuild) {
        this.gameBuild = gameBuild;
        this.luaBindings = new Build42LuaBindings();
        this.zombieBindings = new Build42ZombieBindings();
    }

    @Override
    public ILuaBindings lua() {
        return luaBindings;
    }

    @Override
    public IZombieBindings zombie() {
        return zombieBindings;
    }

    @Override
    public int getGameBuild() {
        return gameBuild;
    }

    // ═══════════════════════════════════════════════════════════════
    // Build 42 Lua Bindings
    // ═══════════════════════════════════════════════════════════════

    private static class Build42LuaBindings implements ILuaBindings {

        private final ILuaAdapter adapter = new Build42LuaAdapter();

        @Override
        public String getEventManagerClassName() {
            return adapter.getEventManagerClassName();
        }

        @Override
        public String getLuaManagerClassName() {
            return adapter.getLuaManagerClassName();
        }

        @Override
        public int getMaxTriggerEventArgs() {
            return adapter.getMaxTriggerEventArgs();
        }

        @Override
        public void onEventStart(String eventName) {
            adapter.onEventStart(eventName);
        }

        @Override
        public void onEventEnd() {
            adapter.onEventEnd();
        }

        @Override
        public boolean hasGlobalLuaAccess() {
            return adapter.hasGlobalLuaAccess();
        }

        @Override
        public Object getGlobalLuaValue(String name) {
            return adapter.getGlobalLuaValue(name);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Build 42 Zombie Bindings
    // ═══════════════════════════════════════════════════════════════

    private static class Build42ZombieBindings implements IZombieBindings {

        private final IZombieAdapter adapter = new Build42ZombieAdapter();

        @Override
        public int getZombieId(Object zombie) {
            return adapter.getZombieId(zombie);
        }

        @Override
        public int getOnlineId(Object zombie) {
            return adapter.getOnlineId(zombie);
        }

        @Override
        public int getLocalId(Object zombie) {
            return adapter.getLocalId(zombie);
        }

        @Override
        public float getX(Object zombie) {
            return adapter.getX(zombie);
        }

        @Override
        public float getY(Object zombie) {
            return adapter.getY(zombie);
        }

        @Override
        public float getZ(Object zombie) {
            return adapter.getZ(zombie);
        }

        @Override
        public float getDistanceSquaredToNearestPlayer(Object zombie) {
            return adapter.getDistanceSquaredToNearestPlayer(zombie);
        }

        @Override
        public boolean isAttacking(Object zombie) {
            return adapter.isAttacking(zombie);
        }

        @Override
        public boolean hasTarget(Object zombie) {
            return adapter.hasTarget(zombie);
        }

        @Override
        public Object getTarget(Object zombie) {
            return adapter.getTarget(zombie);
        }

        @Override
        public boolean isCrawler(Object zombie) {
            return adapter.isCrawler(zombie);
        }

        @Override
        public boolean isOnFloor(Object zombie) {
            return adapter.isOnFloor(zombie);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bindings\EngineBindings.java =====

package com.pulse.bindings;

/**
 * Unified interface for engine bindings.
 * 
 * <p>
 * Abstracts B41/B42 differences behind a stable interface.
 * This is the primary access point for all engine interactions.
 * </p>
 * 
 * <p>
 * Usage:
 * </p>
 * 
 * <pre>
 * EngineBindings bindings = EngineBindingsResolver.get();
 * bindings.lua().registerCallback(...);
 * bindings.zombie().getZombieState(...);
 * </pre>
 * 
 * @since Pulse 0.9
 */
public interface EngineBindings {

    /**
     * Get Lua adapter for the current game version.
     */
    ILuaBindings lua();

    /**
     * Get Zombie/Entity adapter for the current game version.
     */
    IZombieBindings zombie();

    /**
     * Get detected game build version.
     */
    int getGameBuild();

    /**
     * Check if running on Build 41.
     */
    default boolean isBuild41() {
        return getGameBuild() < 42;
    }

    /**
     * Check if running on Build 42 or later.
     */
    default boolean isBuild42OrLater() {
        return getGameBuild() >= 42;
    }

    /**
     * Get human-readable version string.
     */
    default String getVersionString() {
        return "Build " + getGameBuild();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bindings\EngineBindingsResolver.java =====

package com.pulse.bindings;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.version.GameVersion;

/**
 * Resolver for engine bindings.
 * 
 * <p>
 * Default implementation uses GameVersion.get().
 * Loader can replace this via setFactory() for testing or custom resolution.
 * </p>
 * 
 * <p>
 * Usage:
 * </p>
 * 
 * <pre>
 * EngineBindings bindings = EngineBindingsResolver.get();
 * </pre>
 * 
 * @since Pulse 0.9
 */
public final class EngineBindingsResolver {

    private static final String LOG = PulseLogger.PULSE;

    private static volatile EngineBindings instance;
    private static volatile EngineBindingsFactory factory = DefaultBindingsFactory.INSTANCE;

    private EngineBindingsResolver() {
        // Static utility class
    }

    /**
     * Get engine bindings for current game version.
     */
    public static EngineBindings get() {
        if (instance == null) {
            synchronized (EngineBindingsResolver.class) {
                if (instance == null) {
                    instance = factory.create();
                    PulseLogger.debug(LOG, "[Bindings] Created: {}", instance.getVersionString());
                }
            }
        }
        return instance;
    }

    /**
     * Set custom factory (for loader or testing).
     * Must be called before first get() call.
     * 
     * @param customFactory Custom factory implementation
     */
    public static void setFactory(EngineBindingsFactory customFactory) {
        if (customFactory != null) {
            factory = customFactory;
            instance = null; // Reset to use new factory
            PulseLogger.debug(LOG, "[Bindings] Custom factory set: {}", customFactory.getClass().getSimpleName());
        }
    }

    /**
     * Factory interface for creating bindings.
     */
    public interface EngineBindingsFactory {
        EngineBindings create();
    }

    /**
     * Default factory using GameVersion detection.
     */
    private enum DefaultBindingsFactory implements EngineBindingsFactory {
        INSTANCE;

        @Override
        public EngineBindings create() {
            int build = GameVersion.get();

            if (build >= GameVersion.BUILD_42) {
                return new Build42EngineBindings(build);
            }
            return new Build41EngineBindings(build);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Testing Support
    // ═══════════════════════════════════════════════════════════════

    /**
     * Reset for testing.
     */
    static void reset() {
        instance = null;
        factory = DefaultBindingsFactory.INSTANCE;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bindings\ILuaBindings.java =====

package com.pulse.bindings;

/**
 * Lua operations binding interface.
 * 
 * <p>
 * Abstracts Lua-related operations that may differ between B41/B42.
 * </p>
 * 
 * @since Pulse 0.9
 */
public interface ILuaBindings {

    // ═══════════════════════════════════════════════════════════════
    // Class Information
    // ═══════════════════════════════════════════════════════════════

    /**
     * Get LuaEventManager class name.
     */
    String getEventManagerClassName();

    /**
     * Get LuaManager class name.
     */
    String getLuaManagerClassName();

    // ═══════════════════════════════════════════════════════════════
    // Event System
    // ═══════════════════════════════════════════════════════════════

    /**
     * Get max triggerEvent argument count.
     */
    int getMaxTriggerEventArgs();

    /**
     * Signal event start for profiling.
     */
    void onEventStart(String eventName);

    /**
     * Signal event end for profiling.
     */
    void onEventEnd();

    // ═══════════════════════════════════════════════════════════════
    // Lua State Access
    // ═══════════════════════════════════════════════════════════════

    /**
     * Check if global Lua access is available.
     */
    boolean hasGlobalLuaAccess();

    /**
     * Get a global Lua variable value.
     * 
     * @param name Variable name
     * @return Value, or null if not found
     */
    Object getGlobalLuaValue(String name);
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bindings\IZombieBindings.java =====

package com.pulse.bindings;

/**
 * Zombie/Entity operations binding interface.
 * 
 * <p>
 * Abstracts zombie-related operations that may differ between B41/B42.
 * </p>
 * 
 * @since Pulse 0.9
 */
public interface IZombieBindings {

    // ═══════════════════════════════════════════════════════════════
    // ID Methods
    // ═══════════════════════════════════════════════════════════════

    /**
     * Get zombie unique ID.
     * 
     * @param zombie IsoZombie instance
     * @return Zombie ID
     */
    int getZombieId(Object zombie);

    /**
     * Get zombie online ID (MP).
     * 
     * @param zombie IsoZombie instance
     * @return Online ID, -1 if not available
     */
    int getOnlineId(Object zombie);

    /**
     * Get zombie local ID.
     * 
     * @param zombie IsoZombie instance
     * @return Local ID
     */
    int getLocalId(Object zombie);

    // ═══════════════════════════════════════════════════════════════
    // Position Methods
    // ═══════════════════════════════════════════════════════════════

    /**
     * Get zombie X position.
     */
    float getX(Object zombie);

    /**
     * Get zombie Y position.
     */
    float getY(Object zombie);

    /**
     * Get zombie Z position.
     */
    float getZ(Object zombie);

    /**
     * Get squared distance to nearest player.
     * 
     * @param zombie IsoZombie instance
     * @return Squared distance (MAX_VALUE if no player)
     */
    float getDistanceSquaredToNearestPlayer(Object zombie);

    // ═══════════════════════════════════════════════════════════════
    // State Methods
    // ═══════════════════════════════════════════════════════════════

    /**
     * Check if zombie is attacking.
     */
    boolean isAttacking(Object zombie);

    /**
     * Check if zombie has a target.
     */
    boolean hasTarget(Object zombie);

    /**
     * Get zombie's current target.
     * 
     * @return Target object (IsoMovingObject), null if none
     */
    Object getTarget(Object zombie);

    /**
     * Check if zombie is a crawler.
     */
    boolean isCrawler(Object zombie);

    /**
     * Check if zombie is on the floor.
     */
    boolean isOnFloor(Object zombie);
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bootstrap\BootstrapLoader.java =====

package com.pulse.bootstrap;

import com.pulse.api.log.PulseLogger;
import org.spongepowered.asm.launch.MixinBootstrap;
import org.spongepowered.asm.mixin.MixinEnvironment;

import java.lang.reflect.Field;

/**
 * Step 2: Bootstrap Mixin subsystem.
 */
public class BootstrapLoader {
    private static final String LOG = PulseLogger.PULSE;

    public void initialize(InitializationContext context) {
        PulseLogger.info(LOG, "Step 2: Bootstrapping Mixin subsystem...");

        MixinBootstrap.init();

        checkEnvironment();
        inspectPhase();

        PulseLogger.info(LOG, "Step 2: Complete");

        checkMixinInternalState();
    }

    private void checkEnvironment() {
        MixinEnvironment env = MixinEnvironment.getDefaultEnvironment();
        PulseLogger.info(LOG, "  - Default Environment: {}", env);
        PulseLogger.info(LOG, "  - Side: {}", env.getSide());
        PulseLogger.info(LOG, "  - Phase (after init): {}", env.getPhase());
    }

    private void inspectPhase() {
        try {
            MixinEnvironment env = MixinEnvironment.getDefaultEnvironment();
            var currentPhase = env.getPhase();
            PulseLogger.debug(LOG, "  - Current phase: {}", currentPhase);
            PulseLogger.debug(LOG, "  - Attempting to check/set phase for config registration...");

            Field phaseField = MixinEnvironment.class.getDeclaredField("currentPhase");
            phaseField.setAccessible(true);
            PulseLogger.debug(LOG, "  - Internal currentPhase: {}", phaseField.get(null));
        } catch (Exception e) {
            PulseLogger.debug(LOG, "  - Could not inspect phase field: {}", e.getMessage());
        }
    }

    private void checkMixinInternalState() {
        PulseLogger.info(LOG, "Step 2.5: Checking Mixin internal state...");
        try {
            var mixinEnv = MixinEnvironment.getDefaultEnvironment();
            PulseLogger.debug(LOG, "  - Environment: {}", mixinEnv);
            PulseLogger.debug(LOG, "  - Phase: {}", mixinEnv.getPhase());
            PulseLogger.debug(LOG, "  - Side: {}", mixinEnv.getSide());

            var service = org.spongepowered.asm.service.MixinService.getService();
            PulseLogger.info(LOG, "  - Active Service: {}", service.getName());
            PulseLogger.debug(LOG, "  - Service Class: {}", service.getClass().getName());

            var testStream = service.getResourceAsStream("mixins.pulse.json");
            PulseLogger.info(LOG, "  - Service.getResourceAsStream(): {}",
                    (testStream != null ? "OK" : "FAILED"));
            if (testStream != null) {
                byte[] bytes = testStream.readAllBytes();
                PulseLogger.debug(LOG, "  - Config file size: {} bytes", bytes.length);
                PulseLogger.trace(LOG, () -> "  - Config content preview: " +
                        new String(bytes, 0, Math.min(200, bytes.length)));
                testStream.close();
            }
        } catch (Throwable t) {
            PulseLogger.error(LOG, "  - Error checking state: {}", t.getMessage());
            t.printStackTrace();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bootstrap\ConfigRegistrar.java =====

package com.pulse.bootstrap;

import com.pulse.api.log.PulseLogger;
import org.spongepowered.asm.mixin.MixinEnvironment;
import org.spongepowered.asm.mixin.Mixins;

import java.io.InputStream;
import java.lang.reflect.Method;

/**
 * Step 3: Register Mixin configurations.
 */
public class ConfigRegistrar {
    private static final String LOG = PulseLogger.PULSE;
    private static final String CONFIG_FILE = "mixins.pulse.json";

    public void initialize(InitializationContext context) {
        PulseLogger.info(LOG, "Step 3: Registering Mixin configurations...");

        checkConfigFile();
        registerConfig();
        verifyRegistration();

        PulseLogger.info(LOG, "Step 3: Complete");
    }

    private void checkConfigFile() {
        try {
            InputStream configStream = getClass().getClassLoader().getResourceAsStream(CONFIG_FILE);
            if (configStream != null) {
                PulseLogger.info(LOG, "  - Found: {}", CONFIG_FILE);
                configStream.close();
            } else {
                PulseLogger.warn(LOG, "  - WARNING: {} not found in classpath!", CONFIG_FILE);
            }
        } catch (Exception e) {
            PulseLogger.error(LOG, "  - Error checking config file: {}", e.getMessage());
        }
    }

    private void registerConfig() {
        try {
            PulseLogger.debug(LOG, "  - Calling Mixins.addConfiguration()...");

            int beforeCount = Mixins.getConfigs().size();
            PulseLogger.debug(LOG, "  - Configs before: {}", beforeCount);

            Mixins.addConfiguration(CONFIG_FILE);

            int afterCount = Mixins.getConfigs().size();
            PulseLogger.debug(LOG, "  - Configs after: {}", afterCount);

            if (afterCount == beforeCount) {
                PulseLogger.warn(LOG, "  - WARNING: Config was not added! Trying alternative method...");
                registerViaInternalApi();
            }

            PulseLogger.debug(LOG, "  - addConfiguration() completed");
        } catch (Throwable t) {
            PulseLogger.error(LOG, "  - ERROR in addConfiguration(): {}", t.getClass().getName());
            PulseLogger.error(LOG, "  - Message: {}", t.getMessage());
            t.printStackTrace();
        }
    }

    private void registerViaInternalApi() {
        try {
            Class<?> mixinConfigClass = Class.forName("org.spongepowered.asm.mixin.transformer.MixinConfig");
            Method createMethod = mixinConfigClass.getDeclaredMethod("create", String.class, MixinEnvironment.class);
            createMethod.setAccessible(true);

            Object config = createMethod.invoke(null, CONFIG_FILE, MixinEnvironment.getDefaultEnvironment());
            PulseLogger.debug(LOG, "  - Direct MixinConfig.create() result: {}", config);

            if (config != null) {
                PulseLogger.info(LOG, "  - Config created successfully: {}", config);
            }
        } catch (Exception ex) {
            PulseLogger.error(LOG, "  - Alternative method failed: {}", ex.getMessage());
            ex.printStackTrace();
        }
    }

    private void verifyRegistration() {
        try {
            PulseLogger.debug(LOG, "  - Calling Mixins.getConfigs()...");
            var configs = Mixins.getConfigs();
            PulseLogger.info(LOG, "  - Registered configs: {}", (configs != null ? configs.size() : "null"));

            if (configs != null) {
                for (var config : configs) {
                    PulseLogger.debug(LOG, "  - Config: {}", config);
                }
            }
        } catch (Throwable t) {
            PulseLogger.error(LOG, "  - ERROR in getConfigs(): {}", t.getClass().getName());
            PulseLogger.error(LOG, "  - Message: {}", t.getMessage());
            t.printStackTrace();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bootstrap\DebugMonitorFactory.java =====

package com.pulse.bootstrap;

import com.pulse.PulseEnvironment;
import com.pulse.api.log.PulseLogger;
import com.pulse.mod.ModLoader;
import com.pulse.transformer.PulseClassTransformer;

import java.util.Set;

/**
 * Creates and starts the debug monitor thread.
 */
public class DebugMonitorFactory {
    private static final String LOG = PulseLogger.PULSE;

    public void startMonitor(PulseClassTransformer classTransformer) {
        new Thread(() -> runMonitor(classTransformer), "Pulse-Debug-Monitor").start();
    }

    private void runMonitor(PulseClassTransformer classTransformer) {
        PulseLogger.debug(LOG, "Monitor thread started");

        int waitCount = 0;
        // Wait up to 30 seconds for Game ClassLoader
        while (PulseEnvironment.getGameClassLoader() == null && waitCount < 300) {
            try {
                Thread.sleep(100);
                waitCount++;
            } catch (InterruptedException e) {
                break;
            }
        }

        if (PulseEnvironment.getGameClassLoader() != null) {
            PulseLogger.info(LOG, "Game ClassLoader detected after {}ms", (waitCount * 100));
            PulseLogger.debug(LOG, "ClassLoader: {}", PulseEnvironment.getGameClassLoader());

            try {
                PulseLogger.debug(LOG, "Initializing mods...");
                ModLoader.getInstance().initializeMods();
            } catch (Throwable t) {
                PulseLogger.error(LOG, "Mod initialization error: {}", t.getMessage());
                t.printStackTrace();
            }
        } else {
            PulseLogger.warn(LOG, "WARNING: Game ClassLoader not detected after 30s");
        }

        if (classTransformer != null) {
            try {
                Thread.sleep(5000);
                Set<String> transformed = classTransformer.getTransformedClasses();
                PulseLogger.debug(LOG, "Transformed classes: {}", transformed.size());
                for (String cls : transformed) {
                    PulseLogger.trace(LOG, "  - {}", cls);
                }
            } catch (InterruptedException e) {
                // ignore
            }
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bootstrap\InitializationContext.java =====

package com.pulse.bootstrap;

import java.lang.instrument.Instrumentation;

/**
 * Pulse initialization context.
 * Holds references required during the initialization process.
 */
public class InitializationContext {
    private final Instrumentation instrumentation;

    public InitializationContext(Instrumentation instrumentation) {
        this.instrumentation = instrumentation;
    }

    public Instrumentation getInstrumentation() {
        return instrumentation;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bootstrap\ModInitializer.java =====

package com.pulse.bootstrap;

import com.pulse.api.log.PulseLogger;
import com.pulse.mod.ModLoader;

/**
 * Step 7: Initialize mod loader (discovery & mixins).
 */
public class ModInitializer {
    private static final String LOG = PulseLogger.PULSE;
    private final ModLoader modLoader;

    public ModInitializer() {
        this(ModLoader.getInstance());
    }

    public ModInitializer(ModLoader modLoader) {
        this.modLoader = modLoader;
    }

    public void initialize(InitializationContext context) {
        PulseLogger.info(LOG, "Step 7: Initializing mod loader...");

        try {
            modLoader.discoverMods();
            modLoader.resolveDependencies();
            modLoader.registerMixins();

            PulseLogger.info(LOG, "Step 7: Complete");
        } catch (Throwable t) {
            PulseLogger.error(LOG, "Step 7: Mod loader error (non-fatal)");
            t.printStackTrace();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bootstrap\OptimizationInitializer.java =====

package com.pulse.bootstrap;

import com.pulse.api.log.PulseLogger;

/**
 * Step 6.5: Initialize optimization extensions.
 */
public class OptimizationInitializer {
    private static final String LOG = PulseLogger.PULSE;

    public void initialize(InitializationContext context) {
        PulseLogger.info(LOG, "Step 6.5: Initializing optimization extensions...");
        try {
            com.pulse.api.CapabilityFlags.initialize();
            com.pulse.api.optimization.OptimizationPointRegistry.initialize();
            com.pulse.api.SafeGameAccess.setMainThread(Thread.currentThread());

            PulseLogger.info(LOG, "Step 6.5: Complete");
        } catch (Throwable t) {
            PulseLogger.error(LOG, "Step 6.5: Optimization extensions init error (non-fatal)");
            t.printStackTrace();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bootstrap\PulseBootstrap.java =====

package com.pulse.bootstrap;

import com.pulse.di.PulseServiceLocator;
import com.pulse.scheduler.PulseScheduler;
import com.pulse.scheduler.SchedulerConfig;
import com.pulse.scheduler.PulseThreadFactory;

/**
 * Assembly class for Pulse.
 * Responsible for wiring up dependencies and registering them with the
 * ServiceLocator.
 */
public class PulseBootstrap {

    public static void initialize() {
        // 1. Core Infrastructure
        setupScheduler();

        // 2. Services (Placeholder for future services like ModLoader, ConfigManager
        // refactoring)
        // ModLoader is currently a singleton, but future refactoring will instantiate
        // it here.

        // 3. Register to ServiceLocator
        PulseServiceLocator.getInstance().registerService(PulseScheduler.class, PulseScheduler.getInstance());
    }

    private static void setupScheduler() {
        SchedulerConfig config = new SchedulerConfig()
                .setTickBatchSize(100)
                .setExceptionPolicy(SchedulerConfig.ExceptionPolicy.LOG_AND_CONTINUE)
                .setThreadFactory(new PulseThreadFactory("Pulse-Async"));

        PulseScheduler.getInstance().setConfig(config);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bootstrap\SystemPropertyInitializer.java =====

package com.pulse.bootstrap;

import com.pulse.api.log.PulseLogger;

/**
 * Step 1: Initialize system properties.
 */
public class SystemPropertyInitializer {
    private static final String LOG = PulseLogger.PULSE;

    public void initialize(InitializationContext context) {
        PulseLogger.info(LOG, "Step 1: Configuring system properties...");

        // Enable Mixin debugging
        System.setProperty("mixin.debug", "true");
        System.setProperty("mixin.debug.verbose", "true");
        System.setProperty("mixin.debug.export", "true");
        System.setProperty("mixin.debug.export.decompile", "false");
        System.setProperty("mixin.dumpTargetOnFailure", "true");
        System.setProperty("mixin.checks", "true");
        System.setProperty("mixin.hotSwap", "true");

        PulseLogger.info(LOG, "Step 1: Complete");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\bootstrap\TransformerRegistrar.java =====

package com.pulse.bootstrap;

import com.pulse.PulseEnvironment;
import com.pulse.api.log.PulseLogger;
import com.pulse.transformer.PulseClassTransformer;
import org.spongepowered.asm.mixin.transformer.IMixinTransformer;

import java.lang.instrument.Instrumentation;

/**
 * Step 4 & 5: Obtain Mixin Transformer and register PulseClassTransformer.
 */
public class TransformerRegistrar {
    private static final String LOG = PulseLogger.PULSE;

    public PulseClassTransformer initialize(InitializationContext context) {
        PulseLogger.info(LOG, "Step 4: Waiting for Mixin transformer...");

        IMixinTransformer mixinTransformer = waitForMixinTransformer();

        if (mixinTransformer != null) {
            PulseLogger.info(LOG, "  - Mixin Transformer acquired: {}",
                    mixinTransformer.getClass().getName());
        } else {
            PulseLogger.warn(LOG, "  - WARNING: Mixin Transformer not available!");
            PulseLogger.warn(LOG, "  - Mixins may not be applied correctly.");
        }

        PulseLogger.info(LOG, "Step 4: Complete");

        return registerClassTransformer(context.getInstrumentation(), mixinTransformer);
    }

    private IMixinTransformer waitForMixinTransformer() {
        IMixinTransformer mixinTransformer = null;
        for (int i = 0; i < 10; i++) {
            mixinTransformer = PulseEnvironment.getMixinTransformer();
            if (mixinTransformer != null) {
                break;
            }
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                break;
            }
        }
        return mixinTransformer;
    }

    private PulseClassTransformer registerClassTransformer(Instrumentation inst, IMixinTransformer mixinTransformer) {
        PulseLogger.info(LOG, "Step 5: Registering class transformer...");

        PulseClassTransformer classTransformer = new PulseClassTransformer();

        if (mixinTransformer != null) {
            classTransformer.connectMixinTransformer(mixinTransformer);
        }

        inst.addTransformer(classTransformer, true);

        PulseLogger.info(LOG, "  - Transformer registered with Instrumentation");
        PulseLogger.info(LOG, "Step 5: Complete");

        return classTransformer;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\command\Arg.java =====

package com.pulse.command;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 명령어 인자 어노테이션.
 * 메서드 파라미터에 적용.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.PARAMETER)
public @interface Arg {
    /**
     * 인자 이름
     */
    String value();

    /**
     * 선택적 인자 여부
     */
    boolean optional() default false;

    /**
     * 기본값 (선택적 인자용)
     */
    String defaultValue() default "";
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\command\Command.java =====

package com.pulse.command;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 명령어 메서드 마커 어노테이션.
 * 
 * 사용 예:
 * 
 * <pre>
 * public class MyCommands {
 *     {@literal @}Command(name = "heal", description = "Heal the player")
 *     public void healCommand(CommandContext ctx) {
 *         ctx.getSender().sendMessage("Healed!");
 *     }
 *     
 *     {@literal @}Command(name = "spawn", aliases = {"sp"}, permission = "mymod.spawn")
 *     public void spawnCommand(CommandContext ctx, @Arg("entity") String entity) {
 *         // ...
 *     }
 * }
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Command {
    /**
     * 명령어 이름 (필수)
     */
    String name();

    /**
     * 명령어 설명
     */
    String description() default "";

    /**
     * 사용법 (자동 생성if 비어있음)
     */
    String usage() default "";

    /**
     * 별칭
     */
    String[] aliases() default {};

    /**
     * 필요 권한
     */
    String permission() default "";

    /**
     * 플레이어만 사용 가능
     */
    boolean playerOnly() default false;

    /**
     * 콘솔만 사용 가능
     */
    boolean consoleOnly() default false;
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\command\CommandContext.java =====

package com.pulse.command;

import java.util.*;

/**
 * 명령어 실행 컨텍스트.
 * 명령어 핸들러에 전달되는 정보.
 */
public class CommandContext {

    private final CommandSender sender;
    private final String commandName;
    private final String[] rawArgs;
    private int argIndex = 0;

    public CommandContext(CommandSender sender, String commandName, String[] args) {
        this.sender = sender;
        this.commandName = commandName;
        this.rawArgs = args != null ? args : new String[0];
    }

    // ─────────────────────────────────────────────────────────────
    // 기본 정보
    // ─────────────────────────────────────────────────────────────

    public CommandSender getSender() {
        return sender;
    }

    public String getCommandName() {
        return commandName;
    }

    public String[] getRawArgs() {
        return rawArgs;
    }

    public int getArgCount() {
        return rawArgs.length;
    }

    // ─────────────────────────────────────────────────────────────
    // 인자 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * 인자가 있는지 확인
     */
    public boolean hasArg(int index) {
        return index >= 0 && index < rawArgs.length;
    }

    /**
     * 인덱스로 인자 가져오기
     */
    public String getArg(int index) {
        if (index < 0 || index >= rawArgs.length) {
            return null;
        }
        return rawArgs[index];
    }

    /**
     * 인덱스로 인자 가져오기 (기본값)
     */
    public String getArg(int index, String defaultValue) {
        String arg = getArg(index);
        return arg != null ? arg : defaultValue;
    }

    /**
     * 다음 인자 가져오기
     */
    public String nextArg() {
        if (argIndex >= rawArgs.length) {
            return null;
        }
        return rawArgs[argIndex++];
    }

    /**
     * 다음 인자 가져오기 (기본값)
     */
    public String nextArg(String defaultValue) {
        String arg = nextArg();
        return arg != null ? arg : defaultValue;
    }

    /**
     * 나머지 인자 모두 합치기
     */
    public String getRemainingArgs() {
        if (argIndex >= rawArgs.length) {
            return "";
        }
        return String.join(" ", Arrays.copyOfRange(rawArgs, argIndex, rawArgs.length));
    }

    /**
     * 인덱스 이후 모든 인자 합치기
     */
    public String getArgsFrom(int index) {
        if (index >= rawArgs.length) {
            return "";
        }
        return String.join(" ", Arrays.copyOfRange(rawArgs, index, rawArgs.length));
    }

    // ─────────────────────────────────────────────────────────────
    // 타입 변환
    // ─────────────────────────────────────────────────────────────

    public Integer getInt(int index) {
        String arg = getArg(index);
        if (arg == null)
            return null;
        try {
            return Integer.parseInt(arg);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public int getInt(int index, int defaultValue) {
        Integer val = getInt(index);
        return val != null ? val : defaultValue;
    }

    public Double getDouble(int index) {
        String arg = getArg(index);
        if (arg == null)
            return null;
        try {
            return Double.parseDouble(arg);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public double getDouble(int index, double defaultValue) {
        Double val = getDouble(index);
        return val != null ? val : defaultValue;
    }

    public Boolean getBoolean(int index) {
        String arg = getArg(index);
        if (arg == null)
            return null;
        return "true".equalsIgnoreCase(arg) || "yes".equalsIgnoreCase(arg) || "1".equals(arg);
    }

    public boolean getBoolean(int index, boolean defaultValue) {
        Boolean val = getBoolean(index);
        return val != null ? val : defaultValue;
    }

    // ─────────────────────────────────────────────────────────────
    // 응답 헬퍼
    // ─────────────────────────────────────────────────────────────

    public void reply(String message) {
        sender.sendMessage(message);
    }

    public void replyError(String message) {
        sender.sendError(message);
    }

    public void replyFormat(String format, Object... args) {
        sender.sendMessage(String.format(format, args));
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\command\CommandRegistry.java =====

package com.pulse.command;

import com.pulse.api.log.PulseLogger;

import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 명령어 레지스트리.
 * 모든 명령어를 등록하고 실행을 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 어노테이션 기반 등록
 * CommandRegistry.register(new MyCommands());
 * 
 * // 람다 기반 등록
 * CommandRegistry.register("hello", ctx -> {
 *     ctx.reply("Hello, " + ctx.getSender().getName() + "!");
 * });
 * 
 * // 명령어 실행 (채팅 훅에서 호출)
 * CommandRegistry.execute(sender, "/hello world");
 * </pre>
 */
public class CommandRegistry {

    private static final CommandRegistry INSTANCE = new CommandRegistry();
    private static final String LOG = PulseLogger.PULSE;

    // 등록된 명령어
    private final Map<String, RegisteredCommand> commands = new ConcurrentHashMap<>();

    // 명령어 접두사
    private String prefix = "/";

    private CommandRegistry() {
    }

    public static CommandRegistry getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 편의 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 어노테이션 기반 명령어 클래스 등록
     */
    public static void register(Object commandHandler) {
        INSTANCE.registerHandler(commandHandler);
    }

    /**
     * 람다 기반 명령어 등록
     */
    public static void register(String name, CommandExecutor executor) {
        INSTANCE.registerCommand(name, executor);
    }

    /**
     * 람다 기반 명령어 등록 (설명 포함)
     */
    public static void register(String name, String description, CommandExecutor executor) {
        INSTANCE.registerCommand(name, description, executor);
    }

    /**
     * 명령어 실행
     * 
     * @return true if command was found and executed
     */
    public static boolean execute(CommandSender sender, String input) {
        return INSTANCE.executeCommand(sender, input);
    }

    /**
     * 모든 명령어 가져오기
     */
    public static Collection<RegisteredCommand> getAll() {
        return INSTANCE.getAllCommands();
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 어노테이션 기반 핸들러 등록
     */
    public void registerHandler(Object handler) {
        Class<?> clazz = handler.getClass();

        for (Method method : clazz.getDeclaredMethods()) {
            Command annotation = method.getAnnotation(Command.class);
            if (annotation == null)
                continue;

            method.setAccessible(true);

            RegisteredCommand cmd = new RegisteredCommand(
                    annotation.name(),
                    annotation.description(),
                    annotation.usage(),
                    annotation.aliases(),
                    annotation.permission(),
                    annotation.playerOnly(),
                    annotation.consoleOnly(),
                    handler,
                    method);

            registerInternal(cmd);
        }
    }

    /**
     * 람다 기반 등록
     */
    public void registerCommand(String name, CommandExecutor executor) {
        registerCommand(name, "", executor);
    }

    public void registerCommand(String name, String description, CommandExecutor executor) {
        RegisteredCommand cmd = new RegisteredCommand(
                name, description, "", new String[0], "", false, false, executor, null);
        registerInternal(cmd);
    }

    private void registerInternal(RegisteredCommand cmd) {
        commands.put(cmd.getName().toLowerCase(), cmd);

        // 별칭 등록
        for (String alias : cmd.getAliases()) {
            commands.put(alias.toLowerCase(), cmd);
        }

        PulseLogger.info(LOG, "[CMD] Registered command: /{}", cmd.getName());
    }

    /**
     * 명령어 실행
     */
    public boolean executeCommand(CommandSender sender, String input) {
        // 접두사 확인
        if (!input.startsWith(prefix)) {
            return false;
        }

        // 파싱
        String withoutPrefix = input.substring(prefix.length()).trim();
        if (withoutPrefix.isEmpty()) {
            return false;
        }

        String[] parts = withoutPrefix.split("\\s+", 2);
        String cmdName = parts[0].toLowerCase();
        String[] args = parts.length > 1 ? parts[1].split("\\s+") : new String[0];

        // 명령어 찾기
        RegisteredCommand cmd = commands.get(cmdName);
        if (cmd == null) {
            return false;
        }

        // 권한 확인
        if (!cmd.getPermission().isEmpty() && !sender.hasPermission(cmd.getPermission())) {
            sender.sendError("You don't have permission to use this command.");
            return true;
        }

        // 플레이어 전용 확인
        if (cmd.isPlayerOnly() && !sender.isPlayer()) {
            sender.sendError("This command can only be used by players.");
            return true;
        }

        // 콘솔 전용 확인
        if (cmd.isConsoleOnly() && !sender.isConsole()) {
            sender.sendError("This command can only be used from console.");
            return true;
        }

        // 실행
        try {
            CommandContext ctx = new CommandContext(sender, cmdName, args);
            cmd.execute(ctx);
        } catch (Exception e) {
            sender.sendError("Error executing command: " + e.getMessage());
            PulseLogger.error(LOG, "Error executing command", e);
        }

        return true;
    }

    public RegisteredCommand getCommand(String name) {
        return commands.get(name.toLowerCase());
    }

    public Collection<RegisteredCommand> getAllCommands() {
        // 중복 제거 (별칭으로 인해)
        return new HashSet<>(commands.values());
    }

    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }

    public String getPrefix() {
        return prefix;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface CommandExecutor {
        void execute(CommandContext ctx);
    }

    public static class RegisteredCommand {
        private final String name;
        private final String description;
        private final String usage;
        private final String[] aliases;
        private final String permission;
        private final boolean playerOnly;
        private final boolean consoleOnly;
        private final Object handler; // 어노테이션 기반
        private final Method method; // 어노테이션 기반
        private final CommandExecutor executor; // 람다 기반

        public RegisteredCommand(String name, String description, String usage,
                String[] aliases, String permission,
                boolean playerOnly, boolean consoleOnly,
                Object handler, Method method) {
            this.name = name;
            this.description = description;
            this.usage = usage;
            this.aliases = aliases;
            this.permission = permission;
            this.playerOnly = playerOnly;
            this.consoleOnly = consoleOnly;

            if (handler instanceof CommandExecutor exec) {
                this.handler = null;
                this.method = null;
                this.executor = exec;
            } else {
                this.handler = handler;
                this.method = method;
                this.executor = null;
            }
        }

        public void execute(CommandContext ctx) throws Exception {
            if (executor != null) {
                executor.execute(ctx);
            } else if (method != null && handler != null) {
                method.invoke(handler, ctx);
            }
        }

        // Getters
        public String getName() {
            return name;
        }

        public String getDescription() {
            return description;
        }

        public String getUsage() {
            return usage.isEmpty() ? "/" + name : usage;
        }

        public String[] getAliases() {
            return aliases;
        }

        public String getPermission() {
            return permission;
        }

        public boolean isPlayerOnly() {
            return playerOnly;
        }

        public boolean isConsoleOnly() {
            return consoleOnly;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\command\CommandSender.java =====

package com.pulse.command;

/**
 * 명령 발신자 인터페이스.
 * 플레이어, 콘솔, 또는 기타 소스.
 */
import com.pulse.api.log.PulseLogger;

public interface CommandSender {
    String LOG = PulseLogger.PULSE;

    /**
     * 발신자 이름
     */
    String getName();

    /**
     * 메시지 전송
     */
    void sendMessage(String message);

    /**
     * 오류 메시지 전송
     */
    void sendError(String message);

    /**
     * 플레이어인지 확인
     */
    boolean isPlayer();

    /**
     * 서버/콘솔인지 확인
     */
    boolean isConsole();

    /**
     * 권한 확인
     */
    boolean hasPermission(String permission);

    /**
     * 플레이어 객체 (플레이어인 경우)
     */
    Object getPlayer();

    // ─────────────────────────────────────────────────────────────
    // 구현체
    // ─────────────────────────────────────────────────────────────

    /**
     * 콘솔 발신자
     */
    CommandSender CONSOLE = new CommandSender() {
        @Override
        public String getName() {
            return "Console";
        }

        @Override
        public void sendMessage(String message) {
            PulseLogger.info(LOG, "[CMD] {}", message);
        }

        @Override
        public void sendError(String message) {
            PulseLogger.error(LOG, "[CMD] ERROR: {}", message);
        }

        @Override
        public boolean isPlayer() {
            return false;
        }

        @Override
        public boolean isConsole() {
            return true;
        }

        @Override
        public boolean hasPermission(String permission) {
            return true;
        }

        @Override
        public Object getPlayer() {
            return null;
        }
    };
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\command\PulseCommands.java =====

package com.pulse.command;

import com.pulse.api.PulseServices;
import com.pulse.api.log.PulseLogger;

import com.pulse.diagnostics.HotspotMap;
import com.pulse.diagnostics.PulseThreadGuard;
import com.pulse.diagnostics.PulseTickContext;
import com.pulse.hook.PulseHookRegistry;
import com.pulse.mixin.PulseErrorHandler;
import com.pulse.mixin.SafeMixinWrapper;
import com.pulse.runtime.PulseRuntime;
import com.pulse.PulseInfo;

import java.util.List;

/**
 * Pulse 콘솔 명령어 모음.
 * 
 * 로드맵의 "Pulse Console Commands" 요구사항을 충족합니다.
 * 
 * @since Pulse 1.2
 */
public final class PulseCommands {
    private static final String LOG = PulseLogger.PULSE;

    private PulseCommands() {
    }

    /**
     * 모든 /pulse 명령어 등록
     */
    public static void registerAll() {
        CommandRegistry.register("pulse", "Pulse 메인 명령어", PulseCommands::handlePulse);
        PulseLogger.info(LOG, "Registered /pulse commands");
    }

    /**
     * /pulse 명령어 핸들러
     */
    private static void handlePulse(CommandContext ctx) {
        String[] args = ctx.getRawArgs();

        if (args.length == 0) {
            showHelp(ctx);
            return;
        }

        String subCommand = args[0].toLowerCase();
        switch (subCommand) {
            case "status" -> showStatus(ctx);
            case "debug" -> handleDebug(ctx, args);
            case "mixins" -> showMixins(ctx);
            case "events" -> showEvents(ctx);
            case "errors" -> showErrors(ctx);
            case "hotspots" -> showHotspots(ctx);
            case "version" -> showVersion(ctx);
            case "help" -> showHelp(ctx);
            default -> ctx.reply("Unknown subcommand: " + subCommand + ". Use /pulse help");
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 서브 명령어 구현
    // ─────────────────────────────────────────────────────────────

    private static void showHelp(CommandContext ctx) {
        ctx.reply("§a=== Pulse Commands ===");
        ctx.reply("§e/pulse status§r - Pulse 상태 출력");
        ctx.reply("§e/pulse debug on/off§r - 디버그 모드 토글");
        ctx.reply("§e/pulse mixins§r - 로드된 Mixin 정보");
        ctx.reply("§e/pulse events§r - 등록된 이벤트 리스너");
        ctx.reply("§e/pulse errors§r - Mixin 오류 목록");
        ctx.reply("§e/pulse hotspots§r - 핫스팟 함수 목록");
        ctx.reply("§e/pulse version§r - 게임/Pulse 버전");
    }

    private static void showStatus(CommandContext ctx) {
        ctx.reply("§a=== Pulse Status ===");
        ctx.reply("§7Version:§r " + getPulseVersion());
        ctx.reply("§7Game:§r " + PulseRuntime.getVersionString());
        ctx.reply("§7Hook Types:§r " + PulseHookRegistry.getRegisteredTypeCount());
        ctx.reply("§7Mixin Errors:§r " + PulseErrorHandler.getTotalErrorCount());
        ctx.reply("§7Thread:§r " + PulseThreadGuard.getStatus());
        ctx.reply("§7Tick Context:§r " + PulseTickContext.get().getSnapshot());
    }

    private static void handleDebug(CommandContext ctx, String[] args) {
        if (args.length < 2) {
            ctx.reply("Usage: /pulse debug on/off");
            return;
        }

        boolean enable = args[1].equalsIgnoreCase("on");

        // 디버그 모드 설정
        PulseHookRegistry.setDebugEnabled(enable);
        SafeMixinWrapper.setDebugMode(enable);
        PulseServices.eventBus().setDebug(enable);
        HotspotMap.setEnabled(enable);

        ctx.reply("§aDebug mode: " + (enable ? "§aENABLED" : "§cDISABLED"));
    }

    private static void showMixins(CommandContext ctx) {
        ctx.reply("§a=== Loaded Mixins ===");
        ctx.reply("§7Running Mixins:§r");
        ctx.reply("  - IsoWorldMixin (GameTick, LOS)");
        ctx.reply("  - IsoZombieMixin (ZombieUpdate)");
        ctx.reply("  - IsoPlayerMixin (PlayerUpdate)");
        ctx.reply("  - PathfindingMixin (Pathfinding)");
        ctx.reply("  - IsoGridMixin (IsoGrid)");
        ctx.reply("  - GameWindowMixin (Render)");

        if (PulseErrorHandler.getTotalErrorCount() > 0) {
            ctx.reply("§cMixins with errors:§r " + PulseErrorHandler.getErrorCounts().size());
        }
    }

    private static void showEvents(CommandContext ctx) {
        ctx.reply("§a=== Event Listeners ===");
        ctx.reply(PulseHookRegistry.getStatusSummary());
    }

    private static void showErrors(CommandContext ctx) {
        ctx.reply("§a=== Mixin Errors ===");
        int total = PulseErrorHandler.getTotalErrorCount();
        if (total == 0) {
            ctx.reply("§aNo errors recorded.");
            return;
        }

        ctx.reply("§cTotal errors: " + total);
        PulseErrorHandler.getErrorCounts().forEach((mixin, count) -> ctx.reply("  §7" + mixin + ":§r " + count));

        List<PulseErrorHandler.MixinError> recent = PulseErrorHandler.getRecentErrors();
        if (!recent.isEmpty()) {
            ctx.reply("§7Recent:§r");
            recent.stream().limit(5).forEach(e -> ctx.reply("  " + e));
        }
    }

    private static void showHotspots(CommandContext ctx) {
        ctx.reply("§a=== Top Hotspots ===");
        List<HotspotMap.HotspotEntry> top = HotspotMap.getTopHotspots(10);

        if (top.isEmpty()) {
            ctx.reply("§7No hotspots recorded yet.");
            return;
        }

        for (int i = 0; i < top.size(); i++) {
            HotspotMap.HotspotEntry e = top.get(i);
            ctx.reply(String.format("§7%d.§r %s §8(%.2fms total, %.3fms avg, %d calls)",
                    i + 1, e.getFunction(), e.getTotalMs(), e.getAverageMs(), e.getCount()));
        }
    }

    private static void showVersion(CommandContext ctx) {
        ctx.reply("§a=== Version Info ===");
        ctx.reply("§7Pulse:§r " + getPulseVersion());
        ctx.reply("§7Game Version:§r " + PulseRuntime.getVersionString());
        ctx.reply("§7Detected:§r " + PulseRuntime.getVersion().getDisplayName());
        ctx.reply("§7Java:§r " + System.getProperty("java.version"));
    }

    private static String getPulseVersion() {
        return PulseInfo.getVersion();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\config\Config.java =====

package com.pulse.config;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 설정 클래스 마커 어노테이션.
 * 이 어노테이션이 붙은 클래스는 ConfigManager에 의해 자동으로 처리됨.
 * 
 * 사용 예:
 * 
 * <pre>
 * {@literal @}Config(modId = "mymod", fileName = "config.json")
 * public class MyModConfig {
 *     {@literal @}ConfigValue(comment = "Enable feature X")
 *     public static boolean enableFeatureX = true;
 * }
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Config {
    /**
     * 모드 ID (필수)
     */
    String modId();

    /**
     * 설정 파일 이름 (선택, 기본값: modId.json)
     */
    String fileName() default "";

    /**
     * 설정 카테고리 (선택, 폴더 구분용)
     */
    String category() default "";
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\config\ConfigManager.java =====

package com.pulse.config;

import com.google.gson.*;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.PulseConstants;

import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Pulse 설정 관리자.
 * 
 * 모드별 설정 파일 자동 생성, 로드, 저장을 담당.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 설정 클래스 정의
 * {@literal @}Config(modId = "mymod")
 * public class MyModConfig {
 *     {@literal @}ConfigValue(comment = "Enable feature X")
 *     public static boolean enableFeatureX = true;
 *     
 *     {@literal @}ConfigValue(min = 0, max = 100)
 *     public static int someValue = 50;
 * }
 * 
 * // 등록 및 로드
 * ConfigManager.register(MyModConfig.class);
 * 
 * // 사용
 * if (MyModConfig.enableFeatureX) { ... }
 * 
 * // 저장
 * ConfigManager.save(MyModConfig.class);
 * </pre>
 */
public class ConfigManager {

    private static final String LOG = PulseLogger.PULSE;
    private static final ConfigManager INSTANCE = new ConfigManager();

    // 등록된 설정 스펙
    private final Map<Class<?>, ConfigSpec> specs = new ConcurrentHashMap<>();

    // 설정 디렉토리
    private Path configDirectory;

    // JSON 파서
    private final Gson gson = new GsonBuilder()
            .setPrettyPrinting()
            .serializeNulls()
            .create();

    private ConfigManager() {
        // 기본 설정 디렉토리: 게임 폴더/config
        String gameDir = System.getProperty("user.dir");
        this.configDirectory = Paths.get(gameDir, PulseConstants.CONFIG_DIR_NAME);
    }

    public static ConfigManager getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 편의 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 설정 클래스 등록 및 로드
     */
    public static void register(Class<?> configClass) {
        INSTANCE.registerConfig(configClass);
    }

    /**
     * 설정 저장
     */
    public static void save(Class<?> configClass) {
        INSTANCE.saveConfig(configClass);
    }

    /**
     * 설정 리로드
     */
    public static void reload(Class<?> configClass) {
        INSTANCE.loadConfig(configClass);
    }

    /**
     * 모든 설정 저장
     */
    public static void saveAll() {
        INSTANCE.saveAllConfigs();
    }

    /**
     * 모든 설정 리로드
     */
    public static void reloadAll() {
        INSTANCE.loadAllConfigs();
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 설정 클래스 등록
     */
    public void registerConfig(Class<?> configClass) {
        if (!configClass.isAnnotationPresent(Config.class)) {
            throw new com.pulse.api.exception.ConfigurationException(
                    "Class must have @Config annotation: " + configClass.getName());
        }

        ConfigSpec spec = new ConfigSpec(configClass);
        specs.put(configClass, spec);

        PulseLogger.debug(LOG, "Registered config: {}", spec.getModId());

        // 파일에서 로드 시도
        try {
            loadConfig(configClass);
        } catch (Exception e) {
            // 등록 시 로드 실패는 경고만 (아직 초기화 덜 됐을 수 있음)
            PulseLogger.warn(LOG, "Failed to load config during registration: {}", e.getMessage());
        }
    }

    /**
     * 설정 로드
     */
    public void loadConfig(Class<?> configClass) {
        ConfigSpec spec = specs.get(configClass);
        if (spec == null) {
            throw new com.pulse.api.exception.ConfigurationException("Config not registered: " + configClass.getName());
        }

        Path configFile = getConfigPath(spec);

        if (!Files.exists(configFile)) {
            // 파일이 없으면 기본값으로 생성
            saveConfig(configClass);
            return;
        }

        try {
            String json = Files.readString(configFile, StandardCharsets.UTF_8);
            JsonObject root = JsonParser.parseString(json).getAsJsonObject();

            for (ConfigSpec.ConfigEntry entry : spec.getEntries()) {
                if (root.has(entry.getKey())) {
                    JsonElement element = root.get(entry.getKey());
                    Object value = parseValue(element, entry.getType());
                    if (value != null) {
                        entry.setValue(value);
                    }
                }
            }

            PulseLogger.debug(LOG, "Loaded: {}", configFile.getFileName());

        } catch (Exception e) {
            if (com.pulse.PulseEnvironment.isDevelopmentMode()) {
                throw new com.pulse.api.exception.ConfigurationException("Failed to load config: " + configFile, e);
            }
            PulseLogger.error(LOG, "Failed to load {}: {}", configFile, e.getMessage());
            // 로드 실패 시 기본값 유지
        }
    }

    /**
     * 설정 저장
     */
    public void saveConfig(Class<?> configClass) {
        ConfigSpec spec = specs.get(configClass);
        if (spec == null) {
            throw new com.pulse.api.exception.ConfigurationException("Config not registered: " + configClass.getName());
        }

        Path configFile = getConfigPath(spec);

        try {
            // 디렉토리 생성
            Files.createDirectories(configFile.getParent());

            // JSON 객체 구성
            JsonObject root = new JsonObject();

            // 메타데이터 주석
            root.addProperty("_comment", "Configuration for " + spec.getModId());

            for (ConfigSpec.ConfigEntry entry : spec.getEntries()) {
                Object value = entry.getValue();
                JsonElement element = serializeValue(value);

                // 주석이 있으면 _key_comment 형태로 추가
                if (!entry.getComment().isEmpty()) {
                    root.addProperty("_" + entry.getKey() + "_comment", entry.getComment());
                }

                root.add(entry.getKey(), element);
            }

            // 파일에 쓰기
            String json = gson.toJson(root);
            Files.writeString(configFile, json, StandardCharsets.UTF_8);

            PulseLogger.debug(LOG, "Saved: {}", configFile.getFileName());

        } catch (Exception e) {
            if (com.pulse.PulseEnvironment.isDevelopmentMode()) {
                throw new com.pulse.api.exception.ConfigurationException("Failed to save config: " + configFile, e);
            }
            PulseLogger.error(LOG, "Failed to save {}: {}", configFile, e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * 모든 설정 저장
     */
    public void saveAllConfigs() {
        for (Class<?> configClass : specs.keySet()) {
            saveConfig(configClass);
        }
    }

    /**
     * 모든 설정 로드
     */
    public void loadAllConfigs() {
        for (Class<?> configClass : specs.keySet()) {
            loadConfig(configClass);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 직렬화/역직렬화 헬퍼
    // ─────────────────────────────────────────────────────────────

    private Path getConfigPath(ConfigSpec spec) {
        Path base = configDirectory;
        if (!spec.getCategory().isEmpty()) {
            base = base.resolve(spec.getCategory());
        }
        return base.resolve(spec.getFileName());
    }

    private Object parseValue(JsonElement element, Class<?> type) {
        if (element.isJsonNull())
            return null;

        try {
            if (type == boolean.class || type == Boolean.class) {
                return element.getAsBoolean();
            }
            if (type == int.class || type == Integer.class) {
                return element.getAsInt();
            }
            if (type == long.class || type == Long.class) {
                return element.getAsLong();
            }
            if (type == float.class || type == Float.class) {
                return element.getAsFloat();
            }
            if (type == double.class || type == Double.class) {
                return element.getAsDouble();
            }
            if (type == String.class) {
                return element.getAsString();
            }
            if (type.isArray()) {
                return gson.fromJson(element, type);
            }
            if (List.class.isAssignableFrom(type)) {
                return gson.fromJson(element, type);
            }

            // 기타 객체 타입
            return gson.fromJson(element, type);

        } catch (Exception e) {
            PulseLogger.error(LOG, "Failed to parse value: {}", e.getMessage());
            return null;
        }
    }

    private JsonElement serializeValue(Object value) {
        if (value == null)
            return JsonNull.INSTANCE;
        return gson.toJsonTree(value);
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    public void setConfigDirectory(Path directory) {
        this.configDirectory = directory;
    }

    public Path getConfigDirectory() {
        return configDirectory;
    }

    public ConfigSpec getSpec(Class<?> configClass) {
        return specs.get(configClass);
    }

    public Collection<ConfigSpec> getAllSpecs() {
        return Collections.unmodifiableCollection(specs.values());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\config\ConfigSpec.java =====

package com.pulse.config;

import com.pulse.api.log.PulseLogger;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 설정 스펙.
 * 설정 클래스의 메타데이터를 담고 있음.
 */
public class ConfigSpec {

    private final Class<?> configClass;
    private final String modId;
    private final String fileName;
    private final String category;
    private final List<ConfigEntry> entries = new ArrayList<>();
    private static final String LOG = PulseLogger.PULSE;

    public ConfigSpec(Class<?> configClass) {
        this.configClass = configClass;

        Config config = configClass.getAnnotation(Config.class);
        if (config == null) {
            throw new IllegalArgumentException("Class must have @Config annotation");
        }

        this.modId = config.modId();
        this.fileName = config.fileName().isEmpty() ? modId + ".json" : config.fileName();
        this.category = config.category();

        // 필드 스캔
        scanFields();
    }

    private void scanFields() {
        for (Field field : configClass.getDeclaredFields()) {
            ConfigValue annotation = field.getAnnotation(ConfigValue.class);
            if (annotation != null) {
                field.setAccessible(true);

                String key = annotation.key().isEmpty() ? field.getName() : annotation.key();
                Object defaultValue = getFieldValue(field);

                ConfigEntry entry = new ConfigEntry(
                        key,
                        field,
                        annotation.comment(),
                        defaultValue,
                        annotation.min(),
                        annotation.max(),
                        annotation.requiresRestart(),
                        annotation.options(),
                        annotation.step(),
                        annotation.category());

                entries.add(entry);
            }
        }
    }

    private Object getFieldValue(Field field) {
        try {
            return field.get(null);
        } catch (IllegalAccessException e) {
            return null;
        }
    }

    // Getters

    public Class<?> getConfigClass() {
        return configClass;
    }

    public String getModId() {
        return modId;
    }

    public String getFileName() {
        return fileName;
    }

    public String getCategory() {
        return category;
    }

    public List<ConfigEntry> getEntries() {
        return entries;
    }

    /**
     * @Validate 메서드 실행.
     * @return 검증 성공 여부
     */
    public boolean runValidation() {
        for (Method method : configClass.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Validate.class)) {
                method.setAccessible(true);
                try {
                    Object result = method.invoke(null);
                    if (result instanceof Boolean b && !b) {
                        Validate validate = method.getAnnotation(Validate.class);
                        PulseLogger.error(LOG, "[Config] Validation failed: {}", validate.message());
                        return false;
                    }
                } catch (Exception e) {
                    PulseLogger.error(LOG, "[Config] Validation error: {}", e.getMessage());
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 모든 값을 기본값으로 리셋.
     */
    public void resetAll() {
        for (ConfigEntry entry : entries) {
            entry.reset();
        }
        PulseLogger.info(LOG, "[Config] Reset all values to defaults for: {}", modId);
    }

    public static class ConfigEntry {
        private final String key;
        private final Field field;
        private final String comment;
        private final Object defaultValue;
        private final double min;
        private final double max;
        private final boolean requiresRestart;
        private final String[] options;
        private final double step;
        private final String category;

        public ConfigEntry(String key, Field field, String comment, Object defaultValue,
                double min, double max, boolean requiresRestart,
                String[] options, double step, String category) {
            this.key = key;
            this.field = field;
            this.comment = comment;
            this.defaultValue = defaultValue;
            this.min = min;
            this.max = max;
            this.requiresRestart = requiresRestart;
            this.options = options;
            this.step = step;
            this.category = category;
        }

        public String getKey() {
            return key;
        }

        public Field getField() {
            return field;
        }

        public String getComment() {
            return comment;
        }

        public Object getDefaultValue() {
            return defaultValue;
        }

        public double getMin() {
            return min;
        }

        public double getMax() {
            return max;
        }

        public boolean requiresRestart() {
            return requiresRestart;
        }

        public Class<?> getType() {
            return field.getType();
        }

        public Object getValue() {
            try {
                return field.get(null);
            } catch (IllegalAccessException e) {
                return defaultValue;
            }
        }

        public void setValue(Object value) {
            try {
                // options 검증 (String 타입)
                if (options != null && options.length > 0 && value instanceof String strVal) {
                    List<String> optionList = Arrays.asList(options);
                    if (!optionList.contains(strVal)) {
                        PulseLogger.warn(LOG, "[Config] Invalid option '{}' for {}, resetting to default", strVal, key);
                        value = defaultValue;
                    }
                }

                // 범위 검사 및 step 적용 (숫자 타입)
                if (value instanceof Number num) {
                    double val = num.doubleValue();

                    // step 적용 (반올림)
                    if (step > 0) {
                        val = Math.round(val / step) * step;
                    }

                    // min/max 범위 적용
                    if (min != Double.MIN_VALUE && val < min) {
                        val = min;
                    }
                    if (max != Double.MAX_VALUE && val > max) {
                        val = max;
                    }

                    value = convertToFieldType(val, field.getType());
                }

                field.set(null, value);
            } catch (IllegalAccessException e) {
                PulseLogger.error(LOG, "[Config] Failed to set value for {}", key);
            }
        }

        private Object convertToFieldType(double value, Class<?> type) {
            if (type == int.class || type == Integer.class)
                return (int) value;
            if (type == long.class || type == Long.class)
                return (long) value;
            if (type == float.class || type == Float.class)
                return (float) value;
            if (type == double.class || type == Double.class)
                return value;
            return value;
        }

        public void reset() {
            setValue(defaultValue);
        }

        public String[] getOptions() {
            return options;
        }

        public double getStep() {
            return step;
        }

        public String getCategory() {
            return category;
        }

        public boolean hasOptions() {
            return options != null && options.length > 0;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\config\ConfigValue.java =====

package com.pulse.config;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 설정 값 필드 어노테이션.
 * 설정 클래스 내의 필드에 적용하여 설정 메타데이터 제공.
 * 
 * 지원 타입:
 * - 기본형: boolean, int, long, float, double, String
 * - 배열: String[], int[] 등
 * - 리스트: List<String> 등
 * 
 * 사용 예:
 * 
 * <pre>
 * {@literal @}ConfigValue(comment = "Maximum items", min = 1, max = 1000)
 * public static int maxItems = 100;
 * 
 * {@literal @}ConfigValue(options = {"LOW", "MEDIUM", "HIGH"})
 * public static String quality = "MEDIUM";
 * 
 * {@literal @}ConfigValue(min = 0, max = 100, step = 5)
 * public static int volume = 50;
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface ConfigValue {
    /**
     * 설정 설명/주석
     */
    String comment() default "";

    /**
     * 설정 키 이름 (기본값: 필드 이름)
     */
    String key() default "";

    /**
     * 최소값 (숫자 타입에만 적용)
     */
    double min() default Double.MIN_VALUE;

    /**
     * 최대값 (숫자 타입에만 적용)
     */
    double max() default Double.MAX_VALUE;

    /**
     * 재시작 필요 여부
     */
    boolean requiresRestart() default false;

    /**
     * 허용 값 목록 (String/Enum 타입용)
     * 비어있으면 제한 없음
     */
    String[] options() default {};

    /**
     * 증감 단위 (슬라이더 UI용)
     * 0이면 연속 값
     */
    double step() default 0;

    /**
     * 카테고리 (UI 그룹화용)
     */
    String category() default "";

    /**
     * 숨김 여부 (고급 사용자용)
     */
    boolean hidden() default false;
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\config\Validate.java =====

package com.pulse.config;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 설정 유효성 검사 메서드 표시.
 * 메서드는 boolean을 반환해야 하며, 설정 로드 후 호출됨.
 * 
 * 사용 예:
 * 
 * <pre>
 * {@literal @}Config(modId = "mymod")
 * public class MyConfig {
 *     {@literal @}ConfigValue
 *     public static int minValue = 10;
 *     
 *     {@literal @}ConfigValue
 *     public static int maxValue = 100;
 *     
 *     {@literal @}Validate
 *     public static boolean validate() {
 *         // minValue가 maxValue보다 작아야 함
 *         return minValue < maxValue;
 *     }
 * }
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Validate {
    /**
     * 검증 실패 시 메시지
     */
    String message() default "Validation failed";
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\content\DataLoader.java =====

package com.pulse.content;

import com.pulse.api.log.PulseLogger;
import com.pulse.registry.Identifier;
import com.google.gson.*;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;

/**
 * JSON 기반 데이터 로더.
 * 아이템, 레시피 등을 JSON 파일에서 로드.
 */
public class DataLoader {
    private static final String LOG = PulseLogger.PULSE;

    @SuppressWarnings("unused") // Reserved for future JSON serialization
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    // ─────────────────────────────────────────────────────────────
    // 아이템 로딩
    // ─────────────────────────────────────────────────────────────

    /**
     * 디렉토리에서 모든 아이템 JSON 로드.
     */
    public static int loadItems(Path directory) throws IOException {
        int count = 0;

        if (!Files.exists(directory)) {
            PulseLogger.warn(LOG, "[Data] Items directory not found: {}", directory);
            return 0;
        }

        try (var stream = Files.walk(directory)) {
            for (Path path : (Iterable<Path>) stream.filter(p -> p.toString().endsWith(".json"))::iterator) {
                try {
                    ItemDefinition item = loadItem(path);
                    if (item != null) {
                        ItemRegistry.register(item);
                        count++;
                    }
                } catch (Exception e) {
                    PulseLogger.error(LOG, "[Data] Failed to load item: {}", path, e);
                }
            }
        }

        PulseLogger.info(LOG, "[Data] Loaded {} items from {}", count, directory);
        return count;
    }

    /**
     * 단일 아이템 JSON 로드.
     */
    public static ItemDefinition loadItem(Path path) throws IOException {
        String json = Files.readString(path, StandardCharsets.UTF_8);
        JsonObject obj = JsonParser.parseString(json).getAsJsonObject();

        String idStr = getOrDefault(obj, "id", path.getFileName().toString().replace(".json", ""));
        Identifier id = Identifier.parse(idStr);

        ItemDefinition item = new ItemDefinition(id)
                .name(getOrDefault(obj, "name", id.getPath()))
                .description(getOrDefault(obj, "description", ""))
                .icon(getOrDefault(obj, "icon", null))
                .weight(getFloatOrDefault(obj, "weight", 1.0f))
                .maxStack(getIntOrDefault(obj, "maxStackSize", 1));

        // 타입
        if (obj.has("type")) {
            item.type(ItemDefinition.ItemType.valueOf(obj.get("type").getAsString().toUpperCase()));
        }

        // 카테고리
        if (obj.has("category")) {
            item.category(ItemDefinition.ItemCategory.valueOf(obj.get("category").getAsString().toUpperCase()));
        }

        // 태그
        if (obj.has("tags") && obj.get("tags").isJsonArray()) {
            for (JsonElement tag : obj.getAsJsonArray("tags")) {
                item.tag(tag.getAsString());
            }
        }

        // 커스텀 속성
        if (obj.has("properties") && obj.get("properties").isJsonObject()) {
            for (var entry : obj.getAsJsonObject("properties").entrySet()) {
                item.property(entry.getKey(), jsonToValue(entry.getValue()));
            }
        }

        return item;
    }

    // ─────────────────────────────────────────────────────────────
    // 레시피 로딩
    // ─────────────────────────────────────────────────────────────

    /**
     * 디렉토리에서 모든 레시피 JSON 로드.
     */
    public static int loadRecipes(Path directory) throws IOException {
        int count = 0;

        if (!Files.exists(directory)) {
            PulseLogger.warn(LOG, "[Data] Recipes directory not found: {}", directory);
            return 0;
        }

        try (var stream = Files.walk(directory)) {
            for (Path path : (Iterable<Path>) stream.filter(p -> p.toString().endsWith(".json"))::iterator) {
                try {
                    RecipeRegistry.Recipe recipe = loadRecipe(path);
                    if (recipe != null) {
                        RecipeRegistry.register(recipe);
                        count++;
                    }
                } catch (Exception e) {
                    PulseLogger.error(LOG, "[Data] Failed to load recipe: {}", path, e);
                }
            }
        }

        PulseLogger.info(LOG, "[Data] Loaded {} recipes from {}", count, directory);
        return count;
    }

    /**
     * 단일 레시피 JSON 로드.
     */
    public static RecipeRegistry.Recipe loadRecipe(Path path) throws IOException {
        String json = Files.readString(path, StandardCharsets.UTF_8);
        JsonObject obj = JsonParser.parseString(json).getAsJsonObject();

        String idStr = getOrDefault(obj, "id", path.getFileName().toString().replace(".json", ""));
        Identifier id = Identifier.parse(idStr);

        Identifier output = Identifier.parse(obj.get("output").getAsString());
        int outputCount = getIntOrDefault(obj, "outputCount", 1);

        RecipeRegistry.Recipe recipe = new RecipeRegistry.Recipe(id, output, outputCount)
                .craftTime(getIntOrDefault(obj, "craftTime", 60))
                .category(getOrDefault(obj, "category", "General"));

        // 재료
        if (obj.has("ingredients") && obj.get("ingredients").isJsonArray()) {
            for (JsonElement elem : obj.getAsJsonArray("ingredients")) {
                JsonObject ing = elem.getAsJsonObject();
                Identifier item = Identifier.parse(ing.get("item").getAsString());
                int count = getIntOrDefault(ing, "count", 1);
                boolean isTool = getBoolOrDefault(ing, "tool", false);

                if (isTool) {
                    recipe.tool(item);
                } else {
                    recipe.ingredient(item, count);
                }
            }
        }

        // 필요 스킬
        if (obj.has("skills") && obj.get("skills").isJsonArray()) {
            for (JsonElement skill : obj.getAsJsonArray("skills")) {
                recipe.skill(skill.getAsString());
            }
        }

        return recipe;
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    private static String getOrDefault(JsonObject obj, String key, String defaultVal) {
        return obj.has(key) ? obj.get(key).getAsString() : defaultVal;
    }

    private static int getIntOrDefault(JsonObject obj, String key, int defaultVal) {
        return obj.has(key) ? obj.get(key).getAsInt() : defaultVal;
    }

    private static float getFloatOrDefault(JsonObject obj, String key, float defaultVal) {
        return obj.has(key) ? obj.get(key).getAsFloat() : defaultVal;
    }

    private static boolean getBoolOrDefault(JsonObject obj, String key, boolean defaultVal) {
        return obj.has(key) ? obj.get(key).getAsBoolean() : defaultVal;
    }

    private static Object jsonToValue(JsonElement elem) {
        if (elem.isJsonPrimitive()) {
            JsonPrimitive prim = elem.getAsJsonPrimitive();
            if (prim.isBoolean())
                return prim.getAsBoolean();
            if (prim.isNumber())
                return prim.getAsNumber();
            return prim.getAsString();
        }
        return elem.toString();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\content\ItemDefinition.java =====

package com.pulse.content;

import com.pulse.registry.Identifier;

import java.util.*;

/**
 * 커스텀 아이템 정의.
 * JSON 또는 코드로 아이템 속성 정의.
 */
public class ItemDefinition {

    private Identifier id;
    private String name;
    private String description;
    private String icon; // 아이콘 경로

    // 기본 속성
    private float weight = 1.0f;
    private int maxStackSize = 1;
    private ItemType type = ItemType.NORMAL;
    private ItemCategory category = ItemCategory.MISC;

    // 추가 속성
    private final Map<String, Object> properties = new HashMap<>();
    private final List<String> tags = new ArrayList<>();

    public ItemDefinition(Identifier id) {
        this.id = id;
        this.name = id.getPath();
    }

    public ItemDefinition(String namespace, String path) {
        this(Identifier.of(namespace, path));
    }

    // ─────────────────────────────────────────────────────────────
    // 빌더 패턴
    // ─────────────────────────────────────────────────────────────

    public ItemDefinition name(String name) {
        this.name = name;
        return this;
    }

    public ItemDefinition description(String description) {
        this.description = description;
        return this;
    }

    public ItemDefinition icon(String icon) {
        this.icon = icon;
        return this;
    }

    public ItemDefinition weight(float weight) {
        this.weight = weight;
        return this;
    }

    public ItemDefinition maxStack(int maxStackSize) {
        this.maxStackSize = maxStackSize;
        return this;
    }

    public ItemDefinition type(ItemType type) {
        this.type = type;
        return this;
    }

    public ItemDefinition category(ItemCategory category) {
        this.category = category;
        return this;
    }

    public ItemDefinition property(String key, Object value) {
        this.properties.put(key, value);
        return this;
    }

    public ItemDefinition tag(String tag) {
        this.tags.add(tag);
        return this;
    }

    public ItemDefinition tags(String... tags) {
        this.tags.addAll(Arrays.asList(tags));
        return this;
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public Identifier getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public String getIcon() {
        return icon;
    }

    public float getWeight() {
        return weight;
    }

    public int getMaxStackSize() {
        return maxStackSize;
    }

    public ItemType getType() {
        return type;
    }

    public ItemCategory getCategory() {
        return category;
    }

    public Object getProperty(String key) {
        return properties.get(key);
    }

    @SuppressWarnings("unchecked")
    public <T> T getProperty(String key, T defaultValue) {
        Object val = properties.get(key);
        return val != null ? (T) val : defaultValue;
    }

    public List<String> getTags() {
        return Collections.unmodifiableList(tags);
    }

    public boolean hasTag(String tag) {
        return tags.contains(tag);
    }

    // ─────────────────────────────────────────────────────────────
    // 열거형
    // ─────────────────────────────────────────────────────────────

    public enum ItemType {
        NORMAL, // 일반 아이템
        WEAPON, // 무기
        CLOTHING, // 의류
        CONTAINER, // 컨테이너
        FOOD, // 음식
        DRINKABLE, // 음료
        LITERATURE, // 책/잡지
        MOVEABLE, // 이동 가능 오브젝트
        RADIO, // 라디오
        GENERATOR // 발전기
    }

    public enum ItemCategory {
        MISC, // 기타
        WEAPONS, // 무기
        TOOLS, // 도구
        MEDICAL, // 의료
        FOOD, // 음식
        CLOTHING, // 의류
        MATERIALS, // 재료
        ELECTRONICS, // 전자
        LITERATURE // 문헌
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\content\ItemRegistry.java =====

package com.pulse.content;

import com.pulse.api.log.PulseLogger;
import com.pulse.registry.Identifier;

import java.util.*;

/**
 * 아이템 레지스트리.
 * 커스텀 아이템 등록 및 조회.
 */
public class ItemRegistry {

    private static final ItemRegistry INSTANCE = new ItemRegistry();
    private static final String LOG = PulseLogger.PULSE;

    private final Map<Identifier, ItemDefinition> items = new LinkedHashMap<>();
    private final Map<String, Set<Identifier>> byTag = new HashMap<>();
    private final Map<ItemDefinition.ItemCategory, Set<Identifier>> byCategory = new HashMap<>();

    private ItemRegistry() {
    }

    public static ItemRegistry getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 아이템 등록.
     */
    public static void register(ItemDefinition item) {
        INSTANCE.registerInternal(item);
    }

    private void registerInternal(ItemDefinition item) {
        Identifier id = item.getId();

        if (items.containsKey(id)) {
            PulseLogger.error(LOG, "[Items] Duplicate item ID: {}", id);
            return;
        }

        items.put(id, item);

        // 태그 인덱싱
        for (String tag : item.getTags()) {
            byTag.computeIfAbsent(tag, k -> new HashSet<>()).add(id);
        }

        // 카테고리 인덱싱
        byCategory.computeIfAbsent(item.getCategory(), k -> new HashSet<>()).add(id);

        PulseLogger.info(LOG, "[Items] Registered: {}", id);
    }

    /**
     * 아이템 등록 해제.
     */
    public static void unregister(Identifier id) {
        INSTANCE.unregisterInternal(id);
    }

    private void unregisterInternal(Identifier id) {
        ItemDefinition item = items.remove(id);
        if (item != null) {
            // 태그에서 제거
            for (String tag : item.getTags()) {
                Set<Identifier> set = byTag.get(tag);
                if (set != null)
                    set.remove(id);
            }
            // 카테고리에서 제거
            Set<Identifier> catSet = byCategory.get(item.getCategory());
            if (catSet != null)
                catSet.remove(id);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * ID로 아이템 조회.
     */
    public static ItemDefinition get(Identifier id) {
        return INSTANCE.items.get(id);
    }

    /**
     * 문자열 ID로 조회.
     */
    public static ItemDefinition get(String id) {
        return get(Identifier.parse(id));
    }

    /**
     * 태그로 아이템 조회.
     */
    public static Set<ItemDefinition> getByTag(String tag) {
        Set<Identifier> ids = INSTANCE.byTag.get(tag);
        if (ids == null)
            return Collections.emptySet();

        Set<ItemDefinition> result = new HashSet<>();
        for (Identifier id : ids) {
            result.add(INSTANCE.items.get(id));
        }
        return result;
    }

    /**
     * 카테고리로 아이템 조회.
     */
    public static Set<ItemDefinition> getByCategory(ItemDefinition.ItemCategory category) {
        Set<Identifier> ids = INSTANCE.byCategory.get(category);
        if (ids == null)
            return Collections.emptySet();

        Set<ItemDefinition> result = new HashSet<>();
        for (Identifier id : ids) {
            result.add(INSTANCE.items.get(id));
        }
        return result;
    }

    /**
     * 모든 등록된 아이템.
     */
    public static Collection<ItemDefinition> getAll() {
        return Collections.unmodifiableCollection(INSTANCE.items.values());
    }

    /**
     * 등록된 아이템 수.
     */
    public static int count() {
        return INSTANCE.items.size();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\content\ItemTag.java =====

package com.pulse.content;

import com.pulse.registry.Identifier;

import java.util.*;

/**
 * 아이템 태그 시스템.
 * 아이템을 그룹화하여 레시피나 로직에서 사용.
 */
public class ItemTag {

    private static final Map<Identifier, ItemTag> TAGS = new HashMap<>();

    private final Identifier id;
    private final Set<Identifier> items = new HashSet<>();

    private ItemTag(Identifier id) {
        this.id = id;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 태그 생성 또는 가져오기.
     */
    public static ItemTag getOrCreate(Identifier id) {
        return TAGS.computeIfAbsent(id, ItemTag::new);
    }

    /**
     * 문자열 ID로 태그 가져오기.
     */
    public static ItemTag getOrCreate(String id) {
        return getOrCreate(Identifier.parse(id));
    }

    /**
     * 태그 가져오기 (없으면 null).
     */
    public static ItemTag get(Identifier id) {
        return TAGS.get(id);
    }

    /**
     * 모든 태그 ID 가져오기.
     */
    public static Set<Identifier> getAllTags() {
        return Collections.unmodifiableSet(TAGS.keySet());
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 태그에 아이템 추가.
     */
    public ItemTag add(Identifier item) {
        items.add(item);
        return this;
    }

    /**
     * 태그에 아이템들 추가.
     */
    public ItemTag addAll(Identifier... items) {
        this.items.addAll(Arrays.asList(items));
        return this;
    }

    /**
     * 태그에서 아이템 제거.
     */
    public ItemTag remove(Identifier item) {
        items.remove(item);
        return this;
    }

    /**
     * 아이템이 태그에 포함되는지 확인.
     */
    public boolean contains(Identifier item) {
        return items.contains(item);
    }

    /**
     * 태그의 모든 아이템 가져오기.
     */
    public Set<Identifier> getItems() {
        return Collections.unmodifiableSet(items);
    }

    /**
     * 태그 ID.
     */
    public Identifier getId() {
        return id;
    }

    /**
     * 태그 크기.
     */
    public int size() {
        return items.size();
    }

    @Override
    public String toString() {
        return "#" + id.toString();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\content\RecipeRegistry.java =====

package com.pulse.content;

import com.pulse.api.log.PulseLogger;
import com.pulse.registry.Identifier;

import java.util.*;

/**
 * 레시피 레지스트리.
 * 제작 레시피 등록 및 관리.
 */
public class RecipeRegistry {

    private static final RecipeRegistry INSTANCE = new RecipeRegistry();
    private static final String LOG = PulseLogger.PULSE;

    private final Map<Identifier, Recipe> recipes = new LinkedHashMap<>();
    private final Map<Identifier, Set<Recipe>> byOutput = new HashMap<>();

    private RecipeRegistry() {
    }

    public static RecipeRegistry getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 레시피 등록.
     */
    public static void register(Recipe recipe) {
        INSTANCE.registerInternal(recipe);
    }

    private void registerInternal(Recipe recipe) {
        if (recipes.containsKey(recipe.getId())) {
            PulseLogger.error(LOG, "[Recipes] Duplicate recipe ID: {}", recipe.getId());
            return;
        }

        recipes.put(recipe.getId(), recipe);

        // 출력 아이템으로 인덱싱
        byOutput.computeIfAbsent(recipe.getOutput(), k -> new HashSet<>()).add(recipe);

        PulseLogger.info(LOG, "[Recipes] Registered: {}", recipe.getId());
    }

    /**
     * 레시피 제거.
     */
    public static void unregister(Identifier id) {
        Recipe recipe = INSTANCE.recipes.remove(id);
        if (recipe != null) {
            Set<Recipe> set = INSTANCE.byOutput.get(recipe.getOutput());
            if (set != null)
                set.remove(recipe);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 조회
    // ─────────────────────────────────────────────────────────────

    public static Recipe get(Identifier id) {
        return INSTANCE.recipes.get(id);
    }

    public static Set<Recipe> getRecipesFor(Identifier outputItem) {
        Set<Recipe> result = INSTANCE.byOutput.get(outputItem);
        return result != null ? Collections.unmodifiableSet(result) : Collections.emptySet();
    }

    public static Collection<Recipe> getAll() {
        return Collections.unmodifiableCollection(INSTANCE.recipes.values());
    }

    // ─────────────────────────────────────────────────────────────
    // 레시피 클래스
    // ─────────────────────────────────────────────────────────────

    public static class Recipe {
        private final Identifier id;
        private final Identifier output;
        private final int outputCount;
        private final List<Ingredient> ingredients = new ArrayList<>();
        private final List<String> requiredSkills = new ArrayList<>();
        private int craftTime = 60; // 틱
        private String category = "General";

        public Recipe(Identifier id, Identifier output) {
            this(id, output, 1);
        }

        public Recipe(Identifier id, Identifier output, int outputCount) {
            this.id = id;
            this.output = output;
            this.outputCount = outputCount;
        }

        // 빌더
        public Recipe ingredient(Identifier item, int count) {
            ingredients.add(new Ingredient(item, count, false));
            return this;
        }

        public Recipe tool(Identifier item) {
            ingredients.add(new Ingredient(item, 1, true));
            return this;
        }

        public Recipe skill(String skill) {
            requiredSkills.add(skill);
            return this;
        }

        public Recipe craftTime(int ticks) {
            this.craftTime = ticks;
            return this;
        }

        public Recipe category(String category) {
            this.category = category;
            return this;
        }

        // Getters
        public Identifier getId() {
            return id;
        }

        public Identifier getOutput() {
            return output;
        }

        public int getOutputCount() {
            return outputCount;
        }

        public List<Ingredient> getIngredients() {
            return Collections.unmodifiableList(ingredients);
        }

        public List<String> getRequiredSkills() {
            return Collections.unmodifiableList(requiredSkills);
        }

        public int getCraftTime() {
            return craftTime;
        }

        public String getCategory() {
            return category;
        }
    }

    public static class Ingredient {
        private final Identifier item;
        private final int count;
        private final boolean isTool; // 도구는 소비되지 않음

        public Ingredient(Identifier item, int count, boolean isTool) {
            this.item = item;
            this.count = count;
            this.isTool = isTool;
        }

        public Identifier getItem() {
            return item;
        }

        public int getCount() {
            return count;
        }

        public boolean isTool() {
            return isTool;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\core\CoreEnvironment.java =====

package com.pulse.core;

import java.nio.file.Path;

/**
 * Environment abstraction for Pulse Core.
 * 
 * <p>
 * Allows loader to provide custom paths/sinks, while core remains
 * self-sufficient.
 * </p>
 * 
 * <p>
 * Default implementation: {@link DefaultCoreEnvironment}
 * </p>
 * 
 * @since Pulse 0.9
 */
public interface CoreEnvironment {

    /**
     * Get the base path for Pulse data storage.
     * This is NOT necessarily the game installation path.
     */
    Path getBasePath();

    /**
     * Get the configuration directory.
     */
    Path getConfigPath();

    /**
     * Get the log output directory.
     */
    Path getLogPath();

    /**
     * Check if running in server mode.
     */
    boolean isServer();

    /**
     * Check if debug mode is enabled.
     */
    boolean isDebugMode();

    /**
     * Get detected game path (best effort, may be null).
     * For actual game path detection, use bindings layer.
     */
    Path getGamePath();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\core\CoreFeatureFlags.java =====

package com.pulse.core;

/**
 * Feature flag interface for experimental/optional features.
 * 
 * <p>
 * Allows loader to enable/disable features, while core has stable defaults.
 * </p>
 * 
 * @since Pulse 0.9
 */
public interface CoreFeatureFlags {

    /**
     * Check if a specific feature is enabled.
     * 
     * @param feature Feature name (use constants below)
     * @return true if enabled
     */
    boolean isEnabled(String feature);

    // ═══════════════════════════════════════════════════════════════
    // Standard Feature Flags
    // ═══════════════════════════════════════════════════════════════

    /** Lua call profiling (Echo integration) */
    String FEATURE_LUA_PROFILING = "lua_profiling";

    /** Tick phase timing hooks */
    String FEATURE_TICK_PHASE_HOOKS = "tick_phase_hooks";

    /** Network optimization features (Nerve) */
    String FEATURE_NETWORK_OPTIMIZATION = "network_optimization";

    /** Zombie update throttling (Fuse) */
    String FEATURE_ZOMBIE_THROTTLE = "zombie_throttle";

    /** Detailed crash reporting */
    String FEATURE_CRASH_REPORTS = "crash_reports";
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\core\DefaultCoreEnvironment.java =====

package com.pulse.core;

import com.pulse.api.log.PulseLogger;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Default environment for mods-folder execution.
 * Works without loader by detecting paths with robust fallbacks.
 * 
 * <p>
 * Path detection priority:
 * </p>
 * <ol>
 * <li>System property: {@code pulse.base.path}</li>
 * <li>Environment variable: {@code PULSE_BASE_PATH}</li>
 * <li>Detected PZ Zomboid folder in user home</li>
 * <li>Current working directory (if writable)</li>
 * <li>Fallback: user.home/Pulse</li>
 * </ol>
 * 
 * @since Pulse 0.9
 */
public final class DefaultCoreEnvironment implements CoreEnvironment {

    private static final String LOG = PulseLogger.PULSE;
    private static volatile DefaultCoreEnvironment instance;

    private final Path basePath;
    private final Path configPath;
    private final Path logPath;
    private final Path gamePath; // May be null

    private DefaultCoreEnvironment() {
        this.gamePath = detectGamePath();
        this.basePath = detectBasePath();
        this.configPath = basePath.resolve("Pulse");
        this.logPath = configPath.resolve("logs");

        // Ensure directories exist
        ensureDirectoryExists(configPath);
        ensureDirectoryExists(logPath);

        PulseLogger.debug(LOG, "[Environment] basePath={}, gamePath={}", basePath, gamePath);
    }

    public static DefaultCoreEnvironment getInstance() {
        if (instance == null) {
            synchronized (DefaultCoreEnvironment.class) {
                if (instance == null) {
                    instance = new DefaultCoreEnvironment();
                }
            }
        }
        return instance;
    }

    // ═══════════════════════════════════════════════════════════════
    // Path Detection with Fallbacks
    // ═══════════════════════════════════════════════════════════════

    /**
     * Detect base path for Pulse data storage.
     * This path is ALWAYS valid and writable.
     */
    private Path detectBasePath() {
        // Strategy 1: System property
        String sysProp = System.getProperty("pulse.base.path");
        if (sysProp != null) {
            Path path = Paths.get(sysProp);
            if (isValidWritablePath(path)) {
                PulseLogger.debug(LOG, "[Environment] Using pulse.base.path: {}", sysProp);
                return path;
            }
        }

        // Strategy 2: Environment variable
        String envVar = System.getenv("PULSE_BASE_PATH");
        if (envVar != null) {
            Path path = Paths.get(envVar);
            if (isValidWritablePath(path)) {
                PulseLogger.debug(LOG, "[Environment] Using PULSE_BASE_PATH: {}", envVar);
                return path;
            }
        }

        // Strategy 3: Use detected game path if available
        if (gamePath != null && isValidWritablePath(gamePath)) {
            PulseLogger.debug(LOG, "[Environment] Using detected game path: {}", gamePath);
            return gamePath;
        }

        // Strategy 4: PZ user data folder (Zomboid in user home)
        Path zomboidDir = getZomboidUserDir();
        if (zomboidDir != null && isValidWritablePath(zomboidDir)) {
            PulseLogger.debug(LOG, "[Environment] Using Zomboid user dir: {}", zomboidDir);
            return zomboidDir;
        }

        // Strategy 5: Safe fallback - user home
        Path fallback = Paths.get(System.getProperty("user.home"), "Pulse");
        PulseLogger.warn(LOG, "[Environment] Using fallback path: {}", fallback);
        return fallback;
    }

    /**
     * Detect actual game installation path (best effort).
     * May return null if detection fails.
     */
    private static Path detectGamePath() {
        // Strategy 1: System property
        String sysProp = System.getProperty("pulse.game.path");
        if (sysProp != null && looksLikeGamePath(Paths.get(sysProp))) {
            return Paths.get(sysProp);
        }

        // Strategy 2: Environment variable
        String envVar = System.getenv("PZ_GAME_PATH");
        if (envVar != null && looksLikeGamePath(Paths.get(envVar))) {
            return Paths.get(envVar);
        }

        // Strategy 3: Current working directory
        Path userDir = Paths.get(System.getProperty("user.dir"));
        if (looksLikeGamePath(userDir)) {
            return userDir;
        }

        // Strategy 4: Common Steam paths
        Path steamPath = findSteamGamePath();
        if (steamPath != null) {
            return steamPath;
        }

        return null; // Game path not detected
    }

    /**
     * Check if path looks like a PZ game installation.
     * Uses minimal markers to avoid false negatives.
     */
    private static boolean looksLikeGamePath(Path path) {
        if (path == null || !Files.exists(path))
            return false;

        // Check for at least one PZ marker
        return Files.exists(path.resolve("media"))
                || Files.exists(path.resolve("ProjectZomboid64.exe"))
                || Files.exists(path.resolve("ProjectZomboid64.bat"))
                || Files.exists(path.resolve("ProjectZomboid64"))
                || Files.exists(path.resolve("projectzomboid")); // Linux lowercase
    }

    /**
     * Get PZ user data directory (Zomboid folder in user home).
     */
    private static Path getZomboidUserDir() {
        String userHome = System.getProperty("user.home");

        // Windows: C:\Users\<user>\Zomboid
        // Linux/Mac: ~/Zomboid
        Path zomboidDir = Paths.get(userHome, "Zomboid");
        if (Files.exists(zomboidDir)) {
            return zomboidDir;
        }

        return null;
    }

    /**
     * Find game in common Steam installation paths.
     */
    private static Path findSteamGamePath() {
        String os = System.getProperty("os.name", "").toLowerCase();
        String userHome = System.getProperty("user.home");

        Path[] steamPaths;
        if (os.contains("win")) {
            steamPaths = new Path[] {
                    Paths.get("C:", "Program Files (x86)", "Steam", "steamapps", "common", "ProjectZomboid"),
                    Paths.get("C:", "Program Files", "Steam", "steamapps", "common", "ProjectZomboid"),
                    Paths.get("D:", "SteamLibrary", "steamapps", "common", "ProjectZomboid"),
                    Paths.get("E:", "SteamLibrary", "steamapps", "common", "ProjectZomboid")
            };
        } else if (os.contains("mac")) {
            steamPaths = new Path[] {
                    Paths.get(userHome, "Library", "Application Support", "Steam", "steamapps", "common",
                            "ProjectZomboid")
            };
        } else {
            steamPaths = new Path[] {
                    Paths.get(userHome, ".steam", "steam", "steamapps", "common", "ProjectZomboid"),
                    Paths.get(userHome, ".local", "share", "Steam", "steamapps", "common", "ProjectZomboid")
            };
        }

        for (Path path : steamPaths) {
            if (looksLikeGamePath(path)) {
                return path;
            }
        }

        return null;
    }

    private static boolean isValidWritablePath(Path path) {
        if (path == null)
            return false;

        try {
            if (!Files.exists(path)) {
                // Try to create it
                Files.createDirectories(path);
            }
            return Files.isWritable(path);
        } catch (Exception e) {
            return false;
        }
    }

    private void ensureDirectoryExists(Path dir) {
        try {
            if (!Files.exists(dir)) {
                Files.createDirectories(dir);
                PulseLogger.debug(LOG, "[Environment] Created directory: {}", dir);
            }
        } catch (Exception e) {
            PulseLogger.warn(LOG, "[Environment] Failed to create directory {}: {}",
                    dir, e.getMessage());
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // CoreEnvironment Implementation
    // ═══════════════════════════════════════════════════════════════

    @Override
    public Path getBasePath() {
        return basePath;
    }

    @Override
    public Path getConfigPath() {
        return configPath;
    }

    @Override
    public Path getLogPath() {
        return logPath;
    }

    @Override
    public Path getGamePath() {
        return gamePath;
    }

    @Override
    public boolean isServer() {
        return System.getProperty("zomboid.server") != null
                || "true".equalsIgnoreCase(System.getProperty("pulse.server"));
    }

    @Override
    public boolean isDebugMode() {
        return Boolean.getBoolean("pulse.debug");
    }

    // For testing
    static void resetInstance() {
        instance = null;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\core\DefaultCoreFeatureFlags.java =====

package com.pulse.core;

import java.util.Set;

/**
 * Default feature flags for mods-folder execution.
 * Enables stable features by default.
 * 
 * @since Pulse 0.9
 */
public enum DefaultCoreFeatureFlags implements CoreFeatureFlags {
    INSTANCE;

    private static final Set<String> ENABLED_BY_DEFAULT = Set.of(
            FEATURE_TICK_PHASE_HOOKS,
            FEATURE_LUA_PROFILING,
            FEATURE_CRASH_REPORTS);

    @Override
    public boolean isEnabled(String feature) {
        // Check system property override first: pulse.feature.<name>=true/false
        String override = System.getProperty("pulse.feature." + feature);
        if (override != null) {
            return Boolean.parseBoolean(override);
        }
        return ENABLED_BY_DEFAULT.contains(feature);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\core\PulseCoreBootstrap.java =====

package com.pulse.core;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.TickPhaseHook;
import com.pulse.debug.CrashReporter;
import com.pulse.event.EventBus;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Single entry point for Pulse Core initialization.
 * 
 * <p>
 * This is the ONLY way to initialize Pulse Core:
 * </p>
 * 
 * <pre>
 * // Default configuration (mods folder execution)
 * PulseCoreBootstrap.init();
 * 
 * // Custom configuration (loader provides environment)
 * PulseCoreBootstrap.init(PulseCoreConfig.builder()
 *         .environment(loaderEnvironment)
 *         .featureFlags(loaderFlags)
 *         .build());
 * </pre>
 * 
 * <p>
 * Key guarantees:
 * </p>
 * <ul>
 * <li>Idempotent: safe to call multiple times</li>
 * <li>Thread-safe: uses AtomicBoolean for init guard</li>
 * <li>Self-sufficient: works without loader</li>
 * <li>Explicit activation: NO static initialization dependency</li>
 * </ul>
 * 
 * @since Pulse 0.9
 */
public final class PulseCoreBootstrap {

    private static final String LOG = PulseLogger.PULSE;
    private static final AtomicBoolean initialized = new AtomicBoolean(false);
    private static volatile PulseCoreConfig activeConfig;

    // Pre-init access warning (one-time)
    private static final AtomicBoolean preInitWarningShown = new AtomicBoolean(false);

    private PulseCoreBootstrap() {
        // Static utility class
    }

    /**
     * Initialize Pulse Core with default configuration.
     */
    public static void init() {
        init(PulseCoreConfig.builder().build());
    }

    /**
     * Initialize Pulse Core with custom configuration.
     * Idempotent - subsequent calls are no-ops.
     * 
     * @param config Configuration provided by loader or default
     */
    public static void init(PulseCoreConfig config) {
        if (!initialized.compareAndSet(false, true)) {
            PulseLogger.debug(LOG, "PulseCoreBootstrap.init() already called - skipping");
            return;
        }

        activeConfig = config;

        PulseLogger.info(LOG, "═══════════════════════════════════════════════");
        PulseLogger.info(LOG, " Pulse Core Bootstrap Starting");
        PulseLogger.info(LOG, "═══════════════════════════════════════════════");

        // 1. EventBus explicit activation
        installEventBus();

        // 2. TickPhaseHook explicit install
        installTickPhaseHook();

        // 3. CrashGuard/Failsoft explicit install
        installCrashGuard();

        // 4. SPI Registry initialization
        initSpiRegistry();

        PulseLogger.info(LOG, "═══════════════════════════════════════════════");
        PulseLogger.info(LOG, " Pulse Core Bootstrap Complete");
        PulseLogger.info(LOG, "═══════════════════════════════════════════════");
    }

    // ═══════════════════════════════════════════════════════════════
    // Component Installation (explicit activation, not static init)
    // ═══════════════════════════════════════════════════════════════

    private static void installEventBus() {
        PulseLogger.debug(LOG, "[Bootstrap] Installing EventBus...");

        // Get instance to ensure singleton is created
        EventBus.getInstance();

        // Log status
        PulseLogger.info(LOG, "[Bootstrap] ✓ EventBus installed");
    }

    private static void installTickPhaseHook() {
        PulseLogger.debug(LOG, "[Bootstrap] Installing TickPhaseHook...");

        // Check if feature is enabled
        if (!activeConfig.getFeatureFlags().isEnabled(CoreFeatureFlags.FEATURE_TICK_PHASE_HOOKS)) {
            PulseLogger.info(LOG, "[Bootstrap] ⊘ TickPhaseHook disabled by feature flag");
            return;
        }

        // Explicit install (not relying on static init)
        boolean freshInstall = TickPhaseHook.install();

        if (freshInstall) {
            PulseLogger.info(LOG, "[Bootstrap] ✓ TickPhaseHook installed");
        } else {
            PulseLogger.info(LOG, "[Bootstrap] ✓ TickPhaseHook already installed");
        }
    }

    private static void installCrashGuard() {
        PulseLogger.debug(LOG, "[Bootstrap] Installing CrashGuard...");

        // Check if feature is enabled
        if (!activeConfig.getFeatureFlags().isEnabled(CoreFeatureFlags.FEATURE_CRASH_REPORTS)) {
            PulseLogger.info(LOG, "[Bootstrap] ⊘ CrashGuard disabled by feature flag");
            return;
        }

        // Explicit handler install
        CrashReporter.installHandler();

        // Configure based on environment
        if (activeConfig.getEnvironment().isDebugMode()) {
            PulseLogger.debug(LOG, "[Bootstrap] CrashGuard debug mode enabled");
        }

        PulseLogger.info(LOG, "[Bootstrap] ✓ CrashGuard installed");
    }

    private static void initSpiRegistry() {
        PulseLogger.debug(LOG, "[Bootstrap] Initializing SPI Registry...");

        // ServiceLoader-based provider registration
        // This allows Echo, Fuse, Nerve to register their providers

        PulseLogger.info(LOG, "[Bootstrap] ✓ SPI Registry initialized");
    }

    // ═══════════════════════════════════════════════════════════════
    // Status Queries
    // ═══════════════════════════════════════════════════════════════

    /**
     * Check if core has been initialized.
     */
    public static boolean isInitialized() {
        return initialized.get();
    }

    /**
     * Get active configuration.
     * Returns default if called before init (with one-time warning).
     */
    public static PulseCoreConfig getConfig() {
        if (activeConfig == null) {
            warnPreInitAccess("getConfig()");
            return PulseCoreConfig.builder().build();
        }
        return activeConfig;
    }

    /**
     * Get current environment.
     */
    public static CoreEnvironment getEnvironment() {
        if (activeConfig == null) {
            warnPreInitAccess("getEnvironment()");
            return DefaultCoreEnvironment.getInstance();
        }
        return activeConfig.getEnvironment();
    }

    /**
     * Get current feature flags.
     */
    public static CoreFeatureFlags getFeatureFlags() {
        if (activeConfig == null) {
            warnPreInitAccess("getFeatureFlags()");
            return DefaultCoreFeatureFlags.INSTANCE;
        }
        return activeConfig.getFeatureFlags();
    }

    private static void warnPreInitAccess(String method) {
        if (preInitWarningShown.compareAndSet(false, true)) {
            PulseLogger.warn(LOG, "[Bootstrap] {} called before init() - using defaults. " +
                    "This warning will only appear once.", method);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Testing Support
    // ═══════════════════════════════════════════════════════════════

    /**
     * Reset for testing only.
     */
    static void reset() {
        initialized.set(false);
        activeConfig = null;
        preInitWarningShown.set(false);
        TickPhaseHook.uninstall();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\core\PulseCoreConfig.java =====

package com.pulse.core;

import java.util.function.Consumer;

/**
 * Configuration for Pulse Core initialization.
 * Used by {@link PulseCoreBootstrap#init(PulseCoreConfig)}.
 * 
 * @since Pulse 0.9
 */
public final class PulseCoreConfig {

    private final CoreEnvironment environment;
    private final CoreFeatureFlags featureFlags;
    private final Consumer<String> logSink;

    private PulseCoreConfig(Builder builder) {
        this.environment = builder.environment;
        this.featureFlags = builder.featureFlags;
        this.logSink = builder.logSink;
    }

    public CoreEnvironment getEnvironment() {
        return environment;
    }

    public CoreFeatureFlags getFeatureFlags() {
        return featureFlags;
    }

    public Consumer<String> getLogSink() {
        return logSink;
    }

    /**
     * Create a new configuration builder.
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Builder for PulseCoreConfig.
     */
    public static class Builder {
        private CoreEnvironment environment = DefaultCoreEnvironment.getInstance();
        private CoreFeatureFlags featureFlags = DefaultCoreFeatureFlags.INSTANCE;
        private Consumer<String> logSink = System.out::println;

        public Builder environment(CoreEnvironment env) {
            if (env != null)
                this.environment = env;
            return this;
        }

        public Builder featureFlags(CoreFeatureFlags flags) {
            if (flags != null)
                this.featureFlags = flags;
            return this;
        }

        public Builder logSink(Consumer<String> sink) {
            if (sink != null)
                this.logSink = sink;
            return this;
        }

        public PulseCoreConfig build() {
            return new PulseCoreConfig(this);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\debug\CommandExecutor.java =====

package com.pulse.debug;

@FunctionalInterface
public interface CommandExecutor {
    String execute(String args);
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\debug\ConsoleCommand.java =====

package com.pulse.debug;

public class ConsoleCommand {
    private final String description;
    private final CommandExecutor executor;

    public ConsoleCommand(String description, CommandExecutor executor) {
        this.description = description;
        this.executor = executor;
    }

    public String getDescription() {
        return description;
    }

    public String execute(String args) {
        return executor.execute(args);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\debug\CrashReporter.java =====

package com.pulse.debug;

import com.pulse.mixin.MixinDiagnostics;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModLoader;

import com.pulse.api.log.PulseLogger;

import java.io.*;
import java.nio.file.*;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * 크래시 리포터.
 * 예외 발생 시 상세 리포트 생성.
 * 
 * 기능:
 * - 예외 정보 및 스택트레이스
 * - 원인 모드 자동 추적
 * - Mixin 적용 현황
 * - 최근 로그 라인
 * - 시스템/게임 정보
 */
public class CrashReporter {

    private static final String LOG = PulseLogger.PULSE;
    private static Path crashLogDirectory = Paths.get("crash-reports");

    // ═══════════════════════════════════════════════════════════════
    // 이벤트 타입 상수
    // ═══════════════════════════════════════════════════════════════

    /** Mixin 실패 이벤트 */
    public static final String EVENT_MIXIN_FAILURE = "MIXIN_FAILURE";

    /** Lua 예산 초과 이벤트 */
    public static final String EVENT_LUA_BUDGET_EXCEEDED = "LUA_BUDGET_EXCEEDED";

    /** SafeGameAccess fallback 이벤트 */
    public static final String EVENT_SAFE_ACCESS_FALLBACK = "SAFE_ACCESS_FALLBACK";

    /** Fail-soft 정책 트리거 이벤트 */
    public static final String EVENT_FAILSOFT_TRIGGERED = "FAILSOFT_TRIGGERED";

    /** 클래스 미발견 이벤트 */
    public static final String EVENT_CLASS_NOT_FOUND = "CLASS_NOT_FOUND";

    // ═══════════════════════════════════════════════════════════════
    // 로그/이벤트 버퍼
    // ═══════════════════════════════════════════════════════════════

    // 최근 로그 버퍼
    private static final int MAX_LOG_LINES = 100;
    private static final LinkedList<String> recentLogs = new LinkedList<>();
    private static final Object logLock = new Object();

    // 최근 이벤트 버퍼
    private static final int MAX_EVENTS = 50;
    private static final LinkedList<EventRecord> recentEvents = new LinkedList<>();
    private static final Object eventLock = new Object();

    /**
     * 로그 라인 추가 (순환 버퍼).
     */
    public static void addLogLine(String line) {
        synchronized (logLock) {
            if (recentLogs.size() >= MAX_LOG_LINES) {
                recentLogs.removeFirst();
            }
            recentLogs.add(line);
        }
    }

    /**
     * 크래시 리포트 생성.
     */
    public static File report(Throwable throwable, String context) {
        String timestamp = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date());
        String filename = "crash-" + timestamp + ".txt";

        try {
            Files.createDirectories(crashLogDirectory);
            Path reportPath = crashLogDirectory.resolve(filename);

            StringBuilder report = new StringBuilder();

            // 헤더
            report.append("═══════════════════════════════════════════════════════════\n");
            report.append("               PULSE MOD LOADER CRASH REPORT               \n");
            report.append("═══════════════════════════════════════════════════════════\n\n");

            // 시간
            report.append("Time: ").append(new Date()).append("\n");
            report.append("Context: ").append(context != null ? context : "Unknown").append("\n\n");

            // 의심 모드 분석
            String suspectedMod = analyzeSuspectedMod(throwable);
            if (suspectedMod != null) {
                report.append("⚠️ SUSPECTED MOD: ").append(suspectedMod).append("\n\n");
            }

            // 예외 정보
            report.append("── EXCEPTION ─────────────────────────────────────────────\n");
            report.append(throwable.getClass().getName()).append(": ");
            report.append(throwable.getMessage()).append("\n\n");

            // 스택트레이스 (모드 표시 포함)
            report.append("── STACK TRACE ───────────────────────────────────────────\n");
            appendAnnotatedStackTrace(report, throwable);
            report.append("\n");

            // 원인 체인
            Throwable cause = throwable.getCause();
            while (cause != null) {
                report.append("── CAUSED BY ─────────────────────────────────────────────\n");
                report.append(cause.getClass().getName()).append(": ");
                report.append(cause.getMessage()).append("\n");
                appendAnnotatedStackTrace(report, cause);
                report.append("\n");
                cause = cause.getCause();
            }

            // 로드된 모드 목록
            report.append("── LOADED MODS ───────────────────────────────────────────\n");
            appendLoadedMods(report);
            report.append("\n");

            // Mixin 적용 현황
            report.append("── APPLIED MIXINS ────────────────────────────────────────\n");
            appendMixinInfo(report);
            report.append("\n");

            // 최근 로그
            report.append("── RECENT LOG LINES ──────────────────────────────────────\n");
            appendRecentLogs(report);
            report.append("\n");

            // 시스템 정보
            report.append("── SYSTEM INFO ───────────────────────────────────────────\n");
            appendSystemInfo(report);
            report.append("\n");

            // 푸터
            report.append("═══════════════════════════════════════════════════════════\n");
            report.append("Please report this crash to the mod developers.\n");
            if (suspectedMod != null) {
                report.append("The crash appears to be related to: ").append(suspectedMod).append("\n");
            }
            report.append("Include this file with your bug report.\n");
            report.append("═══════════════════════════════════════════════════════════\n");

            // 파일 저장
            Files.writeString(reportPath, report.toString());
            PulseLogger.error(LOG, "[Crash] Report saved to: {}", reportPath.toAbsolutePath());

            return reportPath.toFile();

        } catch (IOException e) {
            PulseLogger.error(LOG, "[Crash] Failed to write crash report: {}", e.getMessage());
            return null;
        }
    }

    /**
     * 스택트레이스에서 의심 모드 분석.
     */
    private static String analyzeSuspectedMod(Throwable throwable) {
        Set<String> suspectedMods = new LinkedHashSet<>();

        for (StackTraceElement element : throwable.getStackTrace()) {
            String modName = findModByClassName(element.getClassName());
            if (modName != null) {
                suspectedMods.add(modName);
            }
        }

        // 원인 체인도 분석
        Throwable cause = throwable.getCause();
        while (cause != null) {
            for (StackTraceElement element : cause.getStackTrace()) {
                String modName = findModByClassName(element.getClassName());
                if (modName != null) {
                    suspectedMods.add(modName);
                }
            }
            cause = cause.getCause();
        }

        if (suspectedMods.isEmpty()) {
            return null;
        }

        return String.join(", ", suspectedMods);
    }

    /**
     * 클래스 이름으로 모드 찾기.
     */
    private static String findModByClassName(String className) {
        ModLoader loader = ModLoader.getInstance();

        for (String modId : loader.getLoadedModIds()) {
            ModContainer mod = loader.getMod(modId);
            if (mod == null)
                continue;

            // 모드 엔트리포인트 확인
            String entrypoint = mod.getMetadata().getEntrypoint();
            if (entrypoint != null && entrypoint.contains(".")) {
                String packageName = entrypoint.substring(0, entrypoint.lastIndexOf('.'));
                if (className.startsWith(packageName)) {
                    return mod.getMetadata().getName() + " (" + modId + ")";
                }
            }

            // 모드 ID 기반 패키지 추정
            if (className.toLowerCase().contains(modId.toLowerCase())) {
                return mod.getMetadata().getName() + " (" + modId + ")";
            }
        }

        // Pulse 내부 패키지 확인
        if (className.startsWith("com.pulse.")) {
            return "Pulse (core)";
        }

        return null;
    }

    /**
     * 모드 표시가 포함된 스택트레이스 출력.
     */
    private static void appendAnnotatedStackTrace(StringBuilder report, Throwable throwable) {
        for (StackTraceElement element : throwable.getStackTrace()) {
            report.append("    at ").append(element.toString());

            String modName = findModByClassName(element.getClassName());
            if (modName != null) {
                report.append(" [").append(modName).append("]");
            }

            report.append("\n");
        }
    }

    /**
     * 로드된 모드 목록 출력.
     */
    private static void appendLoadedMods(StringBuilder report) {
        ModLoader loader = ModLoader.getInstance();
        List<String> modIds = new ArrayList<>(loader.getLoadedModIds());

        if (modIds.isEmpty()) {
            report.append("  (No mods loaded)\n");
            return;
        }

        for (String modId : modIds) {
            ModContainer mod = loader.getMod(modId);
            if (mod != null) {
                var meta = mod.getMetadata();
                report.append("  - ").append(meta.getName())
                        .append(" (").append(modId).append(") v").append(meta.getVersion())
                        .append(" [").append(mod.getState()).append("]\n");
            }
        }
    }

    /**
     * Mixin 적용 현황 출력.
     */
    private static void appendMixinInfo(StringBuilder report) {
        try {
            // MixinDiagnostics에서 정보 가져오기
            Map<String, List<String>> mixinInfo = MixinDiagnostics.getTransformationDetails();

            if (mixinInfo.isEmpty()) {
                report.append("  (No Mixin transformations recorded)\n");
                return;
            }

            for (var entry : mixinInfo.entrySet()) {
                report.append("  ").append(entry.getKey()).append(":\n");
                for (String mixin : entry.getValue()) {
                    report.append("    - ").append(mixin).append("\n");
                }
            }
        } catch (Exception e) {
            report.append("  (Unable to retrieve Mixin info: ").append(e.getMessage()).append(")\n");
        }
    }

    /**
     * 최근 로그 라인 출력.
     */
    private static void appendRecentLogs(StringBuilder report) {
        synchronized (logLock) {
            if (recentLogs.isEmpty()) {
                report.append("  (No recent logs captured)\n");
                return;
            }

            int count = Math.min(recentLogs.size(), 50); // 최대 50줄
            int start = recentLogs.size() - count;

            for (int i = start; i < recentLogs.size(); i++) {
                report.append("  ").append(recentLogs.get(i)).append("\n");
            }
        }
    }

    /**
     * 시스템 정보 출력.
     */
    private static void appendSystemInfo(StringBuilder report) {
        // Java 정보
        report.append("Java Version: ").append(System.getProperty("java.version")).append("\n");
        report.append("Java Vendor: ").append(System.getProperty("java.vendor")).append("\n");
        report.append("Java VM: ").append(System.getProperty("java.vm.name")).append(" ")
                .append(System.getProperty("java.vm.version")).append("\n");

        // OS 정보
        report.append("OS: ").append(System.getProperty("os.name")).append(" ")
                .append(System.getProperty("os.version")).append(" (")
                .append(System.getProperty("os.arch")).append(")\n");

        // 메모리 정보
        Runtime rt = Runtime.getRuntime();
        long usedMB = (rt.totalMemory() - rt.freeMemory()) / 1024 / 1024;
        long totalMB = rt.totalMemory() / 1024 / 1024;
        long maxMB = rt.maxMemory() / 1024 / 1024;
        report.append("Memory: ").append(usedMB).append("MB used / ")
                .append(totalMB).append("MB allocated / ")
                .append(maxMB).append("MB max\n");

        // CPU 정보
        report.append("CPU Cores: ").append(rt.availableProcessors()).append("\n");

        // Pulse 버전
        report.append("Pulse Version: 1.0.0-SNAPSHOT\n");

        // 작업 디렉토리
        report.append("Working Directory: ").append(System.getProperty("user.dir")).append("\n");
    }

    /**
     * 예외 핸들러 설치.
     */
    public static void installHandler() {
        Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {
            PulseLogger.error(LOG, "[Crash] Uncaught exception in thread: {}", thread.getName());
            report(throwable, "Uncaught exception in " + thread.getName());
        });
        PulseLogger.info(LOG, "[Crash] Exception handler installed");
    }

    /**
     * 크래시 로그 디렉토리 설정.
     */
    public static void setLogDirectory(Path path) {
        crashLogDirectory = path;
    }

    /**
     * 크래시 로그 디렉토리 가져오기.
     */
    public static Path getLogDirectory() {
        return crashLogDirectory;
    }

    // ═══════════════════════════════════════════════════════════════
    // 구조화된 이벤트 기록 (Fail-soft 연동)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 구조화된 이벤트 기록.
     * Fail-soft 정책에서 호출됨.
     * 
     * @param eventType 이벤트 타입 (EVENT_* 상수)
     * @param source    이벤트 발생 소스
     * @param message   이벤트 메시지
     */
    public static void recordEvent(String eventType, String source, String message) {
        EventRecord record = new EventRecord(eventType, source, message);

        synchronized (eventLock) {
            if (recentEvents.size() >= MAX_EVENTS) {
                recentEvents.removeFirst();
            }
            recentEvents.add(record);
        }

        // 콘솔에도 출력
        PulseLogger.info(LOG, "[Event] {} | {} | {}", eventType, source, message);
    }

    /**
     * 최근 이벤트 목록 반환.
     *
     * @return 최근 이벤트 리스트 (복사본)
     */
    public static List<EventRecord> getRecentEvents() {
        synchronized (eventLock) {
            return new ArrayList<>(recentEvents);
        }
    }

    /**
     * 특정 타입의 이벤트만 반환.
     *
     * @param eventType 이벤트 타입
     * @return 해당 타입 이벤트 리스트
     */
    public static List<EventRecord> getEventsByType(String eventType) {
        synchronized (eventLock) {
            return recentEvents.stream()
                    .filter(e -> e.eventType.equals(eventType))
                    .collect(java.util.stream.Collectors.toList());
        }
    }

    /**
     * 이벤트 버퍼 초기화.
     */
    public static void clearEvents() {
        synchronized (eventLock) {
            recentEvents.clear();
        }
    }

    /**
     * 이벤트 개수.
     *
     * @return 기록된 이벤트 수
     */
    public static int getEventCount() {
        synchronized (eventLock) {
            return recentEvents.size();
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // 이벤트 레코드 클래스
    // ═══════════════════════════════════════════════════════════════

    /**
     * 구조화된 이벤트 레코드.
     */
    public static class EventRecord {
        public final String eventType;
        public final String source;
        public final String message;
        public final long timestamp;

        public EventRecord(String eventType, String source, String message) {
            this.eventType = eventType;
            this.source = source;
            this.message = message;
            this.timestamp = System.currentTimeMillis();
        }

        @Override
        public String toString() {
            return String.format("[%tF %tT] %s | %s | %s",
                    timestamp, timestamp, eventType, source, message);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\debug\DebugOverlayRegistry.java =====

package com.pulse.debug;

import com.pulse.api.DevMode;
import com.pulse.api.log.PulseLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 디버그 오버레이 레지스트리.
 * 모드별 디버그 렌더러를 등록하고 관리.
 * 
 * 사용 예:
 * // 등록
 * DebugOverlayRegistry.register("mymod", ctx -> {
 * ctx.drawLine("FPS: " + fps);
 * });
 * 
 * // 렌더링 (Pulse 또는 게임에서 호출)
 * DebugOverlayRegistry.renderAll(ctx);
 */
public class DebugOverlayRegistry {

    private static final Map<String, DebugOverlayRenderer> renderers = new ConcurrentHashMap<>();
    private static final String LOG = PulseLogger.PULSE;
    private static boolean enabled = true;

    private DebugOverlayRegistry() {
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 디버그 오버레이 렌더러 등록
     */
    public static void register(String modId, DebugOverlayRenderer renderer) {
        renderers.put(modId, renderer);

        if (DevMode.isEnabled()) {
            PulseLogger.info(LOG, "Registered overlay renderer for: {}", modId);
        }
    }

    /**
     * 디버그 오버레이 렌더러 해제
     */
    public static void unregister(String modId) {
        renderers.remove(modId);
    }

    // ─────────────────────────────────────────────────────────────
    // 렌더링
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 등록된 렌더러 실행
     */
    public static void renderAll(DebugRenderContext ctx) {
        if (!enabled)
            return;

        for (Map.Entry<String, DebugOverlayRenderer> entry : renderers.entrySet()) {
            String modId = entry.getKey();
            DebugOverlayRenderer renderer = entry.getValue();

            try {
                ctx.beginSection("[" + modId + "]");
                renderer.render(ctx);
                ctx.endSection();
            } catch (Exception e) {
                PulseLogger.error(LOG, "Error in overlay renderer for {}", modId);
                if (DevMode.isEnabled()) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * 콘솔에 디버그 정보 출력 (렌더링 미지원 환경용)
     */
    public static void printToConsole() {
        if (!enabled || renderers.isEmpty())
            return;

        DebugRenderContext ctx = new DebugRenderContext();
        ctx.reset(0);

        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "DEBUG OVERLAY OUTPUT");

        renderAll(ctx);

        PulseLogger.info(LOG, "\n{}", ctx.getOutput());
        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // 제어
    // ─────────────────────────────────────────────────────────────

    /**
     * 오버레이 활성화/비활성화
     */
    public static void setEnabled(boolean enable) {
        enabled = enable;
    }

    public static boolean isEnabled() {
        return enabled;
    }

    /**
     * 등록된 렌더러 수
     */
    public static int getRendererCount() {
        return renderers.size();
    }

    /**
     * 등록된 모드 ID 목록
     */
    public static Set<String> getRegisteredMods() {
        return Collections.unmodifiableSet(renderers.keySet());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\debug\DebugOverlayRenderer.java =====

package com.pulse.debug;

/**
 * 디버그 오버레이 렌더러 인터페이스.
 * 모드가 게임 화면에 디버그 정보를 표시하기 위해 구현.
 * 
 * 사용 예:
 * DebugOverlayRegistry.register("mymod", ctx -> {
 * ctx.drawText(10, 10, "My Mod Debug Info");
 * ctx.drawText(10, 30, "Value: " + myValue);
 * });
 */
@FunctionalInterface
public interface DebugOverlayRenderer {

    /**
     * 디버그 오버레이 렌더링
     * 
     * @param ctx 렌더링 컨텍스트
     */
    void render(DebugRenderContext ctx);
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\debug\DebugRenderContext.java =====

package com.pulse.debug;

/**
 * 디버그 렌더링 컨텍스트.
 * 디버그 오버레이에 정보를 그리기 위한 추상화 레이어.
 * 
 * 실제 구현은 PZ 렌더링 시스템과 연동 필요.
 * 이 버전은 콘솔 출력 기반 플레이스홀더.
 */
public class DebugRenderContext {

    private final StringBuilder buffer = new StringBuilder();
    private int currentY = 0;

    // ─────────────────────────────────────────────────────────────
    // 텍스트 그리기
    // ─────────────────────────────────────────────────────────────

    /**
     * 텍스트 그리기
     */
    public void drawText(int x, int y, String text) {
        // 플레이스홀더: 콘솔에 출력
        buffer.append(String.format("[%d,%d] %s\n", x, y, text));
    }

    /**
     * 색상 있는 텍스트 그리기
     */
    public void drawText(int x, int y, String text, int color) {
        drawText(x, y, text);
    }

    /**
     * 다음 줄에 텍스트 그리기 (자동 위치)
     */
    public void drawLine(String text) {
        drawText(10, currentY, text);
        currentY += 15;
    }

    // ─────────────────────────────────────────────────────────────
    // 도형 그리기
    // ─────────────────────────────────────────────────────────────

    /**
     * 사각형 그리기
     */
    public void drawRect(int x, int y, int width, int height, int color) {
        // 플레이스홀더
    }

    /**
     * 채워진 사각형 그리기
     */
    public void fillRect(int x, int y, int width, int height, int color) {
        // 플레이스홀더
    }

    /**
     * 선 그리기
     */
    public void drawLine(int x1, int y1, int x2, int y2, int color) {
        // 플레이스홀더
    }

    // ─────────────────────────────────────────────────────────────
    // 섹션
    // ─────────────────────────────────────────────────────────────

    /**
     * 섹션 시작 (구분선 + 제목)
     */
    public void beginSection(String title) {
        drawLine("═══════════════════════════════════════");
        drawLine(title);
        drawLine("───────────────────────────────────────");
    }

    /**
     * 섹션 종료
     */
    public void endSection() {
        currentY += 5;
    }

    // ─────────────────────────────────────────────────────────────
    // 출력
    // ─────────────────────────────────────────────────────────────

    /**
     * 버퍼 내용 반환 (콘솔 출력용)
     */
    public String getOutput() {
        return buffer.toString();
    }

    /**
     * 현재 Y 위치 초기화
     */
    public void reset(int startY) {
        currentY = startY;
        buffer.setLength(0);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\debug\DevConsole.java =====

package com.pulse.debug;

import com.pulse.mod.ModLoader;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModReloadManager;
import com.pulse.api.log.PulseLogger;

import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.function.Consumer;

/**
 * 인게임 개발자 콘솔.
 * REPL 스타일 디버그 명령어 실행.
 * 
 * <p>
 * <b>멀티플레이어 보안:</b>
 * PermissionValidator를 통해 관리자 권한을 엄격하게 검사합니다.
 * </p>
 */
public class DevConsole {

    private static final DevConsole INSTANCE = new DevConsole();
    private static final String LOG = PulseLogger.PULSE;

    private final Map<String, ConsoleCommand> commands = new LinkedHashMap<>();
    private final Queue<String> outputBuffer = new ConcurrentLinkedQueue<>();
    private Consumer<String> outputHandler;
    private boolean eventMonitoring = false;

    private DevConsole() {
        registerDefaultCommands();
    }

    public static DevConsole getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 권한 관리 (Delegated to PermissionValidator)
    // ─────────────────────────────────────────────────────────────

    public static void setCurrentExecutor(String executorId, boolean isAdmin) {
        PermissionValidator.getInstance().setCurrentExecutor(executorId, isAdmin);
    }

    public static boolean isCurrentExecutorAdmin() {
        return PermissionValidator.getInstance().isCurrentExecutorAdmin();
    }

    public static void resetExecutorToSystem() {
        PermissionValidator.getInstance().resetExecutorToSystem();
    }

    public static void setDebugMode(boolean enabled) {
        PermissionValidator.getInstance().setDebugMode(enabled);
    }

    public static boolean isDebugModeEnabled() {
        return PermissionValidator.getInstance().isDebugModeEnabled();
    }

    public static void onMultiplayerSessionStart() {
        PermissionValidator.getInstance().onMultiplayerSessionStart();
    }

    public static void onMultiplayerSessionEnd() {
        PermissionValidator.getInstance().onMultiplayerSessionEnd();
    }

    public static boolean isInMultiplayerSession() {
        return PermissionValidator.getInstance().isInMultiplayerSession();
    }

    // ─────────────────────────────────────────────────────────────
    // 명령어 실행
    // ─────────────────────────────────────────────────────────────

    public static String execute(String input) {
        return INSTANCE.executeInternal(input);
    }

    private String executeInternal(String input) {
        if (input == null || input.trim().isEmpty()) {
            return "";
        }

        String[] parts = input.trim().split("\\s+", 2);
        String cmdName = parts[0].toLowerCase();
        String args = parts.length > 1 ? parts[1] : "";

        // 보안 검사 위임
        String error = PermissionValidator.getInstance().validateCommand(cmdName, args);
        if (error != null) {
            return error;
        }

        ConsoleCommand cmd = commands.get(cmdName);
        if (cmd == null) {
            return "Unknown command: " + cmdName + ". Type 'help' for available commands.";
        }

        try {
            return cmd.execute(args);
        } catch (Exception e) {
            PulseLogger.error(LOG, "Command execution failed: " + cmdName, e);
            return "Error: " + e.getMessage();
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 기본 명령어 등록
    // ─────────────────────────────────────────────────────────────

    private void registerDefaultCommands() {
        // help
        registerCommand("help", "Show available commands", args -> {
            StringBuilder sb = new StringBuilder("Available commands:\n");
            for (var entry : commands.entrySet()) {
                sb.append("  ").append(entry.getKey())
                        .append(" - ").append(entry.getValue().getDescription())
                        .append("\n");
            }
            return sb.toString();
        });

        // mods
        registerCommand("mods", "Mod management (list/info/reload/disable/enable)", args -> {
            String[] parts = args.split("\\s+", 2);
            String subCmd = parts.length > 0 ? parts[0] : "list";
            String modId = parts.length > 1 ? parts[1] : null;

            switch (subCmd) {
                case "list":
                    return listMods();
                case "info":
                    return modInfo(modId);
                case "reload":
                    return reloadMod(modId);
                case "disable":
                    return disableMod(modId);
                case "enable":
                    return enableMod(modId);
                default:
                    return "Usage: mods [list|info|reload|disable|enable] [modId]";
            }
        });

        // events
        registerCommand("events", "Event system (monitor/stats)", args -> {
            if (args.startsWith("monitor")) {
                eventMonitoring = !eventMonitoring;
                return "Event monitoring: " + (eventMonitoring ? "ON" : "OFF");
            }
            return "Usage: events [monitor|stats]";
        });

        // clear
        registerCommand("clear", "Clear output buffer", args -> {
            outputBuffer.clear();
            return "Output cleared.";
        });

        // lua
        registerCommand("lua", "Execute Lua code (Admin only in multiplayer)", args -> {
            // PermissionValidator에서 이미 권한 및 SandboxOptions 검사를 수행했으므로 바로 실행
            try {
                Object result = com.pulse.lua.LuaBridge.call(args);
                return result != null ? result.toString() : "nil";
            } catch (Exception e) {
                return "Lua error: " + e.getMessage();
            }
        });
    }

    private String listMods() {
        StringBuilder sb = new StringBuilder("Loaded mods:\n");
        ModLoader loader = ModLoader.getInstance();
        for (String modId : loader.getLoadedModIds()) {
            ModContainer mod = loader.getMod(modId);
            String status = ModReloadManager.isEnabled(modId) ? "✓" : "✗";
            sb.append("  [").append(status).append("] ")
                    .append(modId).append(" v").append(mod.getMetadata().getVersion())
                    .append("\n");
        }
        return sb.toString();
    }

    private String modInfo(String modId) {
        if (modId == null)
            return "Usage: mods info <modId>";
        ModContainer mod = ModLoader.getInstance().getMod(modId);
        if (mod == null)
            return "Mod not found: " + modId;

        var meta = mod.getMetadata();
        return String.format(
                "=== %s ===\n" +
                        "ID: %s\n" +
                        "Version: %s\n" +
                        "Author: %s\n" +
                        "Description: %s\n" +
                        "State: %s\n",
                meta.getName(), meta.getId(), meta.getVersion(),
                meta.getAuthor(), meta.getDescription(), mod.getState());
    }

    private String reloadMod(String modId) {
        if (modId == null)
            return "Usage: mods reload <modId>";
        boolean success = ModReloadManager.softReload(modId);
        return success ? "Reloaded: " + modId : "Failed to reload: " + modId;
    }

    private String disableMod(String modId) {
        if (modId == null)
            return "Usage: mods disable <modId>";
        boolean success = ModReloadManager.disable(modId);
        return success ? "Disabled: " + modId : "Failed to disable: " + modId;
    }

    private String enableMod(String modId) {
        if (modId == null)
            return "Usage: mods enable <modId>";
        boolean success = ModReloadManager.enable(modId);
        return success ? "Enabled: " + modId : "Failed to enable: " + modId;
    }

    // ─────────────────────────────────────────────────────────────
    // 명령어 등록 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 커스텀 명령어 등록.
     */
    public static void register(String name, String description, CommandExecutor executor) {
        INSTANCE.registerCommand(name, description, executor);
    }

    private void registerCommand(String name, String description, CommandExecutor executor) {
        commands.put(name.toLowerCase(), new ConsoleCommand(description, executor));
    }

    public static void setOutputHandler(Consumer<String> handler) {
        INSTANCE.outputHandler = handler;
    }

    public static void print(String message) {
        INSTANCE.outputBuffer.offer(message);
        if (INSTANCE.outputHandler != null) {
            INSTANCE.outputHandler.accept(message);
        }
        PulseLogger.info(LOG, "[DevConsole] {}", message);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\debug\EventMonitor.java =====

package com.pulse.debug;

import com.pulse.api.log.PulseLogger;
import com.pulse.event.Event;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 이벤트 모니터.
 * 실시간으로 발생하는 이벤트 추적 및 통계.
 * 
 * 사용 예:
 * 
 * <pre>
 * EventMonitor.enable();
 * // ... 게임 플레이 ...
 * EventMonitor.printStats();
 * </pre>
 */
public class EventMonitor {

    private static final EventMonitor INSTANCE = new EventMonitor();
    private static final String LOG = PulseLogger.PULSE;

    private boolean enabled = false;
    private final Map<Class<? extends Event>, EventStats> stats = new ConcurrentHashMap<>();
    private final List<EventRecord> recentEvents = Collections.synchronizedList(new LinkedList<>());
    private static final int MAX_RECENT = 100;

    private EventMonitor() {
    }

    public static EventMonitor getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 제어
    // ─────────────────────────────────────────────────────────────

    public static void enable() {
        INSTANCE.enabled = true;
        PulseLogger.info(LOG, "[EventMonitor] Monitoring enabled");
    }

    public static void disable() {
        INSTANCE.enabled = false;
        PulseLogger.info(LOG, "[EventMonitor] Monitoring disabled");
    }

    public static boolean isEnabled() {
        return INSTANCE.enabled;
    }

    public static void reset() {
        INSTANCE.stats.clear();
        INSTANCE.recentEvents.clear();
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 기록 (EventBus에서 호출)
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 발생 기록.
     */
    public static void record(Event event, long processingTimeNs) {
        if (!INSTANCE.enabled)
            return;

        Class<? extends Event> type = event.getClass();

        // 통계 업데이트
        INSTANCE.stats.computeIfAbsent(type, k -> new EventStats(type))
                .record(processingTimeNs);

        // 최근 이벤트 저장
        synchronized (INSTANCE.recentEvents) {
            INSTANCE.recentEvents.add(new EventRecord(type, processingTimeNs));
            while (INSTANCE.recentEvents.size() > MAX_RECENT) {
                INSTANCE.recentEvents.remove(0);
            }
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 통계 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 통계 출력.
     */
    public static void printStats() {
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "        EVENT MONITOR STATISTICS        ");
        PulseLogger.info(LOG, "═══════════════════════════════════════");

        List<EventStats> sorted = new ArrayList<>(INSTANCE.stats.values());
        sorted.sort((a, b) -> Long.compare(b.count.get(), a.count.get()));

        for (EventStats stat : sorted) {
            PulseLogger.info(LOG, "  {} : {} events, avg {}ms",
                    String.format("%-30s", stat.eventType.getSimpleName()),
                    stat.count.get(),
                    String.format("%.2f", stat.getAverageMs()));
        }

        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }

    /**
     * 통계 맵 반환.
     */
    public static Map<Class<? extends Event>, EventStats> getStats() {
        return Collections.unmodifiableMap(INSTANCE.stats);
    }

    /**
     * 최근 이벤트 목록.
     */
    public static List<EventRecord> getRecentEvents() {
        return new ArrayList<>(INSTANCE.recentEvents);
    }

    // ─────────────────────────────────────────────────────────────
    // 데이터 클래스
    // ─────────────────────────────────────────────────────────────

    public static class EventStats {
        public final Class<? extends Event> eventType;
        public final AtomicLong count = new AtomicLong(0);
        public final AtomicLong totalTimeNs = new AtomicLong(0);

        EventStats(Class<? extends Event> eventType) {
            this.eventType = eventType;
        }

        void record(long processingTimeNs) {
            count.incrementAndGet();
            totalTimeNs.addAndGet(processingTimeNs);
        }

        public double getAverageMs() {
            long c = count.get();
            if (c == 0)
                return 0;
            return (totalTimeNs.get() / (double) c) / 1_000_000.0;
        }
    }

    public static class EventRecord {
        public final Class<? extends Event> eventType;
        public final long timestamp;
        public final long processingTimeNs;

        EventRecord(Class<? extends Event> eventType, long processingTimeNs) {
            this.eventType = eventType;
            this.timestamp = System.currentTimeMillis();
            this.processingTimeNs = processingTimeNs;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\debug\ModProfiler.java =====

package com.pulse.debug;

import com.pulse.api.log.PulseLogger;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 모드별 성능 프로파일러.
 * 각 모드의 틱 시간, 메모리 사용량 추적.
 * 
 * 사용 예:
 * 
 * <pre>
 * ProfilerSection section = ModProfiler.start("mymod", "onTick");
 * try {
 *     // 작업 수행
 * } finally {
 *     section.end();
 * }
 * </pre>
 */
public class ModProfiler {

    private static final ModProfiler INSTANCE = new ModProfiler();
    private static final String LOG = PulseLogger.PULSE;

    private boolean enabled = false;
    private final Map<String, ModProfile> profiles = new ConcurrentHashMap<>();

    private ModProfiler() {
    }

    public static ModProfiler getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 제어
    // ─────────────────────────────────────────────────────────────

    public static void enable() {
        INSTANCE.enabled = true;
        PulseLogger.info(LOG, "[Profiler] Profiling enabled");
    }

    public static void disable() {
        INSTANCE.enabled = false;
        PulseLogger.info(LOG, "[Profiler] Profiling disabled");
    }

    public static boolean isEnabled() {
        return INSTANCE.enabled;
    }

    public static void reset() {
        INSTANCE.profiles.clear();
    }

    // ─────────────────────────────────────────────────────────────
    // 프로파일링 API
    // ─────────────────────────────────────────────────────────────

    /**
     * 프로파일링 섹션 시작.
     */
    public static ProfilerSection start(String modId, String section) {
        if (!INSTANCE.enabled) {
            return ProfilerSection.NOOP;
        }
        return new ProfilerSection(modId, section, System.nanoTime());
    }

    /**
     * 람다로 프로파일링.
     */
    public static void profile(String modId, String section, Runnable task) {
        ProfilerSection s = start(modId, section);
        try {
            task.run();
        } finally {
            s.end();
        }
    }

    /**
     * 반환값이 있는 람다 프로파일링.
     */
    public static <T> T profileGet(String modId, String section, Supplier<T> task) {
        ProfilerSection s = start(modId, section);
        try {
            return task.get();
        } finally {
            s.end();
        }
    }

    /**
     * 프로파일링 결과 기록.
     */
    static void record(String modId, String section, long durationNs) {
        INSTANCE.profiles
                .computeIfAbsent(modId, k -> new ModProfile(modId))
                .record(section, durationNs);
    }

    // ─────────────────────────────────────────────────────────────
    // 결과 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * 프로파일링 결과 출력.
     */
    public static void printResults() {
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "         MOD PROFILER RESULTS          ");
        PulseLogger.info(LOG, "═══════════════════════════════════════");

        for (ModProfile profile : INSTANCE.profiles.values()) {
            PulseLogger.info(LOG, "\n  [{}]", profile.modId);
            double totalMs = 0;

            for (var entry : profile.sections.entrySet()) {
                SectionStats stats = entry.getValue();
                double avgMs = stats.getAverageMs();
                totalMs += avgMs * stats.count;
                PulseLogger.info(LOG, "    {}: {} calls, avg {}ms",
                        String.format("%-25s", entry.getKey()), stats.count, String.format("%.3f", avgMs));
            }

            PulseLogger.info(LOG, "    {}: {}ms total", String.format("%-25s", "TOTAL"),
                    String.format("%.2f", totalMs));
        }

        PulseLogger.info(LOG, "\n═══════════════════════════════════════");
    }

    /**
     * 특정 모드의 프로파일 조회.
     */
    public static ModProfile getProfile(String modId) {
        return INSTANCE.profiles.get(modId);
    }

    // ─────────────────────────────────────────────────────────────
    // 데이터 클래스
    // ─────────────────────────────────────────────────────────────

    public static class ProfilerSection {
        static final ProfilerSection NOOP = new ProfilerSection(null, null, 0) {
            @Override
            public void end() {
            }
        };

        private final String modId;
        private final String section;
        private final long startNs;

        ProfilerSection(String modId, String section, long startNs) {
            this.modId = modId;
            this.section = section;
            this.startNs = startNs;
        }

        public void end() {
            long duration = System.nanoTime() - startNs;
            record(modId, section, duration);
        }
    }

    public static class ModProfile {
        public final String modId;
        public final Map<String, SectionStats> sections = new ConcurrentHashMap<>();

        ModProfile(String modId) {
            this.modId = modId;
        }

        void record(String section, long durationNs) {
            sections.computeIfAbsent(section, k -> new SectionStats())
                    .record(durationNs);
        }
    }

    public static class SectionStats {
        public long count = 0;
        public long totalNs = 0;
        public long minNs = Long.MAX_VALUE;
        public long maxNs = 0;

        synchronized void record(long durationNs) {
            count++;
            totalNs += durationNs;
            minNs = Math.min(minNs, durationNs);
            maxNs = Math.max(maxNs, durationNs);
        }

        public double getAverageMs() {
            if (count == 0)
                return 0;
            return (totalNs / (double) count) / 1_000_000.0;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\debug\PermissionValidator.java =====

package com.pulse.debug;

import com.pulse.api.log.PulseLogger;
import com.pulse.security.PermissionManager;
import com.pulse.security.PermissionManager.Permission;

import java.util.Set;

/**
 * DevConsole 권한 및 보안 유효성 검사기.
 * 멀티플레이어 환경에서의 보안 정책과 관리자 권한을 관리합니다.
 */
public class PermissionValidator {

    private static final String LOG = PulseLogger.PULSE;
    private static final PermissionValidator INSTANCE = new PermissionValidator();

    /** 위험 명령어 목록 - 권한 검사 필요 */
    private static final Set<String> PRIVILEGED_COMMANDS = Set.of("lua");
    private static final Set<String> MOD_MANAGE_SUBCOMMANDS = Set.of("reload", "disable", "enable");

    /** 현재 콘솔 사용자의 권한 (플레이어 ID 또는 "pulse:system") */
    private String currentExecutor = "pulse:system";
    private boolean currentExecutorIsAdmin = false;

    /** 디버그 모드 여부 (개발 중에만 true) */
    private boolean debugModeEnabled = false;

    /** 멀티플레이어 세션 여부 */
    private boolean inMultiplayerSession = false;

    private PermissionValidator() {
    }

    public static PermissionValidator getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 권한 관리
    // ─────────────────────────────────────────────────────────────

    public void setCurrentExecutor(String executorId, boolean isAdmin) {
        this.currentExecutor = executorId != null ? executorId : "pulse:system";
        this.currentExecutorIsAdmin = isAdmin;
        PulseLogger.info(LOG, "[PermissionValidator] Executor set: {} (admin={})", currentExecutor, isAdmin);
    }

    public boolean isCurrentExecutorAdmin() {
        return currentExecutorIsAdmin;
    }

    public void resetExecutorToSystem() {
        this.currentExecutor = "pulse:system";
        this.currentExecutorIsAdmin = true;
    }

    public void setDebugMode(boolean enabled) {
        this.debugModeEnabled = enabled;
        PulseLogger.info(LOG, "[PermissionValidator] Debug mode: {}", enabled ? "ENABLED" : "DISABLED");
    }

    public boolean isDebugModeEnabled() {
        return debugModeEnabled;
    }

    public void onMultiplayerSessionStart() {
        this.inMultiplayerSession = true;
        this.debugModeEnabled = false;
        PulseLogger.info(LOG, "[PermissionValidator] Multiplayer session started - security enforced");
    }

    public void onMultiplayerSessionEnd() {
        this.inMultiplayerSession = false;
        resetExecutorToSystem();
        PulseLogger.info(LOG, "[PermissionValidator] Multiplayer session ended");
    }

    public boolean isInMultiplayerSession() {
        return inMultiplayerSession;
    }

    // ─────────────────────────────────────────────────────────────
    // 검증 로직
    // ─────────────────────────────────────────────────────────────

    /**
     * 명령어 실행 권한 검사.
     * 
     * @return 검증 실패 시 에러 메시지, 성공 시 null
     */
    public String validateCommand(String cmdName, String args) {
        // [최우선] Project Zomboid 권한 직접 검사
        if (PRIVILEGED_COMMANDS.contains(cmdName) ||
                ("mods".equals(cmdName) && args.length() > 0
                        && MOD_MANAGE_SUBCOMMANDS.contains(args.split("\\s+")[0].toLowerCase()))) {

            // PZ 멀티플레이어 클라이언트에서 Admin이 아니면 차단
            if (isInPZMultiplayerClient() && !isPZAdmin()) {
                PulseLogger.error(LOG,
                        "[DevConsole] BLOCKED: Non-admin attempted privileged command in multiplayer: {}", cmdName);
                return "§c[보안] Error: 관리자 권한이 없습니다. 이 명령어는 멀티플레이에서 관리자만 사용할 수 있습니다.";
            }
        }

        // 보안 검사 (Anti-Cheat) - 2차 검증
        boolean bypassSecurity = (debugModeEnabled && !inMultiplayerSession) || currentExecutorIsAdmin;

        if (!bypassSecurity) {
            // Lua 명령어
            if (PRIVILEGED_COMMANDS.contains(cmdName)) {
                if (!PermissionManager.hasPermission(currentExecutor, Permission.CONSOLE_LUA_EXEC)) {
                    PulseLogger.error(LOG, "[DevConsole] BLOCKED: User '{}' attempted privileged command: {}",
                            currentExecutor, cmdName);
                    return "§c[보안] 권한 부족: '" + cmdName + "' 명령어는 관리자만 사용할 수 있습니다.";
                }
            }

            // 모드 관리 명령어
            if ("mods".equals(cmdName) && args.length() > 0) {
                String subCmd = args.split("\\s+")[0].toLowerCase();
                if (MOD_MANAGE_SUBCOMMANDS.contains(subCmd)) {
                    if (!PermissionManager.hasPermission(currentExecutor, Permission.CONSOLE_MOD_MANAGE)) {
                        PulseLogger.error(LOG, "[DevConsole] BLOCKED: User '{}' attempted mod management: mods {}",
                                currentExecutor, subCmd);
                        return "§c[보안] 권한 부족: 'mods " + subCmd + "'는 관리자만 사용할 수 있습니다.";
                    }
                }
            }
        }

        // Lua 콘솔 허용 여부 (Lua 명령어인 경우)
        if ("lua".equals(cmdName) && inMultiplayerSession) {
            if (!isLuaConsoleAllowedByServer()) {
                PulseLogger.error(LOG, "[DevConsole] BLOCKED: Lua console not allowed on this server");
                return "§c[보안] 이 서버에서는 Lua 콘솔이 비활성화되어 있습니다.";
            }
        }

        return null; // 검증 통과
    }

    // ─────────────────────────────────────────────────────────────
    // Project Zomboid 연동 (Reflection)
    // ─────────────────────────────────────────────────────────────

    public boolean isLuaConsoleAllowedByServer() {
        try {
            Class<?> sandboxOptionsClass = Class.forName("zombie.SandboxOptions");
            java.lang.reflect.Field instanceField = sandboxOptionsClass.getField("instance");
            Object instance = instanceField.get(null);

            if (instance == null) {
                PulseLogger.warn(LOG, "[PermissionValidator] SandboxOptions.instance is null, defaulting to blocked");
                return false;
            }

            java.lang.reflect.Field luaConsoleField = sandboxOptionsClass.getField("AllowedToLuaConsole");
            Object luaConsoleOption = luaConsoleField.get(instance);

            if (luaConsoleOption == null) {
                PulseLogger.warn(LOG, "[PermissionValidator] AllowedToLuaConsole is null, defaulting to blocked");
                return false;
            }

            java.lang.reflect.Method getValueMethod = luaConsoleOption.getClass().getMethod("getValue");
            Object result = getValueMethod.invoke(luaConsoleOption);

            if (result instanceof Boolean) {
                return (Boolean) result;
            }
            return false;
        } catch (ClassNotFoundException e) {
            if (debugModeEnabled)
                return true;
            PulseLogger.info(LOG, "[PermissionValidator] Not running in PZ runtime, Lua console blocked");
            return false;
        } catch (Exception e) {
            PulseLogger.error(LOG, "[PermissionValidator] Error checking SandboxOptions: {}", e.getMessage());
            return false;
        }
    }

    public boolean isInPZMultiplayerClient() {
        if (inMultiplayerSession)
            return true;

        try {
            Class<?> gameWindowClass = Class.forName("zombie.GameWindow");
            java.lang.reflect.Field bServerField = gameWindowClass.getField("bServer");
            boolean isServer = bServerField.getBoolean(null);

            if (isServer)
                return false;

            Class<?> gameClientClass = Class.forName("zombie.network.GameClient");
            java.lang.reflect.Field bConnectedField = gameClientClass.getField("bConnected");
            return bConnectedField.getBoolean(null);

        } catch (ClassNotFoundException e) {
            return inMultiplayerSession;
        } catch (Exception e) {
            PulseLogger.error(LOG, "[PermissionValidator] Error checking multiplayer state: {}", e.getMessage());
            return inMultiplayerSession;
        }
    }

    public boolean isPZAdmin() {
        try {
            Class<?> gameClientClass = Class.forName("zombie.network.GameClient");
            java.lang.reflect.Field connectionField = gameClientClass.getDeclaredField("connection");
            connectionField.setAccessible(true);
            Object connection = connectionField.get(null);

            if (connection != null) {
                java.lang.reflect.Method isAdminMethod = connection.getClass().getMethod("isAdmin");
                Object result = isAdminMethod.invoke(connection);
                if (result instanceof Boolean) {
                    return (Boolean) result;
                }
            }

            Class<?> coreClass = Class.forName("zombie.core.Core");
            java.lang.reflect.Field bDebugField = coreClass.getField("bDebug");
            boolean isDebug = bDebugField.getBoolean(null);
            if (isDebug)
                return true;

            return false;
        } catch (ClassNotFoundException e) {
            return debugModeEnabled;
        } catch (Exception e) {
            PulseLogger.error(LOG, "[PermissionValidator] Error checking admin status: {}", e.getMessage());
            return false;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\di\PulseServiceLocator.java =====

package com.pulse.di;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Service Locator for Pulse ecosystem.
 * Provides a bridge for components that cannot use constructor injection (e.g.
 * Mixins).
 * 
 * Usage:
 * PulseServiceLocator.getInstance().getService(MyService.class);
 */
public class PulseServiceLocator {

    private static final PulseServiceLocator INSTANCE = new PulseServiceLocator();
    private final Map<Class<?>, Object> services = new ConcurrentHashMap<>();

    private PulseServiceLocator() {
    }

    public static PulseServiceLocator getInstance() {
        return INSTANCE;
    }

    public <T> void registerService(Class<T> type, T instance) {
        services.put(type, instance);
    }

    public <T> T getService(Class<T> type) {
        return type.cast(services.get(type));
    }

    public void clear() {
        services.clear();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\diagnostics\HotspotMap.java =====

package com.pulse.diagnostics;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 엔진 함수별 소요 시간을 기록하는 핫스팟 맵.
 * 
 * Fuse 개발자가 "어떤 함수가 병목인지" 자동으로 파악할 수 있게 합니다.
 * 로드맵의 "Hotspot Map API" 요구사항을 충족합니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // Mixin에서 시간 기록
 * long start = System.nanoTime();
 * // ... 함수 로직 ...
 * HotspotMap.record("IsoZombie.update", System.nanoTime() - start);
 * 
 * // 핫스팟 조회
 * List<HotspotEntry> top = HotspotMap.getTopHotspots(10);
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class HotspotMap {

    private static final Map<String, TimingStats> hotspots = new ConcurrentHashMap<>();
    private static volatile boolean enabled = true;

    private HotspotMap() {
    }

    /**
     * 함수 실행 시간 기록
     * 
     * @param function 함수 식별자
     * @param nanos    소요 시간 (나노초)
     */
    public static void record(String function, long nanos) {
        if (!enabled || function == null || nanos < 0) {
            return;
        }
        hotspots.computeIfAbsent(function, k -> new TimingStats()).record(nanos);
    }

    /**
     * 모든 핫스팟 조회
     */
    public static Map<String, TimingStats> getAll() {
        return new HashMap<>(hotspots);
    }

    /**
     * 상위 N개 핫스팟 (총 시간 기준)
     */
    public static List<HotspotEntry> getTopHotspots(int n) {
        List<HotspotEntry> entries = new ArrayList<>();
        hotspots.forEach((name, stats) -> entries.add(new HotspotEntry(name, stats)));

        entries.sort((a, b) -> Long.compare(b.getTotalNanos(), a.getTotalNanos()));

        return entries.subList(0, Math.min(n, entries.size()));
    }

    /**
     * 특정 함수의 통계
     */
    public static TimingStats getStats(String function) {
        return hotspots.get(function);
    }

    /**
     * 모든 통계 초기화
     */
    public static void reset() {
        hotspots.clear();
    }

    /**
     * 활성화/비활성화
     */
    public static void setEnabled(boolean enabled) {
        HotspotMap.enabled = enabled;
    }

    public static boolean isEnabled() {
        return enabled;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    /**
     * 함수별 타이밍 통계
     */
    public static class TimingStats {
        private final AtomicLong count = new AtomicLong(0);
        private final AtomicLong totalNanos = new AtomicLong(0);
        private volatile long minNanos = Long.MAX_VALUE;
        private volatile long maxNanos = 0;

        public void record(long nanos) {
            count.incrementAndGet();
            totalNanos.addAndGet(nanos);

            // Min/Max (경합 조건 있지만 정확도보다 성능 우선)
            if (nanos < minNanos)
                minNanos = nanos;
            if (nanos > maxNanos)
                maxNanos = nanos;
        }

        public long getCount() {
            return count.get();
        }

        public long getTotalNanos() {
            return totalNanos.get();
        }

        public long getMinNanos() {
            return minNanos == Long.MAX_VALUE ? 0 : minNanos;
        }

        public long getMaxNanos() {
            return maxNanos;
        }

        public double getAverageNanos() {
            long c = count.get();
            return c > 0 ? (double) totalNanos.get() / c : 0;
        }

        public double getAverageMs() {
            return getAverageNanos() / 1_000_000.0;
        }

        public double getTotalMs() {
            return totalNanos.get() / 1_000_000.0;
        }

        @Override
        public String toString() {
            return String.format("count=%d, total=%.2fms, avg=%.3fms, min=%.3fms, max=%.3fms",
                    count.get(), getTotalMs(), getAverageMs(),
                    getMinNanos() / 1_000_000.0, getMaxNanos() / 1_000_000.0);
        }
    }

    /**
     * 핫스팟 엔트리 (정렬용)
     */
    public static class HotspotEntry {
        private final String function;
        private final TimingStats stats;

        public HotspotEntry(String function, TimingStats stats) {
            this.function = function;
            this.stats = stats;
        }

        public String getFunction() {
            return function;
        }

        public long getCount() {
            return stats.getCount();
        }

        public long getTotalNanos() {
            return stats.getTotalNanos();
        }

        public double getTotalMs() {
            return stats.getTotalMs();
        }

        public double getAverageMs() {
            return stats.getAverageMs();
        }

        @Override
        public String toString() {
            return String.format("%s: %s", function, stats);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\diagnostics\package-info.java =====

/**
 * Pulse 진단 시스템.
 * 
 * Echo, Fuse, Nerve에서 사용하는 성능 모니터링 및 진단 API입니다.
 * 
 * <h2>주요 클래스</h2>
 * <ul>
 * <li>{@link com.pulse.diagnostics.PulseTickContext} - 틱별 엔진 상태 정보</li>
 * <li>{@link com.pulse.diagnostics.PulseThreadGuard} - 메인 스레드 감지</li>
 * <li>{@link com.pulse.diagnostics.HotspotMap} - 함수별 핫스팟 분석</li>
 * </ul>
 * 
 * @since Pulse 1.2
 */
package com.pulse.diagnostics;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\diagnostics\PulseThreadGuard.java =====

package com.pulse.diagnostics;

import com.pulse.api.log.PulseLogger;

/**
 * 메인 게임 스레드 감지 및 보호.
 * 
 * B42는 스레드 구조 변화가 있기 때문에 Echo가 메인 스레드에서만 동작해야 할 때
 * 이 클래스를 사용하여 검증할 수 있습니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // 메인 스레드 여부 확인
 * if (PulseThreadGuard.isMainThread()) {
 *     // 메인 스레드 전용 로직
 * }
 * 
 * // 메인 스레드 강제 (아닌 경우 경고)
 * PulseThreadGuard.assertMainThread("EchoProfiler.sample");
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class PulseThreadGuard {
    private static final String LOG = PulseLogger.PULSE;

    private static volatile Thread mainThread = null;
    private static volatile String mainThreadName = null;
    private static volatile boolean warningsEnabled = true;
    private static volatile boolean strictMode = false;

    private PulseThreadGuard() {
    }

    /**
     * 현재 스레드를 메인 게임 스레드로 마킹
     * (게임 초기화 시 한 번 호출)
     */
    public static void markMainThread() {
        mainThread = Thread.currentThread();
        mainThreadName = mainThread.getName();
        PulseLogger.info(LOG, "[ThreadGuard] Main thread marked: {}", mainThreadName);
    }

    /**
     * 현재 스레드가 메인 스레드인지 확인
     */
    public static boolean isMainThread() {
        Thread main = mainThread;
        if (main == null) {
            // 아직 마킹되지 않은 경우 - 첫 호출을 메인으로 간주
            return true;
        }
        return Thread.currentThread() == main;
    }

    /**
     * 현재 스레드가 메인 스레드가 아니면 경고/예외
     * 
     * @param context 호출 컨텍스트 (디버깅용)
     */
    public static void assertMainThread(String context) {
        if (!isMainThread()) {
            String message = String.format(
                    "[Pulse/ThreadGuard] WARNING: %s called from non-main thread '%s' (expected: '%s')",
                    context, Thread.currentThread().getName(), mainThreadName);

            if (strictMode) {
                throw new IllegalStateException(message);
            } else if (warningsEnabled) {
                PulseLogger.warn(LOG, message);
                // 스택 트레이스 일부 출력
                StackTraceElement[] stack = Thread.currentThread().getStackTrace();
                for (int i = 2; i < Math.min(6, stack.length); i++) {
                    PulseLogger.warn(LOG, "    at {}", stack[i]);
                }
            }
        }
    }

    /**
     * 현재 스레드가 메인 스레드가 아니면 true 반환
     */
    public static boolean isOffMainThread() {
        return !isMainThread();
    }

    /**
     * 경고 활성화/비활성화
     */
    public static void setWarningsEnabled(boolean enabled) {
        warningsEnabled = enabled;
    }

    /**
     * Strict 모드 (비메인 스레드 호출 시 예외)
     */
    public static void setStrictMode(boolean enabled) {
        strictMode = enabled;
    }

    /**
     * 메인 스레드 이름
     */
    public static String getMainThreadName() {
        return mainThreadName != null ? mainThreadName : "Unknown";
    }

    /**
     * 상태 요약
     */
    public static String getStatus() {
        return String.format(
                "MainThread=%s, Current=%s, IsMain=%s",
                mainThreadName, Thread.currentThread().getName(), isMainThread());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\diagnostics\PulseTickContext.java =====

package com.pulse.diagnostics;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 현재 틱의 엔진 상태 정보를 담는 컨텍스트.
 * 
 * Pulse가 매 틱마다 수집하여 Echo/Fuse에게 제공하는 성능 플래그입니다.
 * 로드맵의 "Performance Flag Broadcast" 요구사항을 충족합니다.
 * 
 * <h2>수집되는 정보</h2>
 * <ul>
 * <li>멀티플레이어 여부</li>
 * <li>좀비 업데이트 수</li>
 * <li>청크 로드/언로드 수</li>
 * <li>플레이어 수 (MP)</li>
 * <li>차량 업데이트 수</li>
 * </ul>
 * 
 * @since Pulse 1.2
 */
public final class PulseTickContext {

    private static final PulseTickContext INSTANCE = new PulseTickContext();

    // 현재 틱 정보
    private volatile long currentTick = 0;
    private volatile boolean multiplayer = false;

    // 업데이트 카운터 (틱별 리셋)
    private final AtomicInteger zombieUpdateCount = new AtomicInteger(0);
    private final AtomicInteger chunkLoadCount = new AtomicInteger(0);
    private final AtomicInteger chunkUnloadCount = new AtomicInteger(0);
    private final AtomicInteger playerCount = new AtomicInteger(0);
    private final AtomicInteger vehicleUpdateCount = new AtomicInteger(0);

    // 누적 통계 (세션)
    private final AtomicLong totalZombieUpdates = new AtomicLong(0);
    private final AtomicLong totalChunkLoads = new AtomicLong(0);

    private PulseTickContext() {
    }

    public static PulseTickContext get() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 틱 관리 (Mixin에서 호출)
    // ─────────────────────────────────────────────────────────────

    /**
     * 새 틱 시작 (카운터 리셋)
     */
    public void beginTick(long tick) {
        this.currentTick = tick;
        zombieUpdateCount.set(0);
        chunkLoadCount.set(0);
        chunkUnloadCount.set(0);
        vehicleUpdateCount.set(0);
    }

    /**
     * 틱 종료 (누적 통계 갱신)
     */
    public void endTick() {
        totalZombieUpdates.addAndGet(zombieUpdateCount.get());
        totalChunkLoads.addAndGet(chunkLoadCount.get());
    }

    // ─────────────────────────────────────────────────────────────
    // 카운터 증가 (Mixin에서 호출)
    // ─────────────────────────────────────────────────────────────

    public void incrementZombieUpdate() {
        zombieUpdateCount.incrementAndGet();
    }

    public void incrementChunkLoad() {
        chunkLoadCount.incrementAndGet();
    }

    public void incrementChunkUnload() {
        chunkUnloadCount.incrementAndGet();
    }

    public void incrementVehicleUpdate() {
        vehicleUpdateCount.incrementAndGet();
    }

    public void setPlayerCount(int count) {
        playerCount.set(count);
    }

    public void setMultiplayer(boolean mp) {
        this.multiplayer = mp;
    }

    // ─────────────────────────────────────────────────────────────
    // Getters (Echo/Fuse에서 호출)
    // ─────────────────────────────────────────────────────────────

    public long getCurrentTick() {
        return currentTick;
    }

    public boolean isMultiplayer() {
        return multiplayer;
    }

    public int getZombieUpdateCount() {
        return zombieUpdateCount.get();
    }

    public int getChunkLoadCount() {
        return chunkLoadCount.get();
    }

    public int getChunkUnloadCount() {
        return chunkUnloadCount.get();
    }

    public int getPlayerCount() {
        return playerCount.get();
    }

    public int getVehicleUpdateCount() {
        return vehicleUpdateCount.get();
    }

    public long getTotalZombieUpdates() {
        return totalZombieUpdates.get();
    }

    public long getTotalChunkLoads() {
        return totalChunkLoads.get();
    }

    // ─────────────────────────────────────────────────────────────
    // 진단용
    // ─────────────────────────────────────────────────────────────

    public String getSnapshot() {
        return String.format(
                "Tick=%d MP=%s Zombies=%d Chunks=+%d/-%d Players=%d Vehicles=%d",
                currentTick, multiplayer, zombieUpdateCount.get(),
                chunkLoadCount.get(), chunkUnloadCount.get(),
                playerCount.get(), vehicleUpdateCount.get());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\diagnostics\TickRateDetector.java =====

package com.pulse.diagnostics;

import com.pulse.api.InternalAPI;

/**
 * 동적 틱 레이트 감지기.
 * 
 * PZ의 가변 FPS(30~144+)를 하드코딩하지 않고 런타임에서 실제 델타 시간을
 * 기반으로 틱 레이트를 감지합니다.
 * 
 * @since 1.0.1
 */
public class TickRateDetector {

    private static final TickRateDetector INSTANCE = new TickRateDetector();

    // 기본값: 60 FPS
    private volatile double detectedTickRate = 60.0;
    private volatile double expectedTickMs = 16.67;
    private final double smoothingFactor = 0.1;

    // 유효한 델타 범위 (5ms = 200fps ~ 200ms = 5fps)
    private static final long MIN_DELTA_MS = 5;
    private static final long MAX_DELTA_MS = 200;

    // 통계
    private volatile long sampleCount = 0;
    private volatile long invalidSampleCount = 0;

    private TickRateDetector() {
    }

    public static TickRateDetector getInstance() {
        return INSTANCE;
    }

    /**
     * 실제 프레임/틱 델타 시간으로 틱 레이트 업데이트.
     * Pulse Mixin에서 각 틱 또는 프레임 시작 시 호출합니다.
     * 
     * @param deltaMs 이전 틱과의 시간 차이 (밀리초)
     * @return true if sample was valid and used, false if filtered out
     */
    @InternalAPI
    public boolean updateFromActualDelta(long deltaMs) {
        // 노이즈 필터링: 범위를 벗어난 델타는 무시
        if (deltaMs < MIN_DELTA_MS || deltaMs > MAX_DELTA_MS) {
            invalidSampleCount++;
            return false;
        }

        // 순간 틱 레이트 계산
        double instantRate = 1000.0 / deltaMs;

        // 지수 평활법으로 스무딩
        detectedTickRate = detectedTickRate * (1 - smoothingFactor)
                + instantRate * smoothingFactor;

        // 예상 틱 시간 업데이트
        expectedTickMs = 1000.0 / detectedTickRate;

        sampleCount++;
        return true;
    }

    /**
     * 감지된 틱 레이트 (초당 틱 수)
     */
    public double getDetectedTickRate() {
        return detectedTickRate;
    }

    /**
     * 감지된 틱 레이트 기준 예상 틱 시간 (ms)
     * Echo의 TickHistogram 등에서 기준값으로 사용
     */
    public double getExpectedTickMs() {
        return expectedTickMs;
    }

    /**
     * 현재 틱 시간이 예상 범위 내인지 확인
     * 
     * @param actualMs         실제 틱 시간
     * @param tolerancePercent 허용 오차 (예: 0.5 = 50%)
     */
    public boolean isWithinExpectedRange(double actualMs, double tolerancePercent) {
        double lower = expectedTickMs * (1 - tolerancePercent);
        double upper = expectedTickMs * (1 + tolerancePercent);
        return actualMs >= lower && actualMs <= upper;
    }

    /**
     * 유효 샘플 수
     */
    public long getSampleCount() {
        return sampleCount;
    }

    /**
     * 필터링된 무효 샘플 수 (노이즈)
     */
    public long getInvalidSampleCount() {
        return invalidSampleCount;
    }

    /**
     * 데이터 품질 지표 (0.0 ~ 1.0)
     * 유효 샘플 비율
     */
    public double getDataQuality() {
        long total = sampleCount + invalidSampleCount;
        if (total == 0)
            return 1.0;
        return (double) sampleCount / total;
    }

    /**
     * 상태 초기화
     */
    @InternalAPI
    public void reset() {
        detectedTickRate = 60.0;
        expectedTickMs = 16.67;
        sampleCount = 0;
        invalidSampleCount = 0;
    }

    /**
     * 디버그 정보
     */
    @Override
    public String toString() {
        return String.format("TickRateDetector[rate=%.2f, expectedMs=%.2f, samples=%d, quality=%.2f%%]",
                detectedTickRate, expectedTickMs, sampleCount, getDataQuality() * 100);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\distribution\ModRepository.java =====

package com.pulse.distribution;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.PulseConstants;

import java.io.*;
import java.net.*;
import java.nio.file.*;
import java.util.*;

/**
 * 모드 저장소 클라이언트.
 * 공식/커뮤니티 모드 저장소에서 모드 검색 및 다운로드.
 */
public class ModRepository {

    private static final ModRepository INSTANCE = new ModRepository();
    private static final String LOG = PulseLogger.PULSE;

    private final List<String> repositoryUrls = new ArrayList<>();
    private Path downloadDirectory;

    private ModRepository() {
        // 기본 저장소
        repositoryUrls.add("https://pulse-mods.example.com");
        downloadDirectory = Paths.get(PulseConstants.MODS_DIR_NAME);
    }

    public static ModRepository getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 저장소 관리
    // ─────────────────────────────────────────────────────────────

    /**
     * 저장소 URL 추가.
     */
    public static void addRepository(String url) {
        INSTANCE.repositoryUrls.add(url);
    }

    /**
     * 다운로드 디렉토리 설정.
     */
    public static void setDownloadDirectory(Path path) {
        INSTANCE.downloadDirectory = path;
    }

    // ─────────────────────────────────────────────────────────────
    // 검색
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 검색.
     */
    public static List<ModInfo> search(String query) {
        return INSTANCE.searchInternal(query);
    }

    private List<ModInfo> searchInternal(String query) {
        List<ModInfo> results = new ArrayList<>();

        for (String repoUrl : repositoryUrls) {
            try {
                URL url = new URL(repoUrl + "/api/search?q=" + URLEncoder.encode(query, "UTF-8"));
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                conn.setConnectTimeout(5000);

                if (conn.getResponseCode() == 200) {
                    // JSON 응답 파싱 (간략화)
                    try (BufferedReader reader = new BufferedReader(
                            new InputStreamReader(conn.getInputStream()))) {
                        String line;
                        while ((line = reader.readLine()) != null) {
                            // 간단한 파싱 로직
                            if (line.contains("\"id\"")) {
                                results.add(parseModInfo(line));
                            }
                        }
                    }
                }
            } catch (Exception e) {
                PulseLogger.error(LOG, "[Repo] Search failed for {}", repoUrl);
            }
        }

        return results;
    }

    private ModInfo parseModInfo(String json) {
        // 간단한 파싱 (실제로는 Gson 사용)
        String id = extractValue(json, "id");
        String name = extractValue(json, "name");
        String version = extractValue(json, "version");
        String author = extractValue(json, "author");
        String downloadUrl = extractValue(json, "downloadUrl");
        int downloads = extractIntValue(json, "downloads");

        return new ModInfo(id, name, version, author, downloadUrl, downloads);
    }

    private String extractValue(String json, String key) {
        int start = json.indexOf("\"" + key + "\":\"");
        if (start < 0)
            return "";
        start += key.length() + 4;
        int end = json.indexOf("\"", start);
        return end > start ? json.substring(start, end) : "";
    }

    private int extractIntValue(String json, String key) {
        try {
            int start = json.indexOf("\"" + key + "\":");
            if (start < 0)
                return 0;
            start += key.length() + 3;
            int end = start;
            while (end < json.length() && Character.isDigit(json.charAt(end)))
                end++;
            return Integer.parseInt(json.substring(start, end));
        } catch (Exception e) {
            return 0;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 다운로드
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 다운로드.
     */
    public static File download(ModInfo modInfo) throws IOException {
        return INSTANCE.downloadInternal(modInfo);
    }

    private File downloadInternal(ModInfo modInfo) throws IOException {
        if (modInfo.downloadUrl == null || modInfo.downloadUrl.isEmpty()) {
            throw new IOException("No download URL for mod: " + modInfo.id);
        }

        Files.createDirectories(downloadDirectory);
        Path targetPath = downloadDirectory.resolve(modInfo.id + "-" + modInfo.version + ".jar");

        PulseLogger.info(LOG, "[Repo] Downloading: {}", modInfo.name);

        URL url = new URL(modInfo.downloadUrl);
        try (InputStream in = url.openStream()) {
            Files.copy(in, targetPath, StandardCopyOption.REPLACE_EXISTING);
        }

        PulseLogger.info(LOG, "[Repo] Downloaded: {}", targetPath);
        return targetPath.toFile();
    }

    /**
     * 의존성 포함 다운로드.
     */
    public static List<File> downloadWithDependencies(ModInfo modInfo) throws IOException {
        List<File> downloaded = new ArrayList<>();
        downloaded.add(download(modInfo));

        // 의존성 다운로드는 추후 구현

        return downloaded;
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 정보
    // ─────────────────────────────────────────────────────────────

    public static class ModInfo {
        public final String id;
        public final String name;
        public final String version;
        public final String author;
        public final String downloadUrl;
        public final int downloads;

        public ModInfo(String id, String name, String version, String author,
                String downloadUrl, int downloads) {
            this.id = id;
            this.name = name;
            this.version = version;
            this.author = author;
            this.downloadUrl = downloadUrl;
            this.downloads = downloads;
        }

        @Override
        public String toString() {
            return String.format("%s (%s) v%s by %s - %d downloads",
                    name, id, version, author, downloads);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\distribution\UpdateChecker.java =====

package com.pulse.distribution;

import com.pulse.api.log.PulseLogger;
import com.pulse.mod.ModLoader;
import com.pulse.mod.ModContainer;

import java.io.*;
import java.net.*;
import java.util.*;

/**
 * 모드 업데이트 확인.
 * 원격 저장소에서 모드의 새 버전 확인.
 */
public class UpdateChecker {

    private static final UpdateChecker INSTANCE = new UpdateChecker();
    private static final String LOG = PulseLogger.PULSE;

    private String updateServerUrl = "https://pulse-mods.example.com/api";
    private final Map<String, UpdateInfo> updateCache = new HashMap<>();
    private long lastCheckTime = 0;
    private static final long CHECK_INTERVAL = 3600000; // 1시간

    private UpdateChecker() {
    }

    public static UpdateChecker getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 업데이트 확인
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 모드의 업데이트 확인.
     */
    public static List<UpdateInfo> checkAll() {
        return INSTANCE.checkAllInternal();
    }

    private List<UpdateInfo> checkAllInternal() {
        List<UpdateInfo> updates = new ArrayList<>();

        if (System.currentTimeMillis() - lastCheckTime < CHECK_INTERVAL && !updateCache.isEmpty()) {
            return new ArrayList<>(updateCache.values());
        }

        for (String modId : ModLoader.getInstance().getLoadedModIds()) {
            try {
                UpdateInfo info = checkMod(modId);
                if (info != null && info.hasUpdate()) {
                    updates.add(info);
                    updateCache.put(modId, info);
                }
            } catch (Exception e) {
                PulseLogger.error(LOG, "[Update] Failed to check: {}", modId);
            }
        }

        lastCheckTime = System.currentTimeMillis();
        PulseLogger.info(LOG, "[Update] Found {} updates available", updates.size());
        return updates;
    }

    /**
     * 특정 모드의 업데이트 확인.
     */
    public static UpdateInfo check(String modId) {
        return INSTANCE.checkMod(modId);
    }

    private UpdateInfo checkMod(String modId) {
        ModContainer mod = ModLoader.getInstance().getMod(modId);
        if (mod == null)
            return null;

        String currentVersion = mod.getMetadata().getVersion();

        try {
            // API 호출
            URL url = new URL(updateServerUrl + "/check?mod=" + modId + "&version=" + currentVersion);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.setConnectTimeout(5000);
            conn.setReadTimeout(5000);

            if (conn.getResponseCode() == 200) {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(conn.getInputStream()))) {

                    // 간단한 JSON 파싱 (예: {"latestVersion":"1.2.0","downloadUrl":"..."})
                    String line = reader.readLine();
                    if (line != null && line.contains("latestVersion")) {
                        String latestVersion = extractJsonValue(line, "latestVersion");
                        String downloadUrl = extractJsonValue(line, "downloadUrl");
                        String changelog = extractJsonValue(line, "changelog");

                        return new UpdateInfo(modId, currentVersion, latestVersion, downloadUrl, changelog);
                    }
                }
            }
        } catch (Exception e) {
            // 네트워크 오류 무시
        }

        return new UpdateInfo(modId, currentVersion, currentVersion, null, null);
    }

    private String extractJsonValue(String json, String key) {
        int start = json.indexOf("\"" + key + "\":\"");
        if (start < 0)
            return null;
        start += key.length() + 4;
        int end = json.indexOf("\"", start);
        if (end < 0)
            return null;
        return json.substring(start, end);
    }

    /**
     * 업데이트 서버 URL 설정.
     */
    public static void setServerUrl(String url) {
        INSTANCE.updateServerUrl = url;
    }

    // ─────────────────────────────────────────────────────────────
    // 업데이트 정보
    // ─────────────────────────────────────────────────────────────

    public static class UpdateInfo {
        private final String modId;
        private final String currentVersion;
        private final String latestVersion;
        private final String downloadUrl;
        private final String changelog;

        public UpdateInfo(String modId, String currentVersion, String latestVersion,
                String downloadUrl, String changelog) {
            this.modId = modId;
            this.currentVersion = currentVersion;
            this.latestVersion = latestVersion;
            this.downloadUrl = downloadUrl;
            this.changelog = changelog;
        }

        public boolean hasUpdate() {
            return !currentVersion.equals(latestVersion);
        }

        public String getModId() {
            return modId;
        }

        public String getCurrentVersion() {
            return currentVersion;
        }

        public String getLatestVersion() {
            return latestVersion;
        }

        public String getDownloadUrl() {
            return downloadUrl;
        }

        public String getChangelog() {
            return changelog;
        }

        @Override
        public String toString() {
            return modId + ": " + currentVersion + " -> " + latestVersion;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\chat\ChatEvent.java =====

package com.pulse.event.chat;

import com.pulse.event.Event;

/**
 * 채팅 관련 이벤트 기본 클래스.
 */
public abstract class ChatEvent extends Event {

    private final Object player; // IsoPlayer
    private String message;

    protected ChatEvent(Object player, String message) {
        this.player = player;
        this.message = message;
    }

    public Object getPlayer() {
        return player;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\chat\ChatReceiveEvent.java =====

package com.pulse.event.chat;

/**
 * 채팅 메시지를 수신할 때 발생.
 */
public class ChatReceiveEvent extends ChatEvent {

    private final Object sender; // 메시지를 보낸 플레이어 (또는 null if system)

    public ChatReceiveEvent(Object player, String message, Object sender) {
        super(player, message);
        this.sender = sender;
    }

    public Object getSender() {
        return sender;
    }

    public boolean isSystemMessage() {
        return sender == null;
    }

    @Override
    public String getEventName() {
        return "ChatReceive";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\chat\ChatSendEvent.java =====

package com.pulse.event.chat;

/**
 * 플레이어가 채팅 메시지를 보낼 때 발생.
 * 취소 가능 - 메시지 전송을 막을 수 있음.
 */
public class ChatSendEvent extends ChatEvent {

    private final ChatType chatType;

    public ChatSendEvent(Object player, String message, ChatType chatType) {
        super(player, message);
        this.chatType = chatType;
    }

    public ChatType getChatType() {
        return chatType;
    }

    @Override
    public String getEventName() {
        return "ChatSend";
    }

    public enum ChatType {
        SAY, // 일반 채팅
        SHOUT, // 외침
        WHISPER, // 속삭임
        RADIO, // 무전기
        ADMIN, // 관리자
        FACTION, // 팩션
        SAFEHOUSE // 세이프하우스
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\chat\CommandEvent.java =====

package com.pulse.event.chat;

import com.pulse.event.Event;

/**
 * 명령어 실행 시 발생.
 */
public class CommandEvent extends Event {

    private final Object player;
    private final String command;
    private final String[] args;

    public CommandEvent(Object player, String command, String[] args) {
        this.player = player;
        this.command = command;
        this.args = args;
    }

    public Object getPlayer() {
        return player;
    }

    public String getCommand() {
        return command;
    }

    public String[] getArgs() {
        return args;
    }

    @Override
    public String getEventName() {
        return "Command";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\DefaultPerformanceAlert.java =====

package com.pulse.event;

import com.pulse.api.PerformanceAlertEvent;

/**
 * PerformanceAlertEvent 기본 구현체.
 * 
 * Echo에서 성능 문제 감지 시 이 이벤트를 생성하여 발행합니다.
 * Nerve에서 수신하여 자동 최적화 또는 사용자 알림을 처리합니다.
 * 
 * @since 1.0.1
 */
public class DefaultPerformanceAlert implements PerformanceAlertEvent {

    private final AlertType alertType;
    private final double severity;
    private final String message;
    private final long timestamp;
    private final ThreadContext threadContext;
    private final String sourceId;
    private boolean cancelled = false;

    public DefaultPerformanceAlert(AlertType alertType, double severity, String message,
            ThreadContext threadContext, String sourceId) {
        this.alertType = alertType;
        this.severity = Math.max(0.0, Math.min(1.0, severity)); // 클램프 0.0~1.0
        this.message = message;
        this.timestamp = System.currentTimeMillis();
        this.threadContext = threadContext;
        this.sourceId = sourceId;
    }

    /**
     * 간단한 생성자 (메인 스레드 기본값)
     */
    public DefaultPerformanceAlert(AlertType alertType, double severity, String message, String sourceId) {
        this(alertType, severity, message, ThreadContext.MAIN, sourceId);
    }

    // --- PerformanceAlertEvent 구현 ---

    @Override
    public AlertType getAlertType() {
        return alertType;
    }

    @Override
    public double getSeverity() {
        return severity;
    }

    @Override
    public String getMessage() {
        return message;
    }

    @Override
    public long getTimestamp() {
        return timestamp;
    }

    @Override
    public ThreadContext getThreadContext() {
        return threadContext;
    }

    @Override
    public String getSourceId() {
        return sourceId;
    }

    // --- IPulseEvent 구현 ---

    @Override
    public String getEventName() {
        return "PerformanceAlert:" + alertType.name();
    }

    @Override
    public boolean isCancellable() {
        return true;
    }

    @Override
    public boolean isCancelled() {
        return cancelled;
    }

    @Override
    public void cancel() {
        this.cancelled = true;
    }

    // --- 유틸리티 메서드 ---

    /**
     * 심각도가 높음인지 확인 (>= 0.7)
     */
    public boolean isHighSeverity() {
        return severity >= 0.7;
    }

    /**
     * 심각도가 치명적인지 확인 (>= 0.9)
     */
    public boolean isCritical() {
        return severity >= 0.9;
    }

    @Override
    public String toString() {
        return String.format("PerformanceAlert[type=%s, severity=%.2f, source=%s, thread=%s, msg=%s]",
                alertType, severity, sourceId, threadContext, message);
    }

    // --- Factory 메서드 ---

    /**
     * LAG_SPIKE 경보 생성
     */
    public static DefaultPerformanceAlert lagSpike(double spikeMs, double threshold, String source) {
        double severity = Math.min(1.0, spikeMs / (threshold * 3));
        String msg = String.format("Lag spike detected: %.2fms (threshold: %.2fms)", spikeMs, threshold);
        return new DefaultPerformanceAlert(AlertType.LAG_SPIKE, severity, msg, source);
    }

    /**
     * FREEZE_WARNING 경보 생성
     */
    public static DefaultPerformanceAlert freezeWarning(long freezeDurationMs, String source) {
        double severity = Math.min(1.0, freezeDurationMs / 3000.0); // 3초에 severity 1.0
        String msg = String.format("Freeze detected: %dms", freezeDurationMs);
        return new DefaultPerformanceAlert(AlertType.FREEZE_WARNING, severity, msg, source);
    }

    /**
     * MEMORY_PRESSURE 경보 생성
     */
    public static DefaultPerformanceAlert memoryPressure(double usagePercent, String source) {
        double severity = Math.max(0, (usagePercent - 70) / 30); // 70%에서 시작, 100%에서 1.0
        String msg = String.format("Memory pressure: %.1f%% used", usagePercent);
        return new DefaultPerformanceAlert(AlertType.MEMORY_PRESSURE, severity, msg, source);
    }

    /**
     * TPS_DROP 경보 생성
     */
    public static DefaultPerformanceAlert tpsDrop(double currentTps, double targetTps, String source) {
        double ratio = currentTps / targetTps;
        double severity = Math.min(1.0, Math.max(0, 1.0 - ratio));
        String msg = String.format("TPS drop: %.1f / %.1f", currentTps, targetTps);
        return new DefaultPerformanceAlert(AlertType.TPS_DROP, severity, msg, source);
    }

    /**
     * ENTITY_OVERLOAD 경보 생성
     */
    public static DefaultPerformanceAlert entityOverload(int entityCount, int threshold, String source) {
        double severity = Math.min(1.0, (double) entityCount / (threshold * 2));
        String msg = String.format("Entity overload: %d entities (threshold: %d)", entityCount, threshold);
        return new DefaultPerformanceAlert(AlertType.ENTITY_OVERLOAD, severity, msg, source);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\environment\TimeChangeEvent.java =====

package com.pulse.event.environment;

import com.pulse.event.Event;

/**
 * 게임 내 시간 변경 이벤트.
 */
public class TimeChangeEvent extends Event {

    private final int hour;
    private final int minute;
    private final int day;
    private final int month;
    private final int year;

    public TimeChangeEvent(int hour, int minute, int day, int month, int year) {
        this.hour = hour;
        this.minute = minute;
        this.day = day;
        this.month = month;
        this.year = year;
    }

    public int getHour() {
        return hour;
    }

    public int getMinute() {
        return minute;
    }

    public int getDay() {
        return day;
    }

    public int getMonth() {
        return month;
    }

    public int getYear() {
        return year;
    }

    public boolean isDawn() {
        return hour >= 5 && hour < 7;
    }

    public boolean isDay() {
        return hour >= 7 && hour < 19;
    }

    public boolean isDusk() {
        return hour >= 19 && hour < 21;
    }

    public boolean isNight() {
        return hour >= 21 || hour < 5;
    }

    @Override
    public String getEventName() {
        return "TimeChange";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\environment\WeatherChangeEvent.java =====

package com.pulse.event.environment;

import com.pulse.event.Event;

/**
 * 날씨 변경 이벤트.
 */
public class WeatherChangeEvent extends Event {

    private final WeatherType previousWeather;
    private final WeatherType newWeather;
    private final float intensity;

    public WeatherChangeEvent(WeatherType previousWeather, WeatherType newWeather, float intensity) {
        this.previousWeather = previousWeather;
        this.newWeather = newWeather;
        this.intensity = intensity;
    }

    public WeatherType getPreviousWeather() {
        return previousWeather;
    }

    public WeatherType getNewWeather() {
        return newWeather;
    }

    public float getIntensity() {
        return intensity;
    }

    @Override
    public String getEventName() {
        return "WeatherChange";
    }

    public enum WeatherType {
        CLEAR,
        CLOUDY,
        RAIN,
        STORM,
        SNOW,
        FOG,
        BLIZZARD
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\Event.java =====

package com.pulse.event;

/**
 * 모든 Pulse 이벤트의 기본 클래스.
 */
public abstract class Event {
    
    private boolean cancelled = false;
    private final boolean cancellable;
    
    protected Event() {
        this(false);
    }
    
    protected Event(boolean cancellable) {
        this.cancellable = cancellable;
    }
    
    /**
     * 이벤트 취소 (취소 가능한 이벤트만)
     */
    public void cancel() {
        if (!cancellable) {
            throw new UnsupportedOperationException("This event cannot be cancelled");
        }
        this.cancelled = true;
    }
    
    public boolean isCancelled() {
        return cancelled;
    }
    
    public boolean isCancellable() {
        return cancellable;
    }
    
    /**
     * 이벤트 이름 (디버깅용)
     */
    public String getEventName() {
        return getClass().getSimpleName();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\EventBus.java =====

package com.pulse.event;

import com.pulse.api.DevMode;
import com.pulse.api.log.PulseLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Pulse 이벤트 버스.
 * 이벤트 등록, 발행, 구독을 관리.
 * 
 * 사용 예:
 * // 구독
 * EventBus.subscribe(GameTickEvent.class, event -> {
 * PulseLogger.info("Pulse", "Game tick: {}", event.getTick());
 * });
 * 
 * // 발행
 * EventBus.post(new GameTickEvent(tickCount));
 */
public class EventBus {

    private static final String LOG = PulseLogger.PULSE;
    private static final EventBus INSTANCE = new EventBus();

    // 이벤트 타입 → 리스너 목록
    private final Map<Class<? extends Event>, List<RegisteredListener<?>>> listeners = new ConcurrentHashMap<>();

    // Lazy Sort 최적화: 정렬이 필요한 이벤트 타입 추적
    private final Set<Class<? extends Event>> needsSort = ConcurrentHashMap.newKeySet();

    // 비동기 이벤트 실행용 스레드 풀
    private final ExecutorService asyncExecutor = Executors.newSingleThreadExecutor(
            r -> {
                Thread t = new Thread(r, "Pulse-AsyncEventBus");
                t.setDaemon(true);
                return t;
            });

    // 디버그 모드
    private boolean debug = false;

    // ─────────────────────────────────────────────────────────────
    // 싱글톤 접근
    // ─────────────────────────────────────────────────────────────

    public static EventBus getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 메서드 (편의용)
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 리스너 등록 (기본 우선순위)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener) {
        INSTANCE.register(eventType, listener, EventPriority.NORMAL, null);
    }

    /**
     * 이벤트 리스너 등록 (우선순위 지정)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener,
            EventPriority priority) {
        INSTANCE.register(eventType, listener, priority, null);
    }

    /**
     * 이벤트 리스너 등록 (modId 지정 - 예외 격리용)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener,
            String modId) {
        INSTANCE.register(eventType, listener, EventPriority.NORMAL, modId);
    }

    /**
     * 이벤트 리스너 등록 (우선순위 + modId 지정)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener,
            EventPriority priority, String modId) {
        INSTANCE.register(eventType, listener, priority, modId);
    }

    /**
     * 이벤트 리스너 해제
     */
    public static <T extends Event> void unsubscribe(Class<T> eventType, EventListener<T> listener) {
        INSTANCE.unregister(eventType, listener);
    }

    /**
     * 이벤트 발행 (동기)
     */
    public static <T extends Event> T post(T event) {
        return INSTANCE.fire(event);
    }

    /**
     * 이벤트 비동기 발행 (UI/네트워크 이벤트용)
     * 
     * 게임 틱에 영향을 주지 않는 백그라운드 이벤트 처리에 사용.
     * 예: 로깅, 네트워크 전송, 파일 I/O
     * 
     * @param event 발행할 이벤트
     */
    public static <T extends Event> void postAsync(T event) {
        INSTANCE.asyncExecutor.submit(() -> {
            try {
                INSTANCE.fire(event);
            } catch (Throwable t) {
                PulseLogger.error(LOG, "[EventBus] Async event error: {}", t.getMessage());
            }
        });
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 리스너 등록 (modId 없이)
     */
    public <T extends Event> void register(Class<T> eventType, EventListener<T> listener,
            EventPriority priority) {
        register(eventType, listener, priority, null);
    }

    /**
     * 리스너 등록 (modId 포함 - 예외 격리용)
     */
    public <T extends Event> void register(Class<T> eventType, EventListener<T> listener,
            EventPriority priority, String modId) {
        List<RegisteredListener<?>> list = listeners.computeIfAbsent(
                eventType,
                k -> new CopyOnWriteArrayList<>());

        RegisteredListener<T> registered = new RegisteredListener<>(listener, priority, modId);
        list.add(registered);

        // Lazy Sort: 즉시 정렬하지 않고 플래그만 설정
        needsSort.add(eventType);

        if (debug) {
            String modInfo = modId != null ? " from mod " + modId : "";
            PulseLogger.debug(LOG, "Registered listener for {} with priority {}{}",
                    eventType.getSimpleName(), priority, modInfo);
        }
    }

    /**
     * 리스너 해제
     */
    public <T extends Event> void unregister(Class<T> eventType, EventListener<T> listener) {
        List<RegisteredListener<?>> list = listeners.get(eventType);
        if (list != null) {
            list.removeIf(reg -> reg.listener == listener);
        }
    }

    /**
     * 이벤트 발행 (모든 리스너에 전달)
     */
    @SuppressWarnings("unchecked")
    public <T extends Event> T fire(T event) {
        Class<? extends Event> eventType = event.getClass();
        List<RegisteredListener<?>> list = listeners.get(eventType);

        if (list == null || list.isEmpty()) {
            return event;
        }

        // Lazy Sort: 필요할 때만 정렬
        if (needsSort.remove(eventType)) {
            list.sort((a, b) -> Integer.compare(b.priority.getValue(), a.priority.getValue()));
        }

        if (debug) {
            PulseLogger.debug(LOG, "Firing {} to {} listener(s)", event.getEventName(), list.size());
        }

        for (RegisteredListener<?> registered : list) {
            // 취소된 이벤트는 더 이상 전달하지 않음 (선택적)
            if (event.isCancelled()) {
                break;
            }

            try {
                ((EventListener<T>) registered.listener).onEvent(event);
            } catch (Exception e) {
                // 예외 격리: 어느 모드에서 문제가 발생했는지 명확히 로그
                String modId = registered.modId != null ? registered.modId : "unknown";
                PulseLogger.error(LOG, "Exception in listener {{}} for event {{}}", modId, event.getEventName());

                // DevMode일 때 추가 정보
                if (DevMode.isEnabled()) {
                    PulseLogger.error(LOG, "  Listener class: {}", registered.listener.getClass().getName());
                    PulseLogger.error(LOG, "  Priority: {}", registered.priority);
                }

                e.printStackTrace();

                // 예외가 발생해도 다른 리스너는 계속 실행됨 (격리)
            }
        }

        return event;
    }

    /**
     * 특정 이벤트 타입의 모든 리스너 해제
     */
    public void clearListeners(Class<? extends Event> eventType) {
        listeners.remove(eventType);
    }

    /**
     * 모든 리스너 해제
     */
    public void clearAll() {
        listeners.clear();
    }

    /**
     * 등록된 리스너 수
     */
    public int getListenerCount(Class<? extends Event> eventType) {
        List<RegisteredListener<?>> list = listeners.get(eventType);
        return list != null ? list.size() : 0;
    }

    /**
     * 특정 modId로 등록된 모든 리스너 해제.
     * 모드 비활성화/리로드 시 사용.
     * 
     * @param modId 해제할 모드 ID
     * @return 해제된 리스너 수
     */
    public static int unsubscribeAll(String modId) {
        return INSTANCE.unregisterAll(modId);
    }

    private int unregisterAll(String modId) {
        if (modId == null)
            return 0;

        int removed = 0;
        for (List<RegisteredListener<?>> list : listeners.values()) {
            int before = list.size();
            list.removeIf(reg -> modId.equals(reg.modId));
            removed += (before - list.size());
        }

        if (removed > 0) {
            PulseLogger.info(LOG, "Unregistered {} listeners for mod: {}", removed, modId);
        }
        return removed;
    }

    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    private static class RegisteredListener<T extends Event> {
        final EventListener<T> listener;
        final EventPriority priority;
        final String modId; // 예외 격리용 모드 식별자

        RegisteredListener(EventListener<T> listener, EventPriority priority, String modId) {
            this.listener = listener;
            this.priority = priority;
            this.modId = modId;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\EventListener.java =====

package com.pulse.event;

/**
 * 이벤트 리스너 함수형 인터페이스.
 * 
 * 사용 예:
 * EventBus.subscribe(GameTickEvent.class, event -> {
 *     System.out.println("Tick!");
 * });
 */
@FunctionalInterface
public interface EventListener<T extends Event> {
    
    /**
     * 이벤트 처리
     * @param event 발생한 이벤트
     */
    void onEvent(T event);
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\EventPriority.java =====

package com.pulse.event;

/**
 * 이벤트 리스너 우선순위.
 * 높은 우선순위가 먼저 실행됨.
 */
public enum EventPriority {
    
    /**
     * 가장 먼저 실행 (모니터링, 로깅용)
     */
    HIGHEST(100),
    
    /**
     * 높은 우선순위
     */
    HIGH(75),
    
    /**
     * 기본 우선순위
     */
    NORMAL(50),
    
    /**
     * 낮은 우선순위
     */
    LOW(25),
    
    /**
     * 가장 나중에 실행 (최종 처리용)
     */
    LOWEST(0);
    
    private final int value;
    
    EventPriority(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\gui\GuiCloseEvent.java =====

package com.pulse.event.gui;

import com.pulse.event.Event;

/**
 * GUI 닫힘 이벤트.
 */
public class GuiCloseEvent extends Event {

    private final Object gui;
    private final String guiType;

    public GuiCloseEvent(Object gui, String guiType) {
        this.gui = gui;
        this.guiType = guiType;
    }

    public Object getGui() {
        return gui;
    }

    public String getGuiType() {
        return guiType;
    }

    @Override
    public String getEventName() {
        return "GuiClose";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\gui\GuiOpenEvent.java =====

package com.pulse.event.gui;

import com.pulse.event.Event;

/**
 * GUI 열림 이벤트.
 * 취소 가능 - GUI 열기를 막을 수 있음.
 */
public class GuiOpenEvent extends Event {

    private final Object gui; // UIElement 또는 패널
    private final String guiType; // 식별자

    public GuiOpenEvent(Object gui, String guiType) {
        this.gui = gui;
        this.guiType = guiType;
    }

    public Object getGui() {
        return gui;
    }

    public String getGuiType() {
        return guiType;
    }

    @Override
    public String getEventName() {
        return "GuiOpen";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\gui\GuiRenderEvent.java =====

package com.pulse.event.gui;

import com.pulse.event.Event;

/**
 * GUI 렌더링 이벤트.
 * 커스텀 UI 요소를 그릴 수 있음.
 */
public class GuiRenderEvent extends Event {

    private final Object gui;
    private final String guiType;
    private final float deltaTime;

    public GuiRenderEvent(Object gui, String guiType, float deltaTime) {
        this.gui = gui;
        this.guiType = guiType;
        this.deltaTime = deltaTime;
    }

    public Object getGui() {
        return gui;
    }

    public String getGuiType() {
        return guiType;
    }

    public float getDeltaTime() {
        return deltaTime;
    }

    @Override
    public String getEventName() {
        return "GuiRender";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\inventory\InventoryEvent.java =====

package com.pulse.event.inventory;

import com.pulse.event.Event;

/**
 * 인벤토리 관련 이벤트 기본 클래스.
 */
public abstract class InventoryEvent extends Event {

    private final Object inventory; // IsoGameCharacter의 인벤토리
    private final Object item; // InventoryItem
    private final int slot;

    protected InventoryEvent(Object inventory, Object item, int slot) {
        this.inventory = inventory;
        this.item = item;
        this.slot = slot;
    }

    public Object getInventory() {
        return inventory;
    }

    public Object getItem() {
        return item;
    }

    public int getSlot() {
        return slot;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\inventory\ItemAddedEvent.java =====

package com.pulse.event.inventory;

/**
 * 아이템이 인벤토리에 추가될 때 발생.
 */
public class ItemAddedEvent extends InventoryEvent {

    public ItemAddedEvent(Object inventory, Object item, int slot) {
        super(inventory, item, slot);
    }

    @Override
    public String getEventName() {
        return "ItemAdded";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\inventory\ItemMovedEvent.java =====

package com.pulse.event.inventory;

/**
 * 아이템이 인벤토리 내에서 이동될 때 발생.
 */
public class ItemMovedEvent extends InventoryEvent {

    private final Object targetInventory;
    private final int targetSlot;

    public ItemMovedEvent(Object inventory, Object item, int slot,
            Object targetInventory, int targetSlot) {
        super(inventory, item, slot);
        this.targetInventory = targetInventory;
        this.targetSlot = targetSlot;
    }

    public Object getTargetInventory() {
        return targetInventory;
    }

    public int getTargetSlot() {
        return targetSlot;
    }

    @Override
    public String getEventName() {
        return "ItemMoved";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\inventory\ItemRemovedEvent.java =====

package com.pulse.event.inventory;

/**
 * 아이템이 인벤토리에서 제거될 때 발생.
 */
public class ItemRemovedEvent extends InventoryEvent {

    public ItemRemovedEvent(Object inventory, Object item, int slot) {
        super(inventory, item, slot);
    }

    @Override
    public String getEventName() {
        return "ItemRemoved";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\lifecycle\GameInitEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 게임 라이프사이클 이벤트들
 */

// ─────────────────────────────────────────────────────────────
// 게임 시작/종료
// ─────────────────────────────────────────────────────────────

/**
 * 게임 초기화 완료 시 발생
 */
public class GameInitEvent extends Event {
    public GameInitEvent() {
        super(false);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\lifecycle\GameTickEndEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 게임 틱 종료 이벤트.
 * 
 * IsoWorld.update() 종료 직후에 발생합니다.
 * Echo에서 틱 소요 시간을 계산하고 분석하는 데 사용됩니다.
 * 
 * @since Pulse 1.2
 */
public class GameTickEndEvent extends Event {

    private final long tick;
    private final long durationNanos;

    public GameTickEndEvent(long tick, long durationNanos) {
        super(false); // 취소 불가
        this.tick = tick;
        this.durationNanos = durationNanos;
    }

    /**
     * 현재 틱 번호
     */
    public long getTick() {
        return tick;
    }

    /**
     * 틱 소요 시간 (나노초)
     */
    public long getDurationNanos() {
        return durationNanos;
    }

    /**
     * 틱 소요 시간 (밀리초)
     */
    public double getDurationMs() {
        return durationNanos / 1_000_000.0;
    }

    @Override
    public String getEventName() {
        return "GameTickEnd";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\lifecycle\GameTickEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 게임 틱마다 발생하는 이벤트
 */
public class GameTickEvent extends Event {
    
    private final long tick;
    private final float deltaTime;
    
    public GameTickEvent(long tick, float deltaTime) {
        super(false);  // 취소 불가
        this.tick = tick;
        this.deltaTime = deltaTime;
    }
    
    /**
     * 현재 틱 번호
     */
    public long getTick() {
        return tick;
    }
    
    /**
     * 이전 틱과의 시간 간격 (초)
     */
    public float getDeltaTime() {
        return deltaTime;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\lifecycle\GameTickStartEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 게임 틱 시작 이벤트.
 * 
 * IsoWorld.update() 진입 직전에 발생합니다.
 * Echo의 TickPhaseProfiler에서 정확한 틱 시작점을 측정하는 데 사용됩니다.
 * 
 * @since Pulse 1.2
 */
public class GameTickStartEvent extends Event {

    private final long tick;
    private final long startTimeNanos;

    public GameTickStartEvent(long tick) {
        super(false); // 취소 불가
        this.tick = tick;
        this.startTimeNanos = System.nanoTime();
    }

    /**
     * 현재 틱 번호
     */
    public long getTick() {
        return tick;
    }

    /**
     * 틱 시작 시간 (나노초)
     */
    public long getStartTimeNanos() {
        return startTimeNanos;
    }

    @Override
    public String getEventName() {
        return "GameTickStart";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\lifecycle\MainMenuRenderEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 메인 메뉴 렌더 이벤트
 * 
 * MainScreenState.render()가 호출될 때 발생합니다.
 * Echo가 이 이벤트를 구독하여 게임에서 메뉴로 복귀했는지 감지할 수 있습니다.
 * 
 * @since Pulse 2.1
 */
public class MainMenuRenderEvent extends Event {

    private static long renderCount = 0;

    public MainMenuRenderEvent() {
        super(false);
        renderCount++;
    }

    /**
     * 현재 렌더 카운트 (게임 시작 후 메뉴 렌더 횟수)
     */
    public long getRenderCount() {
        return renderCount;
    }

    /**
     * 렌더 카운트 리셋 (게임 진입 시)
     */
    public static void resetRenderCount() {
        renderCount = 0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\lifecycle\ModReloadEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 모드 리로드 이벤트.
 * 모드가 활성화/비활성화/리로드될 때 발생.
 */
public class ModReloadEvent extends Event {

    private final String modId;
    private final Action action;

    public enum Action {
        ENABLED, // 모드 활성화됨
        DISABLED, // 모드 비활성화됨
        RELOADED, // 소프트 리로드됨
        CONFIG_RELOADED, // 설정만 리로드됨
        HOT_SWAPPED // JAR 핫 스왑됨
    }

    public ModReloadEvent(String modId, Action action) {
        this.modId = modId;
        this.action = action;
    }

    public String getModId() {
        return modId;
    }

    public Action getAction() {
        return action;
    }

    @Override
    public String toString() {
        return "ModReloadEvent{modId='" + modId + "', action=" + action + "}";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\lifecycle\WorldLoadEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 월드 로드 시 발생
 */
public class WorldLoadEvent extends Event {
    
    private final String worldName;
    
    public WorldLoadEvent(String worldName) {
        super(false);
        this.worldName = worldName;
    }
    
    public String getWorldName() {
        return worldName;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\lifecycle\WorldUnloadEvent.java =====

package com.pulse.event.lifecycle;

import com.pulse.event.Event;

/**
 * 월드 언로드 시 발생
 */
public class WorldUnloadEvent extends Event {
    
    public WorldUnloadEvent() {
        super(false);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\multiplayer\PlayerConnectEvent.java =====

package com.pulse.event.multiplayer;

import com.pulse.event.Event;

/**
 * 플레이어 서버 접속 이벤트.
 * 취소 가능 - 접속을 거부할 수 있음.
 */
public class PlayerConnectEvent extends Event {

    private final Object connection; // UdpConnection
    private final String username;
    private final String steamId;
    private String kickReason;

    public PlayerConnectEvent(Object connection, String username, String steamId) {
        super(true); // cancellable
        this.connection = connection;
        this.username = username;
        this.steamId = steamId;
    }

    public Object getConnection() {
        return connection;
    }

    public String getUsername() {
        return username;
    }

    public String getSteamId() {
        return steamId;
    }

    /**
     * 접속 거부 - cancel()과 함께 사용.
     */
    public void kick(String reason) {
        this.kickReason = reason;
        cancel();
    }

    public String getKickReason() {
        return kickReason;
    }

    @Override
    public String getEventName() {
        return "PlayerConnect";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\multiplayer\PlayerDisconnectEvent.java =====

package com.pulse.event.multiplayer;

import com.pulse.event.Event;

/**
 * 플레이어 서버 연결 종료 이벤트.
 */
public class PlayerDisconnectEvent extends Event {

    private final Object connection;
    private final String username;
    private final DisconnectReason reason;

    public PlayerDisconnectEvent(Object connection, String username, DisconnectReason reason) {
        this.connection = connection;
        this.username = username;
        this.reason = reason;
    }

    public Object getConnection() {
        return connection;
    }

    public String getUsername() {
        return username;
    }

    public DisconnectReason getReason() {
        return reason;
    }

    @Override
    public String getEventName() {
        return "PlayerDisconnect";
    }

    public enum DisconnectReason {
        QUIT, // 정상 종료
        TIMEOUT, // 타임아웃
        KICKED, // 강퇴
        BANNED, // 밴
        SERVER_FULL, // 서버 가득 참
        CONNECTION_LOST // 연결 끊김
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\npc\ZombieBehaviorEvent.java =====

package com.pulse.event.npc;

/**
 * 좀비 AI 행동 결정 시 발생.
 * 취소 가능 - 행동을 막거나 변경할 수 있음.
 */
public class ZombieBehaviorEvent extends ZombieEvent {

    private BehaviorType behavior;
    private Object target; // 대상 (플레이어, 위치 등)

    public ZombieBehaviorEvent(Object zombie, BehaviorType behavior, Object target) {
        super(zombie);
        this.behavior = behavior;
        this.target = target;
    }

    public BehaviorType getBehavior() {
        return behavior;
    }

    public void setBehavior(BehaviorType behavior) {
        this.behavior = behavior;
    }

    public Object getTarget() {
        return target;
    }

    public void setTarget(Object target) {
        this.target = target;
    }

    @Override
    public String getEventName() {
        return "ZombieBehavior";
    }

    public enum BehaviorType {
        IDLE, // 대기
        WANDER, // 배회
        CHASE, // 추적
        ATTACK, // 공격
        INVESTIGATE, // 조사 (소리/시야)
        FEED, // 시체 먹기
        CLIMB, // 등반
        BREAK_DOOR, // 문 부수기
        BREAK_WINDOW // 창문 부수기
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\npc\ZombieDeathEvent.java =====

package com.pulse.event.npc;

/**
 * 좀비가 사망할 때 발생.
 */
public class ZombieDeathEvent extends ZombieEvent {

    private final Object killer; // IsoGameCharacter (플레이어 또는 다른 NPC)
    private final Object weapon; // 사용된 무기 (null 가능)

    public ZombieDeathEvent(Object zombie, Object killer, Object weapon) {
        super(zombie);
        this.killer = killer;
        this.weapon = weapon;
    }

    public Object getKiller() {
        return killer;
    }

    public Object getWeapon() {
        return weapon;
    }

    public boolean hasKiller() {
        return killer != null;
    }

    @Override
    public String getEventName() {
        return "ZombieDeath";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\npc\ZombieEvent.java =====

package com.pulse.event.npc;

import com.pulse.event.Event;

/**
 * 좀비/NPC 관련 이벤트 기본 클래스.
 */
public abstract class ZombieEvent extends Event {

    private final Object zombie; // IsoZombie

    protected ZombieEvent(Object zombie) {
        this.zombie = zombie;
    }

    public Object getZombie() {
        return zombie;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\npc\ZombieSpawnEvent.java =====

package com.pulse.event.npc;

/**
 * 좀비가 스폰될 때 발생.
 * 취소 가능 - 스폰을 막을 수 있음.
 */
public class ZombieSpawnEvent extends ZombieEvent {

    private final float x, y, z;
    private final SpawnReason reason;

    public ZombieSpawnEvent(Object zombie, float x, float y, float z, SpawnReason reason) {
        super(zombie);
        this.x = x;
        this.y = y;
        this.z = z;
        this.reason = reason;
    }

    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }

    public float getZ() {
        return z;
    }

    public SpawnReason getReason() {
        return reason;
    }

    @Override
    public String getEventName() {
        return "ZombieSpawn";
    }

    public enum SpawnReason {
        NATURAL, // 자연 스폰
        MIGRATION, // 이동/마이그레이션
        SOUND, // 소리로 인한 스폰
        META, // 메타 이벤트
        RESPAWN, // 리스폰
        SCRIPTED // 스크립트에 의한 스폰
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\npc\ZombieUpdateEndEvent.java =====

package com.pulse.event.npc;

import com.pulse.event.Event;

/**
 * 좀비 업데이트 루프 종료 이벤트.
 * 
 * 프레임당 모든 좀비 업데이트가 완료된 후 발생합니다.
 * Fuse의 병목 분석에 사용됩니다.
 * 
 * @since Pulse 1.2
 */
public class ZombieUpdateEndEvent extends Event {

    private final long durationNanos;
    private final int updatedCount;

    public ZombieUpdateEndEvent(long durationNanos, int updatedCount) {
        super(false);
        this.durationNanos = durationNanos;
        this.updatedCount = updatedCount;
    }

    /**
     * 총 업데이트 소요 시간 (나노초)
     */
    public long getDurationNanos() {
        return durationNanos;
    }

    /**
     * 업데이트된 좀비 수
     */
    public int getUpdatedCount() {
        return updatedCount;
    }

    /**
     * 좀비당 평균 업데이트 시간 (나노초)
     */
    public double getAveragePerZombie() {
        return updatedCount > 0 ? (double) durationNanos / updatedCount : 0;
    }

    @Override
    public String getEventName() {
        return "ZombieUpdateEnd";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\npc\ZombieUpdateStartEvent.java =====

package com.pulse.event.npc;

import com.pulse.event.Event;

/**
 * 좀비 업데이트 루프 시작 이벤트.
 * 
 * 프레임당 모든 좀비 업데이트가 시작되기 전에 발생합니다.
 * Fuse의 AI 최적화 결정에 사용됩니다.
 * 
 * @since Pulse 1.2
 */
public class ZombieUpdateStartEvent extends Event {

    private final long startTimeNanos;
    private final int zombieCount;

    public ZombieUpdateStartEvent(int zombieCount) {
        super(false);
        this.startTimeNanos = System.nanoTime();
        this.zombieCount = zombieCount;
    }

    /**
     * 업데이트 시작 시간 (나노초)
     */
    public long getStartTimeNanos() {
        return startTimeNanos;
    }

    /**
     * 업데이트할 좀비 수
     */
    public int getZombieCount() {
        return zombieCount;
    }

    @Override
    public String getEventName() {
        return "ZombieUpdateStart";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\package-info.java =====

/**
 * Pulse Event System.
 * 
 * <p>
 * 이벤트 기반 통신을 위한 이벤트 버스 및 이벤트 타입 정의.
 * </p>
 * 
 * <h2>주요 클래스</h2>
 * <ul>
 * <li>{@link com.pulse.event.EventBus} - 이벤트 발행/구독 관리</li>
 * <li>{@link com.pulse.event.Event} - 이벤트 기본 클래스</li>
 * <li>{@link com.pulse.event.EventListener} - 이벤트 리스너 인터페이스</li>
 * <li>{@link com.pulse.event.EventPriority} - 리스너 우선순위</li>
 * </ul>
 * 
 * <h2>하위 패키지</h2>
 * <ul>
 * <li>{@code lifecycle} - 게임 생명주기 이벤트 (GameTickStart, GameTickEnd, WorldLoad
 * 등)</li>
 * <li>{@code player} - 플레이어 관련 이벤트</li>
 * <li>{@code world} - 월드 관련 이벤트</li>
 * <li>{@code network} - 네트워크 이벤트</li>
 * </ul>
 * 
 * <h2>사용 예</h2>
 * 
 * <pre>{@code
 * EventBus.subscribe(GameTickEvent.class, event -> {
 *     System.out.println("Tick: " + event.getTick());
 * });
 * 
 * EventBus.post(new GameTickEvent(tickCount));
 * }</pre>
 * 
 * @since 1.0
 */
package com.pulse.event;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\player\PlayerDamageEvent.java =====

package com.pulse.event.player;

/**
 * 플레이어가 데미지를 받을 때 발생 (취소 가능)
 */
public class PlayerDamageEvent extends PlayerEvent {
    
    private float damage;
    private final String damageType;
    
    public PlayerDamageEvent(Object player, float damage, String damageType) {
        super(player, true);  // 취소 가능
        this.damage = damage;
        this.damageType = damageType;
    }
    
    public float getDamage() {
        return damage;
    }
    
    /**
     * 데미지 양 수정
     */
    public void setDamage(float damage) {
        this.damage = Math.max(0, damage);
    }
    
    public String getDamageType() {
        return damageType;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\player\PlayerEvent.java =====

package com.pulse.event.player;

import com.pulse.access.AccessWidener;
import com.pulse.event.Event;

/**
 * 플레이어 관련 이벤트 기본 클래스.
 * 
 * 플레이어 객체는 Object 타입으로 저장됩니다.
 * 이는 의도적인 설계로, Pulse가 PZ 클래스에 직접 의존하지 않고
 * 런타임에 리플렉션을 통해 접근하기 위함입니다.
 * 
 * IsoPlayer 메서드 접근 예시:
 * 
 * <pre>
 * PlayerEvent event = ...;
 * // 직접 캐스팅 (PZ 클래스패스 필요)
 * IsoPlayer player = (IsoPlayer) event.getPlayer();
 * 
 * // 또는 헬퍼 메서드 사용
 * String username = event.getPlayerUsername();
 * float x = event.getPlayerX();
 * </pre>
 */
public abstract class PlayerEvent extends Event {

    private final Object player;

    protected PlayerEvent(Object player, boolean cancellable) {
        super(cancellable);
        this.player = player;
    }

    /**
     * 플레이어 객체 반환.
     * 런타임에서 zombie.characters.IsoPlayer 타입입니다.
     * 
     * @return 플레이어 객체 (IsoPlayer)
     */
    public Object getPlayer() {
        return player;
    }

    // ─────────────────────────────────────────────────────────────
    // 플레이어 정보 헬퍼 메서드 (리플렉션 기반)
    // ─────────────────────────────────────────────────────────────

    /**
     * 플레이어 유저네임 반환.
     */
    public String getPlayerUsername() {
        if (player == null)
            return null;
        try {
            Object result = AccessWidener.invoke(player, "getUsername");
            return result != null ? result.toString() : null;
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 플레이어 X 좌표.
     */
    public float getPlayerX() {
        if (player == null)
            return 0;
        try {
            Object result = AccessWidener.invoke(player, "getX");
            return result instanceof Number n ? n.floatValue() : 0;
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * 플레이어 Y 좌표.
     */
    public float getPlayerY() {
        if (player == null)
            return 0;
        try {
            Object result = AccessWidener.invoke(player, "getY");
            return result instanceof Number n ? n.floatValue() : 0;
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * 플레이어 Z 좌표 (층).
     */
    public float getPlayerZ() {
        if (player == null)
            return 0;
        try {
            Object result = AccessWidener.invoke(player, "getZ");
            return result instanceof Number n ? n.floatValue() : 0;
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * 플레이어 체력.
     */
    public float getPlayerHealth() {
        if (player == null)
            return 0;
        try {
            Object bodyDamage = AccessWidener.invoke(player, "getBodyDamage");
            if (bodyDamage != null) {
                Object result = AccessWidener.invoke(bodyDamage, "getOverallBodyHealth");
                return result instanceof Number n ? n.floatValue() : 0;
            }
        } catch (Exception e) {
            // 무시
        }
        return 0;
    }

    /**
     * 플레이어 생존 여부.
     */
    public boolean isPlayerAlive() {
        if (player == null)
            return false;
        try {
            Object result = AccessWidener.invoke(player, "isDead");
            return !(result instanceof Boolean b && b);
        } catch (Exception e) {
            return true;
        }
    }

    /**
     * 플레이어가 멀티플레이어 클라이언트인지.
     */
    public boolean isLocalPlayer() {
        if (player == null)
            return false;
        try {
            Object result = AccessWidener.invoke(player, "isLocalPlayer");
            return result instanceof Boolean b && b;
        } catch (Exception e) {
            return false;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\player\PlayerUpdateEndEvent.java =====

package com.pulse.event.player;

import com.pulse.event.Event;

/**
 * 플레이어 업데이트 종료 이벤트.
 * 
 * IsoPlayer.update() 종료 시 발생합니다.
 * 
 * @since Pulse 1.2
 */
public class PlayerUpdateEndEvent extends Event {

    private final long durationNanos;

    public PlayerUpdateEndEvent(long durationNanos) {
        super(false);
        this.durationNanos = durationNanos;
    }

    /**
     * 업데이트 소요 시간 (나노초)
     */
    public long getDurationNanos() {
        return durationNanos;
    }

    @Override
    public String getEventName() {
        return "PlayerUpdateEnd";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\player\PlayerUpdateEvent.java =====

package com.pulse.event.player;

/**
 * 플레이어 업데이트 시 발생
 */
public class PlayerUpdateEvent extends PlayerEvent {
    
    public PlayerUpdateEvent(Object player) {
        super(player, false);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\player\PlayerUpdateStartEvent.java =====

package com.pulse.event.player;

import com.pulse.event.Event;

/**
 * 플레이어 업데이트 시작 이벤트.
 * 
 * IsoPlayer.update() 진입 시 발생합니다.
 * Nerve UI 이벤트에 사용됩니다.
 * 
 * @since Pulse 1.2
 */
public class PlayerUpdateStartEvent extends Event {

    private final long startTimeNanos;

    public PlayerUpdateStartEvent() {
        super(false);
        this.startTimeNanos = System.nanoTime();
    }

    /**
     * 업데이트 시작 시간 (나노초)
     */
    public long getStartTimeNanos() {
        return startTimeNanos;
    }

    @Override
    public String getEventName() {
        return "PlayerUpdateStart";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\render\RenderFrameEvent.java =====

package com.pulse.event.render;

import com.pulse.event.Event;

/**
 * 렌더 프레임 이벤트.
 * 
 * 화면 렌더링 루프에서 발생합니다.
 * Echo의 프레임 타임 분석에 사용됩니다.
 * 
 * @since Pulse 1.2
 */
public class RenderFrameEvent extends Event {

    private final long frameNumber;
    private final long durationNanos;

    public RenderFrameEvent(long frameNumber, long durationNanos) {
        super(false);
        this.frameNumber = frameNumber;
        this.durationNanos = durationNanos;
    }

    /**
     * 프레임 번호
     */
    public long getFrameNumber() {
        return frameNumber;
    }

    /**
     * 프레임 렌더링 소요 시간 (나노초)
     */
    public long getDurationNanos() {
        return durationNanos;
    }

    /**
     * 프레임 렌더링 소요 시간 (밀리초)
     */
    public double getDurationMs() {
        return durationNanos / 1_000_000.0;
    }

    /**
     * 예상 FPS (이 프레임 기준)
     */
    public double getInstantFps() {
        return durationNanos > 0 ? 1_000_000_000.0 / durationNanos : 0;
    }

    @Override
    public String getEventName() {
        return "RenderFrame";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\save\PostLoadEvent.java =====

package com.pulse.event.save;

/**
 * 로드 후 이벤트.
 */
public class PostLoadEvent extends SaveEvent {

    private final boolean success;

    public PostLoadEvent(String saveName, SaveType saveType, boolean success) {
        super(saveName, saveType);
        this.success = success;
    }

    public boolean isSuccess() {
        return success;
    }

    @Override
    public String getEventName() {
        return "PostLoad";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\save\PostSaveEvent.java =====

package com.pulse.event.save;

/**
 * 저장 후 이벤트.
 */
public class PostSaveEvent extends SaveEvent {

    private final boolean success;

    public PostSaveEvent(String saveName, SaveType saveType, boolean success) {
        super(saveName, saveType);
        this.success = success;
    }

    public boolean isSuccess() {
        return success;
    }

    @Override
    public String getEventName() {
        return "PostSave";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\save\PreLoadEvent.java =====

package com.pulse.event.save;

/**
 * 로드 전 이벤트.
 */
public class PreLoadEvent extends SaveEvent {

    public PreLoadEvent(String saveName, SaveType saveType) {
        super(saveName, saveType);
    }

    @Override
    public String getEventName() {
        return "PreLoad";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\save\PreSaveEvent.java =====

package com.pulse.event.save;

/**
 * 저장 전 이벤트.
 * 모드 데이터를 저장하기 전에 준비할 수 있음.
 */
public class PreSaveEvent extends SaveEvent {

    public PreSaveEvent(String saveName, SaveType saveType) {
        super(saveName, saveType);
    }

    @Override
    public String getEventName() {
        return "PreSave";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\save\SaveEvent.java =====

package com.pulse.event.save;

import com.pulse.event.Event;

/**
 * 세이브 관련 이벤트 기본 클래스.
 */
public abstract class SaveEvent extends Event {

    private final String saveName;
    private final SaveType saveType;

    protected SaveEvent(String saveName, SaveType saveType) {
        this.saveName = saveName;
        this.saveType = saveType;
    }

    public String getSaveName() {
        return saveName;
    }

    public SaveType getSaveType() {
        return saveType;
    }

    public enum SaveType {
        WORLD, // 월드 데이터
        PLAYER, // 플레이어 데이터
        SERVER, // 서버 설정
        MOD // 모드 데이터
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\vehicle\VehicleCollisionEvent.java =====

package com.pulse.event.vehicle;

/**
 * 차량 충돌 시 발생.
 */
public class VehicleCollisionEvent extends VehicleEvent {

    private final Object otherObject; // 충돌 대상 (차량, 좀비, 건물 등)
    private final float impactForce;

    public VehicleCollisionEvent(Object vehicle, Object otherObject, float impactForce) {
        super(vehicle);
        this.otherObject = otherObject;
        this.impactForce = impactForce;
    }

    public Object getOtherObject() {
        return otherObject;
    }

    public float getImpactForce() {
        return impactForce;
    }

    @Override
    public String getEventName() {
        return "VehicleCollision";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\vehicle\VehicleEnterEvent.java =====

package com.pulse.event.vehicle;

/**
 * 플레이어가 차량에 탑승할 때 발생.
 * 취소 가능 - 탑승을 막을 수 있음.
 */
public class VehicleEnterEvent extends VehicleEvent {

    private final Object player;
    private final int seat; // 좌석 번호 (0 = 운전석)

    public VehicleEnterEvent(Object vehicle, Object player, int seat) {
        super(vehicle);
        this.player = player;
        this.seat = seat;
    }

    public Object getPlayer() {
        return player;
    }

    public int getSeat() {
        return seat;
    }

    public boolean isDriver() {
        return seat == 0;
    }

    @Override
    public String getEventName() {
        return "VehicleEnter";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\vehicle\VehicleEvent.java =====

package com.pulse.event.vehicle;

import com.pulse.event.Event;

/**
 * 차량 관련 이벤트 기본 클래스.
 */
public abstract class VehicleEvent extends Event {

    private final Object vehicle; // BaseVehicle

    protected VehicleEvent(Object vehicle) {
        this.vehicle = vehicle;
    }

    public Object getVehicle() {
        return vehicle;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\vehicle\VehicleExitEvent.java =====

package com.pulse.event.vehicle;

/**
 * 플레이어가 차량에서 하차할 때 발생.
 */
public class VehicleExitEvent extends VehicleEvent {

    private final Object player;
    private final int seat;

    public VehicleExitEvent(Object vehicle, Object player, int seat) {
        super(vehicle);
        this.player = player;
        this.seat = seat;
    }

    public Object getPlayer() {
        return player;
    }

    public int getSeat() {
        return seat;
    }

    @Override
    public String getEventName() {
        return "VehicleExit";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\world\ChunkLoadEvent.java =====

package com.pulse.event.world;

import com.pulse.event.Event;

/**
 * 청크 로드 이벤트.
 */
public class ChunkLoadEvent extends Event {

    private final int chunkX;
    private final int chunkY;

    public ChunkLoadEvent(int chunkX, int chunkY) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
    }

    public int getChunkX() {
        return chunkX;
    }

    public int getChunkY() {
        return chunkY;
    }

    @Override
    public String getEventName() {
        return "ChunkLoad";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\event\world\ChunkUnloadEvent.java =====

package com.pulse.event.world;

import com.pulse.event.Event;

/**
 * 청크 언로드 이벤트.
 */
public class ChunkUnloadEvent extends Event {

    private final int chunkX;
    private final int chunkY;

    public ChunkUnloadEvent(int chunkX, int chunkY) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
    }

    public int getChunkX() {
        return chunkX;
    }

    public int getChunkY() {
        return chunkY;
    }

    @Override
    public String getEventName() {
        return "ChunkUnload";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\handler\KahluaCallExtractor.java =====

package com.pulse.handler;

import com.pulse.api.log.PulseLogger;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Kahlua Lua 호출 추출기.
 * 
 * <p>
 * MixinKahluaThread에서 분리된 리플렉션 로직을 캡슐화합니다.
 * Multi-Layer Cascading Extraction 전략을 사용하여 Lua 함수 객체를 추출합니다.
 * </p>
 * 
 * <h3>Extraction Priority:</h3>
 * <ol>
 * <li>Stack Top: getTop() - nArgs - 1 → objectStack[pos]</li>
 * <li>Direct Stack: objectStack + top field</li>
 * <li>Callframe closure (works for nested calls)</li>
 * <li>Late extraction at RETURN</li>
 * <li>String fallback (guaranteed)</li>
 * </ol>
 * 
 * @since Pulse 1.6 - Extracted from MixinKahluaThread
 */
public final class KahluaCallExtractor {

    private static final String LOG = "Pulse/KahluaExtractor";

    // Singleton instance
    private static final KahluaCallExtractor INSTANCE = new KahluaCallExtractor();

    // ═══════════════════════════════════════════════════════════════
    // Statistics Tracking
    // ═══════════════════════════════════════════════════════════════

    private final AtomicBoolean loggedStackTop = new AtomicBoolean(false);
    private final AtomicBoolean loggedDirectStack = new AtomicBoolean(false);
    private final AtomicBoolean loggedCallFrame = new AtomicBoolean(false);
    private final AtomicLong successCount = new AtomicLong(0);
    private final AtomicLong fallbackCount = new AtomicLong(0);

    // ═══════════════════════════════════════════════════════════════
    // Reflection Cache
    // ═══════════════════════════════════════════════════════════════

    private volatile Field currentCoroutineField;
    private volatile Method getTopMethod;
    private volatile Method getObjectFromStackMethod;
    private volatile Field objectStackField;
    private volatile Field topField;
    private volatile Method currentCallFrameMethod;
    private volatile Field closureField;
    private volatile Field javaFunctionField;
    private volatile boolean reflectionInitialized = false;
    private volatile boolean reflectionFailed = false;

    // Class references (loaded at runtime)
    private volatile Class<?> kahluaThreadClass;
    private volatile Class<?> coroutineClass;
    private volatile Class<?> luaCallFrameClass;
    private volatile Class<?> luaClosureClass;
    private volatile Class<?> javaFunctionClass;

    private KahluaCallExtractor() {
        // Singleton
    }

    /**
     * Get singleton instance.
     */
    public static KahluaCallExtractor getInstance() {
        return INSTANCE;
    }

    // ═══════════════════════════════════════════════════════════════
    // Public API
    // ═══════════════════════════════════════════════════════════════

    /**
     * Extract callable from KahluaThread at call/pcall start.
     * 
     * @param kahluaThread The KahluaThread instance (this pointer from Mixin)
     * @param callType     "call" or "pcall"
     * @param nArgs        Number of arguments
     * @return Extracted callable object, or null if extraction failed
     */
    public Object extract(Object kahluaThread, String callType, int nArgs) {
        if (reflectionFailed) {
            return null;
        }

        try {
            if (!reflectionInitialized) {
                initReflection();
            }
            if (currentCoroutineField == null) {
                return null;
            }

            Object coroutine = currentCoroutineField.get(kahluaThread);
            if (coroutine == null) {
                return null;
            }

            // Strategy 1: Stack Top (most accurate for call/pcall HEAD)
            Object result = extractViaStackTop(coroutine, nArgs);
            if (result != null) {
                successCount.incrementAndGet();
                return result;
            }

            // Strategy 2: Direct Stack access
            result = extractViaDirectStack(coroutine, nArgs);
            if (result != null) {
                successCount.incrementAndGet();
                return result;
            }

            // Strategy 3: Callframe (works for nested calls)
            result = extractViaCallFrame(coroutine);
            if (result != null) {
                successCount.incrementAndGet();
                return result;
            }

        } catch (Exception e) {
            // Silent - will use fallback
        }
        return null;
    }

    /**
     * Late extraction at RETURN point.
     * 
     * @param kahluaThread The KahluaThread instance
     * @param nArgs        Number of arguments
     * @return Extracted callable object, or null if extraction failed
     */
    public Object lateExtract(Object kahluaThread, int nArgs) {
        if (reflectionFailed || currentCoroutineField == null) {
            return null;
        }
        try {
            Object coroutine = currentCoroutineField.get(kahluaThread);
            if (coroutine != null) {
                Object result = extractViaCallFrame(coroutine);
                if (result != null) {
                    successCount.incrementAndGet();
                }
                return result;
            }
        } catch (Exception e) {
            // Silent
        }
        return null;
    }

    /**
     * Create fallback string when all extraction strategies fail.
     */
    public String createFallback(String callType, int nArgs) {
        fallbackCount.incrementAndGet();
        return callType + ":" + nArgs;
    }

    /**
     * Check if extractor is ready.
     */
    public boolean isReady() {
        return reflectionInitialized && !reflectionFailed;
    }

    // ═══════════════════════════════════════════════════════════════
    // Statistics
    // ═══════════════════════════════════════════════════════════════

    public long getSuccessCount() {
        return successCount.get();
    }

    public long getFallbackCount() {
        return fallbackCount.get();
    }

    public double getSuccessRate() {
        long total = successCount.get() + fallbackCount.get();
        if (total == 0)
            return 0.0;
        return (double) successCount.get() / total * 100.0;
    }

    // ═══════════════════════════════════════════════════════════════
    // Extraction Strategies
    // ═══════════════════════════════════════════════════════════════

    /**
     * Strategy 1: Stack Top via getTop().
     */
    private Object extractViaStackTop(Object coroutine, int nArgs) {
        try {
            if (getTopMethod != null && getObjectFromStackMethod != null) {
                int top = (Integer) getTopMethod.invoke(coroutine);
                int funcPos = top - nArgs - 1;
                if (funcPos >= 0) {
                    Object func = getObjectFromStackMethod.invoke(coroutine, funcPos);
                    if (isLuaCallable(func)) {
                        if (!loggedStackTop.get()) {
                            PulseLogger.debug(LOG, "✓ Strategy 1: Stack Top extraction works!");
                            loggedStackTop.set(true);
                        }
                        return func;
                    }
                }
            }
        } catch (Exception e) {
            // Silent - try next strategy
        }
        return null;
    }

    /**
     * Strategy 2: Direct objectStack access.
     */
    private Object extractViaDirectStack(Object coroutine, int nArgs) {
        try {
            if (objectStackField != null && topField != null) {
                Object[] stack = (Object[]) objectStackField.get(coroutine);
                int top = topField.getInt(coroutine);
                int funcPos = top - nArgs - 1;
                if (stack != null && funcPos >= 0 && funcPos < stack.length) {
                    Object func = stack[funcPos];
                    if (isLuaCallable(func)) {
                        if (!loggedDirectStack.get()) {
                            PulseLogger.debug(LOG, "✓ Strategy 2: Direct Stack works!");
                            loggedDirectStack.set(true);
                        }
                        return func;
                    }
                }
            }
        } catch (Exception e) {
            // Silent - try next strategy
        }
        return null;
    }

    /**
     * Strategy 3: Callframe closure.
     */
    private Object extractViaCallFrame(Object coroutine) {
        try {
            if (currentCallFrameMethod != null) {
                Object frame = currentCallFrameMethod.invoke(coroutine);
                if (frame != null) {
                    if (closureField != null) {
                        Object closure = closureField.get(frame);
                        if (closure != null) {
                            if (!loggedCallFrame.get()) {
                                PulseLogger.debug(LOG, "✓ Strategy 3: Callframe closure works!");
                                loggedCallFrame.set(true);
                            }
                            return closure;
                        }
                    }
                    if (javaFunctionField != null) {
                        Object javaFunc = javaFunctionField.get(frame);
                        if (javaFunc != null) {
                            return javaFunc;
                        }
                    }
                }
            }
        } catch (Exception e) {
            // Silent
        }
        return null;
    }

    /**
     * Check if object is a Lua callable (LuaClosure or JavaFunction).
     */
    private boolean isLuaCallable(Object obj) {
        if (obj == null)
            return false;
        if (luaClosureClass != null && luaClosureClass.isInstance(obj))
            return true;
        if (javaFunctionClass != null && javaFunctionClass.isInstance(obj))
            return true;
        // Fallback: check class name
        String className = obj.getClass().getName();
        return className.contains("LuaClosure") || className.contains("JavaFunction");
    }

    // ═══════════════════════════════════════════════════════════════
    // Reflection Initialization
    // ═══════════════════════════════════════════════════════════════

    private synchronized void initReflection() {
        if (reflectionInitialized) {
            return;
        }

        try {
            // Load Kahlua classes
            kahluaThreadClass = Class.forName("se.krka.kahlua.vm.KahluaThread");
            coroutineClass = Class.forName("se.krka.kahlua.vm.Coroutine");
            luaCallFrameClass = Class.forName("se.krka.kahlua.vm.LuaCallFrame");

            try {
                luaClosureClass = Class.forName("se.krka.kahlua.vm.LuaClosure");
            } catch (ClassNotFoundException e) {
                // Optional
            }

            try {
                javaFunctionClass = Class.forName("se.krka.kahlua.vm.JavaFunction");
            } catch (ClassNotFoundException e) {
                // Optional
            }

            // KahluaThread.currentCoroutine
            currentCoroutineField = getFieldSafe(kahluaThreadClass, "currentCoroutine");
            if (currentCoroutineField != null) {
                PulseLogger.debug(LOG, "✓ currentCoroutine field");
            }

            // Coroutine.getTop()
            getTopMethod = getMethodSafe(coroutineClass, "getTop");
            if (getTopMethod != null) {
                PulseLogger.debug(LOG, "✓ getTop()");
            }

            // Coroutine.getObjectFromStack(int)
            getObjectFromStackMethod = getMethodSafe(coroutineClass, "getObjectFromStack", int.class);
            if (getObjectFromStackMethod != null) {
                PulseLogger.debug(LOG, "✓ getObjectFromStack()");
            }

            // Coroutine.objectStack
            objectStackField = getFieldSafe(coroutineClass, "objectStack");
            if (objectStackField != null) {
                PulseLogger.debug(LOG, "✓ objectStack field");
            }

            // Coroutine.top
            topField = getFieldSafe(coroutineClass, "top");
            if (topField != null) {
                PulseLogger.debug(LOG, "✓ top field");
            }

            // Coroutine.currentCallFrame()
            currentCallFrameMethod = getMethodSafe(coroutineClass, "currentCallFrame");
            if (currentCallFrameMethod != null) {
                PulseLogger.debug(LOG, "✓ currentCallFrame()");
            }

            // LuaCallFrame.closure
            closureField = getFieldSafe(luaCallFrameClass, "closure");

            // LuaCallFrame.javaFunction
            javaFunctionField = getFieldSafe(luaCallFrameClass, "javaFunction");

            if (currentCoroutineField == null) {
                PulseLogger.error(LOG, "Missing currentCoroutine - fallback only mode");
                reflectionFailed = true;
            } else {
                PulseLogger.info(LOG, "✓ KahluaCallExtractor v1.0 ready (Multi-Layer)");
            }
        } catch (Exception e) {
            PulseLogger.error(LOG, "Init failed: " + e.getMessage());
            reflectionFailed = true;
        }
        reflectionInitialized = true;
    }

    /**
     * Safe field getter - tries public first, then declared.
     */
    private Field getFieldSafe(Class<?> clazz, String name) {
        try {
            return clazz.getField(name);
        } catch (NoSuchFieldException e) {
            try {
                Field f = clazz.getDeclaredField(name);
                f.setAccessible(true);
                return f;
            } catch (NoSuchFieldException ex) {
                return null;
            }
        }
    }

    /**
     * Safe method getter - tries public first, then declared.
     */
    private Method getMethodSafe(Class<?> clazz, String name, Class<?>... paramTypes) {
        try {
            return clazz.getMethod(name, paramTypes);
        } catch (NoSuchMethodException e) {
            try {
                Method m = clazz.getDeclaredMethod(name, paramTypes);
                m.setAccessible(true);
                return m;
            } catch (NoSuchMethodException ex) {
                return null;
            }
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\handler\TickEndResult.java =====

package com.pulse.handler;

/**
 * Tick 종료 결과 DTO.
 * 
 * <p>
 * WorldTickHandler.onUpdateEnd() 메서드의 결과를 담습니다.
 * Mixin에서 GameTickEvent 및 GameTickEndEvent 발행에 필요한 정보를 제공합니다.
 * </p>
 * 
 * @since Pulse 1.6
 */
public final class TickEndResult {

    private final long tickCount;
    private final long durationNanos;
    private final float deltaTime;

    /**
     * Create a new TickEndResult.
     * 
     * @param tickCount     Current tick count after this tick
     * @param durationNanos Tick duration in nanoseconds
     * @param deltaTime     Delta time in seconds (since last tick)
     */
    public TickEndResult(long tickCount, long durationNanos, float deltaTime) {
        this.tickCount = tickCount;
        this.durationNanos = durationNanos;
        this.deltaTime = deltaTime;
    }

    /**
     * Current tick count after this tick.
     */
    public long getTickCount() {
        return tickCount;
    }

    /**
     * Tick duration in nanoseconds.
     */
    public long getDurationNanos() {
        return durationNanos;
    }

    /**
     * Delta time in seconds (since last tick).
     */
    public float getDeltaTime() {
        return deltaTime;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\handler\TickStartResult.java =====

package com.pulse.handler;

/**
 * Tick 시작 결과 DTO.
 * 
 * <p>
 * WorldTickHandler.onUpdateStart() 메서드의 결과를 담습니다.
 * Mixin에서 이벤트 발행 결정에 필요한 정보를 제공합니다.
 * </p>
 * 
 * @since Pulse 1.6
 */
public final class TickStartResult {

    private final boolean firstTick;
    private final long startNanos;
    private final long expectedTickCount;

    /**
     * Create a new TickStartResult.
     * 
     * @param firstTick         True if this is the first tick (world just loaded)
     * @param startNanos        Tick start timestamp in nanoseconds
     * @param expectedTickCount Expected tick number after this tick completes
     */
    public TickStartResult(boolean firstTick, long startNanos, long expectedTickCount) {
        this.firstTick = firstTick;
        this.startNanos = startNanos;
        this.expectedTickCount = expectedTickCount;
    }

    /**
     * Whether this is the first tick (indicates WorldLoadEvent should be posted).
     */
    public boolean isFirstTick() {
        return firstTick;
    }

    /**
     * Tick start timestamp in nanoseconds.
     */
    public long getStartNanos() {
        return startNanos;
    }

    /**
     * Expected tick number after this tick completes.
     */
    public long getExpectedTickCount() {
        return expectedTickCount;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\handler\WorldTickHandler.java =====

package com.pulse.handler;

import com.pulse.api.log.PulseLogger;

/**
 * 월드 틱 상태 관리 핸들러.
 * 
 * <p>
 * IsoWorldMixin에서 분리된 틱 관리 로직을 캡슐화합니다.
 * 이벤트 발행은 Mixin에서 수행하고, 이 클래스는 상태 관리와 계산만 담당합니다.
 * </p>
 * 
 * <h3>책임:</h3>
 * <ul>
 * <li>틱 카운트 관리</li>
 * <li>틱 타이밍 계산 (duration, deltaTime)</li>
 * <li>첫 틱 감지</li>
 * <li>PulseMetrics 연동</li>
 * </ul>
 * 
 * @since Pulse 1.6 - Extracted from IsoWorldMixin
 */
public final class WorldTickHandler {

    private static final String LOG = "Pulse/WorldTickHandler";

    // Singleton instance
    private static final WorldTickHandler INSTANCE = new WorldTickHandler();

    // ═══════════════════════════════════════════════════════════════
    // State
    // ═══════════════════════════════════════════════════════════════

    private long tickCount = 0;
    private long lastTickTime = System.nanoTime();
    private long currentTickStartNanos = -1;
    private boolean firstTickProcessed = false;
    private boolean installed = false;

    private WorldTickHandler() {
        // Singleton
    }

    /**
     * Get singleton instance.
     */
    public static WorldTickHandler getInstance() {
        return INSTANCE;
    }

    // ═══════════════════════════════════════════════════════════════
    // Lifecycle
    // ═══════════════════════════════════════════════════════════════

    /**
     * Install handler (called at world load).
     */
    public synchronized void install() {
        if (installed) {
            return;
        }
        reset();
        installed = true;
        PulseLogger.debug(LOG, "Installed");
    }

    /**
     * Reset all state (for world reload).
     */
    public synchronized void reset() {
        tickCount = 0;
        lastTickTime = System.nanoTime();
        currentTickStartNanos = -1;
        firstTickProcessed = false;
        PulseLogger.debug(LOG, "State reset");
    }

    // ═══════════════════════════════════════════════════════════════
    // Tick Processing
    // ═══════════════════════════════════════════════════════════════

    /**
     * Called at IsoWorld.update() HEAD.
     * 
     * <p>
     * Records tick start time and determines if this is the first tick.
     * Caller (Mixin) is responsible for posting events.
     * </p>
     * 
     * @return Result containing firstTick flag and timing info
     */
    public TickStartResult onUpdateStart() {
        boolean isFirstTick = !firstTickProcessed;

        if (isFirstTick) {
            tickCount = 0;
            lastTickTime = System.nanoTime();
            firstTickProcessed = true;
            PulseLogger.debug(LOG, "First tick detected");
        }

        currentTickStartNanos = System.nanoTime();

        // Notify PulseMetrics (Echo integration)
        com.pulse.api.PulseMetrics.onTickStart();

        return new TickStartResult(isFirstTick, currentTickStartNanos, tickCount + 1);
    }

    /**
     * Called at IsoWorld.update() RETURN.
     * 
     * <p>
     * Calculates tick duration and delta time.
     * Caller (Mixin) is responsible for posting events and calling scheduler.
     * </p>
     * 
     * @return Result containing tick count, duration, and delta time
     */
    public TickEndResult onUpdateEnd() {
        long currentTime = System.nanoTime();

        // Calculate duration
        long tickDurationNanos = currentTime - currentTickStartNanos;

        // Notify PulseMetrics
        com.pulse.api.PulseMetrics.onTickEnd(tickDurationNanos);

        // Calculate delta time
        float deltaTime = (currentTime - lastTickTime) / 1_000_000_000.0f;
        lastTickTime = currentTime;

        // Increment tick count
        tickCount++;

        // Periodic debug logging
        if (tickCount % 1000 == 0) {
            PulseLogger.debug(LOG, "Tick #{}, deltaTime={}", tickCount, String.format("%.4f", deltaTime));
        }

        currentTickStartNanos = -1;

        return new TickEndResult(tickCount, tickDurationNanos, deltaTime);
    }

    // ═══════════════════════════════════════════════════════════════
    // Accessors
    // ═══════════════════════════════════════════════════════════════

    /**
     * Get current tick count.
     */
    public long getTickCount() {
        return tickCount;
    }

    /**
     * Get current tick start time in nanoseconds.
     * Returns -1 if not in an active tick.
     */
    public long getCurrentTickStartNanos() {
        return currentTickStartNanos;
    }

    /**
     * Whether the first tick has been processed.
     */
    public boolean isFirstTickProcessed() {
        return firstTickProcessed;
    }

    /**
     * Whether the handler is installed.
     */
    public boolean isInstalled() {
        return installed;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\hook\HookType.java =====

package com.pulse.hook;

import java.util.List;
import java.util.Objects;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Type-safe Hook 식별자.
 * 
 * 제네릭을 사용하여 콜백 타입의 안전성을 보장합니다.
 * 각 HookType은 특정 콜백 인터페이스와 연결됩니다.
 * 
 * @param <T> 이 Hook에 등록될 콜백 타입
 * @since Pulse 1.2
 */
public final class HookType<T> {

    private final String name;
    private final Class<T> callbackType;
    private final List<T> callbacks = new CopyOnWriteArrayList<>();

    private HookType(String name, Class<T> callbackType) {
        this.name = Objects.requireNonNull(name, "Hook name cannot be null");
        this.callbackType = Objects.requireNonNull(callbackType, "Callback type cannot be null");
    }

    /**
     * 새로운 HookType 생성
     * 
     * @param name         Hook 이름
     * @param callbackType 콜백 인터페이스 클래스
     * @return 새로운 HookType 인스턴스
     */
    public static <T> HookType<T> create(String name, Class<T> callbackType) {
        return new HookType<>(name, callbackType);
    }

    /**
     * Hook 이름
     */
    public String getName() {
        return name;
    }

    /**
     * 콜백 타입 클래스
     */
    public Class<T> getCallbackType() {
        return callbackType;
    }

    /**
     * 내부 콜백 리스트 (PulseHookRegistry 전용)
     */
    List<T> getCallbacksInternal() {
        return callbacks;
    }

    @Override
    public String toString() {
        return "HookType[" + name + "]";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        HookType<?> hookType = (HookType<?>) o;
        return name.equals(hookType.name) && callbackType.equals(hookType.callbackType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, callbackType);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\hook\HookTypes.java =====

package com.pulse.hook;

import com.pulse.api.profiler.IsoGridHook;
import com.pulse.api.profiler.PathfindingHook;
import com.pulse.api.profiler.TickPhaseHook;
import com.pulse.api.profiler.ZombieHook;

/**
 * 사전 정의된 Hook 타입들.
 * 
 * Echo, Fuse, Nerve에서 공통으로 사용되는 Hook 타입 상수입니다.
 * 각 타입은 해당하는 콜백 인터페이스와 연결됩니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // TickPhase 콜백 등록
 * PulseHookRegistry.register(HookTypes.TICK_PHASE, myTickPhaseCallback);
 * 
 * // Zombie 프로파일링 콜백 등록
 * PulseHookRegistry.register(HookTypes.ZOMBIE, myZombieCallback);
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class HookTypes {

    private HookTypes() {
        // Constants class
    }

    // ─────────────────────────────────────────────────────────────
    // Profiler Hooks (Echo/Fuse용)
    // ─────────────────────────────────────────────────────────────

    /**
     * Tick Phase 프로파일링 Hook
     * 
     * IsoWorld.update() 전후에 호출됩니다.
     */
    public static final HookType<TickPhaseHook.ITickPhaseCallback> TICK_PHASE = HookType.create("TICK_PHASE",
            TickPhaseHook.ITickPhaseCallback.class);

    /**
     * 좀비 업데이트 프로파일링 Hook
     * 
     * IsoZombie.update() 전후에 호출됩니다.
     */
    public static final HookType<ZombieHook.IZombieCallback> ZOMBIE = HookType.create("ZOMBIE",
            ZombieHook.IZombieCallback.class);

    /**
     * 경로 탐색 프로파일링 Hook
     * 
     * Pathfinding 관련 함수에서 호출됩니다.
     */
    public static final HookType<PathfindingHook.IPathfindingCallback> PATHFINDING = HookType.create("PATHFINDING",
            PathfindingHook.IPathfindingCallback.class);

    /**
     * IsoGrid 프로파일링 Hook
     * 
     * IsoGrid 업데이트 관련 함수에서 호출됩니다.
     */
    public static final HookType<IsoGridHook.IIsoGridCallback> ISO_GRID = HookType.create("ISO_GRID",
            IsoGridHook.IIsoGridCallback.class);

    // ─────────────────────────────────────────────────────────────
    // GamePhase Hooks (Phase 1.1에서 추가 예정)
    // ─────────────────────────────────────────────────────────────

    /**
     * 게임 틱 시작/끝 Hook
     */
    public static final HookType<IGameTickCallback> GAME_TICK = HookType.create("GAME_TICK", IGameTickCallback.class);

    /**
     * 렌더 프레임 Hook
     */
    public static final HookType<IRenderCallback> RENDER_FRAME = HookType.create("RENDER_FRAME", IRenderCallback.class);

    /**
     * 청크 로드/언로드 Hook
     */
    public static final HookType<IChunkCallback> CHUNK = HookType.create("CHUNK", IChunkCallback.class);

    /**
     * Lua Function Call Hook
     * 
     * Hooks into se.krka.kahlua.vm.KahluaThread.call/pcall
     */
    public static final HookType<ILuaCallCallback> LUA_CALL = HookType.create("LUA_CALL", ILuaCallCallback.class);

    // ─────────────────────────────────────────────────────────────
    // 콜백 인터페이스 정의 (Phase 1.1에서 구현 예정)
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua Call Callback Interface
     * 
     * NOTE: nanoTime 파라미터 메서드는 Echo 전용입니다.
     * 다른 모드는 이 파라미터에 의존하지 마세요.
     */
    public interface ILuaCallCallback {
        /**
         * Lua 함수 호출 시작 (legacy)
         * 
         * @param function Function object
         */
        default void onLuaCallStart(Object function) {
        }

        /**
         * Lua 함수 호출 종료 (legacy)
         * 
         * @param function Function object
         */
        default void onLuaCallEnd(Object function) {
        }

        /**
         * Lua 함수 호출 시작 (Echo 전용 - 정확한 시간 측정용)
         * 
         * @param function   Function object
         * @param startNanos System.nanoTime() at call start
         */
        default void onLuaCallStart(Object function, long startNanos) {
            onLuaCallStart(function); // 하위 호환성
        }

        /**
         * Lua 함수 호출 종료 (Echo 전용 - 정확한 시간 측정용)
         * 
         * @param function Function object
         * @param endNanos System.nanoTime() at call end
         */
        default void onLuaCallEnd(Object function, long endNanos) {
            onLuaCallEnd(function); // 하위 호환성
        }
    }

    /**
     * 게임 틱 콜백 인터페이스
     */
    public interface IGameTickCallback {
        /** IsoWorld.update() 진입 직전 */
        default void onGameTickStart(long tickNumber) {
        }

        /** IsoWorld.update() 종료 직후 */
        default void onGameTickEnd(long tickNumber, long durationNanos) {
        }
    }

    /**
     * 렌더 프레임 콜백 인터페이스
     */
    public interface IRenderCallback {
        /** 프레임 렌더링 시작 */
        default void onRenderStart() {
        }

        /** 프레임 렌더링 종료 */
        default void onRenderEnd(long durationNanos) {
        }
    }

    /**
     * 청크 콜백 인터페이스
     */
    public interface IChunkCallback {
        /** 청크 로드됨 */
        default void onChunkLoad(int chunkX, int chunkY) {
        }

        /** 청크 언로드됨 */
        default void onChunkUnload(int chunkX, int chunkY) {
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\hook\package-info.java =====

/**
 * Pulse Hook 시스템.
 * 
 * Echo, Fuse, Nerve 등 모드들이 Pulse의 엔진 후킹을 안전하게 활용할 수 있도록
 * 중앙 집중식 Hook 관리 API를 제공합니다.
 * 
 * <h2>주요 클래스</h2>
 * <ul>
 * <li>{@link com.pulse.hook.PulseHookRegistry} - 중앙 Hook 관리자</li>
 * <li>{@link com.pulse.hook.HookType} - Type-safe Hook 식별자</li>
 * <li>{@link com.pulse.hook.HookTypes} - 사전 정의된 Hook 타입 상수</li>
 * </ul>
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // 콜백 등록
 * PulseHookRegistry.register(HookTypes.TICK_PHASE, new TickPhaseHook.ITickPhaseCallback() {
 *     public long startPhase(String phase) {
 *         return System.nanoTime();
 *     }
 * 
 *     public void endPhase(String phase, long startTime) {
 *         long elapsed = System.nanoTime() - startTime;
 *         System.out.println(phase + " took " + elapsed + " ns");
 *     }
 * 
 *     public void onTickComplete() {
 *     }
 * });
 * 
 * // 콜백 브로드캐스트 (Mixin에서 호출)
 * PulseHookRegistry.broadcast(HookTypes.TICK_PHASE, cb -> cb.onTickComplete());
 * }</pre>
 * 
 * @since Pulse 1.2
 */
package com.pulse.hook;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\hook\PulseHookRegistry.java =====

package com.pulse.hook;

import com.pulse.api.log.PulseLogger;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

/**
 * 중앙 집중식 Hook 관리자.
 * 
 * Echo, Fuse, Nerve 등 모든 모드가 공용으로 사용하는 후킹 레지스트리입니다.
 * 이 클래스는 Pulse가 버전별(B41/B42) 호환성을 관리하고,
 * 개별 모드들은 이 API를 통해 안전하게 콜백을 등록/해제합니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // 콜백 등록 (기본 우선순위)
 * PulseHookRegistry.register(HookTypes.TICK_PHASE, myTickCallback);
 * 
 * // 콜백 등록 (높은 우선순위)
 * PulseHookRegistry.register(HookTypes.TICK_PHASE, myPriorityCallback, PulseHookRegistry.PRIORITY_HIGH);
 * 
 * // 콜백 해제
 * PulseHookRegistry.unregister(HookTypes.TICK_PHASE, myTickCallback);
 * 
 * // 모든 콜백에 이벤트 브로드캐스트
 * PulseHookRegistry.broadcast(HookTypes.TICK_PHASE, cb -> cb.onTickStart());
 * }</pre>
 * 
 * @since Pulse 1.2
 * @since Pulse 0.9 - Added priority support and slow hook detection
 */
public final class PulseHookRegistry {

    // Priority constants
    public static final int PRIORITY_LOWEST = -1000;
    public static final int PRIORITY_LOW = -100;
    public static final int PRIORITY_NORMAL = 0;
    public static final int PRIORITY_HIGH = 100;
    public static final int PRIORITY_HIGHEST = 1000;

    // Slow hook detection
    private static final long HOOK_TIMEOUT_MS = 100;
    private static int slowHookWarningCount = 0;
    private static final int MAX_SLOW_HOOK_WARNINGS = 10;

    private static final Map<HookType<?>, Boolean> registeredTypes = new ConcurrentHashMap<>();
    private static final Map<Object, Integer> callbackPriorities = new ConcurrentHashMap<>();
    private static final Map<Object, String> callbackOwners = new ConcurrentHashMap<>();

    private static volatile boolean debugEnabled = false;
    private static final String LOG = PulseLogger.PULSE;

    private PulseHookRegistry() {
        // Utility class
    }

    /**
     * 콜백 등록 (기본 우선순위)
     * 
     * @param type     Hook 타입
     * @param callback 등록할 콜백
     * @throws NullPointerException type 또는 callback이 null인 경우
     */
    public static <T> void register(HookType<T> type, T callback) {
        register(type, callback, PRIORITY_NORMAL, null);
    }

    /**
     * 콜백 등록 (modId 지정)
     * 
     * @param type     Hook 타입
     * @param callback 등록할 콜백
     * @param modId    소유 모드 ID (리로드 시 일괄 해제용)
     */
    public static <T> void register(HookType<T> type, T callback, String modId) {
        register(type, callback, PRIORITY_NORMAL, modId);
    }

    /**
     * 콜백 등록 (우선순위 지정)
     * 
     * @param type     Hook 타입
     * @param callback 등록할 콜백
     * @param priority 우선순위 (높을수록 먼저 실행)
     * @throws NullPointerException type 또는 callback이 null인 경우
     */
    public static <T> void register(HookType<T> type, T callback, int priority) {
        register(type, callback, priority, null);
    }

    /**
     * 콜백 등록 (우선순위 + modId 지정)
     * 
     * @param type     Hook 타입
     * @param callback 등록할 콜백
     * @param priority 우선순위 (높을수록 먼저 실행)
     * @param modId    소유 모드 ID (null 가능)
     */
    public static <T> void register(HookType<T> type, T callback, int priority, String modId) {
        if (type == null) {
            throw new NullPointerException("HookType cannot be null");
        }
        if (callback == null) {
            throw new NullPointerException("Callback cannot be null");
        }

        List<T> callbacks = type.getCallbacksInternal();
        if (!callbacks.contains(callback)) {
            callbacks.add(callback);
            callbackPriorities.put(callback, priority);
            if (modId != null) {
                callbackOwners.put(callback, modId);
            }
            registeredTypes.put(type, true);

            // Sort by priority (higher first)
            sortCallbacksByPriority(callbacks);

            if (debugEnabled) {
                PulseLogger.debug(LOG, "[HookRegistry] Registered callback for {} (priority={}, total={})",
                        type.getName(), priority, callbacks.size());
            }
        }
    }

    /**
     * Sort callbacks by priority (higher priority first)
     */
    private static <T> void sortCallbacksByPriority(List<T> callbacks) {
        // Create a copy, sort it, then update the original
        List<T> sorted = new ArrayList<>(callbacks);
        sorted.sort((a, b) -> {
            int priorityA = callbackPriorities.getOrDefault(a, PRIORITY_NORMAL);
            int priorityB = callbackPriorities.getOrDefault(b, PRIORITY_NORMAL);
            return Integer.compare(priorityB, priorityA); // Descending (higher first)
        });
        callbacks.clear();
        callbacks.addAll(sorted);
    }

    /**
     * 콜백 해제
     * 
     * @param type     Hook 타입
     * @param callback 해제할 콜백
     * @return 콜백이 존재하여 제거되었으면 true
     */
    public static <T> boolean unregister(HookType<T> type, T callback) {
        if (type == null || callback == null) {
            return false;
        }

        List<T> callbacks = type.getCallbacksInternal();
        boolean removed = callbacks.remove(callback);

        if (removed) {
            callbackPriorities.remove(callback);
            callbackOwners.remove(callback);
            if (debugEnabled) {
                PulseLogger.debug(LOG, "[HookRegistry] Unregistered callback for {} (remaining: {})",
                        type.getName(), callbacks.size());
            }
        }

        return removed;
    }

    /**
     * 등록된 모든 콜백 가져오기
     * 
     * @param type Hook 타입
     * @return 등록된 콜백 리스트 (읽기 전용)
     */
    public static <T> List<T> getCallbacks(HookType<T> type) {
        if (type == null) {
            return Collections.emptyList();
        }
        return Collections.unmodifiableList(type.getCallbacksInternal());
    }

    /**
     * 콜백 존재 여부 확인
     */
    public static <T> boolean hasCallbacks(HookType<T> type) {
        return type != null && !type.getCallbacksInternal().isEmpty();
    }

    /**
     * 등록된 모든 콜백에 이벤트 브로드캐스트
     * 
     * 각 콜백에서 발생하는 예외는 로그에 기록되고, 다른 콜백 실행에 영향을 주지 않습니다.
     * Slow hook detection: 100ms 이상 걸리면 경고 로그 (rate-limited)
     * 
     * @param type   Hook 타입
     * @param action 각 콜백에 실행할 액션
     */
    public static <T> void broadcast(HookType<T> type, Consumer<T> action) {
        if (type == null || action == null) {
            return;
        }

        List<T> callbacks = type.getCallbacksInternal();
        for (T callback : callbacks) {
            long start = System.nanoTime();
            try {
                action.accept(callback);
            } catch (Throwable t) {
                PulseLogger.error(LOG, "[HookRegistry] Error in callback for {}: {}", type.getName(), t.getMessage());
                if (debugEnabled) {
                    PulseLogger.error(LOG, "Stack trace", t);
                }
            } finally {
                long elapsedMs = (System.nanoTime() - start) / 1_000_000;
                if (elapsedMs > HOOK_TIMEOUT_MS && slowHookWarningCount < MAX_SLOW_HOOK_WARNINGS) {
                    slowHookWarningCount++;
                    PulseLogger.warn(LOG, "[HookRegistry] Slow hook detected ({}ms): {} for {} (warning {}/{})",
                            elapsedMs, callback.getClass().getName(), type.getName(), slowHookWarningCount,
                            MAX_SLOW_HOOK_WARNINGS);
                }
            }
        }
    }

    /**
     * 특정 Hook의 모든 콜백 제거
     */
    public static <T> void clearCallbacks(HookType<T> type) {
        if (type != null) {
            List<T> callbacks = type.getCallbacksInternal();
            for (T callback : callbacks) {
                callbackPriorities.remove(callback);
            }
            callbacks.clear();
            if (debugEnabled) {
                PulseLogger.debug(LOG, "[HookRegistry] Cleared all callbacks for {}", type.getName());
            }
        }
    }

    /**
     * 특정 modId의 모든 콜백 제거
     * 
     * @param modId 모드 ID
     * @return 제거된 콜백 수
     */
    public static int unregisterAll(String modId) {
        if (modId == null || modId.isEmpty()) {
            return 0;
        }

        int removed = 0;

        // 모든 HookType 순회하여 해당 modId의 콜백 제거
        for (HookType<?> type : registeredTypes.keySet()) {
            removed += unregisterAllFromType(type, modId);
        }

        if (debugEnabled && removed > 0) {
            PulseLogger.debug(LOG, "[HookRegistry] Unregistered {} callbacks for mod: {}", removed, modId);
        }

        return removed;
    }

    /**
     * 특정 HookType에서 modId의 콜백 제거
     */
    private static <T> int unregisterAllFromType(HookType<T> type, String modId) {
        List<T> callbacks = type.getCallbacksInternal();
        List<T> toRemove = new java.util.ArrayList<>();

        for (T callback : callbacks) {
            String owner = callbackOwners.get(callback);
            if (modId.equals(owner)) {
                toRemove.add(callback);
            }
        }

        for (T callback : toRemove) {
            callbacks.remove(callback);
            callbackPriorities.remove(callback);
            callbackOwners.remove(callback);
        }

        return toRemove.size();
    }

    /**
     * 디버그 모드 설정
     */
    public static void setDebugEnabled(boolean enabled) {
        debugEnabled = enabled;
    }

    /**
     * 디버그 모드 상태
     */
    public static boolean isDebugEnabled() {
        return debugEnabled;
    }

    /**
     * 등록된 Hook 타입 수
     */
    public static int getRegisteredTypeCount() {
        return registeredTypes.size();
    }

    /**
     * Slow hook warning 카운터 리셋 (테스트용)
     */
    public static void resetSlowHookWarnings() {
        slowHookWarningCount = 0;
    }

    /**
     * 전체 상태 요약 (디버깅용)
     */
    public static String getStatusSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("PulseHookRegistry Status:\n");
        sb.append("  Debug: ").append(debugEnabled).append("\n");
        sb.append("  Slow Hook Warnings: ").append(slowHookWarningCount).append("/").append(MAX_SLOW_HOOK_WARNINGS)
                .append("\n");
        sb.append("  Registered Hook Types: ").append(registeredTypes.size()).append("\n");

        for (HookType<?> type : registeredTypes.keySet()) {
            int count = type.getCallbacksInternal().size();
            sb.append("    - ").append(type.getName()).append(": ").append(count).append(" callbacks\n");
        }

        return sb.toString();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\input\KeyBinding.java =====

package com.pulse.input;

/**
 * 키 바인딩 정의.
 * 모드에서 사용할 키 조합을 정의.
 * 
 * 사용 예:
 * 
 * <pre>
 * KeyBinding myKey = KeyBinding.create("mymod", "open_menu")
 *         .defaultKey(KeyCode.KEY_M)
 *         .withCtrl()
 *         .category("My Mod")
 *         .build();
 * 
 * KeyBindingRegistry.register(myKey);
 * </pre>
 */
public class KeyBinding {

    private final String modId;
    private final String id;
    private final String translationKey;
    private final String category;

    // 기본 키
    private int defaultKeyCode;
    private boolean defaultCtrl = false;
    private boolean defaultShift = false;
    private boolean defaultAlt = false;

    // 현재 바인딩된 키
    private int keyCode;
    private boolean ctrl = false;
    private boolean shift = false;
    private boolean alt = false;

    // 상태
    private boolean pressed = false;
    private boolean wasPressed = false;
    private int pressCount = 0;

    private KeyBinding(String modId, String id, String translationKey, String category) {
        this.modId = modId;
        this.id = id;
        this.translationKey = translationKey;
        this.category = category;
    }

    /**
     * 빌더 생성
     */
    public static Builder create(String modId, String id) {
        return new Builder(modId, id);
    }

    // ─────────────────────────────────────────────────────────────
    // 상태 체크
    // ─────────────────────────────────────────────────────────────

    /**
     * 키가 현재 눌려있는지 확인
     */
    public boolean isPressed() {
        return pressed;
    }

    /**
     * 키가 이번 틱에 눌렸는지 확인 (1회성)
     * wasPressed()와 달리 호출 시 상태가 리셋되지 않음
     */
    public boolean isDown() {
        return pressed && !wasPressed;
    }

    /**
     * 키가 이번 틱에 눌렸는지 확인하고 상태 리셋
     * 1회 입력 처리에 사용
     */
    public boolean wasPressed() {
        if (pressCount > 0) {
            pressCount--;
            return true;
        }
        return false;
    }

    /**
     * 키가 이번 틱에 릴리즈되었는지 확인
     */
    public boolean isReleased() {
        return !pressed && wasPressed;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 상태 업데이트 (KeyBindingRegistry에서 호출)
    // ─────────────────────────────────────────────────────────────

    void updateState(boolean pressed) {
        this.wasPressed = this.pressed;
        this.pressed = pressed;

        if (pressed && !wasPressed) {
            pressCount++;
        }
    }

    void resetPressCount() {
        pressCount = 0;
    }

    // ─────────────────────────────────────────────────────────────
    // 키 설정
    // ─────────────────────────────────────────────────────────────

    /**
     * 키 바인딩 변경
     */
    public void setKey(int keyCode, boolean ctrl, boolean shift, boolean alt) {
        this.keyCode = keyCode;
        this.ctrl = ctrl;
        this.shift = shift;
        this.alt = alt;
    }

    /**
     * 기본값으로 리셋
     */
    public void resetToDefault() {
        this.keyCode = defaultKeyCode;
        this.ctrl = defaultCtrl;
        this.shift = defaultShift;
        this.alt = defaultAlt;
    }

    /**
     * 입력이 이 키 바인딩과 일치하는지 확인
     */
    public boolean matches(int inputKeyCode, boolean inputCtrl, boolean inputShift, boolean inputAlt) {
        return this.keyCode == inputKeyCode &&
                this.ctrl == inputCtrl &&
                this.shift == inputShift &&
                this.alt == inputAlt;
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public String getModId() {
        return modId;
    }

    public String getId() {
        return id;
    }

    public String getFullId() {
        return modId + ":" + id;
    }

    public String getTranslationKey() {
        return translationKey;
    }

    public String getCategory() {
        return category;
    }

    public int getKeyCode() {
        return keyCode;
    }

    public int getDefaultKeyCode() {
        return defaultKeyCode;
    }

    public boolean hasCtrl() {
        return ctrl;
    }

    public boolean hasShift() {
        return shift;
    }

    public boolean hasAlt() {
        return alt;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        if (ctrl)
            sb.append("Ctrl+");
        if (shift)
            sb.append("Shift+");
        if (alt)
            sb.append("Alt+");
        sb.append(KeyCode.getName(keyCode));
        return sb.toString();
    }

    // ─────────────────────────────────────────────────────────────
    // 빌더
    // ─────────────────────────────────────────────────────────────

    public static class Builder {
        private final String modId;
        private final String id;
        private String translationKey;
        private String category = "misc";
        private int keyCode = KeyCode.KEY_UNKNOWN;
        private boolean ctrl = false;
        private boolean shift = false;
        private boolean alt = false;

        private Builder(String modId, String id) {
            this.modId = modId;
            this.id = id;
            this.translationKey = "key." + modId + "." + id;
        }

        public Builder translationKey(String key) {
            this.translationKey = key;
            return this;
        }

        public Builder category(String category) {
            this.category = category;
            return this;
        }

        public Builder defaultKey(int keyCode) {
            this.keyCode = keyCode;
            return this;
        }

        public Builder withCtrl() {
            this.ctrl = true;
            return this;
        }

        public Builder withShift() {
            this.shift = true;
            return this;
        }

        public Builder withAlt() {
            this.alt = true;
            return this;
        }

        public KeyBinding build() {
            KeyBinding binding = new KeyBinding(modId, id, translationKey, category);
            binding.defaultKeyCode = keyCode;
            binding.defaultCtrl = ctrl;
            binding.defaultShift = shift;
            binding.defaultAlt = alt;
            binding.resetToDefault();
            return binding;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\input\KeyBindingRegistry.java =====

package com.pulse.input;

import com.pulse.api.log.PulseLogger;
import com.pulse.event.EventBus;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 키 바인딩 레지스트리.
 * 모든 키 바인딩을 관리하고 입력 처리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 키 바인딩 생성 및 등록
 * KeyBinding openMenu = KeyBinding.create("mymod", "open_menu")
 *         .defaultKey(KeyCode.KEY_M)
 *         .category("My Mod")
 *         .build();
 * 
 * KeyBindingRegistry.register(openMenu);
 * 
 * // 사용 (매 틱)
 * if (openMenu.wasPressed()) {
 *     openMyMenu();
 * }
 * </pre>
 */
public class KeyBindingRegistry {

    private static final KeyBindingRegistry INSTANCE = new KeyBindingRegistry();
    private static final String LOG = PulseLogger.PULSE;

    // 등록된 키 바인딩
    private final Map<String, KeyBinding> bindings = new ConcurrentHashMap<>();

    // 카테고리별 바인딩
    private final Map<String, List<KeyBinding>> byCategory = new ConcurrentHashMap<>();

    // 현재 키 상태
    private final Set<Integer> pressedKeys = ConcurrentHashMap.newKeySet();
    private boolean ctrlPressed = false;
    private boolean shiftPressed = false;
    private boolean altPressed = false;

    private KeyBindingRegistry() {
    }

    public static KeyBindingRegistry getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 편의 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 키 바인딩 등록
     */
    public static void register(KeyBinding binding) {
        INSTANCE.registerBinding(binding);
    }

    /**
     * 키 바인딩 가져오기
     */
    public static KeyBinding get(String modId, String id) {
        return INSTANCE.getBinding(modId + ":" + id);
    }

    /**
     * 모든 키 바인딩
     */
    public static Collection<KeyBinding> getAll() {
        return INSTANCE.getAllBindings();
    }

    /**
     * 카테고리별 키 바인딩
     */
    public static List<KeyBinding> getByCategory(String category) {
        return INSTANCE.getBindingsByCategory(category);
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    public void registerBinding(KeyBinding binding) {
        String fullId = binding.getFullId();

        if (bindings.containsKey(fullId)) {
            PulseLogger.error(LOG, "[Input] Duplicate keybinding: {}", fullId);
            return;
        }

        bindings.put(fullId, binding);
        byCategory.computeIfAbsent(binding.getCategory(), k -> new ArrayList<>())
                .add(binding);

        PulseLogger.info(LOG, "[Input] Registered keybinding: {} ({})", fullId, binding);
    }

    public KeyBinding getBinding(String fullId) {
        return bindings.get(fullId);
    }

    public Collection<KeyBinding> getAllBindings() {
        return Collections.unmodifiableCollection(bindings.values());
    }

    public List<KeyBinding> getBindingsByCategory(String category) {
        return byCategory.getOrDefault(category, Collections.emptyList());
    }

    public Set<String> getCategories() {
        return Collections.unmodifiableSet(byCategory.keySet());
    }

    // ─────────────────────────────────────────────────────────────
    // 입력 처리 (Mixin에서 호출)
    // ─────────────────────────────────────────────────────────────

    /**
     * 키 프레스 이벤트 처리
     */
    public void onKeyPress(int keyCode, boolean ctrl, boolean shift, boolean alt) {
        // 수정자 키 상태 업데이트
        this.ctrlPressed = ctrl;
        this.shiftPressed = shift;
        this.altPressed = alt;

        pressedKeys.add(keyCode);

        // 매칭되는 키 바인딩 업데이트
        for (KeyBinding binding : bindings.values()) {
            if (binding.matches(keyCode, ctrl, shift, alt)) {
                binding.updateState(true);
            }
        }

        // KeyEvent 발생
        EventBus.post(new KeyEvent(KeyEvent.Type.PRESS, keyCode, ctrl, shift, alt));
    }

    /**
     * 키 릴리즈 이벤트 처리
     */
    public void onKeyRelease(int keyCode, boolean ctrl, boolean shift, boolean alt) {
        this.ctrlPressed = ctrl;
        this.shiftPressed = shift;
        this.altPressed = alt;

        pressedKeys.remove(keyCode);

        // 매칭되는 키 바인딩 업데이트
        for (KeyBinding binding : bindings.values()) {
            if (binding.getKeyCode() == keyCode) {
                binding.updateState(false);
            }
        }

        // KeyEvent 발생
        EventBus.post(new KeyEvent(KeyEvent.Type.RELEASE, keyCode, ctrl, shift, alt));
    }

    /**
     * 특정 키가 현재 눌려있는지 확인
     */
    public boolean isKeyPressed(int keyCode) {
        return pressedKeys.contains(keyCode);
    }

    public boolean isCtrlPressed() {
        return ctrlPressed;
    }

    public boolean isShiftPressed() {
        return shiftPressed;
    }

    public boolean isAltPressed() {
        return altPressed;
    }

    /**
     * 모든 상태 리셋 (포커스 손실 시 등)
     */
    public void resetAll() {
        pressedKeys.clear();
        ctrlPressed = false;
        shiftPressed = false;
        altPressed = false;

        for (KeyBinding binding : bindings.values()) {
            binding.updateState(false);
            binding.resetPressCount();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\input\KeyCode.java =====

package com.pulse.input;

/**
 * 키 코드 상수.
 * LWJGL/GLFW 키 코드와 호환.
 */
public final class KeyCode {

    private KeyCode() {
    }

    // 알 수 없는 키
    public static final int KEY_UNKNOWN = -1;

    // 특수 키
    public static final int KEY_SPACE = 32;
    public static final int KEY_APOSTROPHE = 39; // '
    public static final int KEY_COMMA = 44; // ,
    public static final int KEY_MINUS = 45; // -
    public static final int KEY_PERIOD = 46; // .
    public static final int KEY_SLASH = 47; // /

    // 숫자 키 (상단)
    public static final int KEY_0 = 48;
    public static final int KEY_1 = 49;
    public static final int KEY_2 = 50;
    public static final int KEY_3 = 51;
    public static final int KEY_4 = 52;
    public static final int KEY_5 = 53;
    public static final int KEY_6 = 54;
    public static final int KEY_7 = 55;
    public static final int KEY_8 = 56;
    public static final int KEY_9 = 57;

    // 문자 키
    public static final int KEY_A = 65;
    public static final int KEY_B = 66;
    public static final int KEY_C = 67;
    public static final int KEY_D = 68;
    public static final int KEY_E = 69;
    public static final int KEY_F = 70;
    public static final int KEY_G = 71;
    public static final int KEY_H = 72;
    public static final int KEY_I = 73;
    public static final int KEY_J = 74;
    public static final int KEY_K = 75;
    public static final int KEY_L = 76;
    public static final int KEY_M = 77;
    public static final int KEY_N = 78;
    public static final int KEY_O = 79;
    public static final int KEY_P = 80;
    public static final int KEY_Q = 81;
    public static final int KEY_R = 82;
    public static final int KEY_S = 83;
    public static final int KEY_T = 84;
    public static final int KEY_U = 85;
    public static final int KEY_V = 86;
    public static final int KEY_W = 87;
    public static final int KEY_X = 88;
    public static final int KEY_Y = 89;
    public static final int KEY_Z = 90;

    // 기능 키
    public static final int KEY_ESCAPE = 256;
    public static final int KEY_ENTER = 257;
    public static final int KEY_TAB = 258;
    public static final int KEY_BACKSPACE = 259;
    public static final int KEY_INSERT = 260;
    public static final int KEY_DELETE = 261;
    public static final int KEY_RIGHT = 262;
    public static final int KEY_LEFT = 263;
    public static final int KEY_DOWN = 264;
    public static final int KEY_UP = 265;
    public static final int KEY_PAGE_UP = 266;
    public static final int KEY_PAGE_DOWN = 267;
    public static final int KEY_HOME = 268;
    public static final int KEY_END = 269;
    public static final int KEY_CAPS_LOCK = 280;
    public static final int KEY_SCROLL_LOCK = 281;
    public static final int KEY_NUM_LOCK = 282;
    public static final int KEY_PRINT_SCREEN = 283;
    public static final int KEY_PAUSE = 284;

    // F키
    public static final int KEY_F1 = 290;
    public static final int KEY_F2 = 291;
    public static final int KEY_F3 = 292;
    public static final int KEY_F4 = 293;
    public static final int KEY_F5 = 294;
    public static final int KEY_F6 = 295;
    public static final int KEY_F7 = 296;
    public static final int KEY_F8 = 297;
    public static final int KEY_F9 = 298;
    public static final int KEY_F10 = 299;
    public static final int KEY_F11 = 300;
    public static final int KEY_F12 = 301;

    // 넘패드
    public static final int KEY_KP_0 = 320;
    public static final int KEY_KP_1 = 321;
    public static final int KEY_KP_2 = 322;
    public static final int KEY_KP_3 = 323;
    public static final int KEY_KP_4 = 324;
    public static final int KEY_KP_5 = 325;
    public static final int KEY_KP_6 = 326;
    public static final int KEY_KP_7 = 327;
    public static final int KEY_KP_8 = 328;
    public static final int KEY_KP_9 = 329;

    // 수정자 키
    public static final int KEY_LEFT_SHIFT = 340;
    public static final int KEY_LEFT_CONTROL = 341;
    public static final int KEY_LEFT_ALT = 342;
    public static final int KEY_RIGHT_SHIFT = 344;
    public static final int KEY_RIGHT_CONTROL = 345;
    public static final int KEY_RIGHT_ALT = 346;

    /**
     * 키 코드를 이름으로 변환
     */
    public static String getName(int keyCode) {
        return switch (keyCode) {
            case KEY_UNKNOWN -> "Unknown";
            case KEY_SPACE -> "Space";
            case KEY_ESCAPE -> "Escape";
            case KEY_ENTER -> "Enter";
            case KEY_TAB -> "Tab";
            case KEY_BACKSPACE -> "Backspace";
            case KEY_DELETE -> "Delete";
            case KEY_UP -> "Up";
            case KEY_DOWN -> "Down";
            case KEY_LEFT -> "Left";
            case KEY_RIGHT -> "Right";
            case KEY_LEFT_SHIFT, KEY_RIGHT_SHIFT -> "Shift";
            case KEY_LEFT_CONTROL, KEY_RIGHT_CONTROL -> "Ctrl";
            case KEY_LEFT_ALT, KEY_RIGHT_ALT -> "Alt";
            default -> {
                if (keyCode >= KEY_A && keyCode <= KEY_Z) {
                    yield String.valueOf((char) keyCode);
                } else if (keyCode >= KEY_0 && keyCode <= KEY_9) {
                    yield String.valueOf((char) keyCode);
                } else if (keyCode >= KEY_F1 && keyCode <= KEY_F12) {
                    yield "F" + (keyCode - KEY_F1 + 1);
                } else if (keyCode >= KEY_KP_0 && keyCode <= KEY_KP_9) {
                    yield "Numpad " + (keyCode - KEY_KP_0);
                }
                yield "Key " + keyCode;
            }
        };
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\input\KeyEvent.java =====

package com.pulse.input;

import com.pulse.event.Event;

/**
 * 키 입력 이벤트.
 * 키 프레스/릴리즈 시 발생.
 */
public class KeyEvent extends Event {

    public enum Type {
        PRESS,
        RELEASE,
        REPEAT
    }

    private final Type type;
    private final int keyCode;
    private final boolean ctrl;
    private final boolean shift;
    private final boolean alt;

    public KeyEvent(Type type, int keyCode, boolean ctrl, boolean shift, boolean alt) {
        this.type = type;
        this.keyCode = keyCode;
        this.ctrl = ctrl;
        this.shift = shift;
        this.alt = alt;
    }

    public Type getType() {
        return type;
    }

    public int getKeyCode() {
        return keyCode;
    }

    public boolean hasCtrl() {
        return ctrl;
    }

    public boolean hasShift() {
        return shift;
    }

    public boolean hasAlt() {
        return alt;
    }

    public boolean isPress() {
        return type == Type.PRESS;
    }

    public boolean isRelease() {
        return type == Type.RELEASE;
    }

    public boolean isRepeat() {
        return type == Type.REPEAT;
    }

    /**
     * 특정 키와 일치하는지 확인
     */
    public boolean matches(int keyCode) {
        return this.keyCode == keyCode;
    }

    /**
     * 키 바인딩과 일치하는지 확인
     */
    public boolean matches(KeyBinding binding) {
        return binding.matches(keyCode, ctrl, shift, alt);
    }

    @Override
    public String getEventName() {
        return "KeyEvent";
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("KeyEvent[");
        sb.append(type).append(", ");
        if (ctrl)
            sb.append("Ctrl+");
        if (shift)
            sb.append("Shift+");
        if (alt)
            sb.append("Alt+");
        sb.append(KeyCode.getName(keyCode)).append("]");
        return sb.toString();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\internal\InternalLuaHook.java =====

package com.pulse.internal;

import java.util.ArrayDeque;
import java.util.Deque;

/**
 * Pulse 내부 Lua 이벤트 훅.
 * 
 * MixinLuaEventManager에서 직접 사용.
 * pulse-api 의존성 문제 우회를 위해 Pulse 내부에 구현.
 * 
 * Phase 2C 설계:
 * - ThreadLocal<Deque> 스택: 중첩 이벤트 대응
 * - profilingEnabled 플래그: true일 때만 nanoTime() 호출
 * - 예외 방어: 스택 언더플로우 시 안전 처리
 * 
 * @since Pulse 1.3
 */
public final class InternalLuaHook {

    /** 콜백 인터페이스 - Echo가 구현 */
    public interface LuaEventCallback {
        void onEventEnd(String eventName, long durationMicros);
    }

    /** 등록된 콜백 (null이면 미등록) */
    private static volatile LuaEventCallback callback = null;

    /** 상세 프로파일링 활성화 여부 */
    private static volatile boolean profilingEnabled = false;

    /** 중첩 이벤트 대응 스택 (ThreadLocal) */
    private static final ThreadLocal<Deque<EventFrame>> EVENT_STACK = ThreadLocal.withInitial(ArrayDeque::new);

    /** 이벤트 프레임 (eventName + startNanos) */
    private static final class EventFrame {
        final String eventName;
        final long startNanos;

        EventFrame(String eventName, long startNanos) {
            this.eventName = eventName;
            this.startNanos = startNanos;
        }
    }

    private InternalLuaHook() {
    }

    // =========================================
    // Mixin에서 호출하는 메서드
    // =========================================

    /**
     * 이벤트 시작 (Phase 2C).
     * 프로파일링 활성화 시에만 스택에 push.
     */
    public static void fireEventStart(String eventName) {
        if (!profilingEnabled) {
            return;
        }
        EVENT_STACK.get().push(new EventFrame(eventName, System.nanoTime()));
    }

    /**
     * 이벤트 종료 (Phase 2C).
     * 스택에서 pop하고 콜백 호출.
     */
    public static void fireEventEnd() {
        if (!profilingEnabled) {
            return;
        }

        Deque<EventFrame> stack = EVENT_STACK.get();
        EventFrame frame = stack.poll();
        if (frame == null) {
            return; // 예외로 빠져나온 경우
        }

        LuaEventCallback cb = callback;
        if (cb != null) {
            long durationNanos = System.nanoTime() - frame.startNanos;
            long durationMicros = durationNanos / 1000;
            cb.onEventEnd(frame.eventName, durationMicros);
        }
    }

    // =========================================
    // 외부 API
    // =========================================

    public static void setCallback(LuaEventCallback cb) {
        callback = cb;
    }

    public static void setProfilingEnabled(boolean value) {
        profilingEnabled = value;
    }

    public static boolean isProfilingEnabled() {
        return profilingEnabled;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lifecycle\LifecycleManager.java =====

package com.pulse.lifecycle;

import com.pulse.api.PulseServices;
import com.pulse.api.log.PulseLogger;
import com.pulse.di.PulseServiceLocator;
import com.pulse.lua.LuaBridge;
import com.pulse.mod.ModLoader;

import java.io.Closeable;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Pulse 생명주기 관리자.
 * 
 * 게임 시작/종료 시 리소스 초기화 및 정리를 담당합니다.
 * 모든 Pulse 컴포넌트의 정리를 보장합니다.
 * 
 * @since 1.2.0
 */
public final class LifecycleManager {

    private static final LifecycleManager INSTANCE = new LifecycleManager();
    private static final String LOG = PulseLogger.PULSE;

    // 정리 대상 컴포넌트 목록
    private final List<ShutdownHook> shutdownHooks = new CopyOnWriteArrayList<>();
    private final List<Closeable> closeables = new CopyOnWriteArrayList<>();

    // 셧다운 상태
    private volatile boolean shuttingDown = false;
    private volatile boolean shutdownComplete = false;

    private LifecycleManager() {
        // JVM 셧다운 훅 등록
        Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown, "Pulse-ShutdownHook"));
    }

    public static LifecycleManager getInstance() {
        return INSTANCE;
    }

    // ───────────────────────────────────────────────────────────────
    // 등록 API
    // ───────────────────────────────────────────────────────────────

    /**
     * 셧다운 시 호출될 훅 등록
     */
    public void registerShutdownHook(ShutdownHook hook) {
        if (!shuttingDown) {
            shutdownHooks.add(hook);
        }
    }

    /**
     * 셧다운 시 close()를 호출할 Closeable 등록
     */
    public void registerCloseable(Closeable closeable) {
        if (!shuttingDown) {
            closeables.add(closeable);
        }
    }

    /**
     * 셧다운 훅 해제
     */
    public void unregisterShutdownHook(ShutdownHook hook) {
        shutdownHooks.remove(hook);
    }

    // ───────────────────────────────────────────────────────────────
    // 초기화 / 셧다운
    // ───────────────────────────────────────────────────────────────

    /**
     * Pulse 초기화 완료 시 호출 (선택적)
     */
    public void onInitialized() {
        PulseLogger.info(LOG, "[Lifecycle] Pulse initialized");
        shuttingDown = false;
        shutdownComplete = false;
    }

    /**
     * 게임 종료 시 리소스 정리
     */
    public void shutdown() {
        if (shuttingDown || shutdownComplete) {
            return;
        }

        shuttingDown = true;
        PulseLogger.info(LOG, "[Lifecycle] Shutting down Pulse...");

        List<String> errors = new ArrayList<>();

        // 1. 사용자 정의 셧다운 훅 호출
        for (ShutdownHook hook : shutdownHooks) {
            try {
                hook.onShutdown();
            } catch (Throwable t) {
                errors.add("ShutdownHook: " + t.getMessage());
                PulseLogger.error(LOG, "[Lifecycle] Shutdown hook failed: {}", t.getMessage());
            }
        }
        shutdownHooks.clear();

        // 2. Closeable 리소스 정리
        for (Closeable closeable : closeables) {
            try {
                closeable.close();
            } catch (Throwable t) {
                errors.add("Closeable: " + t.getMessage());
                PulseLogger.error(LOG, "[Lifecycle] Closeable.close() failed: {}", t.getMessage());
            }
        }
        closeables.clear();

        // 3. 핵심 컴포넌트 정리
        try {
            PulseServices.scheduler().shutdown();
            PulseLogger.debug(LOG, "[Lifecycle] Scheduler shutdown complete");
        } catch (Throwable t) {
            errors.add("Scheduler: " + t.getMessage());
        }

        try {
            PulseServices.eventBus().clearAll();
            PulseLogger.debug(LOG, "[Lifecycle] EventBus cleared");
        } catch (Throwable t) {
            errors.add("EventBus: " + t.getMessage());
        }

        try {
            PulseServiceLocator.getInstance().clear();
            PulseLogger.debug(LOG, "[Lifecycle] ServiceLocator cleared");
        } catch (Throwable t) {
            errors.add("ServiceLocator: " + t.getMessage());
        }

        try {
            LuaBridge.reinitialize();
            PulseLogger.debug(LOG, "[Lifecycle] LuaBridge reset");
        } catch (Throwable t) {
            errors.add("LuaBridge: " + t.getMessage());
        }

        // 4. 모드 언로드
        try {
            ModLoader loader = ModLoader.getInstance();
            loader.unloadAll();
            PulseLogger.debug(LOG, "[Lifecycle] Mods unloaded");
        } catch (Throwable t) {
            errors.add("ModLoader: " + t.getMessage());
        }

        shutdownComplete = true;

        if (errors.isEmpty()) {
            PulseLogger.info(LOG, "[Lifecycle] Pulse shutdown complete");
        } else {
            PulseLogger.warn(LOG, "[Lifecycle] Pulse shutdown complete with {} errors", errors.size());
        }
    }

    /**
     * 셧다운 상태 확인
     */
    public boolean isShuttingDown() {
        return shuttingDown;
    }

    /**
     * 셧다운 완료 여부
     */
    public boolean isShutdownComplete() {
        return shutdownComplete;
    }

    // ───────────────────────────────────────────────────────────────
    // 셧다운 훅 인터페이스
    // ───────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface ShutdownHook {
        void onShutdown();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lifecycle\package-info.java =====

/**
 * Pulse Lifecycle Management.
 * 
 * <p>
 * 게임 시작/종료 시 리소스 초기화 및 정리를 담당합니다.
 * </p>
 * 
 * <h2>주요 클래스</h2>
 * <ul>
 * <li>{@link com.pulse.lifecycle.LifecycleManager} - 생명주기 관리자</li>
 * </ul>
 * 
 * <h2>기능</h2>
 * <ul>
 * <li>JVM 셧다운 훅 자동 등록</li>
 * <li>사용자 정의 셧다운 훅 지원</li>
 * <li>Closeable 리소스 자동 정리</li>
 * <li>핵심 컴포넌트(Scheduler, EventBus, ServiceLocator) 정리</li>
 * </ul>
 * 
 * @since 1.2
 */
package com.pulse.lifecycle;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\loader\ModReloader.java =====

package com.pulse.loader;

import com.pulse.api.log.PulseLogger;
import com.pulse.event.EventBus;
import com.pulse.hook.PulseHookRegistry;

import java.io.File;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * 안전한 모드 핫 리로드 관리자.
 * 
 * 코드 전체 재시작 없이 모드의 Lua/Core 부분만 재적용합니다.
 * Fuse/Nerve 파라미터 실험 시 유용합니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // 특정 모드 리로드
 * ModReloader.reload("my-mod");
 * 
 * // 리로드 리스너 등록
 * ModReloader.addListener((modId, success) -> {
 *     System.out.println(modId + " reloaded: " + success);
 * });
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class ModReloader {

    private static final String LOG = PulseLogger.PULSE;

    // 등록된 모드 정보
    private static final Map<String, ModInfo> registeredMods = new LinkedHashMap<>();

    // 리로드 리스너
    private static final List<ReloadListener> listeners = new CopyOnWriteArrayList<>();

    // 리로드 히스토리
    private static final List<ReloadRecord> history = new ArrayList<>();
    private static final int MAX_HISTORY = 50;

    private ModReloader() {
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 리로드 가능한 모드 등록
     * 
     * @param modId   모드 ID
     * @param modPath 모드 루트 경로
     */
    public static void registerMod(String modId, File modPath) {
        registerMod(modId, modPath, null);
    }

    /**
     * 리로드 가능한 모드 등록 (콜백 포함)
     * 
     * @param modId    모드 ID
     * @param modPath  모드 루트 경로
     * @param callback 리로드 시 호출될 콜백
     */
    public static void registerMod(String modId, File modPath, ReloadCallback callback) {
        if (modId == null || modId.isEmpty()) {
            throw new IllegalArgumentException("Mod ID cannot be null or empty");
        }

        ModInfo info = new ModInfo(modId, modPath, callback);
        registeredMods.put(modId, info);
        PulseLogger.info(LOG, "[ModReloader] Registered mod: {}", modId);
    }

    /**
     * 모드 등록 해제
     */
    public static void unregisterMod(String modId) {
        if (registeredMods.remove(modId) != null) {
            PulseLogger.info(LOG, "[ModReloader] Unregistered mod: {}", modId);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 리로드 실행
    // ─────────────────────────────────────────────────────────────

    /**
     * 특정 모드 리로드
     * 
     * @param modId 리로드할 모드 ID
     * @return 성공 여부
     */
    public static boolean reload(String modId) {
        ModInfo info = registeredMods.get(modId);
        if (info == null) {
            PulseLogger.error(LOG, "[ModReloader] Unknown mod: {}", modId);
            return false;
        }

        long startTime = System.currentTimeMillis();
        boolean success = false;
        String errorMessage = null;

        try {
            PulseLogger.info(LOG, "[ModReloader] Starting reload: {}", modId);

            // 1. 모드의 이벤트 리스너 해제
            int unsubscribed = EventBus.unsubscribeAll(modId);
            PulseLogger.info(LOG, "[ModReloader]   Unsubscribed {} event listeners", unsubscribed);

            // 2. 모드의 Hook 콜백 해제
            int unregisteredHooks = PulseHookRegistry.unregisterAll(modId);
            PulseLogger.info(LOG, "[ModReloader]   Unregistered {} hook callbacks", unregisteredHooks);

            // 3. Lua 파일 리로드 (게임 API 호출)
            success = reloadLuaFiles(info);

            // 4. 모드 콜백 호출
            if (info.callback != null) {
                info.callback.onReload();
            }

            PulseLogger.info(LOG, "[ModReloader] Reload {}: {}", success ? "successful" : "failed", modId);

        } catch (Exception e) {
            errorMessage = e.getMessage();
            PulseLogger.error(LOG, "[ModReloader] Reload failed: {} - {}", modId, e.getMessage(), e);
        }

        long duration = System.currentTimeMillis() - startTime;

        // 히스토리 기록
        addToHistory(new ReloadRecord(modId, success, duration, errorMessage));

        // 리스너 알림
        for (ReloadListener listener : listeners) {
            try {
                listener.onModReloaded(modId, success);
            } catch (Exception e) {
                // 리스너 예외 무시
            }
        }

        return success;
    }

    /**
     * 모든 등록된 모드 리로드
     * 
     * @return 리로드된 모드 수
     */
    public static int reloadAll() {
        int reloaded = 0;
        for (String modId : new ArrayList<>(registeredMods.keySet())) {
            if (reload(modId)) {
                reloaded++;
            }
        }
        return reloaded;
    }

    /**
     * Lua 파일 리로드 (내부 구현)
     * 
     * PZ의 Lua API를 reflection으로 호출합니다:
     * 1. LuaManager.LoadDirRecursive 시도
     * 2. LuaManager.LoadDir 폴백
     * 3. 게임 런타임 외부면 시뮬레이션
     */
    private static boolean reloadLuaFiles(ModInfo info) {
        if (info.modPath == null) {
            PulseLogger.info(LOG, "[ModReloader] No mod path specified, skipping Lua reload");
            return true;
        }

        String luaPath = info.modPath.getAbsolutePath() + "/media/lua";
        java.io.File luaDir = new java.io.File(luaPath);

        if (!luaDir.exists() || !luaDir.isDirectory()) {
            PulseLogger.info(LOG, "[ModReloader] Lua directory not found: {}", luaPath);
            return true; // 디렉토리 없으면 성공으로 처리 (Java-only 모드 가능)
        }

        try {
            Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");

            // 1. LoadDirRecursive 시도 (PZ B41+)
            try {
                java.lang.reflect.Method loadDirRecursive = luaManagerClass.getMethod(
                        "LoadDirRecursive", String.class, boolean.class, boolean.class);
                loadDirRecursive.invoke(null, luaPath, true, false);
                PulseLogger.info(LOG, "[ModReloader] Reloaded Lua via LoadDirRecursive: {}", luaPath);
                return true;
            } catch (NoSuchMethodException e) {
                // LoadDirRecursive 없음, 다음 시도
            }

            // 2. LoadDir 시도 (older API)
            try {
                java.lang.reflect.Method loadDir = luaManagerClass.getMethod("LoadDir", String.class);
                loadDir.invoke(null, luaPath);
                PulseLogger.info(LOG, "[ModReloader] Reloaded Lua via LoadDir: {}", luaPath);
                return true;
            } catch (NoSuchMethodException e) {
                // LoadDir 없음, 실패
            }

            // 3. reloadLuaFiles 시도 (alternative API)
            try {
                java.lang.reflect.Method reloadMethod = luaManagerClass.getMethod("reloadLuaFiles", String.class);
                reloadMethod.invoke(null, luaPath);
                PulseLogger.info(LOG, "[ModReloader] Reloaded Lua via reloadLuaFiles: {}", luaPath);
                return true;
            } catch (NoSuchMethodException e) {
                PulseLogger.error(LOG, "[ModReloader] No suitable Lua reload method found in LuaManager");
                return false;
            }

        } catch (ClassNotFoundException e) {
            // 게임 런타임 외부에서 실행 중
            PulseLogger.info(LOG, "[ModReloader] Not in game runtime, simulating Lua reload: {}", luaPath);
            return true;
        } catch (Exception e) {
            PulseLogger.error(LOG, "[ModReloader] Lua reload failed: {}", e.getMessage());
            if (e.getCause() != null) {
                PulseLogger.error(LOG, "[ModReloader]   Cause: {}", e.getCause().getMessage());
            }
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 리스너
    // ─────────────────────────────────────────────────────────────

    /**
     * 리로드 리스너 추가
     */
    public static void addListener(ReloadListener listener) {
        if (listener != null) {
            listeners.add(listener);
        }
    }

    /**
     * 리로드 리스너 제거
     */
    public static void removeListener(ReloadListener listener) {
        listeners.remove(listener);
    }

    // ─────────────────────────────────────────────────────────────
    // 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * 등록된 모드 목록
     */
    public static Set<String> getRegisteredMods() {
        return new LinkedHashSet<>(registeredMods.keySet());
    }

    /**
     * 모드 등록 여부
     */
    public static boolean isRegistered(String modId) {
        return registeredMods.containsKey(modId);
    }

    /**
     * 리로드 히스토리
     */
    public static List<ReloadRecord> getHistory() {
        synchronized (history) {
            return new ArrayList<>(history);
        }
    }

    private static void addToHistory(ReloadRecord record) {
        synchronized (history) {
            if (history.size() >= MAX_HISTORY) {
                history.remove(0);
            }
            history.add(record);
        }
    }

    /**
     * 상태 요약
     */
    public static String getStatusSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("ModReloader Status:\n");
        sb.append("  Registered Mods: ").append(registeredMods.size()).append("\n");
        for (String modId : registeredMods.keySet()) {
            sb.append("    - ").append(modId).append("\n");
        }
        sb.append("  Reload History: ").append(history.size()).append(" records\n");
        return sb.toString();
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 정보
     */
    private static class ModInfo {
        @SuppressWarnings("unused") // Used for identification in future modId-based operations
        final String modId;
        final File modPath;
        final ReloadCallback callback;

        ModInfo(String modId, File modPath, ReloadCallback callback) {
            this.modId = modId;
            this.modPath = modPath;
            this.callback = callback;
        }
    }

    /**
     * 리로드 콜백
     */
    @FunctionalInterface
    public interface ReloadCallback {
        void onReload();
    }

    /**
     * 리로드 리스너
     */
    @FunctionalInterface
    public interface ReloadListener {
        void onModReloaded(String modId, boolean success);
    }

    /**
     * 리로드 기록
     */
    public static class ReloadRecord {
        private final String modId;
        private final boolean success;
        private final long durationMs;
        private final String errorMessage;
        private final long timestamp;

        public ReloadRecord(String modId, boolean success, long durationMs, String errorMessage) {
            this.modId = modId;
            this.success = success;
            this.durationMs = durationMs;
            this.errorMessage = errorMessage;
            this.timestamp = System.currentTimeMillis();
        }

        public String getModId() {
            return modId;
        }

        public boolean isSuccess() {
            return success;
        }

        public long getDurationMs() {
            return durationMs;
        }

        public String getErrorMessage() {
            return errorMessage;
        }

        public long getTimestamp() {
            return timestamp;
        }

        @Override
        public String toString() {
            return String.format("%s: %s (%dms)%s",
                    modId, success ? "OK" : "FAILED", durationMs,
                    errorMessage != null ? " - " + errorMessage : "");
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\loader\package-info.java =====

/**
 * Pulse 모드 로더 시스템.
 * 
 * 모드의 안전한 로드/언로드/리로드를 관리합니다.
 * 
 * <h2>주요 클래스</h2>
 * <ul>
 * <li>{@link com.pulse.loader.ModReloader} - 안전한 모드 핫 리로드</li>
 * </ul>
 * 
 * @since Pulse 1.2
 */
package com.pulse.loader;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lua\BatchLuaBridge.java =====

package com.pulse.lua;

import com.pulse.api.log.PulseLogger;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Batched Lua Bridge.
 * Queues Lua calls and executes them in a single batch to reduce JNI/Reflection
 * overhead overhead frequency.
 * 
 * Note: Since PZ Lua engine (Kahlua) is fundamentally single-threaded,
 * this batching mainly helps with logical grouping and potential future
 * optimization
 * where we might construct a single Lua chunk to execute multiple calls.
 * 
 * @since 1.1.0
 */
public class BatchLuaBridge implements IBatchExecutor {

    private static final String LOG = PulseLogger.PULSE;
    private final int batchSize;
    private final ConcurrentLinkedQueue<LuaCall> pendingCalls = new ConcurrentLinkedQueue<>();

    private static class LuaCall {
        final String function;
        final Object[] args;

        LuaCall(String function, Object[] args) {
            this.function = function;
            this.args = args;
        }
    }

    /**
     * Creates a new BatchLuaBridge with default batch size of 100.
     */
    public BatchLuaBridge() {
        this(100);
    }

    /**
     * Creates a new BatchLuaBridge.
     * 
     * @param batchSize Number of calls to buffer before auto-flushing.
     */
    public BatchLuaBridge(int batchSize) {
        this.batchSize = batchSize;
    }

    /**
     * Queues a Lua function call.
     * Automatically flushes if batch size is reached.
     * 
     * @param function Function path (e.g. "print")
     * @param args     Arguments
     */
    public void queueCall(String function, Object... args) {
        pendingCalls.offer(new LuaCall(function, args));
        if (pendingCalls.size() >= batchSize) {
            flush();
        }
    }

    /**
     * Flushes all pending calls to the Lua engine.
     * This executes them one by one using the underlying LuaBridge.
     */
    public synchronized void flush() {
        if (pendingCalls.isEmpty()) {
            return;
        }

        if (!LuaBridge.isAvailable()) {
            // Cannot execute yet, keep in queue or clear?
            // For now, we wait until available, but warn if queue gets too large
            if (pendingCalls.size() > 1000) {
                PulseLogger.warn(LOG, "[BatchLua] Queue too large (1000+), clearing to prevent OOM. Lua not ready?");
                pendingCalls.clear();
            }
            return;
        }

        List<LuaCall> batch = new ArrayList<>();
        LuaCall call;
        while ((call = pendingCalls.poll()) != null) {
            batch.add(call);
        }

        // Execute batch
        // In the future, this could generate a single Lua script string:
        // "func1(args); func2(args); ..." for true batching.
        // For now, we iterate.
        int successCount = 0;
        for (LuaCall c : batch) {
            try {
                LuaBridge.call(c.function, c.args);
                successCount++;
            } catch (Exception e) {
                PulseLogger.error(LOG, "[BatchLua] Error executing batched call {}: {}", c.function, e.getMessage());
            }
        }

        PulseLogger.trace(LOG, "[BatchLua] Flushed {} calls", successCount);
    }

    /**
     * Current queue size.
     */
    public int getQueueSize() {
        return pendingCalls.size();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lua\IBatchExecutor.java =====

package com.pulse.lua;

/**
 * Interface for batch execution of Lua calls.
 * Allows switching between different batching strategies (e.g. Iterative vs
 * Script Generation).
 */
public interface IBatchExecutor {

    /**
     * Queues a Lua function call.
     * 
     * @param function Function path (e.g. "print")
     * @param args     Arguments
     */
    void queueCall(String function, Object... args);

    /**
     * Flushes all pending calls to the Lua engine.
     */
    void flush();

    /**
     * Gets the current number of pending calls.
     */
    int getQueueSize();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lua\LuaBridge.java =====

package com.pulse.lua;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.util.ReflectionCache;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.function.Function;

/**
 * Lua-Java 브릿지 (파사드).
 * 
 * <p>
 * Java에서 Lua 함수를 호출하고 Lua에서 Java를 호출할 수 있도록 함.
 * PZ는 Kahlua2 기반 Lua 엔진을 사용하므로, 이 브릿지는 그에 맞춰 설계됨.
 * </p>
 * 
 * <p>
 * v2.0: 책임 분리됨
 * </p>
 * <ul>
 * <li>{@link LuaStateManager} - 초기화 및 상태 관리</li>
 * <li>{@link LuaCallInvoker} - Lua 함수 호출 및 코드 실행</li>
 * <li>{@link LuaExposure} - Java 클래스 노출 및 테이블 관리</li>
 * </ul>
 * 
 * <h2>사용 예</h2>
 * 
 * <pre>
 * // Lua 함수 호출
 * LuaBridge.call("Events.OnTick.Add", myJavaCallback);
 * 
 * // Lua 전역 변수 접근
 * Object value = LuaBridge.getGlobal("SomeGlobalVar");
 * 
 * // Java 메서드를 Lua에 노출
 * LuaBridge.expose("MyMod", MyModAPI.class);
 * </pre>
 * 
 * @since Pulse 1.0
 * @since Pulse 2.0 - 책임 분리 (LuaStateManager, LuaCallInvoker, LuaExposure)
 */
public class LuaBridge {

    private static final String LOG = PulseLogger.PULSE;
    private static final LuaBridge INSTANCE = new LuaBridge();

    private LuaBridge() {
    }

    public static LuaBridge getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 초기화 (위임: LuaStateManager)
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 브릿지 초기화.
     */
    public static void initialize() {
        LuaStateManager.getInstance().initialize();
    }

    /**
     * 런타임에 Lua 상태가 사용 가능한지 확인.
     */
    public static boolean isAvailable() {
        return LuaStateManager.getInstance().isAvailable();
    }

    /**
     * Lua 상태 재초기화.
     */
    public static void reinitialize() {
        LuaStateManager.getInstance().reinitialize();
    }

    // ─────────────────────────────────────────────────────────────
    // Lua 함수 호출 (위임: LuaCallInvoker)
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 함수 호출.
     */
    public static Object call(String functionPath, Object... args) {
        return LuaCallInvoker.getInstance().call(functionPath, args);
    }

    /**
     * Lua 전역 변수 읽기.
     */
    public static Object getGlobal(String name) {
        return LuaCallInvoker.getInstance().getGlobal(name);
    }

    /**
     * Lua 전역 변수 설정.
     */
    public static void setGlobal(String name, Object value) {
        LuaCallInvoker.getInstance().setGlobal(name, value);
    }

    /**
     * Lua 코드 문자열 직접 실행.
     */
    public static Object executeLuaCode(String luaCode) {
        return LuaCallInvoker.getInstance().executeLuaCode(luaCode);
    }

    /**
     * 간단한 print 문 실행.
     */
    public static void luaPrint(String message) {
        LuaCallInvoker.getInstance().luaPrint(message);
    }

    /**
     * Get the total number of Lua calls made.
     */
    public static long getCallCount() {
        return LuaCallInvoker.getInstance().getCallCount();
    }

    // ─────────────────────────────────────────────────────────────
    // Java 클래스 노출 (위임: LuaExposure)
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 클래스를 Lua 전역으로 노출.
     */
    public static void expose(String globalName, Class<?> clazz) {
        LuaExposure.getInstance().expose(globalName, clazz);
    }

    /**
     * 대기 중인 노출 처리.
     */
    public static void processPendingExposures() {
        LuaExposure.getInstance().processPendingExposures();
    }

    /**
     * 새 Lua 테이블 생성.
     */
    public static Object createLuaTable() {
        return LuaExposure.getInstance().createLuaTable();
    }

    /**
     * Lua 테이블에 값 설정.
     */
    public static void setTableField(Object table, String key, Object value) {
        LuaExposure.getInstance().setTableField(table, key, value);
    }

    /**
     * Lua 테이블에서 값 가져오기.
     */
    public static Object getTableField(Object table, String key) {
        return LuaExposure.getInstance().getTableField(table, key);
    }

    /**
     * Java Map을 Lua 테이블로 변환하여 전역에 설정.
     */
    public static void setGlobalTable(String name, Map<String, Object> map) {
        LuaExposure.getInstance().setGlobalTable(name, map);
    }

    /**
     * Java 콜백을 Lua에서 호출 가능하게 등록.
     */
    public static void registerCallback(String name, Function<Object[], Object> callback) {
        LuaExposure.getInstance().registerCallback(name, callback);
    }

    // ─────────────────────────────────────────────────────────────
    // 디버그 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 디버그: Lua 전역 변수 덤프.
     */
    public static void dumpGlobals() {
        if (!isAvailable())
            return;

        try {
            Class<?> luaManagerClass = LuaStateManager.getLuaManagerClass();
            if (luaManagerClass == null)
                return;

            Field envField = ReflectionCache.getField(luaManagerClass, "env");
            Object env = envField.get(null);

            PulseLogger.info(LOG, "[Lua] === Global Variables ===");
            if (env != null) {
                PulseLogger.info(LOG, "[Lua] Env type: {}", env.getClass().getName());

                Method keysMethod = ReflectionCache.getMethodOrNull(env.getClass(), "keys");
                if (keysMethod != null) {
                    Object keys = keysMethod.invoke(env);

                    if (keys instanceof Iterable<?> iterable) {
                        int count = 0;
                        for (Object key : iterable) {
                            PulseLogger.info(LOG, "[Lua]   - {}", key);
                            count++;
                            if (count >= 50) {
                                PulseLogger.info(LOG, "[Lua]   ... (truncated, {}+ items)", count);
                                break;
                            }
                        }
                    } else if (keys != null) {
                        PulseLogger.info(LOG, "[Lua] Keys type: {}", keys.getClass().getName());
                    }
                } else {
                    PulseLogger.info(LOG, "[Lua] (keys() method not available)");
                }
            } else {
                PulseLogger.info(LOG, "[Lua] (env is null)");
            }
            PulseLogger.info(LOG, "[Lua] ========================");
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Failed to dump globals: {}", e.getMessage());
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lua\LuaCallInvoker.java =====

package com.pulse.lua;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.util.ReflectionCache;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Lua 함수 호출 및 전역 변수 접근.
 * 
 * <p>
 * v2.0: LuaBridge에서 분리됨
 * </p>
 * 
 * @since Pulse 2.0
 */
public final class LuaCallInvoker {

    private static final String LOG = PulseLogger.PULSE;
    private static final LuaCallInvoker INSTANCE = new LuaCallInvoker();
    private static final AtomicLong callCount = new AtomicLong(0);

    private LuaCallInvoker() {
    }

    public static LuaCallInvoker getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // Lua 함수 호출
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 함수 호출.
     * 
     * @param functionPath 함수 경로 (예: "Events.OnTick.Add" 또는 단순히 "print")
     * @param args         인자들
     * @return 반환값 (없으면 null)
     */
    public Object call(String functionPath, Object... args) {
        if (!LuaStateManager.getInstance().isAvailable()) {
            PulseLogger.error(LOG, "[Lua] Cannot call - Lua not available");
            return null;
        }

        callCount.incrementAndGet();
        try {
            Method cachedCallMethod = LuaStateManager.getCachedCallMethod();
            if (cachedCallMethod != null) {
                return cachedCallMethod.invoke(null, functionPath, args);
            }
            // Fallback
            Class<?> luaManagerClass = LuaStateManager.getLuaManagerClass();
            if (luaManagerClass == null)
                return null;
            Method callMethod = ReflectionCache.getMethod(
                    luaManagerClass, "call", String.class, Object[].class);
            return callMethod.invoke(null, functionPath, args);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Call failed: {}", functionPath, e);
            return null;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 전역 변수 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 전역 변수 읽기.
     */
    public Object getGlobal(String name) {
        if (!LuaStateManager.getInstance().isAvailable())
            return null;

        try {
            Method cachedGetGlobalMethod = LuaStateManager.getCachedGetGlobalMethod();
            if (cachedGetGlobalMethod != null) {
                return cachedGetGlobalMethod.invoke(null, name);
            }
            Class<?> luaManagerClass = LuaStateManager.getLuaManagerClass();
            if (luaManagerClass == null)
                return null;
            Method getMethod = ReflectionCache.getMethod(
                    luaManagerClass, "getGlobalObject", String.class);
            return getMethod.invoke(null, name);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Failed to get global: {}", name);
            return null;
        }
    }

    /**
     * Lua 전역 변수 설정.
     */
    public void setGlobal(String name, Object value) {
        if (!LuaStateManager.getInstance().isAvailable())
            return;

        try {
            Object converted = LuaTypeConverter.javaToLua(value);
            Method cachedSetGlobalMethod = LuaStateManager.getCachedSetGlobalMethod();
            if (cachedSetGlobalMethod != null) {
                cachedSetGlobalMethod.invoke(null, name, converted);
                return;
            }
            Class<?> luaManagerClass = LuaStateManager.getLuaManagerClass();
            if (luaManagerClass == null)
                return;
            Method setMethod = ReflectionCache.getMethod(
                    luaManagerClass, "setGlobalObject", String.class, Object.class);
            setMethod.invoke(null, name, converted);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Failed to set global: {}", name);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // Lua 코드 실행
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 코드 문자열 직접 실행.
     * 
     * @param luaCode 실행할 Lua 코드 문자열
     * @return 실행 결과 또는 null
     */
    public Object executeLuaCode(String luaCode) {
        if (!LuaStateManager.getInstance().isAvailable()) {
            PulseLogger.error(LOG, "[Lua] Cannot execute - Lua not available");
            return null;
        }

        try {
            Class<?> luaManagerClass = LuaStateManager.getLuaManagerClass();
            if (luaManagerClass == null)
                return null;

            // RunLua 메서드 시도
            Method runMethod = ReflectionCache.getMethodOrNull(luaManagerClass, "RunLua", String.class);
            if (runMethod != null) {
                return runMethod.invoke(null, luaCode);
            }

            // 대안: LuaManager.convertor.load() 시도
            try {
                Field convertorField = ReflectionCache.getField(luaManagerClass, "convertor");
                Object convertor = convertorField.get(null);

                if (convertor != null) {
                    Method loadMethod = ReflectionCache.getMethod(
                            convertor.getClass(), "load", String.class, String.class);
                    return loadMethod.invoke(convertor, luaCode, "Pulse");
                }
            } catch (NoSuchFieldException | NoSuchMethodException ignored) {
            }
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Failed to execute code: {}", e.getMessage(), e);
        }

        return null;
    }

    /**
     * 간단한 print 문 실행.
     */
    public void luaPrint(String message) {
        executeLuaCode("print(\"" + message.replace("\"", "\\\"") + "\")");
    }

    // ─────────────────────────────────────────────────────────────
    // 통계
    // ─────────────────────────────────────────────────────────────

    /**
     * Get the total number of Lua calls made.
     */
    public long getCallCount() {
        return callCount.get();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lua\LuaEventAdapter.java =====

package com.pulse.lua;

import com.pulse.api.log.PulseLogger;
import com.pulse.event.Event;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.event.lifecycle.WorldLoadEvent;
import com.pulse.event.lifecycle.WorldUnloadEvent;
import com.pulse.event.player.PlayerUpdateEvent;
import com.pulse.event.player.PlayerDamageEvent;
import com.pulse.event.npc.ZombieDeathEvent;
import com.pulse.event.npc.ZombieSpawnEvent;
import com.pulse.event.environment.TimeChangeEvent;
import com.pulse.event.environment.WeatherChangeEvent;
import com.pulse.event.vehicle.VehicleEnterEvent;
import com.pulse.event.vehicle.VehicleExitEvent;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * EventBus ↔ Lua 이벤트 양방향 어댑터.
 * 
 * Java 이벤트 → Lua 콜백:
 * 
 * <pre>
 * LuaEventAdapter.bridgeToLua(GameTickEvent.class, "OnTick");
 * </pre>
 * 
 * Lua 이벤트 → Java EventBus:
 * 
 * <pre>
 * LuaEventAdapter.bridgeFromLua("OnPlayerMove", PlayerMoveEvent.class,
 *         args -> new PlayerMoveEvent(args[0], args[1], args[2]));
 * </pre>
 */
public class LuaEventAdapter {

    private static final String LOG = PulseLogger.PULSE;
    private static final String MOD_ID = "pulse_lua_adapter";
    private static boolean standardMappingsInitialized = false;

    // Lua 이벤트 이름 → Java 이벤트 클래스
    private static final Map<String, LuaToJavaMapping<?>> luaToJavaMappings = new ConcurrentHashMap<>();

    // Java 이벤트 클래스 → Lua 이벤트 이름
    private static final Map<Class<? extends Event>, String> javaToLuaMappings = new ConcurrentHashMap<>();

    private LuaEventAdapter() {
    }

    // ─────────────────────────────────────────────────────────────
    // Java → Lua 브릿지
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 이벤트가 발생하면 Lua 이벤트로 전달.
     * 
     * @param eventClass   Java 이벤트 클래스
     * @param luaEventName PZ Lua 이벤트 이름 (예: "OnTick", "OnPlayerMove")
     */
    public static <T extends Event> void bridgeToLua(Class<T> eventClass, String luaEventName) {
        if (javaToLuaMappings.containsKey(eventClass)) {
            return; // 이미 등록됨
        }

        javaToLuaMappings.put(eventClass, luaEventName);

        EventBus.subscribe(eventClass, event -> {
            triggerLuaEvent(luaEventName, eventToLuaArgs(event));
        }, MOD_ID);

        PulseLogger.info(LOG, "[LuaAdapter] Bridged {} → Lua:{}", eventClass.getSimpleName(), luaEventName);
    }

    /**
     * Lua 이벤트 트리거.
     */
    private static void triggerLuaEvent(String eventName, Object... args) {
        if (!LuaBridge.isAvailable())
            return;

        try {
            // Events.<eventName>.Trigger(args...)
            LuaBridge.call("Events." + eventName + ".Trigger", args);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[LuaAdapter] Failed to trigger Lua event: {}", eventName);
        }
    }

    /**
     * Event 객체를 Lua 인자로 변환.
     */
    private static Object[] eventToLuaArgs(Event event) {
        // 이벤트 타입에 따라 적절한 인자 추출
        if (event instanceof GameTickEvent e) {
            return new Object[] { e.getTick() };
        }
        if (event instanceof PlayerUpdateEvent e) {
            return new Object[] { e.getPlayer() };
        }
        if (event instanceof PlayerDamageEvent e) {
            return new Object[] { e.getPlayer(), e.getDamage(), e.getDamageType() };
        }
        if (event instanceof ZombieDeathEvent e) {
            return new Object[] { e.getZombie(), e.getKiller() };
        }
        if (event instanceof ZombieSpawnEvent e) {
            return new Object[] { e.getZombie() };
        }
        if (event instanceof TimeChangeEvent e) {
            return new Object[] { e.getHour(), e.getMinute() };
        }
        if (event instanceof VehicleEnterEvent e) {
            return new Object[] { e.getVehicle(), e.getPlayer() };
        }
        if (event instanceof VehicleExitEvent e) {
            return new Object[] { e.getVehicle(), e.getPlayer() };
        }

        // 기본: 이벤트 객체 자체를 전달
        return new Object[] { event };
    }

    // ─────────────────────────────────────────────────────────────
    // Lua → Java 브릿지
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 이벤트를 Java EventBus로 전달.
     * 
     * @param luaEventName Lua 이벤트 이름
     * @param eventClass   Java 이벤트 클래스
     * @param factory      Lua 인자 → Java 이벤트 변환 함수
     */
    public static <T extends Event> void bridgeFromLua(
            String luaEventName,
            Class<T> eventClass,
            LuaEventFactory<T> factory) {

        luaToJavaMappings.put(luaEventName, new LuaToJavaMapping<>(eventClass, factory));

        // Lua에 Java 콜백 등록
        registerLuaCallback(luaEventName);

        PulseLogger.info(LOG, "[LuaAdapter] Bridged Lua:{} → {}", luaEventName, eventClass.getSimpleName());
    }

    /**
     * Lua 이벤트에 Java 콜백 등록.
     */
    private static void registerLuaCallback(String luaEventName) {
        if (!LuaBridge.isAvailable()) {
            // 나중에 처리
            return;
        }

        try {
            // Lua 쪽에서 호출할 Java 메서드 노출
            // Events.<eventName>.Add(function) 형태로 등록

            // Java 콜백 객체 생성
            LuaCallback callback = args -> onLuaEvent(luaEventName, args);

            // Lua에 등록
            LuaBridge.call("Events." + luaEventName + ".Add", callback);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[LuaAdapter] Failed to register Lua callback: {}", luaEventName);
        }
    }

    /**
     * Lua에서 호출되는 콜백.
     */
    @SuppressWarnings("unchecked")
    private static void onLuaEvent(String luaEventName, Object[] args) {
        LuaToJavaMapping<?> mapping = luaToJavaMappings.get(luaEventName);
        if (mapping == null)
            return;

        try {
            Event event = ((LuaToJavaMapping<Event>) mapping).factory.create(args);
            EventBus.post(event);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[LuaAdapter] Failed to create event from Lua: {}", luaEventName, e);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 표준 이벤트 매핑 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 표준 PZ 이벤트 ↔ Pulse 이벤트 매핑 설정.
     */
    public static void initializeStandardMappings() {
        if (standardMappingsInitialized) {
            return;
        }

        int count = 0;

        // ═══════════════════════════════════════════════════════════
        // Java → Lua 방향
        // ═══════════════════════════════════════════════════════════

        // 라이프사이클 이벤트
        bridgeToLua(GameTickEvent.class, "OnPulseTick");
        count++;

        bridgeToLua(WorldLoadEvent.class, "OnPulseWorldLoad");
        count++;

        bridgeToLua(WorldUnloadEvent.class, "OnPulseWorldUnload");
        count++;

        // 플레이어 이벤트
        bridgeToLua(PlayerUpdateEvent.class, "OnPulsePlayerUpdate");
        count++;

        bridgeToLua(PlayerDamageEvent.class, "OnPulsePlayerDamage");
        count++;

        // 좀비 이벤트
        bridgeToLua(ZombieDeathEvent.class, "OnPulseZombieDeath");
        count++;

        bridgeToLua(ZombieSpawnEvent.class, "OnPulseZombieSpawn");
        count++;

        // 환경 이벤트
        bridgeToLua(TimeChangeEvent.class, "OnPulseTimeChange");
        count++;

        bridgeToLua(WeatherChangeEvent.class, "OnPulseWeatherChange");
        count++;

        // 차량 이벤트
        bridgeToLua(VehicleEnterEvent.class, "OnPulseVehicleEnter");
        count++;

        bridgeToLua(VehicleExitEvent.class, "OnPulseVehicleExit");
        count++;

        // ═══════════════════════════════════════════════════════════
        // Lua → Java 방향 (PZ 네이티브 이벤트 래핑)
        // ═══════════════════════════════════════════════════════════

        // 이 부분은 게임 이벤트를 Java EventBus로 변환
        // 실제 연결은 런타임에 LuaBridge가 사용 가능할 때 수행됨

        standardMappingsInitialized = true;
        PulseLogger.info(LOG, "[LuaAdapter] Standard mappings initialized: {} events", count);
    }

    /**
     * 매핑 현황 출력 (디버그용).
     */
    public static void printMappings() {
        PulseLogger.info(LOG, "[LuaAdapter] === Event Mappings ===");
        PulseLogger.info(LOG, "[LuaAdapter] Java → Lua:");
        for (var entry : javaToLuaMappings.entrySet()) {
            PulseLogger.info(LOG, "[LuaAdapter]   {} → {}", entry.getKey().getSimpleName(), entry.getValue());
        }
        PulseLogger.info(LOG, "[LuaAdapter] Lua → Java:");
        for (var entry : luaToJavaMappings.entrySet()) {
            PulseLogger.info(LOG, "[LuaAdapter]   {} → {}", entry.getKey(),
                    entry.getValue().eventClass.getSimpleName());
        }
        PulseLogger.info(LOG, "[LuaAdapter] =====================");
    }

    /**
     * 매핑 개수 반환.
     */
    public static int getMappingCount() {
        return javaToLuaMappings.size() + luaToJavaMappings.size();
    }

    // ─────────────────────────────────────────────────────────────
    // 헬퍼 클래스/인터페이스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface LuaEventFactory<T extends Event> {
        T create(Object[] luaArgs);
    }

    @FunctionalInterface
    public interface LuaCallback {
        void call(Object[] args);
    }

    private static class LuaToJavaMapping<T extends Event> {
        final Class<T> eventClass;
        final LuaEventFactory<T> factory;

        LuaToJavaMapping(Class<T> eventClass, LuaEventFactory<T> factory) {
            this.eventClass = eventClass;
            this.factory = factory;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lua\LuaExposure.java =====

package com.pulse.lua;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.util.ReflectionCache;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

/**
 * Java 클래스를 Lua에 노출하고 테이블/콜백을 관리.
 * 
 * <p>
 * v2.0: LuaBridge에서 분리됨
 * </p>
 * 
 * @since Pulse 2.0
 */
public final class LuaExposure {

    private static final String LOG = PulseLogger.PULSE;
    private static final LuaExposure INSTANCE = new LuaExposure();

    // 지연 노출 대기열
    private static final Map<String, Class<?>> pendingExposures = new ConcurrentHashMap<>();

    private LuaExposure() {
    }

    public static LuaExposure getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // Java 클래스 노출
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 클래스를 Lua 전역으로 노출.
     * 정적 메서드들이 Lua에서 호출 가능해짐.
     * 
     * @param globalName Lua에서 사용할 이름
     * @param clazz      노출할 클래스
     */
    public void expose(String globalName, Class<?> clazz) {
        if (!LuaStateManager.getInstance().isAvailable()) {
            pendingExposures.put(globalName, clazz);
            return;
        }
        exposeInternal(globalName, clazz);
    }

    private void exposeInternal(String globalName, Class<?> clazz) {
        try {
            Method cachedExposeMethod = LuaStateManager.getCachedExposeMethod();
            if (cachedExposeMethod != null) {
                cachedExposeMethod.invoke(null, globalName, clazz);
                PulseLogger.info(LOG, "[Lua] Exposed: {} -> {}", globalName, clazz.getSimpleName());
                return;
            }
            Class<?> luaManagerClass = LuaStateManager.getLuaManagerClass();
            if (luaManagerClass == null)
                return;
            Method exposeMethod = ReflectionCache.getMethod(
                    luaManagerClass, "expose", String.class, Class.class);
            exposeMethod.invoke(null, globalName, clazz);
            PulseLogger.info(LOG, "[Lua] Exposed: {} -> {}", globalName, clazz.getSimpleName());
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Failed to expose: {}", globalName, e);
        }
    }

    /**
     * 대기 중인 노출 처리 (초기화 후 호출).
     */
    public void processPendingExposures() {
        if (!LuaStateManager.getInstance().isAvailable())
            return;
        for (var entry : pendingExposures.entrySet()) {
            exposeInternal(entry.getKey(), entry.getValue());
        }
        pendingExposures.clear();
    }

    // ─────────────────────────────────────────────────────────────
    // Lua 테이블 생성/조작
    // ─────────────────────────────────────────────────────────────

    /**
     * 새 Lua 테이블 생성.
     * 
     * @return Lua 테이블 객체 또는 null
     */
    public Object createLuaTable() {
        if (!LuaStateManager.getInstance().isAvailable()) {
            return null;
        }

        try {
            Class<?> kahluaTableClass = ReflectionCache.getClassOrNull(
                    "se.krka.kahlua.vm.KahluaTable", LuaExposure.class.getClassLoader());
            if (kahluaTableClass != null) {
                return kahluaTableClass.getDeclaredConstructor().newInstance();
            }

            Class<?> luaManagerClass = LuaStateManager.getLuaManagerClass();
            if (luaManagerClass != null) {
                Field envField = ReflectionCache.getField(luaManagerClass, "env");
                Object env = envField.get(null);

                if (env != null) {
                    Method newTableMethod = ReflectionCache.getMethod(env.getClass(), "newTable");
                    return newTableMethod.invoke(env);
                }
            }
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Failed to create table: {}", e.getMessage());
        }

        return null;
    }

    /**
     * Lua 테이블에 값 설정.
     */
    public void setTableField(Object table, String key, Object value) {
        if (table == null)
            return;

        try {
            Method rawsetMethod = table.getClass().getMethod("rawset", Object.class, Object.class);
            Object converted = LuaTypeConverter.javaToLua(value);
            rawsetMethod.invoke(table, key, converted);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Failed to set table field: {}", key);
        }
    }

    /**
     * Lua 테이블에서 값 가져오기.
     */
    public Object getTableField(Object table, String key) {
        if (table == null)
            return null;

        try {
            Method rawgetMethod = table.getClass().getMethod("rawget", Object.class);
            return rawgetMethod.invoke(table, key);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Failed to get table field: {}", key);
            return null;
        }
    }

    /**
     * Java Map을 Lua 테이블로 변환하여 전역에 설정.
     */
    public void setGlobalTable(String name, Map<String, Object> map) {
        if (!LuaStateManager.getInstance().isAvailable())
            return;

        Object table = createLuaTable();
        if (table == null)
            return;

        for (var entry : map.entrySet()) {
            setTableField(table, entry.getKey(), entry.getValue());
        }

        LuaCallInvoker.getInstance().setGlobal(name, table);
    }

    // ─────────────────────────────────────────────────────────────
    // Java 콜백 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 콜백을 Lua에서 호출 가능하게 등록.
     */
    public void registerCallback(String name, Function<Object[], Object> callback) {
        if (!LuaStateManager.getInstance().isAvailable()) {
            PulseLogger.error(LOG, "[Lua] Cannot register callback - Lua not available");
            return;
        }

        Object wrapper = createCallableWrapper(callback);
        if (wrapper != null) {
            LuaCallInvoker.getInstance().setGlobal(name, wrapper);
            PulseLogger.info(LOG, "[Lua] Registered callback: {}", name);
        }
    }

    private Object createCallableWrapper(Function<Object[], Object> callback) {
        try {
            Class<?> luaCallerClass = ReflectionCache.getClassOrNull(
                    "se.krka.kahlua.vm.LuaCallable", LuaExposure.class.getClassLoader());
            if (luaCallerClass == null) {
                PulseLogger.warn(LOG, "[Lua] LuaCallable class not found");
                return null;
            }

            return java.lang.reflect.Proxy.newProxyInstance(
                    luaCallerClass.getClassLoader(),
                    new Class<?>[] { luaCallerClass },
                    (proxy, method, args) -> {
                        if (method.getName().equals("call")) {
                            Object callFrame = args[0];
                            int argCount = (int) args[1];

                            Object[] luaArgs = new Object[argCount];
                            Method getMethod = ReflectionCache.getMethod(callFrame.getClass(), "get", int.class);
                            for (int i = 0; i < argCount; i++) {
                                luaArgs[i] = getMethod.invoke(callFrame, i);
                            }

                            Object result = callback.apply(luaArgs);

                            if (result != null) {
                                Method pushMethod = ReflectionCache.getMethod(callFrame.getClass(), "push",
                                        Object.class);
                                pushMethod.invoke(callFrame, LuaTypeConverter.javaToLua(result));
                                return 1;
                            }
                            return 0;
                        }
                        return null;
                    });
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Failed to create callable wrapper: {}", e.getMessage());
            return null;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lua\LuaStateManager.java =====

package com.pulse.lua;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.util.ReflectionCache;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * Lua 상태 관리자.
 * Lua 엔진 초기화 및 상태 관리를 담당합니다.
 * 
 * <p>
 * v2.0: LuaBridge에서 분리됨
 * </p>
 * 
 * @since Pulse 2.0
 */
public final class LuaStateManager {

    private static final String LOG = PulseLogger.PULSE;
    private static final LuaStateManager INSTANCE = new LuaStateManager();

    static final String LUA_MANAGER_CLASS = "zombie.Lua.LuaManager";

    private boolean initialized = false;
    private Object luaState; // KahluaThread 또는 LuaState

    // 캐싱된 리플렉션 참조
    private static volatile Class<?> cachedLuaManagerClass;
    private static volatile Method cachedCallMethod;
    private static volatile Method cachedGetGlobalMethod;
    private static volatile Method cachedSetGlobalMethod;
    private static volatile Method cachedExposeMethod;

    private LuaStateManager() {
    }

    public static LuaStateManager getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 브릿지 초기화.
     * PulseAgent에서 게임 시작 시 호출됨.
     */
    public void initialize() {
        if (initialized)
            return;

        try {
            Class<?> luaManagerClass = getLuaManagerClass();
            if (luaManagerClass == null) {
                PulseLogger.warn(LOG, "[Lua] PZ Lua classes not found - running outside game?");
                return;
            }

            Field stateField = ReflectionCache.getField(luaManagerClass, "thread");
            luaState = stateField.get(null);

            if (luaState != null) {
                initMethodCache(luaManagerClass);
                PulseLogger.info(LOG, "[Lua] Lua state acquired successfully (cached)");
                initialized = true;
            } else {
                PulseLogger.warn(LOG, "[Lua] Lua state is null - game not fully loaded yet");
            }
        } catch (NoSuchFieldException e) {
            PulseLogger.warn(LOG, "[Lua] LuaManager.thread field not found");
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Lua] Failed to initialize: {}", e.getMessage());
        }
    }

    /**
     * LuaManager 클래스 캐싱된 조회
     */
    static Class<?> getLuaManagerClass() {
        if (cachedLuaManagerClass == null) {
            synchronized (LuaStateManager.class) {
                if (cachedLuaManagerClass == null) {
                    cachedLuaManagerClass = ReflectionCache.getClassOrNull(
                            LUA_MANAGER_CLASS, LuaStateManager.class.getClassLoader());
                }
            }
        }
        return cachedLuaManagerClass;
    }

    /**
     * 자주 호출되는 메서드들 초기화 시 캐싱
     */
    private void initMethodCache(Class<?> luaManagerClass) {
        try {
            cachedCallMethod = ReflectionCache.getMethodOrNull(
                    luaManagerClass, "call", String.class, Object[].class);
            cachedGetGlobalMethod = ReflectionCache.getMethodOrNull(
                    luaManagerClass, "getGlobalObject", String.class);
            cachedSetGlobalMethod = ReflectionCache.getMethodOrNull(
                    luaManagerClass, "setGlobalObject", String.class, Object.class);
            cachedExposeMethod = ReflectionCache.getMethodOrNull(
                    luaManagerClass, "expose", String.class, Class.class);
        } catch (Exception e) {
            PulseLogger.warn(LOG, "[Lua] Some methods not cached: {}", e.getMessage());
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 상태 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * 런타임에 Lua 상태가 사용 가능한지 확인.
     */
    public boolean isAvailable() {
        return initialized && luaState != null;
    }

    /**
     * Lua 상태 반환.
     */
    public Object getLuaState() {
        return luaState;
    }

    /**
     * 초기화 여부 반환.
     */
    public boolean isInitialized() {
        return initialized;
    }

    // ─────────────────────────────────────────────────────────────
    // 캐싱된 메서드 접근자
    // ─────────────────────────────────────────────────────────────

    static Method getCachedCallMethod() {
        return cachedCallMethod;
    }

    static Method getCachedGetGlobalMethod() {
        return cachedGetGlobalMethod;
    }

    static Method getCachedSetGlobalMethod() {
        return cachedSetGlobalMethod;
    }

    static Method getCachedExposeMethod() {
        return cachedExposeMethod;
    }

    // ─────────────────────────────────────────────────────────────
    // 재초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 상태 재초기화 (게임 재시작 시 호출).
     */
    public void reinitialize() {
        initialized = false;
        luaState = null;
        cachedLuaManagerClass = null;
        cachedCallMethod = null;
        cachedGetGlobalMethod = null;
        cachedSetGlobalMethod = null;
        cachedExposeMethod = null;
        initialize();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lua\LuaTypeConverter.java =====

package com.pulse.lua;

import java.util.List;
import java.util.Map;

/**
 * Java ↔ Lua 타입 변환기.
 * 양방향으로 타입을 안전하게 변환.
 */
public class LuaTypeConverter {

    private LuaTypeConverter() {
    }

    // ─────────────────────────────────────────────────────────────
    // Java → Lua
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 객체를 Lua 호환 객체로 변환.
     */
    public static Object javaToLua(Object javaValue) {
        if (javaValue == null) {
            return null;
        }

        // 기본 타입은 그대로 전달 (Kahlua가 처리)
        if (javaValue instanceof String ||
                javaValue instanceof Number ||
                javaValue instanceof Boolean) {
            return javaValue;
        }

        // 배열 → Lua 테이블 (인덱스 1부터)
        if (javaValue.getClass().isArray()) {
            return arrayToLuaTable(javaValue);
        }

        // List → Lua 테이블
        if (javaValue instanceof List<?>) {
            return listToLuaTable((List<?>) javaValue);
        }

        // Map → Lua 테이블
        if (javaValue instanceof Map<?, ?>) {
            return mapToLuaTable((Map<?, ?>) javaValue);
        }

        // 기타 객체는 그대로 (userdata로 전달됨)
        return javaValue;
    }

    private static Object arrayToLuaTable(Object array) {
        try {
            // KahluaTable 생성 시도
            Class<?> tableClass = Class.forName("se.krka.kahlua.vm.KahluaTable");
            Object table = tableClass.getDeclaredConstructor().newInstance();

            int length = java.lang.reflect.Array.getLength(array);
            for (int i = 0; i < length; i++) {
                Object item = java.lang.reflect.Array.get(array, i);
                // Lua는 1-based 인덱스
                tableClass.getMethod("rawset", Object.class, Object.class)
                        .invoke(table, (double) (i + 1), javaToLua(item));
            }
            return table;
        } catch (Exception e) {
            // 테이블 생성 실패 시 원본 반환
            return array;
        }
    }

    private static Object listToLuaTable(List<?> list) {
        try {
            Class<?> tableClass = Class.forName("se.krka.kahlua.vm.KahluaTable");
            Object table = tableClass.getDeclaredConstructor().newInstance();

            int i = 1;
            for (Object item : list) {
                tableClass.getMethod("rawset", Object.class, Object.class)
                        .invoke(table, (double) i++, javaToLua(item));
            }
            return table;
        } catch (Exception e) {
            return list;
        }
    }

    private static Object mapToLuaTable(Map<?, ?> map) {
        try {
            Class<?> tableClass = Class.forName("se.krka.kahlua.vm.KahluaTable");
            Object table = tableClass.getDeclaredConstructor().newInstance();

            for (var entry : map.entrySet()) {
                Object key = javaToLua(entry.getKey());
                Object value = javaToLua(entry.getValue());
                tableClass.getMethod("rawset", Object.class, Object.class)
                        .invoke(table, key, value);
            }
            return table;
        } catch (Exception e) {
            return map;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // Lua → Java
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 값을 Java 타입으로 변환.
     */
    @SuppressWarnings("unchecked")
    public static <T> T luaToJava(Object luaValue, Class<T> targetType) {
        if (luaValue == null) {
            return null;
        }

        // 이미 원하는 타입이면 그대로 반환
        if (targetType.isInstance(luaValue)) {
            return (T) luaValue;
        }

        // Lua number → 다양한 숫자 타입
        if (luaValue instanceof Double) {
            Double d = (Double) luaValue;
            if (targetType == Integer.class || targetType == int.class) {
                return (T) Integer.valueOf(d.intValue());
            }
            if (targetType == Long.class || targetType == long.class) {
                return (T) Long.valueOf(d.longValue());
            }
            if (targetType == Float.class || targetType == float.class) {
                return (T) Float.valueOf(d.floatValue());
            }
            if (targetType == Double.class || targetType == double.class) {
                return (T) d;
            }
        }

        // String 변환
        if (targetType == String.class) {
            return (T) String.valueOf(luaValue);
        }

        // Boolean 변환
        if (targetType == Boolean.class || targetType == boolean.class) {
            if (luaValue instanceof Boolean) {
                return (T) luaValue;
            }
            return (T) Boolean.TRUE; // Lua에서 nil과 false만 falsy
        }

        // KahluaTable → List
        if (targetType == List.class) {
            return (T) luaTableToList(luaValue);
        }

        // KahluaTable → Map
        if (targetType == Map.class) {
            return (T) luaTableToMap(luaValue);
        }

        // 변환 불가 - 원본 반환 시도
        try {
            return (T) luaValue;
        } catch (ClassCastException e) {
            return null;
        }
    }

    private static List<Object> luaTableToList(Object luaTable) {
        List<Object> result = new java.util.ArrayList<>();
        try {
            Class<?> tableClass = luaTable.getClass();
            java.lang.reflect.Method lenMethod = tableClass.getMethod("len");
            int len = ((Number) lenMethod.invoke(luaTable)).intValue();

            java.lang.reflect.Method rawgetMethod = tableClass.getMethod(
                    "rawget", Object.class);

            for (int i = 1; i <= len; i++) {
                Object value = rawgetMethod.invoke(luaTable, (double) i);
                result.add(value);
            }
        } catch (Exception e) {
            // 변환 실패
        }
        return result;
    }

    private static Map<Object, Object> luaTableToMap(Object luaTable) {
        Map<Object, Object> result = new java.util.LinkedHashMap<>();
        try {
            Class<?> tableClass = luaTable.getClass();

            // 테이블의 next() 메서드로 순회
            java.lang.reflect.Method nextMethod = tableClass.getMethod(
                    "next", Object.class);
            java.lang.reflect.Method rawgetMethod = tableClass.getMethod(
                    "rawget", Object.class);

            Object key = nextMethod.invoke(luaTable, (Object) null);
            while (key != null) {
                Object value = rawgetMethod.invoke(luaTable, key);
                result.put(key, value);
                key = nextMethod.invoke(luaTable, key);
            }
        } catch (Exception e) {
            // 변환 실패
        }
        return result;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\lua\PulseLuaController.java =====

package com.pulse.lua;

import com.pulse.api.log.PulseLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Lua 실행 제어 및 샌드박스 관리.
 * 
 * Nerve 최적화에 필요한 기능들을 제공합니다:
 * - Lua 콜백 호출 시간 제한 (budget)
 * - 과도한 UI/Lua 이벤트 차단
 * - 비싼 함수 throttle/skip 결정
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // 실행 시간 제한 설정 (밀리초)
 * PulseLuaController.setBudget(50);
 * 
 * // 특정 함수 차단
 * PulseLuaController.blockFunction("ISInventoryPane:refreshBackground");
 * 
 * // 이벤트 모니터링
 * PulseLuaController.monitorLuaEvent("OnTick");
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class PulseLuaController {

    // 기본 예산 (밀리초)
    private static final long DEFAULT_BUDGET_MS = 100;
    private static final String LOG = PulseLogger.PULSE;

    // 현재 예산
    private static volatile long budgetMs = DEFAULT_BUDGET_MS;

    // 차단된 함수 목록
    private static final Set<String> blockedFunctions = ConcurrentHashMap.newKeySet();

    // Throttle 대상 함수 (호출 간격 제한)
    private static final Map<String, ThrottleConfig> throttledFunctions = new ConcurrentHashMap<>();

    // 모니터링 대상 이벤트
    private static final Set<String> monitoredEvents = ConcurrentHashMap.newKeySet();

    // 이벤트별 호출 통계
    private static final Map<String, LuaEventStats> eventStats = new ConcurrentHashMap<>();

    // 글로벌 활성화 상태
    private static volatile boolean enabled = true;

    // 로깅 활성화
    private static volatile boolean loggingEnabled = false;

    private PulseLuaController() {
    }

    // ─────────────────────────────────────────────────────────────
    // Budget 관리
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 실행 예산 설정 (밀리초)
     * 
     * @param ms 최대 실행 시간 (밀리초)
     */
    public static void setBudget(long ms) {
        if (ms <= 0) {
            throw new IllegalArgumentException("Budget must be positive");
        }
        budgetMs = ms;
        if (loggingEnabled) {
            PulseLogger.info(LOG, "[LuaController] Budget set to {}ms", ms);
        }
    }

    /**
     * 현재 예산 조회
     */
    public static long getBudget() {
        return budgetMs;
    }

    /**
     * 예산 초과 여부 확인
     * 
     * @param elapsedMs 경과 시간 (밀리초)
     * @return 예산 초과 시 true
     */
    public static boolean isBudgetExceeded(long elapsedMs) {
        return elapsedMs > budgetMs;
    }

    // ─────────────────────────────────────────────────────────────
    // 함수 차단
    // ─────────────────────────────────────────────────────────────

    /**
     * 함수 차단
     * 
     * @param funcName 차단할 함수 이름 (예: "ISInventoryPane:refreshBackground")
     */
    public static void blockFunction(String funcName) {
        if (funcName != null && !funcName.isEmpty()) {
            blockedFunctions.add(funcName);
            if (loggingEnabled) {
                PulseLogger.info(LOG, "[LuaController] Blocked function: {}", funcName);
            }
        }
    }

    /**
     * 함수 차단 해제
     */
    public static void unblockFunction(String funcName) {
        blockedFunctions.remove(funcName);
    }

    /**
     * 함수 차단 여부 확인
     */
    public static boolean isBlocked(String funcName) {
        return enabled && blockedFunctions.contains(funcName);
    }

    /**
     * 차단된 함수 목록
     */
    public static Set<String> getBlockedFunctions() {
        return new HashSet<>(blockedFunctions);
    }

    // ─────────────────────────────────────────────────────────────
    // 함수 Throttle (호출 빈도 제한)
    // ─────────────────────────────────────────────────────────────

    /**
     * 함수 호출 빈도 제한
     * 
     * @param funcName   함수 이름
     * @param intervalMs 최소 호출 간격 (밀리초)
     */
    public static void throttleFunction(String funcName, long intervalMs) {
        throttledFunctions.put(funcName, new ThrottleConfig(intervalMs));
    }

    /**
     * Throttle 해제
     */
    public static void unthrottleFunction(String funcName) {
        throttledFunctions.remove(funcName);
    }

    /**
     * 함수 호출 허용 여부 확인 (Throttle 체크)
     * 
     * @param funcName 함수 이름
     * @return 호출 허용 시 true
     */
    public static boolean shouldAllow(String funcName) {
        if (!enabled)
            return true;
        if (isBlocked(funcName))
            return false;

        ThrottleConfig config = throttledFunctions.get(funcName);
        if (config == null)
            return true;

        long now = System.currentTimeMillis();
        if (now - config.lastCallTime < config.intervalMs) {
            config.skippedCount.incrementAndGet();
            return false;
        }

        config.lastCallTime = now;
        return true;
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 모니터링
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 이벤트 모니터링 등록
     * 
     * @param eventName 이벤트 이름 (예: "OnTick", "OnRenderTick")
     */
    public static void monitorLuaEvent(String eventName) {
        if (eventName != null && !eventName.isEmpty()) {
            monitoredEvents.add(eventName);
            eventStats.computeIfAbsent(eventName, k -> new LuaEventStats());
            if (loggingEnabled) {
                PulseLogger.info(LOG, "[LuaController] Monitoring event: {}", eventName);
            }
        }
    }

    /**
     * 이벤트 모니터링 해제
     */
    public static void unmonitorLuaEvent(String eventName) {
        monitoredEvents.remove(eventName);
    }

    /**
     * 이벤트 호출 기록
     * 
     * @param eventName     이벤트 이름
     * @param durationNanos 소요 시간 (나노초)
     */
    public static void recordEventCall(String eventName, long durationNanos) {
        if (!enabled || !monitoredEvents.contains(eventName))
            return;

        LuaEventStats stats = eventStats.get(eventName);
        if (stats != null) {
            stats.record(durationNanos);
        }
    }

    /**
     * 이벤트 통계 조회
     */
    public static Map<String, LuaEventStats> getEventStats() {
        return new HashMap<>(eventStats);
    }

    // ─────────────────────────────────────────────────────────────
    // 글로벌 제어
    // ─────────────────────────────────────────────────────────────

    /**
     * 컨트롤러 활성화/비활성화
     */
    public static void setEnabled(boolean enabled) {
        PulseLuaController.enabled = enabled;
    }

    public static boolean isEnabled() {
        return enabled;
    }

    /**
     * 로깅 활성화
     */
    public static void setLoggingEnabled(boolean enabled) {
        loggingEnabled = enabled;
    }

    /**
     * 모든 설정 초기화
     */
    public static void reset() {
        budgetMs = DEFAULT_BUDGET_MS;
        blockedFunctions.clear();
        throttledFunctions.clear();
        monitoredEvents.clear();
        eventStats.clear();
    }

    /**
     * 상태 요약
     */
    public static String getStatusSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("PulseLuaController Status:\n");
        sb.append("  Enabled: ").append(enabled).append("\n");
        sb.append("  Budget: ").append(budgetMs).append("ms\n");
        sb.append("  Blocked Functions: ").append(blockedFunctions.size()).append("\n");
        sb.append("  Throttled Functions: ").append(throttledFunctions.size()).append("\n");
        sb.append("  Monitored Events: ").append(monitoredEvents.size()).append("\n");
        return sb.toString();
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    /**
     * Throttle 설정
     */
    private static class ThrottleConfig {
        final long intervalMs;
        volatile long lastCallTime = 0;
        final AtomicLong skippedCount = new AtomicLong(0);

        ThrottleConfig(long intervalMs) {
            this.intervalMs = intervalMs;
        }
    }

    /**
     * Lua 이벤트 통계
     */
    public static class LuaEventStats {
        private final AtomicLong callCount = new AtomicLong(0);
        private final AtomicLong totalNanos = new AtomicLong(0);
        private volatile long maxNanos = 0;

        void record(long nanos) {
            callCount.incrementAndGet();
            totalNanos.addAndGet(nanos);
            if (nanos > maxNanos)
                maxNanos = nanos;
        }

        public long getCallCount() {
            return callCount.get();
        }

        public long getTotalNanos() {
            return totalNanos.get();
        }

        public long getMaxNanos() {
            return maxNanos;
        }

        public double getAverageMs() {
            long c = callCount.get();
            return c > 0 ? (totalNanos.get() / c) / 1_000_000.0 : 0;
        }

        @Override
        public String toString() {
            return String.format("calls=%d, avg=%.3fms, max=%.3fms",
                    callCount.get(), getAverageMs(), maxNanos / 1_000_000.0);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\GameClientMixin.java =====

package com.pulse.mixin;

import org.spongepowered.asm.mixin.Mixin;

/**
 * GameClient Mixin.
 * 멀티플레이어 전용 클라이언트 업데이트 훅.
 * 
 * v0.9: Scheduler tick consolidated to IsoWorldMixin only.
 * GameClientMixin no longer calls tick() to prevent double-tick in MP.
 * 
 * Note: GameTickEvent는 IsoWorldMixin에서만 발행됨.
 * Note: PulseScheduler.tick()도 IsoWorldMixin에서만 호출됨.
 * 
 * 이 Mixin은 향후 MP 전용 훅 추가를 위해 유지됩니다.
 */
@Mixin(targets = "zombie.network.GameClient")
public abstract class GameClientMixin {
    // v0.9: tick() 호출 제거됨 - IsoWorldMixin에서 단일 호출로 통합
    // MP 환경에서 double-tick 방지를 위한 필수 수정
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\GameWindowMixin.java =====

package com.pulse.mixin;

import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameInitEvent;
import com.pulse.api.log.PulseLogger;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * GameWindow Mixin.
 * 게임 윈도우 초기화 시점에 GameInitEvent 발생.
 */
@Mixin(targets = "zombie.GameWindow")
public abstract class GameWindowMixin {
    @Unique
    private static final String Pulse$LOG = PulseLogger.PULSE;

    @Unique
    private static boolean Pulse$initEventFired = false;

    /**
     * 게임 윈도우 초기화 완료 시 GameInitEvent 발생 (한 번만)
     */
    @Inject(method = "init", at = @At("RETURN"))
    private static void Pulse$onInit(CallbackInfo ci) {
        if (!Pulse$initEventFired) {
            Pulse$initEventFired = true;
            PulseLogger.info(Pulse$LOG, "Game initialization complete, firing GameInitEvent");
            EventBus.post(new GameInitEvent());
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\IsoGridMixin.java =====

package com.pulse.mixin;

import com.pulse.api.profiler.IsoGridHook;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

/**
 * Mixin for IsoGrid profiling.
 * 
 * Provides hooks for floor rendering and property recalculation in
 * IsoGridSquare.
 * These hooks allow Echo to profile grid-level operations.
 * 
 * @since Pulse 0.2.0
 * @since Pulse 1.2 - Activated with enabled flag check
 * @since Pulse 1.3 - Fixed: renderFloor returns boolean, use
 *        CallbackInfoReturnable
 */
@Mixin(targets = "zombie.iso.IsoGridSquare")
public class IsoGridMixin {

    // NOTE: renderFloor returns boolean, so we need CallbackInfoReturnable
    @Inject(method = "renderFloor", at = @At("HEAD"), remap = false)
    private void Pulse$onRenderFloorStart(CallbackInfoReturnable<Boolean> cir) {
        if (IsoGridHook.enabled) {
            IsoGridHook.onFloorUpdateStart();
        }
    }

    @Inject(method = "renderFloor", at = @At("RETURN"), remap = false)
    private void Pulse$onRenderFloorEnd(CallbackInfoReturnable<Boolean> cir) {
        if (IsoGridHook.enabled) {
            IsoGridHook.onFloorUpdateEnd();
        }
    }

    // Echo 2.0 Phase 2: RecalcProperties Hook

    @Inject(method = "RecalcProperties", at = @At("HEAD"), remap = false)
    private void Pulse$onRecalcPropertiesStart(CallbackInfo ci) {
        if (IsoGridHook.enabled) {
            IsoGridHook.onRecalcPropertiesStart();
        }
    }

    @Inject(method = "RecalcProperties", at = @At("RETURN"), remap = false)
    private void Pulse$onRecalcPropertiesEnd(CallbackInfo ci) {
        if (IsoGridHook.enabled) {
            IsoGridHook.onRecalcPropertiesEnd();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\IsoPlayerMixin.java =====

package com.pulse.mixin;

import com.pulse.event.EventBus;
import com.pulse.event.player.PlayerDamageEvent;
import com.pulse.event.player.PlayerUpdateEvent;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

/**
 * IsoPlayer Mixin.
 * 플레이어 업데이트 및 데미지 처리 훅.
 */
@Mixin(targets = "zombie.characters.IsoPlayer")
public abstract class IsoPlayerMixin {

    /**
     * 플레이어 업데이트 시 PlayerUpdateEvent 발생
     */
    @Inject(method = "update", at = @At("HEAD"))
    private void Pulse$onUpdate(CallbackInfo ci) {
        // this는 IsoPlayer 인스턴스
        EventBus.post(new PlayerUpdateEvent(this));
    }

    /**
     * 플레이어가 데미지를 받을 때 PlayerDamageEvent 발생
     * Hit() 메서드 시작 시점에 호출
     *
     * 참고: Project Zomboid의 Hit 메서드는 float를 반환함
     */
    @Inject(method = "Hit", at = @At("HEAD"), cancellable = true)
    private void Pulse$onHit(CallbackInfoReturnable<Float> cir) {

        // 기본 데미지 값 (실제로는 파라미터에서 가져와야 함)
        float damage = 10.0f;
        String damageType = "unknown";

        PlayerDamageEvent event = new PlayerDamageEvent(this, damage, damageType);
        EventBus.post(event);

        // 이벤트가 취소되었으면 원래 메서드 실행 취소 (0.0f 반환)
        if (event.isCancelled()) {
            cir.setReturnValue(0.0f);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\IsoWorldMixin.java =====

package com.pulse.mixin;

import com.pulse.api.PulseServices;
import com.pulse.api.log.PulseLogger;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.event.lifecycle.GameTickStartEvent;
import com.pulse.event.lifecycle.GameTickEndEvent;
import com.pulse.event.lifecycle.WorldLoadEvent;
import com.pulse.handler.TickEndResult;
import com.pulse.handler.TickStartResult;
import com.pulse.handler.WorldTickHandler;
import com.pulse.hook.HookTypes;
import com.pulse.hook.PulseHookRegistry;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * IsoWorld Mixin.
 * 
 * <p>
 * 월드 로드/언로드 및 게임 틱 이벤트 발생.
 * </p>
 * 
 * <p>
 * v2.0: 상태 관리 로직을 {@link WorldTickHandler}로 분리.
 * </p>
 * 
 * <h3>Responsibilities:</h3>
 * <ul>
 * <li>Mixin injection points</li>
 * <li>Event posting (WorldLoadEvent, GameTickEvent, etc.)</li>
 * <li>HookRegistry broadcasting</li>
 * <li>Scheduler tick triggering</li>
 * </ul>
 * 
 * @since Pulse 1.0
 * @since Pulse 1.6 - Refactored to use WorldTickHandler
 */
@Mixin(targets = "zombie.iso.IsoWorld")
public abstract class IsoWorldMixin {

    private static final String LOG = PulseLogger.PULSE;

    @Shadow
    public abstract String getWorld();

    // Echo: SubProfiler phase tracking
    @Unique
    private static long Pulse$worldUpdateStart = -1;

    // ═══════════════════════════════════════════════════════════════
    // World Init
    // ═══════════════════════════════════════════════════════════════

    /**
     * 월드 로드 완료 시점에 WorldLoadEvent 발생.
     * init() 메서드 리턴 시점에 호출.
     */
    @Inject(method = "init", at = @At("RETURN"))
    private void Pulse$onWorldInit(CallbackInfo ci) {
        PulseLogger.debug(LOG, "IsoWorld.init() CALLED - Mixin injection SUCCESS!");

        String worldName = getWorldNameSafe();

        // Initialize handler
        WorldTickHandler.getInstance().install();

        PulseLogger.info(LOG, "World loaded: {}", worldName);
        EventBus.post(new WorldLoadEvent(worldName));

        PulseLogger.debug(LOG, "WorldLoadEvent posted for: " + worldName);
    }

    // ═══════════════════════════════════════════════════════════════
    // Update Start
    // ═══════════════════════════════════════════════════════════════

    /**
     * IsoWorld.update() 시작 시점.
     * 
     * <p>
     * v2.0: 상태 관리는 WorldTickHandler에 위임.
     * </p>
     */
    @Inject(method = "update", at = @At("HEAD"))
    private void Pulse$onUpdateStart(CallbackInfo ci) {
        try {
            WorldTickHandler handler = WorldTickHandler.getInstance();
            TickStartResult result = handler.onUpdateStart();

            // First tick - post WorldLoadEvent if init() wasn't called
            if (result.isFirstTick()) {
                String worldName = getWorldNameSafe();
                PulseLogger.debug(LOG, "First update() detected - firing WorldLoadEvent for: " + worldName);
                PulseLogger.info(LOG, "World loaded (via update): {}", worldName);
                EventBus.post(new WorldLoadEvent(worldName));
            }

            // GameTickStartEvent
            EventBus.post(new GameTickStartEvent(result.getExpectedTickCount()));

            // HookRegistry broadcast
            final long tickNum = result.getExpectedTickCount();
            PulseHookRegistry.broadcast(HookTypes.GAME_TICK, cb -> cb.onGameTickStart(tickNum));

            // Echo: WORLD_UPDATE Phase Start
            Pulse$worldUpdateStart = com.pulse.api.profiler.TickPhaseHook.startPhase("WORLD_UPDATE");
        } catch (Throwable t) {
            if (com.pulse.PulseEnvironment.isDevelopmentMode()) {
                throw t;
            }
            PulseErrorHandler.reportMixinFailure("IsoWorldMixin.onUpdateStart", t);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Update End
    // ═══════════════════════════════════════════════════════════════

    /**
     * IsoWorld.update() 종료 시점.
     * 
     * <p>
     * v2.0: 타이밍 계산은 WorldTickHandler에 위임.
     * </p>
     */
    @Inject(method = "update", at = @At("RETURN"))
    private void Pulse$onUpdate(CallbackInfo ci) {
        try {
            // Echo: WORLD_UPDATE Phase End
            com.pulse.api.profiler.TickPhaseHook.endPhase("WORLD_UPDATE", Pulse$worldUpdateStart);
            Pulse$worldUpdateStart = -1;

            WorldTickHandler handler = WorldTickHandler.getInstance();
            TickEndResult result = handler.onUpdateEnd();

            // Scheduler tick
            PulseServices.scheduler().tick();

            // Tick complete hook
            com.pulse.api.profiler.TickPhaseHook.onTickComplete();

            // GameTickEndEvent
            EventBus.post(new GameTickEndEvent(result.getTickCount(), result.getDurationNanos()));

            // HookRegistry broadcast
            final long tickNum = result.getTickCount();
            final long duration = result.getDurationNanos();
            PulseHookRegistry.broadcast(HookTypes.GAME_TICK, cb -> cb.onGameTickEnd(tickNum, duration));

            // Legacy GameTickEvent (backward compatibility)
            EventBus.post(new GameTickEvent(result.getTickCount(), result.getDeltaTime()));
        } catch (Throwable t) {
            if (com.pulse.PulseEnvironment.isDevelopmentMode()) {
                throw t;
            }
            PulseErrorHandler.reportMixinFailure("IsoWorldMixin.onUpdate", t);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Helper Methods
    // ═══════════════════════════════════════════════════════════════

    @Unique
    private String getWorldNameSafe() {
        try {
            String worldName = getWorld();
            if (worldName == null || worldName.isEmpty()) {
                return "World";
            }
            return worldName;
        } catch (Exception e) {
            return "Unknown";
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\IsoZombieMixin.java =====

package com.pulse.mixin;

import com.pulse.adapter.zombie.IZombieAdapter;
import com.pulse.adapter.zombie.ZombieAdapterProvider;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.profiler.SubProfilerHook;
import com.pulse.api.profiler.ThrottleLevel;
import com.pulse.api.profiler.ZombieHook;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * IsoZombie Mixin.
 * 
 * Phase 3: Tiered throttle - update() 절대 취소 안 함!
 * ThrottleLevel을 컨텍스트에 저장하여 Step hook에서 활용.
 * 
 * Version Adapter 적용:
 * - 직접 reflection 호출 → ZombieAdapterProvider 사용
 * - Build 41/42 버전 호환성 보장
 * 
 * @since Pulse 1.2
 * @since Pulse 1.4 - Version Adapter 적용
 * @since Pulse 1.5 - Tiered throttle (ci.cancel 제거)
 */
@Mixin(targets = "zombie.characters.IsoZombie")
public abstract class IsoZombieMixin {

    @Unique
    private long Pulse$zombieUpdateStart = -1;

    @Unique
    private static int Pulse$worldTick = 0;

    @Unique
    private static final java.util.concurrent.atomic.AtomicInteger Pulse$debugCallCount = new java.util.concurrent.atomic.AtomicInteger(
            0);

    @Unique
    private static IZombieAdapter Pulse$adapter = null;

    /**
     * 어댑터 Lazy Initialization.
     * Mixin 로드 시점에 어댑터가 초기화되지 않을 수 있으므로 지연 로드.
     */
    @Unique
    private static IZombieAdapter Pulse$getAdapter() {
        if (Pulse$adapter == null) {
            Pulse$adapter = ZombieAdapterProvider.get();
        }
        return Pulse$adapter;
    }

    /**
     * IsoZombie.update() 시작
     * 
     * 중요: cancellable = false! update()는 절대 취소하지 않음.
     * ThrottleLevel만 컨텍스트에 저장하여 Step hook에서 활용.
     */
    @Inject(method = "update", at = @At("HEAD"))
    private void Pulse$onZombieUpdateStart(CallbackInfo ci) {
        try {
            Pulse$worldTick++;

            // 디버그: Mixin 호출 확인
            int callCount = Pulse$debugCallCount.incrementAndGet();
            if (callCount == 1) {
                IZombieAdapter adapter = Pulse$getAdapter();
                PulseLogger.info("Pulse/IsoZombieMixin", "✅ First update() call! Tiered Throttle active.");
                PulseLogger.info("Pulse/IsoZombieMixin", "Using adapter: " + adapter.getName());
            }

            IZombieAdapter adapter = Pulse$getAdapter();

            // 거리 및 상태 체크
            float distSq = adapter.getDistanceSquaredToNearestPlayer(this);
            boolean attacking = adapter.isAttacking(this);
            boolean hasTarget = adapter.hasTarget(this);

            // 최근 피격 여부 (어댑터 기반 - B41/B42 호환)
            boolean recentlyEngaged = adapter.isRecentlyHit(this);

            // ThrottleLevel 결정 (cancel 없음!)
            ThrottleLevel level = ZombieHook.getThrottleLevel(distSq, attacking, hasTarget, recentlyEngaged);
            ZombieHook.setCurrentThrottleLevel(level, Pulse$worldTick);

            // SubProfiler - 항상 실행 (Echo heavy_functions용)
            Pulse$zombieUpdateStart = SubProfilerHook.start("ZOMBIE_UPDATE");

            // Fuse 콜백 - 조건부 (zombie.total_updates용)
            if (ZombieHook.profilingEnabled) {
                ZombieHook.onZombieUpdate(this);
                ZombieHook.onMotionUpdateStart(this);
            }
        } catch (Throwable t) {
            PulseErrorHandler.reportMixinFailure("IsoZombieMixin.onZombieUpdateStart", t);
        }
    }

    /**
     * IsoZombie.update() 종료
     */
    @Inject(method = "update", at = @At("RETURN"))
    private void Pulse$onZombieUpdateEnd(CallbackInfo ci) {
        try {
            // ThrottleLevel 컨텍스트 정리 (필수!)
            ZombieHook.clearCurrentThrottleLevel();

            // SubProfiler - 항상 실행
            if (Pulse$zombieUpdateStart > 0) {
                SubProfilerHook.end("ZOMBIE_UPDATE", Pulse$zombieUpdateStart);
                Pulse$zombieUpdateStart = -1;
            }

            // Fuse 콜백 - 조건부
            if (ZombieHook.profilingEnabled) {
                ZombieHook.onMotionUpdateEnd(this);
            }
        } catch (Throwable t) {
            PulseErrorHandler.reportMixinFailure("IsoZombieMixin.onZombieUpdateEnd", t);
        }
    }

    // =================================================================
    // NOTE: Helper methods removed - now using ZombieAdapterProvider
    //
    // 기존 Pulse$getDistSqToPlayer(), Pulse$isAttacking(),
    // Pulse$hasTarget(), Pulse$getZombieId() 메서드들은
    // Build41ZombieAdapter로 이동되었습니다.
    //
    // spotted(), Hit(), Kill() 메서드들은 파라미터 타입이
    // IsoMovingObject, IsoGameCharacter 등 게임 클래스를 요구합니다.
    // 컴파일 타임에 이 클래스들이 없으므로 Mixin Injection이 실패합니다.
    //
    // 향후 필요 시:
    // 1. compileOnly로 게임 JAR 의존성 추가
    // 2. 또는 ASM을 이용한 수동 바이트코드 조작
    // =================================================================
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\kahlua\MixinKahluaThread.java =====

package com.pulse.mixin.kahlua;

import com.pulse.api.log.PulseLogger;
import com.pulse.handler.KahluaCallExtractor;
import com.pulse.hook.HookTypes;
import com.pulse.hook.PulseHookRegistry;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
import se.krka.kahlua.vm.KahluaThread;

import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Mixin for se.krka.kahlua.vm.KahluaThread.
 * 
 * <p>
 * Lua 호출(call/pcall)을 가로채서 Echo 프로파일링에 노출합니다.
 * </p>
 * 
 * <p>
 * v3.0: 리플렉션 로직을 {@link KahluaCallExtractor}로 분리하여 간소화됨.
 * </p>
 * 
 * @since Pulse 1.0
 * @since Pulse 1.6 - Refactored to use KahluaCallExtractor handler
 */
@Mixin(KahluaThread.class)
public class MixinKahluaThread {

    private static final String LOG = "Pulse/MixinKahluaThread";

    // First activation logging
    private static final AtomicBoolean LOGGED_ONCE = new AtomicBoolean(false);

    // ThreadLocal context: [0]=callable, [1]=startNanos, [2]=needsLateExtract,
    // [3]=nArgs, [4]=callType
    private static final ThreadLocal<Object[]> CALL_CONTEXT = ThreadLocal.withInitial(() -> new Object[5]);

    // ═══════════════════════════════════════════════════════════════
    // call(int) hooks
    // ═══════════════════════════════════════════════════════════════

    @Inject(method = "call(I)I", at = @At("HEAD"), remap = false)
    private void onCallIntStart(int nArgs, CallbackInfoReturnable<Integer> cir) {
        if (!PulseHookRegistry.hasCallbacks(HookTypes.LUA_CALL)) {
            return;
        }

        logFirstActivation();

        KahluaCallExtractor extractor = KahluaCallExtractor.getInstance();
        Object callable = extractor.extract(this, "call", nArgs);

        Object[] ctx = CALL_CONTEXT.get();
        ctx[0] = callable;
        ctx[1] = System.nanoTime();
        ctx[2] = (callable == null);
        ctx[3] = nArgs;
        ctx[4] = "call";

        if (callable != null) {
            long startNanos = (Long) ctx[1];
            PulseHookRegistry.broadcast(HookTypes.LUA_CALL, cb -> cb.onLuaCallStart(callable, startNanos));
        }
    }

    @Inject(method = "call(I)I", at = @At("RETURN"), remap = false)
    private void onCallIntEnd(int nArgs, CallbackInfoReturnable<Integer> cir) {
        if (!PulseHookRegistry.hasCallbacks(HookTypes.LUA_CALL)) {
            return;
        }

        Object[] ctx = CALL_CONTEXT.get();
        Object callable = ctx[0];
        long startNanos = ctx[1] != null ? (Long) ctx[1] : System.nanoTime();
        boolean needsLate = ctx[2] != null && (Boolean) ctx[2];
        String callType = ctx[4] != null ? (String) ctx[4] : "call";

        // Late extraction if HEAD failed
        if (needsLate && callable == null) {
            KahluaCallExtractor extractor = KahluaCallExtractor.getInstance();
            callable = extractor.lateExtract(this, nArgs);
            if (callable != null) {
                final Object c = callable;
                final long sn = startNanos;
                PulseHookRegistry.broadcast(HookTypes.LUA_CALL, cb -> cb.onLuaCallStart(c, sn));
            }
        }

        // Final fallback
        if (callable == null) {
            callable = KahluaCallExtractor.getInstance().createFallback(callType, nArgs);
            final Object c = callable;
            final long sn = startNanos;
            PulseHookRegistry.broadcast(HookTypes.LUA_CALL, cb -> cb.onLuaCallStart(c, sn));
        }

        long endNanos = System.nanoTime();
        final Object c = callable;
        PulseHookRegistry.broadcast(HookTypes.LUA_CALL, cb -> cb.onLuaCallEnd(c, endNanos));

        clearContext(ctx);
    }

    // ═══════════════════════════════════════════════════════════════
    // pcall(int) hooks
    // ═══════════════════════════════════════════════════════════════

    @Inject(method = "pcall(I)I", at = @At("HEAD"), remap = false)
    private void onPcallStart(int nArgs, CallbackInfoReturnable<Integer> cir) {
        if (!PulseHookRegistry.hasCallbacks(HookTypes.LUA_CALL)) {
            return;
        }

        logFirstActivation();

        KahluaCallExtractor extractor = KahluaCallExtractor.getInstance();
        Object callable = extractor.extract(this, "pcall", nArgs);

        Object[] ctx = CALL_CONTEXT.get();
        ctx[0] = callable;
        ctx[1] = System.nanoTime();
        ctx[2] = (callable == null);
        ctx[3] = nArgs;
        ctx[4] = "pcall";

        if (callable != null) {
            long startNanos = (Long) ctx[1];
            PulseHookRegistry.broadcast(HookTypes.LUA_CALL, cb -> cb.onLuaCallStart(callable, startNanos));
        }
    }

    @Inject(method = "pcall(I)I", at = @At("RETURN"), remap = false)
    private void onPcallEnd(int nArgs, CallbackInfoReturnable<Integer> cir) {
        if (!PulseHookRegistry.hasCallbacks(HookTypes.LUA_CALL)) {
            return;
        }

        Object[] ctx = CALL_CONTEXT.get();
        Object callable = ctx[0];
        long startNanos = ctx[1] != null ? (Long) ctx[1] : System.nanoTime();
        boolean needsLate = ctx[2] != null && (Boolean) ctx[2];
        String callType = ctx[4] != null ? (String) ctx[4] : "pcall";

        if (needsLate && callable == null) {
            KahluaCallExtractor extractor = KahluaCallExtractor.getInstance();
            callable = extractor.lateExtract(this, nArgs);
            if (callable != null) {
                final Object c = callable;
                final long sn = startNanos;
                PulseHookRegistry.broadcast(HookTypes.LUA_CALL, cb -> cb.onLuaCallStart(c, sn));
            }
        }

        if (callable == null) {
            callable = KahluaCallExtractor.getInstance().createFallback(callType, nArgs);
            final Object c = callable;
            final long sn = startNanos;
            PulseHookRegistry.broadcast(HookTypes.LUA_CALL, cb -> cb.onLuaCallStart(c, sn));
        }

        long endNanos = System.nanoTime();
        final Object c = callable;
        PulseHookRegistry.broadcast(HookTypes.LUA_CALL, cb -> cb.onLuaCallEnd(c, endNanos));

        clearContext(ctx);
    }

    // ═══════════════════════════════════════════════════════════════
    // call(Object, Object[]) hooks - direct function access
    // ═══════════════════════════════════════════════════════════════

    @Inject(method = "call(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;", at = @At("HEAD"), remap = false)
    private void onCallObjStart(Object function, Object[] args, CallbackInfoReturnable<Object> cir) {
        if (!PulseHookRegistry.hasCallbacks(HookTypes.LUA_CALL)) {
            return;
        }

        logFirstActivation();

        Object[] ctx = CALL_CONTEXT.get();
        ctx[0] = function; // Direct access - no extraction needed
        ctx[1] = System.nanoTime();
        ctx[2] = false;
        ctx[3] = args != null ? args.length : 0;
        ctx[4] = "call_obj";

        long startNanos = (Long) ctx[1];
        PulseHookRegistry.broadcast(HookTypes.LUA_CALL, cb -> cb.onLuaCallStart(function, startNanos));
    }

    @Inject(method = "call(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;", at = @At("RETURN"), remap = false)
    private void onCallObjEnd(Object function, Object[] args, CallbackInfoReturnable<Object> cir) {
        if (!PulseHookRegistry.hasCallbacks(HookTypes.LUA_CALL)) {
            return;
        }

        long endNanos = System.nanoTime();
        PulseHookRegistry.broadcast(HookTypes.LUA_CALL, cb -> cb.onLuaCallEnd(function, endNanos));

        clearContext(CALL_CONTEXT.get());
    }

    // ═══════════════════════════════════════════════════════════════
    // Helper methods
    // ═══════════════════════════════════════════════════════════════

    private static void logFirstActivation() {
        if (LOGGED_ONCE.compareAndSet(false, true)) {
            PulseLogger.info(LOG, "v3.0 active (using KahluaCallExtractor)");
        }
    }

    private static void clearContext(Object[] ctx) {
        ctx[0] = null;
        ctx[1] = null;
        ctx[2] = null;
        ctx[3] = null;
        ctx[4] = null;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\lua\MixinLuaEventManager.java =====

package com.pulse.mixin.lua;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.lua.PulseLuaHook;
import com.pulse.internal.InternalLuaHook;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

import java.util.concurrent.atomic.AtomicBoolean;

/**
 * LuaEventManager Mixin.
 * 
 * zombie.Lua.LuaEventManager.triggerEvent()를 후킹하여
 * Lua 이벤트 통계를 수집.
 * 
 * Phase 2C 설계:
 * - HEAD: incrementPathHit() + fireEventStart(eventName)
 * - RETURN: fireEventEnd()
 * - On-Demand: profilingEnabled 시에만 타이밍 측정
 * 
 * @since Pulse 1.3
 */
@Mixin(targets = "zombie.Lua.LuaEventManager")
public abstract class MixinLuaEventManager {

    /** 최초 호출 플래그 */
    @Unique
    private static final AtomicBoolean FIRST = new AtomicBoolean(false);

    // =========================================
    // triggerEvent 오버로드 0~8 (HEAD + RETURN)
    // =========================================

    // === triggerEvent(String) ===
    @Inject(method = "triggerEvent(Ljava/lang/String;)V", at = @At("HEAD"), remap = false)
    private static void Pulse$onEvent0Head(String eventName, CallbackInfo ci) {
        Pulse$onEventHead(eventName);
    }

    @Inject(method = "triggerEvent(Ljava/lang/String;)V", at = @At("RETURN"), remap = false)
    private static void Pulse$onEvent0Return(String eventName, CallbackInfo ci) {
        InternalLuaHook.fireEventEnd();
    }

    // === triggerEvent(String, Object) ===
    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;)V", at = @At("HEAD"), remap = false)
    private static void Pulse$onEvent1Head(String eventName, Object a1, CallbackInfo ci) {
        Pulse$onEventHead(eventName);
    }

    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;)V", at = @At("RETURN"), remap = false)
    private static void Pulse$onEvent1Return(String eventName, Object a1, CallbackInfo ci) {
        InternalLuaHook.fireEventEnd();
    }

    // === triggerEvent(String, Object, Object) ===
    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("HEAD"), remap = false)
    private static void Pulse$onEvent2Head(String eventName, Object a1, Object a2, CallbackInfo ci) {
        Pulse$onEventHead(eventName);
    }

    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("RETURN"), remap = false)
    private static void Pulse$onEvent2Return(String eventName, Object a1, Object a2, CallbackInfo ci) {
        InternalLuaHook.fireEventEnd();
    }

    // === triggerEvent(String, Object x 3) ===
    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("HEAD"), remap = false)
    private static void Pulse$onEvent3Head(String eventName, Object a1, Object a2, Object a3, CallbackInfo ci) {
        Pulse$onEventHead(eventName);
    }

    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("RETURN"), remap = false)
    private static void Pulse$onEvent3Return(String eventName, Object a1, Object a2, Object a3, CallbackInfo ci) {
        InternalLuaHook.fireEventEnd();
    }

    // === triggerEvent(String, Object x 4) ===
    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("HEAD"), remap = false)
    private static void Pulse$onEvent4Head(String eventName, Object a1, Object a2, Object a3, Object a4,
            CallbackInfo ci) {
        Pulse$onEventHead(eventName);
    }

    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("RETURN"), remap = false)
    private static void Pulse$onEvent4Return(String eventName, Object a1, Object a2, Object a3, Object a4,
            CallbackInfo ci) {
        InternalLuaHook.fireEventEnd();
    }

    // === triggerEvent(String, Object x 5) ===
    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("HEAD"), remap = false)
    private static void Pulse$onEvent5Head(String eventName, Object a1, Object a2, Object a3, Object a4, Object a5,
            CallbackInfo ci) {
        Pulse$onEventHead(eventName);
    }

    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("RETURN"), remap = false)
    private static void Pulse$onEvent5Return(String eventName, Object a1, Object a2, Object a3, Object a4, Object a5,
            CallbackInfo ci) {
        InternalLuaHook.fireEventEnd();
    }

    // === triggerEvent(String, Object x 6) ===
    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("HEAD"), remap = false)
    private static void Pulse$onEvent6Head(String eventName, Object a1, Object a2, Object a3, Object a4, Object a5,
            Object a6, CallbackInfo ci) {
        Pulse$onEventHead(eventName);
    }

    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("RETURN"), remap = false)
    private static void Pulse$onEvent6Return(String eventName, Object a1, Object a2, Object a3, Object a4, Object a5,
            Object a6, CallbackInfo ci) {
        InternalLuaHook.fireEventEnd();
    }

    // === triggerEvent(String, Object x 7) ===
    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("HEAD"), remap = false)
    private static void Pulse$onEvent7Head(String eventName, Object a1, Object a2, Object a3, Object a4, Object a5,
            Object a6, Object a7, CallbackInfo ci) {
        Pulse$onEventHead(eventName);
    }

    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("RETURN"), remap = false)
    private static void Pulse$onEvent7Return(String eventName, Object a1, Object a2, Object a3, Object a4, Object a5,
            Object a6, Object a7, CallbackInfo ci) {
        InternalLuaHook.fireEventEnd();
    }

    // === triggerEvent(String, Object x 8) ===
    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("HEAD"), remap = false)
    private static void Pulse$onEvent8Head(String eventName, Object a1, Object a2, Object a3, Object a4, Object a5,
            Object a6, Object a7, Object a8, CallbackInfo ci) {
        Pulse$onEventHead(eventName);
    }

    @Inject(method = "triggerEvent(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V", at = @At("RETURN"), remap = false)
    private static void Pulse$onEvent8Return(String eventName, Object a1, Object a2, Object a3, Object a4, Object a5,
            Object a6, Object a7, Object a8, CallbackInfo ci) {
        InternalLuaHook.fireEventEnd();
    }

    // =========================================
    // 공통 헬퍼 메서드 (DRY)
    // =========================================

    @Unique
    private static void Pulse$onEventHead(String eventName) {
        // Phase 1B: 경로 카운터 (항상 실행, ~10ns)
        PulseLuaHook.incrementPathHit();

        // Phase 2C: 이벤트 시작 기록 (On-Demand)
        InternalLuaHook.fireEventStart(eventName);

        if (FIRST.compareAndSet(false, true)) {
            PulseLogger.info("Pulse/MixinLuaEventManager", "✅ First triggerEvent! Mixin is working.");
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\MainScreenStateMixin.java =====

package com.pulse.mixin;

import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.MainMenuRenderEvent;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * MainScreenState Mixin.
 * 게임 메인 화면 렌더링에 훅을 건다.
 * 
 * @since Pulse 2.1 - MainMenuRenderEvent 발생 (Echo에서 세션 종료 감지)
 */
@Mixin(targets = "zombie.gameStates.MainScreenState")
public abstract class MainScreenStateMixin {

    @Inject(method = "render", at = @At("HEAD"))
    private void Pulse$onRenderHead(CallbackInfo ci) {
        try {
            // Pulse 1.3: 프레임 시작 알림 (Echo PulseMetrics 연동)
            com.pulse.api.PulseMetrics.onFrameStart();

            // v2.1: MainMenuRenderEvent 발생 - Echo가 세션 종료 감지
            EventBus.post(new MainMenuRenderEvent());
        } catch (Throwable t) {
            if (com.pulse.PulseEnvironment.isDevelopmentMode()) {
                throw t;
            }
            PulseErrorHandler.reportMixinFailure("MainScreenStateMixin.onRenderHead", t);
        }
    }

    @Inject(method = "render", at = @At("RETURN"))
    private void Pulse$onRenderReturn(CallbackInfo ci) {
        // 렌더링 완료 훅 - 필요시 여기에 로직 추가
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\MixinDiagnostics.java =====

package com.pulse.mixin;

import com.pulse.api.DevMode;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.mixin.MixinInjectionValidator;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Mixin 진단 도구.
 * 적용된 Mixin 추적 및 잠재적 충돌 감지.
 * 
 * DevMode가 활성화되면 상세한 리포트 출력.
 */
public class MixinDiagnostics {

    private static final String LOG = PulseLogger.PULSE;
    private static final MixinDiagnostics INSTANCE = new MixinDiagnostics();

    // 타겟 클래스 → 적용된 Mixin 정보 목록
    private final Map<String, List<MixinInfo>> appliedMixins = new ConcurrentHashMap<>();

    // 로드 실패한 Mixin 목록
    private final List<FailedMixin> failedMixins = new ArrayList<>();

    public static MixinDiagnostics getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // Mixin 추적
    // ─────────────────────────────────────────────────────────────

    /**
     * Mixin 적용 기록
     */
    public void recordMixinApplied(String targetClass, String mixinClass,
            String modId, int priority) {
        long startTime = System.currentTimeMillis();
        MixinInfo info = new MixinInfo(mixinClass, modId, priority);
        appliedMixins.computeIfAbsent(targetClass, k -> new ArrayList<>()).add(info);
        long elapsed = System.currentTimeMillis() - startTime;

        // v1.0.1: MixinInjectionValidator에도 성공 기록
        try {
            MixinInjectionValidator.recordSuccess(mixinClass, targetClass, elapsed);
        } catch (Exception e) {
            // ignore - Validator가 초기화되지 않았을 수 있음
        }

        if (DevMode.isEnabled()) {
            PulseLogger.debug(LOG, "Applied {} to {} (mod: {}, priority: {})",
                    mixinClass, targetClass, modId, priority);
        }
    }

    /**
     * Mixin 실패 기록
     */
    public void recordMixinFailed(String mixinClass, String modId,
            String targetClass, String reason) {
        FailedMixin failed = new FailedMixin(mixinClass, modId, targetClass, reason);
        failedMixins.add(failed);

        // v1.0.1: MixinInjectionValidator에도 실패 기록
        try {
            MixinInjectionValidator.recordFailure(mixinClass, targetClass, reason);
        } catch (Exception e) {
            // ignore - Validator가 초기화되지 않았을 수 있음
        }

        PulseLogger.error(LOG, "Failed {} from {} to {}: {}", mixinClass, modId, targetClass, reason);
    }

    // ─────────────────────────────────────────────────────────────
    // 충돌 감지
    // ─────────────────────────────────────────────────────────────

    /**
     * 잠재적 충돌 검사 및 경고
     */
    public void checkConflicts() {
        if (!DevMode.isEnabled())
            return;

        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "Checking for potential Mixin conflicts...");

        int conflictCount = 0;

        for (Map.Entry<String, List<MixinInfo>> entry : appliedMixins.entrySet()) {
            String targetClass = entry.getKey();
            List<MixinInfo> mixins = entry.getValue();

            if (mixins.size() > 1) {
                // 동일 타겟에 여러 Mixin - 잠재적 충돌
                Set<String> mods = new HashSet<>();
                for (MixinInfo info : mixins) {
                    mods.add(info.modId);
                }

                if (mods.size() > 1) {
                    // 다른 모드의 Mixin이 같은 클래스를 수정
                    PulseLogger.warn(LOG, "Potential conflict on {}:", targetClass);
                    for (MixinInfo info : mixins) {
                        PulseLogger.warn(LOG, "  - {}: {} (priority: {})",
                                info.modId, info.mixinClass, info.priority);
                    }
                    conflictCount++;
                }
            }
        }

        if (conflictCount == 0) {
            PulseLogger.info(LOG, "No conflicts detected.");
        } else {
            PulseLogger.warn(LOG, "{} potential conflict(s) found.", conflictCount);
        }

        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // 리포트
    // ─────────────────────────────────────────────────────────────

    /**
     * 전체 Mixin 적용 상태 리포트
     */
    public void printReport() {
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "MIXIN APPLICATION REPORT");
        PulseLogger.info(LOG, "═══════════════════════════════════════");

        PulseLogger.info(LOG, "Applied Mixins by Target:");
        for (Map.Entry<String, List<MixinInfo>> entry : appliedMixins.entrySet()) {
            PulseLogger.info(LOG, "  {}:", entry.getKey());
            for (MixinInfo info : entry.getValue()) {
                PulseLogger.debug(LOG, "    - {} ({}, p={})",
                        info.mixinClass, info.modId, info.priority);
            }
        }

        if (!failedMixins.isEmpty()) {
            PulseLogger.warn(LOG, "Failed Mixins:");
            for (FailedMixin failed : failedMixins) {
                PulseLogger.error(LOG, "  ✗ {} from {} → {}",
                        failed.mixinClass, failed.modId, failed.targetClass);
                PulseLogger.error(LOG, "    Reason: {}", failed.reason);
            }
        }

        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public int getAppliedCount() {
        return appliedMixins.values().stream().mapToInt(List::size).sum();
    }

    public int getFailedCount() {
        return failedMixins.size();
    }

    public List<MixinInfo> getMixinsForTarget(String targetClass) {
        return appliedMixins.getOrDefault(targetClass, Collections.emptyList());
    }

    /**
     * 크래시 리포트용 변환 상세 정보 반환.
     * 
     * @return 타겟 클래스 → Mixin 클래스 목록 맵
     */
    public static Map<String, List<String>> getTransformationDetails() {
        Map<String, List<String>> result = new LinkedHashMap<>();

        for (Map.Entry<String, List<MixinInfo>> entry : INSTANCE.appliedMixins.entrySet()) {
            List<String> mixinNames = new ArrayList<>();
            for (MixinInfo info : entry.getValue()) {
                mixinNames.add(info.mixinClass + " (" + info.modId + ")");
            }
            result.put(entry.getKey(), mixinNames);
        }

        return result;
    }

    /**
     * 적용된 Mixin 목록 문자열로 반환.
     */
    public static List<String> getAppliedMixins() {
        List<String> result = new ArrayList<>();
        for (Map.Entry<String, List<MixinInfo>> entry : INSTANCE.appliedMixins.entrySet()) {
            for (MixinInfo info : entry.getValue()) {
                result.add(info.mixinClass + " → " + entry.getKey() + " (" + info.modId + ")");
            }
        }
        return result;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    public static class MixinInfo {
        public final String mixinClass;
        public final String modId;
        public final int priority;

        public MixinInfo(String mixinClass, String modId, int priority) {
            this.mixinClass = mixinClass;
            this.modId = modId;
            this.priority = priority;
        }
    }

    public static class FailedMixin {
        public final String mixinClass;
        public final String modId;
        public final String targetClass;
        public final String reason;

        public FailedMixin(String mixinClass, String modId,
                String targetClass, String reason) {
            this.mixinClass = mixinClass;
            this.modId = modId;
            this.targetClass = targetClass;
            this.reason = reason;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 통계 메서드 (평가 개선사항)
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드별 적용된 Mixin 수 반환.
     * 
     * @return 모드 ID → Mixin 수 맵
     */
    public Map<String, Integer> getMixinCountByMod() {
        Map<String, Integer> counts = new HashMap<>();
        for (List<MixinInfo> infos : appliedMixins.values()) {
            for (MixinInfo info : infos) {
                counts.merge(info.modId, 1, (a, b) -> a + b);
            }
        }
        return counts;
    }

    /**
     * 가장 많이 Mixin이 적용된 클래스 TOP N 반환.
     * 
     * @param n 반환할 개수
     * @return (클래스명, Mixin 수) 리스트
     */
    public List<Map.Entry<String, Integer>> getTopMixedClasses(int n) {
        List<Map.Entry<String, Integer>> entries = new ArrayList<>();
        for (Map.Entry<String, List<MixinInfo>> entry : appliedMixins.entrySet()) {
            entries.add(new AbstractMap.SimpleEntry<>(entry.getKey(), entry.getValue().size()));
        }
        entries.sort((a, b) -> Integer.compare(b.getValue(), a.getValue()));
        return entries.subList(0, Math.min(n, entries.size()));
    }

    /**
     * 동일 타겟, 동일 모드 내에서 우선순위 충돌 검사.
     * 같은 모드에서 같은 타겟에 다른 우선순위의 Mixin이 있으면 경고.
     */
    public void checkPriorityConflicts() {
        if (!DevMode.isEnabled())
            return;

        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "Checking priority conflicts...");

        int conflictCount = 0;

        for (Map.Entry<String, List<MixinInfo>> entry : appliedMixins.entrySet()) {
            String targetClass = entry.getKey();
            List<MixinInfo> mixins = entry.getValue();

            // 같은 모드 내 우선순위별 그룹화
            Map<String, List<Integer>> modPriorities = new HashMap<>();
            for (MixinInfo info : mixins) {
                modPriorities.computeIfAbsent(info.modId, k -> new ArrayList<>()).add(info.priority);
            }

            // 같은 모드에서 여러 우선순위 있으면 경고
            for (Map.Entry<String, List<Integer>> modEntry : modPriorities.entrySet()) {
                List<Integer> priorities = modEntry.getValue();
                if (priorities.size() > 1) {
                    Set<Integer> uniquePriorities = new HashSet<>(priorities);
                    if (uniquePriorities.size() > 1) {
                        PulseLogger.warn(LOG, "Priority variation in {} for {}: {}",
                                modEntry.getKey(), targetClass, uniquePriorities);
                        conflictCount++;
                    }
                }
            }
        }

        if (conflictCount == 0) {
            PulseLogger.info(LOG, "No priority conflicts detected.");
        } else {
            PulseLogger.warn(LOG, "{} priority variation(s) found.", conflictCount);
        }

        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }

    /**
     * 전체 진단 실행 (충돌 + 우선순위 검사).
     */
    public void runFullDiagnostics() {
        printReport();
        checkConflicts();
        checkPriorityConflicts();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\MixinHelper.java =====

package com.pulse.mixin;

import com.pulse.api.DevMode;
import com.pulse.api.log.PulseLogger;
import com.pulse.event.Event;
import com.pulse.event.EventBus;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

import java.util.function.Function;

/**
 * Mixin 개발 유틸리티.
 * Mixin 클래스에서 자주 사용되는 패턴을 헬퍼 메서드로 제공.
 * 
 * 사용 예:
 * 
 * <pre>
 * {@literal @}Mixin(IsoZombie.class)
 * public class ZombieMixin {
 *     {@literal @}Inject(method = "update", at = @At("HEAD"), cancellable = true)
 *     private void onUpdate(CallbackInfo ci) {
 *         IsoZombie zombie = MixinHelper.self(this);
 *         ZombieUpdateEvent event = new ZombieUpdateEvent(zombie);
 *         MixinHelper.fireEvent(event, ci);  // 자동으로 취소 처리
 *     }
 * }
 * </pre>
 */
public final class MixinHelper {

    private static final String LOG = PulseLogger.PULSE;

    private MixinHelper() {
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 발행 헬퍼
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 발행 및 취소 처리.
     * 이벤트가 취소되면 CallbackInfo.cancel()을 자동 호출.
     * 
     * @param event 발행할 이벤트
     * @param ci    Mixin CallbackInfo
     * @return true if event was cancelled
     */
    public static boolean fireEvent(Event event, CallbackInfo ci) {
        EventBus.post(event);
        if (event.isCancellable() && event.isCancelled()) {
            ci.cancel();
            return true;
        }
        return false;
    }

    /**
     * 이벤트 발행만 수행 (취소 처리 없음).
     * 
     * @param event 발행할 이벤트
     * @return 발행된 이벤트 (체이닝용)
     */
    public static <T extends Event> T fire(T event) {
        EventBus.post(event);
        return event;
    }

    /**
     * 반환값이 있는 이벤트 발행.
     * 이벤트가 취소되면 지정된 반환값으로 설정.
     * 
     * @param event       발행할 이벤트
     * @param cir         Mixin CallbackInfoReturnable
     * @param returnValue 취소 시 반환할 값
     * @return true if event was cancelled
     */
    public static <T> boolean fireEventWithReturn(
            Event event,
            CallbackInfoReturnable<T> cir,
            T returnValue) {
        EventBus.post(event);
        if (event.isCancellable() && event.isCancelled()) {
            cir.setReturnValue(returnValue);
            return true;
        }
        return false;
    }

    /**
     * 조건부 이벤트 발행.
     * 조건이 참일 때만 이벤트 발행.
     * 
     * @param condition 발행 조건
     * @param event     발행할 이벤트
     * @param ci        Mixin CallbackInfo
     * @return true if event was cancelled
     */
    public static boolean fireEventIf(boolean condition, Event event, CallbackInfo ci) {
        if (!condition)
            return false;
        return fireEvent(event, ci);
    }

    // ─────────────────────────────────────────────────────────────
    // 캐스팅 헬퍼
    // ─────────────────────────────────────────────────────────────

    /**
     * Mixin에서 this를 원본 타입으로 캐스팅.
     * 
     * <pre>
     * // Mixin 클래스 내에서:
     * IsoZombie zombie = MixinHelper.self(this);
     * </pre>
     * 
     * @param mixinThis Mixin 클래스의 this
     * @return 원본 타입으로 캐스팅된 객체
     */
    @SuppressWarnings("unchecked")
    public static <T> T self(Object mixinThis) {
        return (T) mixinThis;
    }

    /**
     * 안전한 캐스팅 (실패 시 null 반환).
     * 
     * @param obj   캐스팅할 객체
     * @param clazz 타겟 클래스
     * @return 캐스팅된 객체 또는 null
     */
    public static <T> T safeCast(Object obj, Class<T> clazz) {
        if (obj == null)
            return null;
        if (clazz.isInstance(obj)) {
            return clazz.cast(obj);
        }
        return null;
    }

    // ─────────────────────────────────────────────────────────────
    // 반환값 조작 헬퍼
    // ─────────────────────────────────────────────────────────────

    /**
     * 반환값 설정 및 메서드 종료.
     * 
     * @param cir   Mixin CallbackInfoReturnable
     * @param value 반환할 값
     */
    public static <T> void setReturn(CallbackInfoReturnable<T> cir, T value) {
        cir.setReturnValue(value);
    }

    /**
     * 조건부 반환값 설정.
     * 
     * @param condition 조건
     * @param cir       Mixin CallbackInfoReturnable
     * @param value     반환할 값
     * @return true if return value was set
     */
    public static <T> boolean setReturnIf(boolean condition, CallbackInfoReturnable<T> cir, T value) {
        if (condition) {
            cir.setReturnValue(value);
            return true;
        }
        return false;
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * null-safe 비교.
     */
    public static boolean equals(Object a, Object b) {
        if (a == b)
            return true;
        if (a == null || b == null)
            return false;
        return a.equals(b);
    }

    /**
     * 디버그 로그 출력.
     * 
     * @param mixinName Mixin 클래스 이름
     * @param message   로그 메시지
     */
    public static void debug(String mixinName, String message) {
        PulseLogger.debug(LOG, "[Mixin/{}] {}", mixinName, message);
    }

    /**
     * 메서드 주입 성공 로그.
     * 
     * @param targetClass  타겟 클래스
     * @param targetMethod 타겟 메서드
     */
    public static void logInjection(String targetClass, String targetMethod) {
        PulseLogger.debug(LOG, "Injected: {}.{}", targetClass, targetMethod);
    }

    // ─────────────────────────────────────────────────────────────
    // @ModifyVariable / @Redirect 헬퍼
    // ─────────────────────────────────────────────────────────────

    /**
     * 로컬 변수 수정 헬퍼 (@ModifyVariable 용).
     * 
     * <pre>
     * {@literal @}ModifyVariable(method = "update", at = @At("HEAD"))
     * private float modifySpeed(float original) {
     *     return MixinHelper.modifyLocal(original, speed -> speed * 1.5f);
     * }
     * </pre>
     * 
     * @param original 원본 값
     * @param modifier 수정 함수
     * @return 수정된 값
     */
    public static <T> T modifyLocal(T original, Function<T, T> modifier) {
        return modifier.apply(original);
    }

    /**
     * 메서드 반환값 수정 헬퍼 (@Redirect 용).
     * 
     * <pre>
     * {@literal @}Redirect(method = "update", at = @At(value = "INVOKE", target = "..."))
     * private float redirectDamage(float original) {
     *     return MixinHelper.redirect(original, dmg -> dmg * 0.5f);
     * }
     * </pre>
     * 
     * @param original   원본 값
     * @param redirector 리다이렉트 함수
     * @return 수정된 값
     */
    public static <T> T redirect(T original, Function<T, T> redirector) {
        return redirector.apply(original);
    }

    /**
     * DevMode일 때만 디버그 로그 출력.
     * 
     * @param mixinName Mixin 이름
     * @param message   로그 메시지
     */
    public static void debugIf(String mixinName, String message) {
        if (DevMode.isEnabled()) {
            debug(mixinName, message);
        }
    }

    /**
     * DevMode일 때만 주입 로그 출력.
     * 
     * @param targetClass  타겟 클래스
     * @param targetMethod 타겟 메서드
     */
    public static void logInjectionIf(String targetClass, String targetMethod) {
        if (DevMode.isEnabled()) {
            logInjection(targetClass, targetMethod);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\package-info.java =====

/**
 * Pulse Mixin Integration.
 * 
 * <p>
 * SpongePowered Mixin을 사용하여 Project Zomboid 게임 코드에 후킹.
 * </p>
 * 
 * <h2>주요 Mixin</h2>
 * <ul>
 * <li>{@code IsoWorldMixin} - 게임 틱 후킹 {@code update()}</li>
 * <li>{@code IsoPlayerMixin} - 플레이어 동작 후킹</li>
 * <li>{@code IsoZombieMixin} - 좀비 업데이트 후킹</li>
 * <li>{@code GameClientMixin} - 네트워크 클라이언트 후킹</li>
 * <li>{@code MainScreenStateMixin} - 렌더링 후킹</li>
 * <li>{@code PathfindingMixin} - 경로 탐색 후킹</li>
 * </ul>
 * 
 * <h2>오류 처리</h2>
 * <p>
 * 모든 Mixin 메서드는 fail-soft 정책을 따릅니다:
 * </p>
 * <ul>
 * <li>try-catch로 감싸서 게임 크래시 방지</li>
 * <li>{@link com.pulse.mixin.PulseErrorHandler}로 오류 보고</li>
 * <li>오류 발생 시 해당 기능만 비활성화</li>
 * </ul>
 * 
 * @since 1.0
 */
package com.pulse.mixin;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\PathfindingMixin.java =====

package com.pulse.mixin;

import com.pulse.api.profiler.PathfindingHook;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

/**
 * Mixin for AI Pathfinding profiling.
 * 
 * @since Pulse 0.2.0
 */
@Mixin(targets = "zombie.ai.astar.AStarPathFinder")
public class PathfindingMixin {

    @Inject(method = "findPath", at = @At("HEAD"))
    private void Pulse$onFindPathStart(CallbackInfoReturnable<Object> cir) {
        PathfindingHook.onPathRequest();
        PathfindingHook.onGridSearchStart();
    }

    @Inject(method = "findPath", at = @At("RETURN"))
    private void Pulse$onFindPathEnd(CallbackInfoReturnable<Object> cir) {
        PathfindingHook.onGridSearchEnd();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\PulseErrorHandler.java =====

package com.pulse.mixin;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Mixin 오류 중앙 처리기.
 * 
 * Pulse 전체의 Mixin 오류를 수집하고, 진단 정보를 제공합니다.
 * 
 * @since Pulse 1.2
 */
public final class PulseErrorHandler {

    private static final List<MixinError> errorLog = Collections.synchronizedList(new ArrayList<>());
    private static final Map<String, Integer> errorCountByMixin = new ConcurrentHashMap<>();
    private static final int MAX_ERROR_LOG_SIZE = 100;

    private static volatile ErrorCallback callback = null;

    private PulseErrorHandler() {
        // Utility class
    }

    /**
     * Mixin 오류 보고
     * 
     * @param mixinId Mixin 식별자
     * @param error   발생한 오류
     */
    public static void reportMixinFailure(String mixinId, Throwable error) {
        // 오류 카운트 증가 (using lambda to avoid null safety warning)
        errorCountByMixin.merge(mixinId, 1, (a, b) -> a + b);

        // 오류 로그 저장 (최대 크기 제한)
        MixinError errorInfo = new MixinError(mixinId, error);
        synchronized (errorLog) {
            if (errorLog.size() >= MAX_ERROR_LOG_SIZE) {
                errorLog.remove(0);
            }
            errorLog.add(errorInfo);
        }

        // 콜백 호출
        ErrorCallback cb = callback;
        if (cb != null) {
            try {
                cb.onMixinError(mixinId, error);
            } catch (Throwable t) {
                // 콜백 자체 오류는 무시
            }
        }
    }

    /**
     * 오류 콜백 설정 (외부 모니터링용)
     */
    public static void setCallback(ErrorCallback cb) {
        callback = cb;
    }

    /**
     * 최근 오류 목록
     */
    public static List<MixinError> getRecentErrors() {
        synchronized (errorLog) {
            return new ArrayList<>(errorLog);
        }
    }

    /**
     * Mixin별 오류 카운트
     */
    public static Map<String, Integer> getErrorCounts() {
        return new ConcurrentHashMap<>(errorCountByMixin);
    }

    /**
     * 특정 Mixin 오류 존재 여부
     */
    public static boolean hasErrors(String mixinId) {
        return errorCountByMixin.containsKey(mixinId);
    }

    /**
     * 전체 오류 카운트
     */
    public static int getTotalErrorCount() {
        return errorCountByMixin.values().stream().mapToInt(Integer::intValue).sum();
    }

    /**
     * 오류 로그 초기화
     */
    public static void clearErrors() {
        synchronized (errorLog) {
            errorLog.clear();
        }
        errorCountByMixin.clear();
    }

    /**
     * 상태 요약 (진단용)
     */
    public static String getStatusSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("PulseErrorHandler Status:\n");
        sb.append("  Total Errors: ").append(getTotalErrorCount()).append("\n");
        sb.append("  Affected Mixins: ").append(errorCountByMixin.size()).append("\n");

        if (!errorCountByMixin.isEmpty()) {
            sb.append("  Error Breakdown:\n");
            errorCountByMixin.forEach(
                    (mixin, count) -> sb.append("    - ").append(mixin).append(": ").append(count).append("\n"));
        }

        return sb.toString();
    }

    /**
     * 오류 콜백 인터페이스
     */
    @FunctionalInterface
    public interface ErrorCallback {
        void onMixinError(String mixinId, Throwable error);
    }

    /**
     * Mixin 오류 정보 클래스
     */
    public static class MixinError {
        private final String mixinId;
        private final String errorType;
        private final String message;
        private final String stackTrace;
        private final LocalDateTime timestamp;

        public MixinError(String mixinId, Throwable error) {
            this.mixinId = mixinId;
            this.errorType = error.getClass().getSimpleName();
            this.message = error.getMessage();
            this.stackTrace = getStackTraceString(error);
            this.timestamp = LocalDateTime.now();
        }

        private static String getStackTraceString(Throwable t) {
            StringWriter sw = new StringWriter();
            t.printStackTrace(new PrintWriter(sw));
            return sw.toString();
        }

        public String getMixinId() {
            return mixinId;
        }

        public String getErrorType() {
            return errorType;
        }

        public String getMessage() {
            return message;
        }

        public String getStackTrace() {
            return stackTrace;
        }

        public LocalDateTime getTimestamp() {
            return timestamp;
        }

        @Override
        public String toString() {
            return String.format("[%s] %s in %s: %s",
                    timestamp.format(DateTimeFormatter.ISO_LOCAL_TIME),
                    errorType, mixinId, message);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\PulseMixinPlugin.java =====

package com.pulse.mixin;

import com.pulse.api.DevMode;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.mixin.MixinInjectionValidator;
import org.spongepowered.asm.mixin.extensibility.IMixinConfigPlugin;
import org.spongepowered.asm.mixin.extensibility.IMixinInfo;

import java.util.List;
import java.util.Set;

/**
 * Pulse Mixin 구성 플러그인.
 * Mixin 시스템과 fail-soft 정책을 연동합니다.
 * 
 * mixin.json에서 다음과 같이 등록:
 * 
 * <pre>
 * {
 *   "package": "com.pulse.mixin",
 *   "plugin": "com.pulse.mixin.PulseMixinPlugin",
 *   ...
 * }
 * </pre>
 * 
 * @since 1.1.0
 */
public class PulseMixinPlugin implements IMixinConfigPlugin {

    private static final String LOG = PulseLogger.PULSE;
    private String mixinPackage;

    @Override
    public void onLoad(String mixinPackage) {
        this.mixinPackage = mixinPackage;
        PulseLogger.debug(LOG, "MixinPlugin loaded for package: {}", mixinPackage);
    }

    @Override
    public String getRefMapperConfig() {
        // 기본 refmap 사용
        return null;
    }

    /**
     * Mixin 적용 여부 결정.
     * fail-soft에 의해 비활성화된 Mixin은 건너뜀.
     * 
     * @param targetClassName 대상 클래스
     * @param mixinClassName  Mixin 클래스
     * @return 적용하려면 true, 건너뛰려면 false
     */
    @Override
    public boolean shouldApplyMixin(String targetClassName, String mixinClassName) {
        // Mixin이 비활성화되어 있는지 확인
        if (MixinInjectionValidator.isMixinDisabled(mixinClassName)) {
            PulseLogger.debug(LOG, "Skipping disabled mixin: {}", mixinClassName);
            return false;
        }

        // 등록된 패키지의 Mixin인지 검증
        if (mixinPackage != null && !mixinClassName.startsWith(mixinPackage)) {
            PulseLogger.trace(LOG, "Note: Mixin from external package: {}", mixinClassName);
        }

        return true;
    }

    @Override
    public void acceptTargets(Set<String> myTargets, Set<String> otherTargets) {
        // 다른 Mixin과의 타겟 충돌 처리
        // 현재는 모든 타겟 허용
    }

    @Override
    public List<String> getMixins() {
        // 동적 Mixin 추가 (없음)
        return null;
    }

    @Override
    public void preApply(String targetClassName, org.objectweb.asm.tree.ClassNode targetClass,
            String mixinClassName, IMixinInfo mixinInfo) {
        // Mixin 적용 전 훅
        // 디버그 로깅 (DevMode에서만)
        if (DevMode.isEnabled()) {
            PulseLogger.debug(LOG, "Pre-apply: {} → {}", mixinClassName, targetClassName);
        }
    }

    @Override
    public void postApply(String targetClassName, org.objectweb.asm.tree.ClassNode targetClass,
            String mixinClassName, IMixinInfo mixinInfo) {
        // Mixin 적용 후 훅
        // 성공 기록
        MixinInjectionValidator.recordSuccess(mixinClassName, targetClassName, 0);

        if (DevMode.isEnabled()) {
            PulseLogger.debug(LOG, "Post-apply: {} → {} ✓", mixinClassName, targetClassName);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mixin\SafeMixinWrapper.java =====

package com.pulse.mixin;

import com.pulse.api.log.PulseLogger;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;

/**
 * Mixin 로직의 안전한 실행을 보장하는 래퍼.
 * 
 * Fuse 같은 딥 엔진 후킹 모드에서 발생할 수 있는 예외를 격리하여
 * 게임 전체 크래시를 방지합니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // 반환값이 없는 경우
 * SafeMixinWrapper.execute("IsoZombieMixin.update", () -> {
 *     // 위험할 수 있는 Mixin 로직
 * });
 * 
 * // 반환값이 있는 경우
 * int result = SafeMixinWrapper.executeWithReturn("SomeMixin.calc", () -> {
 *     return complexCalculation();
 * }, 0); // 실패 시 기본값 0 반환
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class SafeMixinWrapper {

    private static final String LOG = PulseLogger.PULSE;

    // Mixin별 오류 카운터 (로그 스팸 방지)
    private static final Map<String, AtomicInteger> errorCounts = new ConcurrentHashMap<>();

    // 동일 오류 로그 제한 (최대 N번까지만 출력)
    private static final int MAX_ERROR_LOGS_PER_MIXIN = 5;

    // 디버그 모드 (모든 오류 출력)
    private static volatile boolean debugMode = false;

    private SafeMixinWrapper() {
        // Utility class
    }

    /**
     * Mixin 로직을 안전하게 실행 (반환값 없음)
     * 
     * @param mixinId Mixin 식별자 (예: "IsoZombieMixin.update")
     * @param logic   실행할 로직
     */
    public static void execute(String mixinId, Runnable logic) {
        try {
            logic.run();
        } catch (Throwable t) {
            handleError(mixinId, t);
        }
    }

    /**
     * Mixin 로직을 안전하게 실행 (반환값 있음)
     * 
     * @param mixinId  Mixin 식별자
     * @param logic    실행할 로직
     * @param fallback 실패 시 반환할 기본값
     * @return 로직 결과 또는 fallback
     */
    public static <T> T executeWithReturn(String mixinId, Supplier<T> logic, T fallback) {
        try {
            return logic.get();
        } catch (Throwable t) {
            handleError(mixinId, t);
            return fallback;
        }
    }

    /**
     * 조건부 Mixin 로직 실행
     * 
     * @param condition 실행 조건
     * @param mixinId   Mixin 식별자
     * @param logic     실행할 로직
     */
    public static void executeIf(boolean condition, String mixinId, Runnable logic) {
        if (condition) {
            execute(mixinId, logic);
        }
    }

    /**
     * 오류 처리
     */
    private static void handleError(String mixinId, Throwable t) {
        AtomicInteger counter = errorCounts.computeIfAbsent(mixinId, k -> new AtomicInteger(0));
        int count = counter.incrementAndGet();

        // 오류 보고
        PulseErrorHandler.reportMixinFailure(mixinId, t);

        // 로그 스팸 방지 (디버그 모드가 아닌 경우)
        if (debugMode || count <= MAX_ERROR_LOGS_PER_MIXIN) {
            PulseLogger.error(LOG, "Error in {} (#{})): {}", mixinId, count, t.getMessage());
            if (debugMode) {
                t.printStackTrace();
            }
        } else if (count == MAX_ERROR_LOGS_PER_MIXIN + 1) {
            PulseLogger.warn(LOG, "Suppressing further errors for {}", mixinId);
        }
    }

    /**
     * 특정 Mixin의 오류 카운터 리셋
     */
    public static void resetErrorCount(String mixinId) {
        errorCounts.remove(mixinId);
    }

    /**
     * 모든 Mixin 오류 카운터 리셋
     */
    public static void resetAllErrorCounts() {
        errorCounts.clear();
    }

    /**
     * 디버그 모드 설정
     */
    public static void setDebugMode(boolean enabled) {
        debugMode = enabled;
        if (enabled) {
            PulseLogger.info(LOG, "SafeMixin debug mode enabled - all errors will be printed");
        }
    }

    /**
     * 현재 오류 통계 반환
     */
    public static Map<String, Integer> getErrorStats() {
        Map<String, Integer> stats = new ConcurrentHashMap<>();
        errorCounts.forEach((k, v) -> stats.put(k, v.get()));
        return stats;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\dependency\DependencyResolver.java =====


package com.pulse.mod.dependency;

import com.pulse.api.log.PulseLogger;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModMetadata;
import com.pulse.mod.VersionComparator;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Handles dependency resolution and topological sorting of mods.
 */
public class DependencyResolver {
    private static final String LOG = PulseLogger.PULSE;
    private final Map<String, ModContainer> mods;

    public DependencyResolver(Map<String, ModContainer> mods) {
        this.mods = mods;
    }

    public List<ModContainer> resolve() {
        PulseLogger.info(LOG, "Resolving dependencies...");

        List<String> errors = checkDependenciesAndConflicts();
        if (!errors.isEmpty()) {
            PulseLogger.error(LOG, "Dependency/Conflict errors:");
            for (String error : errors) {
                PulseLogger.error(LOG, "  ✗ {}", error);
            }
        }

        List<ModContainer> loadOrder = performTopologicalSort();

        for (ModContainer container : loadOrder) {
            container.setState(ModContainer.ModState.DEPENDENCIES_RESOLVED);
        }

        PulseLogger.info(LOG, "Load order: {}",
                loadOrder.stream().map(ModContainer::getId).collect(Collectors.joining(" → ")));

        return loadOrder;
    }

    private List<String> checkDependenciesAndConflicts() {
        List<String> errors = new ArrayList<>();
        for (ModContainer container : mods.values()) {
            ModMetadata metadata = container.getMetadata();

            // Check Dependencies
            for (ModMetadata.Dependency dep : metadata.getDependencies()) {
                if ("Pulse".equals(dep.getId()))
                    continue;

                ModContainer depMod = mods.get(dep.getId());
                if (depMod == null) {
                    if (dep.isOptional()) {
                        PulseLogger.info(LOG, "  - {}: optional dependency '{}' not found",
                                metadata.getId(), dep.getId());
                    } else {
                        errors.add(metadata.getId() + " requires " + dep.getId() + " " + dep.getVersion());
                    }
                } else {
                    String actualVersion = depMod.getMetadata().getVersion();
                    String requiredVersion = dep.getVersion();
                    if (requiredVersion != null && !requiredVersion.isEmpty() && !"*".equals(requiredVersion)) {
                        if (VersionComparator.matches(actualVersion, requiredVersion)) {
                            PulseLogger.info(LOG, "  - {} → {} v{} ✓", metadata.getId(), dep.getId(), actualVersion);
                        } else {
                            errors.add(metadata.getId() + " requires " + dep.getId() + " " +
                                    requiredVersion + " but found " + actualVersion);
                        }
                    } else {
                        PulseLogger.info(LOG, "  - {} → {} v{} ✓", metadata.getId(), dep.getId(), actualVersion);
                    }
                }
            }

            // Check Conflicts
            for (String conflictId : metadata.getConflicts()) {
                if (mods.containsKey(conflictId)) {
                    errors.add(metadata.getId() + " conflicts with " + conflictId);
                    PulseLogger.error(LOG, "✗ Conflict detected: {} and {} cannot be loaded together",
                            metadata.getId(), conflictId);
                }
            }
        }
        return errors;
    }

    private List<ModContainer> performTopologicalSort() {
        List<ModContainer> result = new ArrayList<>();
        Set<String> visited = new HashSet<>();
        Set<String> visiting = new HashSet<>();

        for (String modId : mods.keySet()) {
            if (!visited.contains(modId)) {
                topologicalSort(modId, visited, visiting, result);
            }
        }
        return result;
    }

    private void topologicalSort(String modId, Set<String> visited, Set<String> visiting, List<ModContainer> result) {
        if (visited.contains(modId))
            return;
        if (visiting.contains(modId)) {
            PulseLogger.error(LOG, "Circular dependency detected: {}", modId);
            return;
        }

        visiting.add(modId);

        ModContainer container = mods.get(modId);
        if (container != null) {
            for (ModMetadata.Dependency dep : container.getMetadata().getDependencies()) {
                if (mods.containsKey(dep.getId())) {
                    topologicalSort(dep.getId(), visited, visiting, result);
                }
            }
            result.add(container);
        }

        visiting.remove(modId);
        visited.add(modId);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\discovery\ModDiscovery.java =====

package com.pulse.mod.discovery;

import com.google.gson.Gson;
import com.pulse.api.log.PulseLogger;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModMetadata;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

/**
 * Handles discovery of mods from the mods directory.
 */
public class ModDiscovery {
    private static final String LOG = PulseLogger.PULSE;
    private final Path modsDirectory;
    private final Gson gson;

    public ModDiscovery(Path modsDirectory, Gson gson) {
        this.modsDirectory = modsDirectory;
        this.gson = gson;
    }

    public Map<String, ModContainer> discoverMods() {
        Map<String, ModContainer> mods = new LinkedHashMap<>();

        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "Discovering mods...");

        ensureDirectoryExists();
        scanJarFiles(mods);

        PulseLogger.info(LOG, "Discovered {} mod(s)", mods.size());
        PulseLogger.info(LOG, "═══════════════════════════════════════");

        return mods;
    }

    private void ensureDirectoryExists() {
        try {
            if (!Files.exists(modsDirectory)) {
                Files.createDirectories(modsDirectory);
                PulseLogger.info(LOG, "Created mods directory");
            }
        } catch (IOException e) {
            PulseLogger.error(LOG, "Failed to create mods directory: {}", e.getMessage());
        }
    }

    private void scanJarFiles(Map<String, ModContainer> mods) {
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(modsDirectory, "*.jar")) {
            for (Path jarPath : stream) {
                try {
                    discoverMod(jarPath, mods);
                } catch (Exception e) {
                    PulseLogger.error(LOG, "Failed to load mod: {}", jarPath.getFileName());
                    e.printStackTrace();
                }
            }
        } catch (IOException e) {
            PulseLogger.error(LOG, "Failed to scan mods directory: {}", e.getMessage());
        }
    }

    private void discoverMod(Path jarPath, Map<String, ModContainer> mods) throws Exception {
        PulseLogger.debug(LOG, "Scanning: {}", jarPath.getFileName());

        try (JarFile jar = new JarFile(jarPath.toFile())) {
            JarEntry metadataEntry = jar.getJarEntry("pulse.mod.json");

            if (metadataEntry == null) {
                PulseLogger.debug(LOG, "  - No pulse.mod.json found, skipping");
                return;
            }

            ModMetadata metadata;
            try (InputStream is = jar.getInputStream(metadataEntry);
                    InputStreamReader reader = new InputStreamReader(is)) {
                metadata = gson.fromJson(reader, ModMetadata.class);
            }

            if (metadata.getId() == null || metadata.getId().isEmpty()) {
                PulseLogger.error(LOG, "  - Invalid mod: missing 'id' field");
                return;
            }

            if (mods.containsKey(metadata.getId())) {
                PulseLogger.error(LOG, "  - Duplicate mod ID: {}", metadata.getId());
                return;
            }

            metadata.setSourceFile(jarPath.toAbsolutePath().toString());

            URL jarUrl = jarPath.toUri().toURL();
            URLClassLoader classLoader = new URLClassLoader(
                    new URL[] { jarUrl },
                    getClass().getClassLoader());

            ModContainer container = new ModContainer(metadata, classLoader);
            container.setState(ModContainer.ModState.METADATA_LOADED);

            mods.put(metadata.getId(), container);

            PulseLogger.info(LOG, "  ✓ {}", metadata);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\EntryPoints.java =====

package com.pulse.mod;

/**
 * 환경별 엔트리포인트 정의.
 * 클라이언트/서버/공통 각각 다른 초기화 클래스 지정 가능.
 * 
 * pulse.mod.json 예:
 * 
 * <pre>
 * "entryPoints": {
 *     "common": "com.example.ModCommon",
 *     "client": "com.example.ModClient", 
 *     "server": "com.example.ModServer"
 * }
 * </pre>
 */
public class EntryPoints {

    private String common; // 공통 (항상 실행)
    private String client; // 클라이언트 전용
    private String server; // 서버 전용

    public String getCommon() {
        return common;
    }

    public void setCommon(String common) {
        this.common = common;
    }

    public String getClient() {
        return client;
    }

    public void setClient(String client) {
        this.client = client;
    }

    public String getServer() {
        return server;
    }

    public void setServer(String server) {
        this.server = server;
    }

    /**
     * 현재 환경에 맞는 엔트리포인트 반환.
     */
    public String getForEnvironment(Environment env) {
        switch (env) {
            case CLIENT:
                return client != null ? client : common;
            case SERVER:
                return server != null ? server : common;
            default:
                return common;
        }
    }

    public enum Environment {
        CLIENT,
        SERVER,
        INTEGRATED // 싱글플레이 (클라이언트 + 서버)
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\mixin\MixinRegistrar.java =====

package com.pulse.mod.mixin;

import com.pulse.api.log.PulseLogger;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModMetadata;
import org.spongepowered.asm.mixin.Mixins;

import java.util.List;

/**
 * Handles registration of Mixin configurations from mods.
 */
public class MixinRegistrar {
    private static final String LOG = PulseLogger.PULSE;

    public void registerMixins(List<ModContainer> loadOrder) {
        PulseLogger.info(LOG, "Registering mod mixins...");

        for (ModContainer container : loadOrder) {
            ModMetadata metadata = container.getMetadata();
            List<String> mixinConfigs = metadata.getMixins();

            if (mixinConfigs == null || mixinConfigs.isEmpty()) {
                continue;
            }

            for (String mixinConfig : mixinConfigs) {
                try {
                    PulseLogger.info(LOG, "Registered mixin config {} from {}",
                            mixinConfig, metadata.getId());
                    Mixins.addConfiguration(mixinConfig);
                } catch (Exception e) {
                    PulseLogger.error(LOG, "✗ Failed to register {} from {}: {}",
                            mixinConfig, metadata.getId(), e.getMessage());
                }
            }

            container.setState(ModContainer.ModState.MIXINS_APPLIED);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\ModContainer.java =====

package com.pulse.mod;

import com.pulse.api.log.PulseLogger;

import java.net.URLClassLoader;

/**
 * 로드된 모드를 나타내는 컨테이너.
 * 메타데이터, 클래스로더, 모드 인스턴스를 관리.
 */
public class ModContainer {

    private final ModMetadata metadata;
    private final URLClassLoader classLoader;
    private Object modInstance; // entrypoint 클래스의 인스턴스
    private ModState state = ModState.DISCOVERED;

    public ModContainer(ModMetadata metadata, URLClassLoader classLoader) {
        this.metadata = metadata;
        this.classLoader = classLoader;
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 상태
    // ─────────────────────────────────────────────────────────────

    public enum ModState {
        DISCOVERED, // JAR 발견됨
        METADATA_LOADED, // 메타데이터 파싱 완료
        DEPENDENCIES_RESOLVED, // 의존성 확인 완료
        MIXINS_APPLIED, // Mixin 적용됨
        INITIALIZED, // 초기화 완료
        LOADED, // 정상 로드됨 (활성 상태)
        DISABLED, // 비활성화됨 (핫 리로드)
        UNLOADED, // 언로드됨 (종료 시)
        ERRORED // 에러 발생
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 엔트리포인트 클래스를 로드하고 인스턴스화
     */
    public void initialize() throws Exception {
        String entrypoint = metadata.getEntrypoint();
        if (entrypoint == null || entrypoint.isEmpty()) {
            PulseLogger.info(PulseLogger.PULSE, "{} has no entrypoint, skipping initialization", metadata.getId());
            state = ModState.INITIALIZED;
            return;
        }

        try {
            PulseLogger.info(PulseLogger.PULSE, "Initializing mod: {}", metadata.getId());

            // 엔트리포인트 클래스 로드
            Class<?> entryClass = classLoader.loadClass(entrypoint);

            // PulseMod 인터페이스 구현 여부 확인
            if (PulseMod.class.isAssignableFrom(entryClass)) {
                modInstance = entryClass.getDeclaredConstructor().newInstance();
                ((PulseMod) modInstance).onInitialize();
                PulseLogger.info(PulseLogger.PULSE, "✓ {} initialized successfully", metadata.getId());
            } else {
                PulseLogger.warn(PulseLogger.PULSE, "{} does not implement PulseMod interface", entrypoint);
                modInstance = entryClass.getDeclaredConstructor().newInstance();
            }

            state = ModState.INITIALIZED;
            metadata.setLoaded(true);

        } catch (Exception e) {
            state = ModState.ERRORED;
            PulseLogger.error(PulseLogger.PULSE, "Failed to initialize mod: {}", metadata.getId());
            throw e;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public ModMetadata getMetadata() {
        return metadata;
    }

    public String getId() {
        return metadata.getId();
    }

    public String getVersion() {
        return metadata.getVersion();
    }

    public URLClassLoader getClassLoader() {
        return classLoader;
    }

    public Object getModInstance() {
        return modInstance;
    }

    @SuppressWarnings("unchecked")
    public <T> T getModInstance(Class<T> type) {
        if (type.isInstance(modInstance)) {
            return (T) modInstance;
        }
        return null;
    }

    public ModState getState() {
        return state;
    }

    public void setState(ModState state) {
        this.state = state;
    }

    public boolean isLoaded() {
        return state == ModState.INITIALIZED;
    }

    public boolean hasError() {
        return state == ModState.ERRORED;
    }

    @Override
    public String toString() {
        return String.format("ModContainer[%s v%s, state=%s]",
                metadata.getId(), metadata.getVersion(), state);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\ModLoader.java =====

package com.pulse.mod;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.pulse.api.log.PulseLogger;
import com.pulse.api.PulseConstants;
import com.pulse.api.exception.InitializationException;
import com.pulse.mod.dependency.DependencyResolver;
import com.pulse.mod.discovery.ModDiscovery;
import com.pulse.mod.mixin.MixinRegistrar;

import java.nio.file.*;
import java.util.*;

/**
 * Pulse 모드 로더.
 * mods/ 폴더에서 모드 JAR를 발견하고 로드.
 */
public class ModLoader {

    private static final String LOG = PulseLogger.PULSE;

    private static ModLoader instance;

    private final Path modsDirectory;
    private final Map<String, ModContainer> mods = new LinkedHashMap<>();
    private final List<ModContainer> loadOrder = new ArrayList<>();
    private final Gson gson = new GsonBuilder().setPrettyPrinting().create();

    private boolean discoveryComplete = false;
    private boolean initialized = false;

    // ─────────────────────────────────────────────────────────────
    // 싱글톤
    // ─────────────────────────────────────────────────────────────

    public static ModLoader getInstance() {
        if (instance == null) {
            instance = new ModLoader();
        }
        return instance;
    }

    private ModLoader() {
        // 게임 디렉토리에서 mods 폴더 찾기
        String gameDir = System.getProperty("user.dir");
        this.modsDirectory = Paths.get(gameDir, PulseConstants.MODS_DIR_NAME);

        PulseLogger.info(LOG, "Mods directory: {}", modsDirectory.toAbsolutePath());
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 발견
    // ─────────────────────────────────────────────────────────────

    /**
     * mods/ 폴더에서 모든 모드 JAR 스캔
     */
    public void discoverMods() {
        if (discoveryComplete) {
            PulseLogger.info(LOG, "Discovery already complete");
            return;
        }

        ModDiscovery discovery = new ModDiscovery(modsDirectory, gson);
        Map<String, ModContainer> discoveredMods = discovery.discoverMods();
        mods.putAll(discoveredMods);

        discoveryComplete = true;
    }

    // ─────────────────────────────────────────────────────────────
    // 의존성 해결 및 로드 순서 결정
    // ─────────────────────────────────────────────────────────────

    /**
     * 의존성 검사 및 로드 순서 결정 (토폴로지 정렬)
     */
    public void resolveDependencies() {
        DependencyResolver resolver = new DependencyResolver(mods);
        List<ModContainer> resolvedOrder = resolver.resolve();

        loadOrder.clear();
        loadOrder.addAll(resolvedOrder);
    }

    // ─────────────────────────────────────────────────────────────
    // Mixin 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 모드의 Mixin config 등록
     */
    public void registerMixins() {
        new MixinRegistrar().registerMixins(loadOrder);
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 모드 초기화 (엔트리포인트 호출)
     */
    public void initializeMods() {
        if (initialized) {
            PulseLogger.info(LOG, "Mods already initialized");
            return;
        }

        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "Initializing mods...");

        int success = 0;
        int failed = 0;

        for (ModContainer container : loadOrder) {
            try {
                container.initialize();
                success++;
            } catch (InitializationException e) {
                failed++;
                PulseLogger.error(LOG, "✗ {} failed: {} (phase: {})",
                        container.getId(), e.getMessage(), e.getPhase());
            } catch (Exception e) {
                failed++;
                PulseLogger.error(LOG, "✗ {} failed unexpectedly: {}",
                        container.getId(), e.getMessage(), e);
            }
        }

        initialized = true;

        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "Initialization complete: {} loaded, {} failed", success, failed);
        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    public ModContainer getMod(String id) {
        return mods.get(id);
    }

    public Collection<ModContainer> getAllMods() {
        return Collections.unmodifiableCollection(mods.values());
    }

    public List<ModContainer> getLoadOrder() {
        return Collections.unmodifiableList(loadOrder);
    }

    public int getModCount() {
        return mods.size();
    }

    public Set<String> getLoadedModIds() {
        return Collections.unmodifiableSet(mods.keySet());
    }

    public boolean isModLoaded(String id) {
        ModContainer container = mods.get(id);
        return container != null && container.isLoaded();
    }

    /**
     * 모든 모드 언로드 (게임 종료 시)
     */
    public void unloadAll() {
        PulseLogger.info(LOG, "Unloading all mods...");

        // 역순으로 언로드 (의존성 고려)
        for (int i = loadOrder.size() - 1; i >= 0; i--) {
            ModContainer container = loadOrder.get(i);
            try {
                PulseMod mod = container.getModInstance(PulseMod.class);
                if (mod != null) {
                    mod.onUnload();
                }
                container.setState(ModContainer.ModState.UNLOADED);
                PulseLogger.debug(LOG, "Unloaded: {}", container.getId());
            } catch (RuntimeException e) {
                PulseLogger.error(LOG, "Failed to unload mod {}: {}", container.getId(), e.getMessage());
            }
        }

        loadOrder.clear();
        mods.clear();
        initialized = false;
        discoveryComplete = false;

        PulseLogger.info(LOG, "All mods unloaded");
    }

    public Path getModsDirectory() {
        return modsDirectory;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\ModMetadata.java =====

package com.pulse.mod;

import java.util.ArrayList;
import java.util.List;

/**
 * 모드 메타데이터.
 * 각 모드의 pulse.mod.json 파일에서 파싱됨.
 * 
 * 예시 pulse.mod.json:
 * {
 * "id": "mymod",
 * "name": "My Awesome Mod",
 * "version": "1.0.0",
 * "author": "ModAuthor",
 * "description": "A cool mod for Project Zomboid",
 * "entrypoint": "com.example.mymod.MyMod",
 * "mixins": ["mixins.mymod.json"],
 * "dependencies": [
 * { "id": "Pulse", "version": ">=1.0.0" },
 * { "id": "othermod", "version": ">=2.0.0", "optional": true }
 * ]
 * }
 */
public class ModMetadata {

    private String id;
    private String name;
    private String version;
    private String author;
    private String description;
    private String entrypoint;
    private List<String> mixins = new ArrayList<>();
    private List<Dependency> dependencies = new ArrayList<>();
    private List<String> conflicts = new ArrayList<>();

    // Phase 2 추가 필드
    private String license;
    private String loaderVersion; // 필요한 Pulse 버전 (예: ">=1.0.0")
    private String gameVersion; // 필요한 PZ 버전 (예: "41.78+")
    private List<String> authors = new ArrayList<>();
    private EntryPoints entryPoints; // 환경별 엔트리포인트
    private List<String> accessWideners = new ArrayList<>();
    private List<String> permissions = new ArrayList<>();
    private String loadOrder; // 로드 순서 힌트 (예: "after:othermod")
    private String homepage;
    private String issues; // 이슈 트래커 URL
    private String source; // 소스 코드 URL

    // 런타임에 설정되는 필드
    private transient String sourceFile; // JAR 파일 경로
    private transient boolean loaded = false;

    // ─────────────────────────────────────────────────────────────
    // Getters & Setters
    // ─────────────────────────────────────────────────────────────

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getEntrypoint() {
        return entrypoint;
    }

    public void setEntrypoint(String entrypoint) {
        this.entrypoint = entrypoint;
    }

    public List<String> getMixins() {
        return mixins;
    }

    public void setMixins(List<String> mixins) {
        this.mixins = mixins != null ? mixins : new ArrayList<>();
    }

    public List<Dependency> getDependencies() {
        return dependencies;
    }

    public void setDependencies(List<Dependency> dependencies) {
        this.dependencies = dependencies != null ? dependencies : new ArrayList<>();
    }

    public List<String> getConflicts() {
        return conflicts;
    }

    public void setConflicts(List<String> conflicts) {
        this.conflicts = conflicts != null ? conflicts : new ArrayList<>();
    }

    public List<String> getPermissions() {
        return permissions;
    }

    public void setPermissions(List<String> permissions) {
        this.permissions = permissions != null ? permissions : new ArrayList<>();
    }

    public String getLicense() {
        return license;
    }

    public void setLicense(String license) {
        this.license = license;
    }

    public String getLoaderVersion() {
        return loaderVersion;
    }

    public void setLoaderVersion(String loaderVersion) {
        this.loaderVersion = loaderVersion;
    }

    public String getGameVersion() {
        return gameVersion;
    }

    public void setGameVersion(String gameVersion) {
        this.gameVersion = gameVersion;
    }

    public List<String> getAuthors() {
        return authors;
    }

    public void setAuthors(List<String> authors) {
        this.authors = authors != null ? authors : new ArrayList<>();
    }

    public EntryPoints getEntryPoints() {
        return entryPoints;
    }

    public void setEntryPoints(EntryPoints entryPoints) {
        this.entryPoints = entryPoints;
    }

    public List<String> getAccessWideners() {
        return accessWideners;
    }

    public void setAccessWideners(List<String> accessWideners) {
        this.accessWideners = accessWideners != null ? accessWideners : new ArrayList<>();
    }

    public String getLoadOrder() {
        return loadOrder;
    }

    public void setLoadOrder(String loadOrder) {
        this.loadOrder = loadOrder;
    }

    public String getHomepage() {
        return homepage;
    }

    public void setHomepage(String homepage) {
        this.homepage = homepage;
    }

    public String getIssues() {
        return issues;
    }

    public void setIssues(String issues) {
        this.issues = issues;
    }

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public String getSourceFile() {
        return sourceFile;
    }

    public void setSourceFile(String sourceFile) {
        this.sourceFile = sourceFile;
    }

    public boolean isLoaded() {
        return loaded;
    }

    public void setLoaded(boolean loaded) {
        this.loaded = loaded;
    }

    // ─────────────────────────────────────────────────────────────
    // 의존성 클래스
    // ─────────────────────────────────────────────────────────────

    public static class Dependency {
        private String id;
        private String version;
        private boolean optional = false;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getVersion() {
            return version;
        }

        public void setVersion(String version) {
            this.version = version;
        }

        public boolean isOptional() {
            return optional;
        }

        public void setOptional(boolean optional) {
            this.optional = optional;
        }

        @Override
        public String toString() {
            return id + " " + version + (optional ? " (optional)" : "");
        }
    }

    @Override
    public String toString() {
        return String.format("%s (%s) v%s by %s", name, id, version, author);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\ModReloadManager.java =====

package com.pulse.mod;

import com.pulse.api.log.PulseLogger;
import com.pulse.config.ConfigManager;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.ModReloadEvent;

import java.io.File;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 모드 핫 리로드 매니저.
 * 런타임에 모드를 비활성화/재활성화할 수 있는 기능 제공.
 * 
 * 제한사항:
 * - Mixin이 적용된 모드는 완전한 언로드가 불가능
 * - 리로드는 설정 및 이벤트 리스너만 갱신
 * - 바이트코드 변경은 게임 재시작 필요
 * 
 * 사용 예:
 * 
 * <pre>
 * // 모드 비활성화
 * ModReloadManager.disable("mymod");
 * 
 * // 모드 재활성화
 * ModReloadManager.enable("mymod");
 * 
 * // 설정만 리로드
 * ModReloadManager.reloadConfig("mymod");
 * 
 * // 전체 소프트 리로드 (Mixin 제외)
 * ModReloadManager.softReload("mymod");
 * </pre>
 */
public class ModReloadManager {

    private static final String LOG = PulseLogger.PULSE;
    private static final ModReloadManager INSTANCE = new ModReloadManager();

    // 비활성화된 모드 목록
    private final Set<String> disabledMods = ConcurrentHashMap.newKeySet();

    private ModReloadManager() {
    }

    public static ModReloadManager getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 활성화/비활성화
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 비활성화.
     * 이벤트 리스너 해제, 스케줄러 태스크 취소.
     * 
     * @param modId 비활성화할 모드 ID
     * @return 성공 여부
     */
    public static boolean disable(String modId) {
        return INSTANCE.disableMod(modId);
    }

    /**
     * 모드 활성화.
     * 비활성화된 모드를 다시 활성화.
     * 
     * @param modId 활성화할 모드 ID
     * @return 성공 여부
     */
    public static boolean enable(String modId) {
        return INSTANCE.enableMod(modId);
    }

    /**
     * 모드가 활성 상태인지 확인.
     */
    public static boolean isEnabled(String modId) {
        return !INSTANCE.disabledMods.contains(modId);
    }

    /**
     * 비활성화된 모드 목록.
     */
    public static Set<String> getDisabledMods() {
        return Collections.unmodifiableSet(INSTANCE.disabledMods);
    }

    private boolean disableMod(String modId) {
        ModLoader loader = ModLoader.getInstance();
        ModContainer container = loader.getMod(modId);

        if (container == null) {
            PulseLogger.error(LOG, "Mod not found: {}", modId);
            return false;
        }

        if (disabledMods.contains(modId)) {
            PulseLogger.debug(LOG, "Mod already disabled: {}", modId);
            return true;
        }

        try {
            PulseLogger.info(LOG, "Disabling mod: {}", modId);

            // 1. 모드의 onUnload 호출
            PulseMod instance = container.getModInstance(PulseMod.class);
            if (instance != null) {
                try {
                    instance.onUnload();
                } catch (Exception e) {
                    PulseLogger.error(LOG, "Error in onUnload: {}", e.getMessage());
                }
            }

            // 2. 설정 저장
            ConfigManager.saveAll();

            // 3. 비활성화 상태로 표시
            disabledMods.add(modId);
            container.setState(ModContainer.ModState.DISABLED);

            // 4. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.DISABLED));

            PulseLogger.info(LOG, "Mod disabled: {}", modId);
            return true;

        } catch (Exception e) {
            PulseLogger.error(LOG, "Failed to disable mod: {}", modId);
            e.printStackTrace();
            return false;
        }
    }

    private boolean enableMod(String modId) {
        ModLoader loader = ModLoader.getInstance();
        ModContainer container = loader.getMod(modId);

        if (container == null) {
            PulseLogger.error(LOG, "Mod not found: {}", modId);
            return false;
        }

        if (!disabledMods.contains(modId)) {
            PulseLogger.debug(LOG, "Mod already enabled: {}", modId);
            return true;
        }

        try {
            PulseLogger.info(LOG, "Enabling mod: {}", modId);

            // 1. 활성화 상태로 표시
            disabledMods.remove(modId);
            container.setState(ModContainer.ModState.LOADED);

            // 2. 설정 리로드
            reloadConfigInternal(modId);

            // 3. 모드의 onInitialize 다시 호출
            PulseMod instance = container.getModInstance(PulseMod.class);
            if (instance != null) {
                try {
                    instance.onInitialize();
                } catch (Exception e) {
                    PulseLogger.error(LOG, "Error in onInitialize: {}", e.getMessage());
                }
            }

            // 4. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.ENABLED));

            PulseLogger.info(LOG, "Mod enabled: {}", modId);
            return true;

        } catch (Exception e) {
            PulseLogger.error(LOG, "Failed to enable mod: {}", modId);
            e.printStackTrace();
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 리로드
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 설정만 리로드.
     * 파일에서 설정을 다시 읽어옴.
     */
    public static boolean reloadConfig(String modId) {
        return INSTANCE.reloadConfigInternal(modId);
    }

    /**
     * 모드 소프트 리로드.
     * 설정 리로드 + 이벤트 리스너 재등록.
     * Mixin 변경은 반영되지 않음.
     */
    public static boolean softReload(String modId) {
        return INSTANCE.softReloadMod(modId);
    }

    /**
     * 모든 모드 설정 리로드.
     */
    public static void reloadAllConfigs() {
        ConfigManager.reloadAll();
        PulseLogger.info(LOG, "All configs reloaded");
    }

    private boolean reloadConfigInternal(String modId) {
        try {
            // modId에 해당하는 설정 클래스를 알 수 없으므로 전체 리로드
            ConfigManager.reloadAll();
            PulseLogger.debug(LOG, "Config reloaded for: {}", modId);
            return true;
        } catch (Exception e) {
            PulseLogger.error(LOG, "Failed to reload config: {}", modId);
            e.printStackTrace();
            return false;
        }
    }

    private boolean softReloadMod(String modId) {
        ModLoader loader = ModLoader.getInstance();
        ModContainer container = loader.getMod(modId);

        if (container == null) {
            PulseLogger.error(LOG, "Mod not found: {}", modId);
            return false;
        }

        try {
            PulseLogger.info(LOG, "Soft reloading mod: {}", modId);

            PulseMod instance = container.getModInstance(PulseMod.class);

            // 1. onUnload 호출 (정리)
            if (instance != null) {
                try {
                    instance.onUnload();
                } catch (Exception e) {
                    PulseLogger.error(LOG, "Error in onUnload: {}", e.getMessage());
                }
            }

            // 2. 설정 리로드
            reloadConfigInternal(modId);

            // 3. onInitialize 호출 (재초기화)
            if (instance != null) {
                try {
                    instance.onInitialize();
                } catch (Exception e) {
                    PulseLogger.error(LOG, "Error in onInitialize: {}", e.getMessage());
                }
            }

            // 4. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.RELOADED));

            PulseLogger.info(LOG, "Mod soft reloaded: {}", modId);
            return true;

        } catch (Exception e) {
            PulseLogger.error(LOG, "Failed to soft reload mod: {}", modId);
            e.printStackTrace();
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 핫 스왑 (실험적)
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 JAR 파일 핫 스왑 (실험적).
     * 새 JAR 파일을 로드하여 모드 클래스를 교체 시도.
     * 
     * ⚠️ 제한 사항:
     * - JVM은 이미 로드된 클래스를 교체할 수 없음
     * - 새 클래스만 새 로더에서 로드됨
     * - 완전한 핫 스왑은 게임 재시작 필요
     */
    public static boolean hotSwap(String modId, File newJarFile) {
        return INSTANCE.hotSwapMod(modId, newJarFile);
    }

    private boolean hotSwapMod(String modId, File newJarFile) {
        if (!newJarFile.exists() || !newJarFile.getName().endsWith(".jar")) {
            PulseLogger.error(LOG, "Invalid JAR file: {}", newJarFile);
            return false;
        }

        try {
            PulseLogger.info(LOG, "Hot swapping mod: {}", modId);
            PulseLogger.info(LOG, "New JAR: {}", newJarFile.getAbsolutePath());

            // 1. 현재 모드 비활성화
            disable(modId);

            // 2. 새 클래스 로더로 JAR 로드
            URL jarUrl = newJarFile.toURI().toURL();
            @SuppressWarnings("resource")
            URLClassLoader newLoader = new URLClassLoader(
                    new URL[] { jarUrl },
                    getClass().getClassLoader());

            // 3. 새 entrypoint 로드 시도
            ModLoader loader = ModLoader.getInstance();
            ModContainer container = loader.getMod(modId);

            if (container != null) {
                String entrypoint = container.getMetadata().getEntrypoint();
                if (entrypoint != null && !entrypoint.isEmpty()) {
                    try {
                        Class<?> newModClass = newLoader.loadClass(entrypoint);
                        Object newInstance = newModClass.getDeclaredConstructor().newInstance();

                        if (newInstance instanceof PulseMod) {
                            // 새 인스턴스로 교체 (리플렉션)
                            java.lang.reflect.Field instanceField = ModContainer.class.getDeclaredField("modInstance");
                            instanceField.setAccessible(true);
                            instanceField.set(container, newInstance);

                            PulseLogger.info(LOG, "Loaded new mod instance");
                        }
                    } catch (ClassNotFoundException e) {
                        PulseLogger.debug(LOG, "Entrypoint not found in new JAR, using existing");
                    }
                }
            }

            // 4. 다시 활성화
            enable(modId);

            // 5. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.HOT_SWAPPED));

            PulseLogger.info(LOG, "Hot swap complete (partial - JVM limitations apply)");
            return true;

        } catch (Exception e) {
            PulseLogger.error(LOG, "Hot swap failed: {}", modId);
            e.printStackTrace();
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 비활성화 여부를 확인하고 실행을 스킵할지 결정.
     * 이벤트 핸들러 등에서 사용.
     */
    public static boolean shouldSkip(String modId) {
        return INSTANCE.disabledMods.contains(modId);
    }

    /**
     * 모든 모드 상태 출력.
     */
    public static void printStatus() {
        PulseLogger.info(LOG, "═══════════════════════════════════════");
        PulseLogger.info(LOG, "       MOD RELOAD MANAGER STATUS       ");
        PulseLogger.info(LOG, "═══════════════════════════════════════");

        ModLoader loader = ModLoader.getInstance();
        for (String modId : loader.getLoadedModIds()) {
            ModContainer mod = loader.getMod(modId);
            String status = INSTANCE.disabledMods.contains(mod.getId()) ? "DISABLED" : "ENABLED";
            PulseLogger.info(LOG, "  {} v{} [{}]", mod.getId(), mod.getMetadata().getVersion(), status);
        }

        PulseLogger.info(LOG, "═══════════════════════════════════════");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\package-info.java =====

/**
 * Pulse Mod Loading System.
 * 
 * <p>
 * 모드 발견, 의존성 해결, 초기화를 담당합니다.
 * </p>
 * 
 * <h2>주요 클래스</h2>
 * <ul>
 * <li>{@link com.pulse.mod.ModLoader} - 모드 로더 싱글톤</li>
 * <li>{@link com.pulse.mod.ModContainer} - 로드된 모드 래퍼</li>
 * <li>{@link com.pulse.mod.ModMetadata} - 모드 메타데이터 (pulse.mod.json)</li>
 * <li>{@link com.pulse.mod.PulseMod} - 모드 엔트리포인트 인터페이스</li>
 * <li>{@link com.pulse.mod.ModReloadManager} - 핫 리로드 지원</li>
 * </ul>
 * 
 * <h2>모드 생명주기</h2>
 * <ol>
 * <li>Discovery - mods/ 폴더에서 JAR 스캔</li>
 * <li>Metadata Loading - pulse.mod.json 파싱</li>
 * <li>Dependency Resolution - 토폴로지 정렬</li>
 * <li>Mixin Registration - Mixin 설정 등록</li>
 * <li>Initialization - {@code PulseMod.onInitialize()} 호출</li>
 * </ol>
 * 
 * @since 1.0
 */
package com.pulse.mod;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\PulseMod.java =====

package com.pulse.mod;

/**
 * 모드 엔트리포인트 인터페이스.
 * 모든 Pulse 모드는 이 인터페이스를 구현해야 함.
 * 
 * 예시:
 * public class MyMod implements PulseMod {
 *     @Override
 *     public void onInitialize() {
 *         System.out.println("My mod loaded!");
 *         // 이벤트 리스너 등록, 설정 로드 등
 *     }
 * }
 */
public interface PulseMod {
    
    /**
     * 모드 초기화 시 호출됨.
     * 이벤트 리스너 등록, 설정 로드 등을 수행.
     */
    void onInitialize();
    
    /**
     * 모드가 언로드될 때 호출됨 (선택적 구현).
     * 리소스 정리 등을 수행.
     */
    default void onUnload() {
        // 기본 구현: 아무것도 안 함
    }
    
    /**
     * 게임 월드가 로드된 후 호출됨 (선택적 구현).
     */
    default void onWorldLoad() {
        // 기본 구현: 아무것도 안 함
    }
    
    /**
     * 게임 월드가 언로드될 때 호출됨 (선택적 구현).
     */
    default void onWorldUnload() {
        // 기본 구현: 아무것도 안 함
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\mod\VersionComparator.java =====

package com.pulse.mod;

import com.pulse.api.log.PulseLogger;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Semantic Versioning (SemVer) 기반 버전 비교 유틸리티.
 * 
 * 지원하는 버전 형식:
 * - 1.0.0
 * - 1.0.0-alpha
 * - 1.0.0-beta.1
 * - 1.0.0+build.123
 * 
 * 지원하는 비교 연산자:
 * - = 또는 없음: 정확히 일치
 * - >: 초과
 * - >=: 이상
 * - <: 미만
 * - <=: 이하
 * - ~: 마이너 버전 호환 (예: ~1.2.3 → >=1.2.3 <1.3.0)
 * - ^: 메이저 버전 호환 (예: ^1.2.3 → >=1.2.3 <2.0.0)
 * - *: 모든 버전
 * 
 * 사용 예:
 * 
 * <pre>
 * Version v1 = Version.parse("1.2.3");
 * Version v2 = Version.parse("1.3.0");
 * 
 * v1.compareTo(v2); // -1 (v1 < v2)
 * 
 * VersionComparator.matches("1.2.3", ">=1.0.0"); // true
 * VersionComparator.matches("1.2.3", "~1.2.0"); // true
 * VersionComparator.matches("2.0.0", "^1.2.3"); // false
 * </pre>
 */
public class VersionComparator {

    private static final String LOG = PulseLogger.PULSE;

    // ─────────────────────────────────────────────────────────────
    // Version 클래스
    // ─────────────────────────────────────────────────────────────

    /**
     * SemVer 버전을 표현하는 불변 클래스.
     */
    public static class Version implements Comparable<Version> {

        // SemVer 정규식: major.minor.patch[-prerelease][+build]
        private static final Pattern SEMVER_PATTERN = Pattern.compile(
                "^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:-([a-zA-Z0-9.]+))?(?:\\+([a-zA-Z0-9.]+))?$");

        private final int major;
        private final int minor;
        private final int patch;
        private final String prerelease;
        private final String build;

        public Version(int major, int minor, int patch, String prerelease, String build) {
            this.major = major;
            this.minor = minor;
            this.patch = patch;
            this.prerelease = prerelease;
            this.build = build;
        }

        public Version(int major, int minor, int patch) {
            this(major, minor, patch, null, null);
        }

        /**
         * 버전 문자열 파싱.
         * 
         * @param version 버전 문자열 (예: "1.2.3-alpha")
         * @return 파싱된 Version 객체, 실패 시 null
         */
        public static Version parse(String version) {
            if (version == null || version.trim().isEmpty()) {
                return null;
            }

            version = version.trim();

            // v 접두사 제거 (v1.0.0 → 1.0.0)
            if (version.startsWith("v") || version.startsWith("V")) {
                version = version.substring(1);
            }

            Matcher matcher = SEMVER_PATTERN.matcher(version);
            if (!matcher.matches()) {
                PulseLogger.error(LOG, "[Version] Invalid version format: {}", version);
                return null;
            }

            int major = Integer.parseInt(matcher.group(1));
            int minor = matcher.group(2) != null ? Integer.parseInt(matcher.group(2)) : 0;
            int patch = matcher.group(3) != null ? Integer.parseInt(matcher.group(3)) : 0;
            String prerelease = matcher.group(4);
            String build = matcher.group(5);

            return new Version(major, minor, patch, prerelease, build);
        }

        public int getMajor() {
            return major;
        }

        public int getMinor() {
            return minor;
        }

        public int getPatch() {
            return patch;
        }

        public String getPrerelease() {
            return prerelease;
        }

        public String getBuild() {
            return build;
        }

        public boolean isPrerelease() {
            return prerelease != null && !prerelease.isEmpty();
        }

        @Override
        public int compareTo(Version other) {
            if (other == null)
                return 1;

            // 메이저 비교
            int result = Integer.compare(this.major, other.major);
            if (result != 0)
                return result;

            // 마이너 비교
            result = Integer.compare(this.minor, other.minor);
            if (result != 0)
                return result;

            // 패치 비교
            result = Integer.compare(this.patch, other.patch);
            if (result != 0)
                return result;

            // 프리릴리스 비교
            // 프리릴리스가 있으면 없는 것보다 낮음 (1.0.0-alpha < 1.0.0)
            if (this.prerelease == null && other.prerelease == null) {
                return 0;
            }
            if (this.prerelease == null) {
                return 1; // this가 릴리스, other가 프리릴리스
            }
            if (other.prerelease == null) {
                return -1; // this가 프리릴리스, other가 릴리스
            }

            // 둘 다 프리릴리스인 경우 문자열 비교
            return comparePrerelease(this.prerelease, other.prerelease);
        }

        private int comparePrerelease(String a, String b) {
            String[] partsA = a.split("\\.");
            String[] partsB = b.split("\\.");

            int length = Math.max(partsA.length, partsB.length);
            for (int i = 0; i < length; i++) {
                String partA = i < partsA.length ? partsA[i] : "";
                String partB = i < partsB.length ? partsB[i] : "";

                boolean aIsNumeric = partA.matches("\\d+");
                boolean bIsNumeric = partB.matches("\\d+");

                int result;
                if (aIsNumeric && bIsNumeric) {
                    result = Integer.compare(Integer.parseInt(partA), Integer.parseInt(partB));
                } else if (aIsNumeric) {
                    result = -1; // 숫자가 문자열보다 낮음
                } else if (bIsNumeric) {
                    result = 1;
                } else {
                    result = partA.compareTo(partB);
                }

                if (result != 0)
                    return result;
            }

            return 0;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null || getClass() != obj.getClass())
                return false;
            Version other = (Version) obj;
            return major == other.major &&
                    minor == other.minor &&
                    patch == other.patch &&
                    Objects.equals(prerelease, other.prerelease);
        }

        @Override
        public int hashCode() {
            return Objects.hash(major, minor, patch, prerelease);
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(major).append(".").append(minor).append(".").append(patch);
            if (prerelease != null) {
                sb.append("-").append(prerelease);
            }
            if (build != null) {
                sb.append("+").append(build);
            }
            return sb.toString();
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 버전 비교 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 버전이 요구사항을 만족하는지 확인.
     * 
     * @param version     확인할 버전 (예: "1.2.3")
     * @param requirement 요구사항 (예: ">=1.0.0", "~1.2.0", "^1.0.0")
     * @return 만족하면 true
     */
    public static boolean matches(String version, String requirement) {
        if (version == null || version.isEmpty()) {
            return false;
        }
        if (requirement == null || requirement.isEmpty() || "*".equals(requirement)) {
            return true; // 요구사항 없음 = 모든 버전 허용
        }

        Version ver = Version.parse(version);
        if (ver == null) {
            return false;
        }

        return matchesRequirement(ver, requirement.trim());
    }

    /**
     * 두 버전을 비교.
     * 
     * @return v1 < v2 → 음수, v1 == v2 → 0, v1 > v2 → 양수
     */
    public static int compare(String v1, String v2) {
        Version ver1 = Version.parse(v1);
        Version ver2 = Version.parse(v2);

        if (ver1 == null && ver2 == null)
            return 0;
        if (ver1 == null)
            return -1;
        if (ver2 == null)
            return 1;

        return ver1.compareTo(ver2);
    }

    private static boolean matchesRequirement(Version version, String requirement) {
        // 공백으로 분리된 여러 조건 처리 (예: ">=1.0.0 <2.0.0")
        if (requirement.contains(" ")) {
            String[] parts = requirement.split("\\s+");
            for (String part : parts) {
                if (!matchesSingleRequirement(version, part.trim())) {
                    return false;
                }
            }
            return true;
        }

        return matchesSingleRequirement(version, requirement);
    }

    private static boolean matchesSingleRequirement(Version version, String req) {
        if (req.isEmpty() || "*".equals(req)) {
            return true;
        }

        // 틸드 범위: ~1.2.3 → >=1.2.3 <1.3.0
        if (req.startsWith("~")) {
            Version reqVer = Version.parse(req.substring(1));
            if (reqVer == null)
                return false;

            // 하한: >=reqVer
            if (version.compareTo(reqVer) < 0)
                return false;

            // 상한: <next minor
            Version upperBound = new Version(reqVer.major, reqVer.minor + 1, 0);
            return version.compareTo(upperBound) < 0;
        }

        // 캐럿 범위: ^1.2.3 → >=1.2.3 <2.0.0
        if (req.startsWith("^")) {
            Version reqVer = Version.parse(req.substring(1));
            if (reqVer == null)
                return false;

            // 하한: >=reqVer
            if (version.compareTo(reqVer) < 0)
                return false;

            // 상한: <next major (단, 0.x는 0.(x+1).0)
            Version upperBound;
            if (reqVer.major == 0) {
                upperBound = new Version(0, reqVer.minor + 1, 0);
            } else {
                upperBound = new Version(reqVer.major + 1, 0, 0);
            }
            return version.compareTo(upperBound) < 0;
        }

        // 비교 연산자
        if (req.startsWith(">=")) {
            Version reqVer = Version.parse(req.substring(2));
            return reqVer != null && version.compareTo(reqVer) >= 0;
        }
        if (req.startsWith("<=")) {
            Version reqVer = Version.parse(req.substring(2));
            return reqVer != null && version.compareTo(reqVer) <= 0;
        }
        if (req.startsWith(">")) {
            Version reqVer = Version.parse(req.substring(1));
            return reqVer != null && version.compareTo(reqVer) > 0;
        }
        if (req.startsWith("<")) {
            Version reqVer = Version.parse(req.substring(1));
            return reqVer != null && version.compareTo(reqVer) < 0;
        }
        if (req.startsWith("=")) {
            Version reqVer = Version.parse(req.substring(1));
            return reqVer != null && version.compareTo(reqVer) == 0;
        }

        // 연산자 없음 = 정확히 일치
        Version reqVer = Version.parse(req);
        return reqVer != null && version.compareTo(reqVer) == 0;
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 버전 파싱 시도.
     */
    public static Version parse(String version) {
        return Version.parse(version);
    }

    /**
     * 유효한 버전 문자열인지 확인.
     */
    public static boolean isValid(String version) {
        return Version.parse(version) != null;
    }

    /**
     * 테스트용 메인 메서드.
     */
    public static void main(String[] args) {
        PulseLogger.info(LOG, "=== VersionComparator Tests ===");

        // 파싱 테스트
        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "[Parsing]");
        PulseLogger.info(LOG, "1.0.0 → {}", Version.parse("1.0.0"));
        PulseLogger.info(LOG, "1.2.3-alpha → {}", Version.parse("1.2.3-alpha"));
        PulseLogger.info(LOG, "v2.0.0-beta.1+build.123 → {}", Version.parse("v2.0.0-beta.1+build.123"));

        // 비교 테스트
        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "[Comparison]");
        PulseLogger.info(LOG, "1.0.0 vs 1.0.1: {}", compare("1.0.0", "1.0.1"));
        PulseLogger.info(LOG, "1.1.0 vs 1.0.9: {}", compare("1.1.0", "1.0.9"));
        PulseLogger.info(LOG, "2.0.0-alpha vs 2.0.0: {}", compare("2.0.0-alpha", "2.0.0"));

        // 매칭 테스트
        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "[Matching]");
        PulseLogger.info(LOG, "1.2.3 matches >=1.0.0: {}", matches("1.2.3", ">=1.0.0"));
        PulseLogger.info(LOG, "1.2.3 matches <2.0.0: {}", matches("1.2.3", "<2.0.0"));
        PulseLogger.info(LOG, "1.2.3 matches ~1.2.0: {}", matches("1.2.3", "~1.2.0"));
        PulseLogger.info(LOG, "1.3.0 matches ~1.2.0: {}", matches("1.3.0", "~1.2.0"));
        PulseLogger.info(LOG, "1.9.9 matches ^1.2.3: {}", matches("1.9.9", "^1.2.3"));
        PulseLogger.info(LOG, "2.0.0 matches ^1.2.3: {}", matches("2.0.0", "^1.2.3"));
        PulseLogger.info(LOG, "1.5.0 matches >=1.0.0 <2.0.0: {}", matches("1.5.0", ">=1.0.0 <2.0.0"));

        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "=== All Tests Completed ===");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\network\GameNetworkBridge.java =====

package com.pulse.network;

import com.pulse.api.log.PulseLogger;

import java.lang.reflect.Method;
import java.nio.ByteBuffer;

/**
 * 게임 네트워크 시스템 브릿지.
 * Project Zomboid의 네트워크 시스템에 연결하여 실제 패킷 전송을 수행.
 * 
 * Refactored: Uses NetworkAccess for reflection and NetworkPacketStats for
 * metrics.
 */
public class GameNetworkBridge {

    private static final String LOG = PulseLogger.PULSE;
    private static final GameNetworkBridge INSTANCE = new GameNetworkBridge();

    // Pulse 커스텀 패킷 채널 ID
    private static final short Pulse_PACKET_ID = (short) 0x4D55; // "MU" in hex

    private final NetworkAccess access = new NetworkAccess();
    private final NetworkPacketStats stats = new NetworkPacketStats();

    private boolean debugMode = false;

    private GameNetworkBridge() {
    }

    public static GameNetworkBridge getInstance() {
        return INSTANCE;
    }

    /**
     * 네트워크 브릿지 초기화.
     */
    public void initialize() {
        access.initialize();
    }

    /**
     * 서버로 패킷 전송 (클라이언트에서 호출)
     */
    public boolean sendToServer(byte[] data) {
        if (!access.isInitialized()) {
            initialize();
        }

        if (access.getGameClientClass() == null) {
            if (debugMode) {
                PulseLogger.warn(LOG, "Cannot send to server: GameClient not available");
            }
            return false;
        }

        try {
            Object writer = access.createByteBufferWriter();
            if (writer == null) {
                return sendRawPacket(data, null);
            }

            // Write packet
            access.writeShort(writer, Pulse_PACKET_ID);
            access.writeInt(writer, data.length);
            access.writeBytes(writer, data);

            // Send
            Method sendMethod = access.getClientSendMethod();
            if (sendMethod != null) {
                sendMethod.invoke(null, writer);
                if (debugMode) {
                    PulseLogger.debug(LOG, "Sent {} bytes to server", data.length);
                }
                stats.recordSent(data.length);
                return true;
            }

            return sendRawPacket(data, null);

        } catch (Exception e) {
            PulseLogger.error(LOG, "Error sending to server: {}", e.getMessage());
            if (debugMode) {
                e.printStackTrace();
            }
            return false;
        }
    }

    /**
     * 특정 클라이언트로 패킷 전송 (서버에서 호출)
     */
    public boolean sendToClient(Object connection, byte[] data) {
        if (!access.isInitialized()) {
            initialize();
        }

        if (access.getGameServerClass() == null) {
            if (debugMode) {
                PulseLogger.warn(LOG, "Cannot send to client: GameServer not available");
            }
            return false;
        }

        try {
            Object writer = access.createByteBufferWriter();
            if (writer == null) {
                return sendRawPacket(data, connection);
            }

            // Write packet
            access.writeShort(writer, Pulse_PACKET_ID);
            access.writeInt(writer, data.length);
            access.writeBytes(writer, data);

            // Send via UdpConnection
            if (connection != null && access.isUdpConnection(connection)) {
                Method sendMethod = access.getUdpSendMethod();
                if (sendMethod != null) {
                    sendMethod.invoke(connection, writer);
                    if (debugMode) {
                        PulseLogger.debug(LOG, "Sent {} bytes to client", data.length);
                    }
                    stats.recordSent(data.length);
                    return true;
                }
            }

            return sendRawPacket(data, connection);

        } catch (Exception e) {
            PulseLogger.error(LOG, "Error sending to client: {}", e.getMessage());
            if (debugMode) {
                e.printStackTrace();
            }
            return false;
        }
    }

    /**
     * 모든 클라이언트로 패킷 전송 (서버에서 호출)
     */
    public boolean sendToAll(byte[] data) {
        if (!access.isInitialized()) {
            initialize();
        }

        if (access.getGameServerClass() == null) {
            if (debugMode) {
                PulseLogger.warn(LOG, "Cannot send to all: GameServer not available");
            }
            return false;
        }

        try {
            Object connections = access.getUdpEngine();

            if (connections == null) {
                if (debugMode) {
                    PulseLogger.debug(LOG, "No connections found, cannot broadcast");
                }
                return false;
            }

            // connections가 iterable인 경우 순회
            if (connections instanceof Iterable<?>) {
                int sent = 0;
                for (Object connection : (Iterable<?>) connections) {
                    if (sendToClient(connection, data)) {
                        sent++;
                    }
                }
                if (debugMode) {
                    PulseLogger.debug(LOG, "Broadcast to {} clients", sent);
                }
                return sent > 0;
            }

            return false;

        } catch (Exception e) {
            PulseLogger.error(LOG, "Error broadcasting: {}", e.getMessage());
            if (debugMode) {
                e.printStackTrace();
            }
            return false;
        }
    }

    /**
     * 수신된 패킷 처리.
     */
    public void handleReceived(ByteBuffer buffer, Object sender) {
        try {
            // Pulse 패킷 ID 확인
            short packetId = buffer.getShort();
            if (packetId != Pulse_PACKET_ID) {
                // Pulse 패킷이 아님 - 무시
                return;
            }

            // 데이터 길이 읽기
            int length = buffer.getInt();

            // 데이터 읽기
            byte[] data = new byte[length];
            buffer.get(data);

            // NetworkManager에 전달
            NetworkManager.getInstance().handleReceived(data, sender);

            if (debugMode) {
                PulseLogger.debug(LOG, "Received {} bytes", length);
            }
            stats.recordReceived(length);

        } catch (Exception e) {
            PulseLogger.error(LOG, "Error handling received packet: {}", e.getMessage());
            if (debugMode) {
                e.printStackTrace();
            }
        }
    }

    private boolean sendRawPacket(byte[] data, Object target) {
        if (debugMode) {
            PulseLogger.debug(LOG, "Raw packet send not implemented ({} bytes)", data.length);
        }
        return false;
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    public boolean isClient() {
        return access.getGameClientClass() != null && com.pulse.api.access.NetworkAccess.isSinglePlayer() == false;
    }

    public boolean isServer() {
        return access.getGameServerClass() != null && !com.pulse.api.access.NetworkAccess.isSinglePlayer();
    }

    public boolean isInitialized() {
        return access.isInitialized();
    }

    public void setDebugMode(boolean debug) {
        this.debugMode = debug;
    }

    public static short getPulsePacketId() {
        return Pulse_PACKET_ID;
    }

    public NetworkPacketStats getStats() {
        return stats;
    }

    // Legacy delegates for stats (optional, but good for backward compat if needed)
    public int getSentPacketCount() {
        return stats.getSentPacketCount();
    }

    public int getReceivedPacketCount() {
        return stats.getReceivedPacketCount();
    }

    public long getTotalBytesSent() {
        return stats.getTotalBytesSent();
    }

    public long getTotalBytesReceived() {
        return stats.getTotalBytesReceived();
    }

    public void resetStatistics() {
        stats.reset();
    }

    public String getStatisticsReport() {
        return stats.getReport();
    }

    public void reconnect() {
        // Not easily supported with final fields, but we can re-initialize access?
        // Actually access can just try reloading.
        // For now, simple re-init.
        access.initialize();
        PulseLogger.info(LOG, "Network Access re-initialized");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\network\HandshakeHandler.java =====

package com.pulse.network;

import com.pulse.api.log.PulseLogger;
import com.pulse.mod.ModLoader;
import com.pulse.mod.ModContainer;

import java.util.*;

/**
 * 핸드셰이크 핸들러.
 * 서버-클라이언트 모드 호환성 검증.
 */
public class HandshakeHandler {

    private static final String LOG = PulseLogger.PULSE;
    private static final HandshakeHandler INSTANCE = new HandshakeHandler();

    // 필수 모드 목록 (이 모드들은 클라이언트와 서버 모두에 있어야 함)
    private final Set<String> requiredMods = new HashSet<>();

    // 검증 모드
    private ValidationMode validationMode = ValidationMode.STRICT;

    private HandshakeHandler() {
    }

    public static HandshakeHandler getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 검증
    // ─────────────────────────────────────────────────────────────

    /**
     * 클라이언트 모드 목록 검증 (서버 측).
     * 
     * @param clientMods 클라이언트의 modId -> version 맵
     * @return 검증 결과
     */
    public static HandshakeResult validate(Map<String, String> clientMods) {
        return INSTANCE.validateInternal(clientMods);
    }

    private HandshakeResult validateInternal(Map<String, String> clientMods) {
        List<String> missingOnClient = new ArrayList<>();
        List<String> missingOnServer = new ArrayList<>();
        List<String> versionMismatch = new ArrayList<>();

        ModLoader loader = ModLoader.getInstance();
        Map<String, String> serverMods = new HashMap<>();

        for (String modId : loader.getLoadedModIds()) {
            ModContainer container = loader.getMod(modId);
            if (container != null) {
                serverMods.put(modId, container.getMetadata().getVersion());
            }
        }

        // 1. 서버 모드가 클라이언트에 있는지 확인
        for (var entry : serverMods.entrySet()) {
            String modId = entry.getKey();
            String serverVersion = entry.getValue();

            if (!clientMods.containsKey(modId)) {
                if (isRequired(modId)) {
                    missingOnClient.add(modId);
                }
            } else {
                String clientVersion = clientMods.get(modId);
                if (!serverVersion.equals(clientVersion)) {
                    versionMismatch.add(modId + " (server: " + serverVersion +
                            ", client: " + clientVersion + ")");
                }
            }
        }

        // 2. 클라이언트 모드가 서버에 있는지 확인
        for (String modId : clientMods.keySet()) {
            if (!serverMods.containsKey(modId) && isRequired(modId)) {
                missingOnServer.add(modId);
            }
        }

        // 결과 생성
        if (missingOnClient.isEmpty() && missingOnServer.isEmpty() &&
                (versionMismatch.isEmpty() || validationMode == ValidationMode.LENIENT)) {
            return HandshakeResult.success();
        }

        StringBuilder reason = new StringBuilder();
        if (!missingOnClient.isEmpty()) {
            reason.append("Missing on client: ").append(missingOnClient).append(". ");
        }
        if (!missingOnServer.isEmpty()) {
            reason.append("Missing on server: ").append(missingOnServer).append(". ");
        }
        if (!versionMismatch.isEmpty() && validationMode == ValidationMode.STRICT) {
            reason.append("Version mismatch: ").append(versionMismatch);
        }

        return HandshakeResult.failure(reason.toString().trim());
    }

    private boolean isRequired(String modId) {
        // pulse_ 로 시작하는 것은 필수 (핵심 모드)
        if (modId.startsWith("pulse_") || modId.equals("pulse")) {
            return true;
        }
        return requiredMods.contains(modId);
    }

    // ─────────────────────────────────────────────────────────────
    // 설정
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드를 필수로 지정.
     */
    public static void markRequired(String modId) {
        INSTANCE.requiredMods.add(modId);
    }

    /**
     * 검증 모드 설정.
     */
    public static void setValidationMode(ValidationMode mode) {
        INSTANCE.validationMode = mode;
    }

    // ─────────────────────────────────────────────────────────────
    // 패킷 핸들러 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 핸드셰이크 시스템 초기화.
     */
    public static void initialize() {
        // 패킷 등록
        NetworkManager.registerPacket(
                HandshakePacket.class,
                HandshakePacket::new,
                NetworkSide.BOTH);

        // 핸들러 등록
        NetworkManager.registerHandler(HandshakePacket.class, INSTANCE::handlePacket);

        PulseLogger.info(LOG, "Handshake system initialized");
    }

    private void handlePacket(HandshakePacket packet, Object sender) {
        switch (packet.getPhase()) {
            case REQUEST:
                // 클라이언트 요청 처리 (서버 측)
                handleClientRequest(packet, sender);
                break;
            case RESPONSE:
                // 서버 응답 처리 (클라이언트 측)
                handleServerResponse(packet);
                break;
            case ACCEPT:
                PulseLogger.info(LOG, "Handshake accepted");
                break;
            case REJECT:
                PulseLogger.error(LOG, "Handshake rejected");
                break;
        }
    }

    private void handleClientRequest(HandshakePacket clientPacket, Object connection) {
        HandshakeResult result = validate(clientPacket.getModVersions());

        // SilentMode 콜백 - 클라이언트에 Pulse가 있는지 확인
        boolean clientHasPulse = clientPacket.getModVersions().containsKey("pulse");
        com.pulse.api.SilentMode.onHandshakeReceived(clientHasPulse);

        if (result.isSuccess()) {
            PulseLogger.info(LOG, "Client validated successfully");
            HandshakePacket response = HandshakePacket.create(HandshakePacket.HandshakePhase.ACCEPT);
            NetworkManager.sendToClient(connection, response);
        } else {
            PulseLogger.error(LOG, "Client validation failed: {}", result.getReason());
            HandshakePacket response = HandshakePacket.create(HandshakePacket.HandshakePhase.REJECT);
            NetworkManager.sendToClient(connection, response);

            // 연결 종료
            disconnectClient(connection, result.getReason());
        }
    }

    private void handleServerResponse(HandshakePacket serverPacket) {
        // SilentMode 콜백 - 서버에 Pulse가 있는지 확인
        boolean serverHasPulse = serverPacket.getModVersions().containsKey("pulse");
        com.pulse.api.SilentMode.onHandshakeReceived(serverHasPulse);

        // 클라이언트 측에서 서버 모드 확인
        HandshakeResult result = validate(serverPacket.getModVersions());

        if (!result.isSuccess()) {
            PulseLogger.error(LOG, "Server mod mismatch: {}", result.getReason());

            // 경고 표시 및 연결 종료
            showModMismatchWarning(result.getReason());
            disconnectFromServer(result.getReason());
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 연결 관리
    // ─────────────────────────────────────────────────────────────

    /**
     * 클라이언트 연결 종료 (서버 측).
     */
    private void disconnectClient(Object connection, String reason) {
        try {
            // GameServer.kick 또는 유사한 메서드 호출
            Class<?> gameServerClass = Class.forName("zombie.network.GameServer");

            // connection에서 플레이어/연결 정보 추출 시도
            if (connection != null) {
                java.lang.reflect.Method disconnectMethod = gameServerClass.getMethod("disconnect", Object.class,
                        String.class);
                disconnectMethod.invoke(null, connection, "Mod mismatch: " + reason);
                PulseLogger.info(LOG, "Client disconnected: {}", reason);
            }
        } catch (ClassNotFoundException e) {
            // GameServer 클래스 없음 - 싱글플레이어이거나 다른 환경
            PulseLogger.debug(LOG, "Cannot disconnect client (not a server environment)");
        } catch (Exception e) {
            PulseLogger.error(LOG, "Failed to disconnect client: {}", e.getMessage());
        }
    }

    /**
     * 서버 연결 종료 (클라이언트 측).
     */
    private void disconnectFromServer(String reason) {
        try {
            Class<?> gameClientClass = Class.forName("zombie.network.GameClient");
            java.lang.reflect.Method disconnectMethod = gameClientClass.getMethod("disconnect");
            disconnectMethod.invoke(null);
            PulseLogger.info(LOG, "Disconnected from server: {}", reason);
        } catch (ClassNotFoundException e) {
            PulseLogger.debug(LOG, "Cannot disconnect (not a client environment)");
        } catch (Exception e) {
            PulseLogger.error(LOG, "Failed to disconnect from server: {}", e.getMessage());
        }
    }

    /**
     * 모드 불일치 경고 표시.
     */
    private void showModMismatchWarning(String reason) {
        // 콘솔에 경고 출력
        PulseLogger.error(LOG, "══════════════════════════════════════════════════════════");
        PulseLogger.error(LOG, "  [Pulse] MOD MISMATCH WARNING");
        PulseLogger.error(LOG, "══════════════════════════════════════════════════════════");
        PulseLogger.error(LOG, "  {}", reason);
        PulseLogger.error(LOG, "══════════════════════════════════════════════════════════");

        // UI 모달 표시 시도 (게임 UI 사용 가능한 경우)
        try {
            Class<?> luaManagerClass = Class.forName("zombie.Lua.LuaManager");
            java.lang.reflect.Method runLuaMethod = luaManagerClass.getMethod("RunLua", String.class);
            String luaCode = String.format(
                    "getCore():doPopup('[Pulse] Mod Mismatch', '%s')",
                    reason.replace("'", "\\'"));
            runLuaMethod.invoke(null, luaCode);
        } catch (Exception e) {
            // UI 팝업 실패 - 콘솔 경고만 표시됨
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 결과 클래스
    // ─────────────────────────────────────────────────────────────

    public static class HandshakeResult {
        private final boolean success;
        private final String reason;

        private HandshakeResult(boolean success, String reason) {
            this.success = success;
            this.reason = reason;
        }

        public static HandshakeResult success() {
            return new HandshakeResult(true, null);
        }

        public static HandshakeResult failure(String reason) {
            return new HandshakeResult(false, reason);
        }

        public boolean isSuccess() {
            return success;
        }

        public String getReason() {
            return reason;
        }
    }

    public enum ValidationMode {
        STRICT, // 버전까지 일치 필요
        LENIENT // 모드 존재만 확인
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\network\HandshakePacket.java =====

package com.pulse.network;

import com.pulse.api.Pulse;
import com.pulse.mod.ModLoader;
import com.pulse.registry.Identifier;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * 서버-클라이언트 핸드셰이크 패킷.
 * 연결 시 모드 목록과 버전을 교환하여 호환성 검증.
 */
public class HandshakePacket implements Packet {

    private static final Identifier ID = Identifier.of("pulse", "handshake");

    private String loaderVersion;
    private Map<String, String> modVersions; // modId -> version
    private HandshakePhase phase;

    public HandshakePacket() {
        this.modVersions = new LinkedHashMap<>();
        this.phase = HandshakePhase.REQUEST;
    }

    public HandshakePacket(HandshakePhase phase) {
        this();
        this.phase = phase;
    }

    /**
     * 현재 로드된 모드 정보로 패킷 생성.
     */
    public static HandshakePacket create(HandshakePhase phase) {
        HandshakePacket packet = new HandshakePacket(phase);
        packet.loaderVersion = Pulse.VERSION;

        // 로드된 모드 정보 수집
        ModLoader loader = ModLoader.getInstance();
        for (String modId : loader.getLoadedModIds()) {
            var container = loader.getMod(modId);
            if (container != null) {
                packet.modVersions.put(modId, container.getMetadata().getVersion());
            }
        }

        return packet;
    }

    @Override
    public Identifier getId() {
        return ID;
    }

    @Override
    public void write(PacketBuffer buf) {
        buf.writeByte(phase.ordinal());
        buf.writeString(loaderVersion);
        buf.writeInt(modVersions.size());
        for (var entry : modVersions.entrySet()) {
            buf.writeString(entry.getKey());
            buf.writeString(entry.getValue());
        }
    }

    @Override
    public void read(PacketBuffer buf) {
        phase = HandshakePhase.values()[buf.readByte()];
        loaderVersion = buf.readString();
        int count = buf.readInt();
        modVersions = new LinkedHashMap<>();
        for (int i = 0; i < count; i++) {
            String modId = buf.readString();
            String version = buf.readString();
            modVersions.put(modId, version);
        }
    }

    public String getLoaderVersion() {
        return loaderVersion;
    }

    public Map<String, String> getModVersions() {
        return modVersions;
    }

    public HandshakePhase getPhase() {
        return phase;
    }

    public enum HandshakePhase {
        REQUEST, // 클라이언트 → 서버 (모드 목록 요청 또는 전송)
        RESPONSE, // 서버 → 클라이언트 (서버 모드 목록)
        ACCEPT, // 핸드셰이크 성공
        REJECT // 핸드셰이크 실패
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\network\NetworkAccess.java =====

package com.pulse.network;

import com.pulse.PulseEnvironment;
import com.pulse.access.AccessWidener;
import com.pulse.api.log.PulseLogger;

import java.lang.reflect.Method;

/**
 * Project Zomboid 네트워크 클래스 접근 헬퍼
 */
public class NetworkAccess {

    private static final String LOG = PulseLogger.PULSE;

    // 게임 네트워크 클래스 캐시
    private Class<?> gameClientClass;
    private Class<?> gameServerClass;
    private Class<?> byteBufferWriterClass;
    private Class<?> udpConnectionClass;

    // Method Cache
    private Method clientSendMethod;
    private Method udpSendMethod;

    private boolean initialized = false;

    public void initialize() {
        if (initialized)
            return;

        try {
            ClassLoader loader = PulseEnvironment.getGameClassLoader();
            if (loader == null) {
                loader = ClassLoader.getSystemClassLoader();
            }

            // 게임 클래스 로드
            gameClientClass = loadClass(loader, "zombie.network.GameClient",
                    "GameClient class not found (may be server-only)");
            gameServerClass = loadClass(loader, "zombie.network.GameServer",
                    "GameServer class not found (may be client-only)");
            byteBufferWriterClass = loadClass(loader, "zombie.core.network.ByteBufferWriter",
                    "ByteBufferWriter class not found");
            udpConnectionClass = loadClass(loader, "zombie.network.UdpConnection", "UdpConnection class not found");

            initialized = true;

            // Cache methods
            if (gameClientClass != null) {
                clientSendMethod = findSendMethod(gameClientClass);
            }
            if (udpConnectionClass != null) {
                udpSendMethod = findUdpSendMethod();
            }

            PulseLogger.info(LOG, "Network access initialized");

        } catch (Exception e) {
            PulseLogger.error(LOG, "Failed to initialize network access: {}", e.getMessage());
            e.printStackTrace();
        }
    }

    private Class<?> loadClass(ClassLoader loader, String name, String errorMessage) {
        try {
            Class<?> clazz = loader.loadClass(name);
            PulseLogger.debug(LOG, "Loaded: " + name);
            return clazz;
        } catch (ClassNotFoundException e) {
            PulseLogger.debug(LOG, errorMessage);
            return null;
        }
    }

    public boolean isInitialized() {
        return initialized;
    }

    public Class<?> getGameClientClass() {
        return gameClientClass;
    }

    public Class<?> getGameServerClass() {
        return gameServerClass;
    }

    public Object createByteBufferWriter() {
        if (byteBufferWriterClass == null) {
            return null;
        }
        return AccessWidener.newInstance(byteBufferWriterClass);
    }

    public void writeShort(Object writer, short value) {
        AccessWidener.invoke(writer, "putShort", value);
    }

    public void writeInt(Object writer, int value) {
        AccessWidener.invoke(writer, "putInt", value);
    }

    public void writeBytes(Object writer, byte[] data) {
        AccessWidener.invoke(writer, "putBytes", data);
    }

    public Method getClientSendMethod() {
        return clientSendMethod;
    }

    public Method getUdpSendMethod() {
        return udpSendMethod;
    }

    private Method findSendMethod(Class<?> clazz) {
        try {
            for (Method method : clazz.getDeclaredMethods()) {
                String name = method.getName().toLowerCase();
                if ((name.contains("send") || name.contains("write")) &&
                        method.getParameterCount() == 1 &&
                        byteBufferWriterClass != null &&
                        byteBufferWriterClass.isAssignableFrom(method.getParameterTypes()[0])) {
                    method.setAccessible(true);
                    return method;
                }
            }
        } catch (Exception e) {
            // Ignore
        }
        return null;
    }

    private Method findUdpSendMethod() {
        if (udpConnectionClass == null)
            return null;
        try {
            for (Method method : udpConnectionClass.getDeclaredMethods()) {
                String name = method.getName().toLowerCase();
                if (name.contains("send") && method.getParameterCount() == 1) {
                    method.setAccessible(true);
                    return method;
                }
            }
        } catch (Exception e) {
            // Ignore
        }
        return null;
    }

    public boolean isUdpConnection(Object obj) {
        return udpConnectionClass != null && udpConnectionClass.isInstance(obj);
    }

    public Object getUdpEngine() {
        if (gameServerClass == null)
            return null;
        Object connections = AccessWidener.getStaticField(gameServerClass, "udpEngine");
        if (connections == null) {
            connections = AccessWidener.getStaticField(gameServerClass, "connections");
        }
        return connections;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\network\NetworkManager.java =====

package com.pulse.network;

import com.pulse.api.log.PulseLogger;
import com.pulse.registry.Identifier;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 네트워크 매니저.
 * 패킷 등록, 전송, 수신을 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 패킷 등록
 * NetworkManager.registerPacket(MyPacket.class, MyPacket::new, NetworkSide.SERVER);
 * 
 * // 패킷 핸들러 등록
 * NetworkManager.registerHandler(MyPacket.class, (packet, sender) -> {
 *     PulseLogger.info("Pulse", "Received: {}", packet.getMessage());
 * });
 * 
 * // 패킷 송신
 * NetworkManager.sendToServer(new MyPacket("Hello!"));
 * </pre>
 */
public class NetworkManager {

    private static final String LOG = PulseLogger.PULSE;
    private static final NetworkManager INSTANCE = new NetworkManager();

    // 등록된 패킷 타입
    private final Map<Identifier, PacketRegistration<?>> packetsByType = new ConcurrentHashMap<>();
    private final Map<Class<?>, PacketRegistration<?>> packetsByClass = new ConcurrentHashMap<>();

    private NetworkManager() {
    }

    public static NetworkManager getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 패킷 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 패킷 타입 등록
     */
    public static <T extends Packet> void registerPacket(
            Class<T> packetClass,
            Supplier<T> factory,
            NetworkSide side) {
        INSTANCE.register(packetClass, factory, side);
    }

    /**
     * 패킷 핸들러 등록
     */
    public static <T extends Packet> void registerHandler(
            Class<T> packetClass,
            PacketHandler<T> handler) {
        INSTANCE.addHandler(packetClass, handler);
    }

    private <T extends Packet> void register(
            Class<T> packetClass,
            Supplier<T> factory,
            NetworkSide side) {

        // 임시 인스턴스로 ID 확인
        T temp = factory.get();
        Identifier id = temp.getId();

        PacketRegistration<T> registration = new PacketRegistration<>(
                id, packetClass, factory, side);

        packetsByType.put(id, registration);
        packetsByClass.put(packetClass, registration);

        PulseLogger.debug(LOG, "Registered packet: {} ({})", id, side);
    }

    @SuppressWarnings("unchecked")
    private <T extends Packet> void addHandler(Class<T> packetClass, PacketHandler<T> handler) {
        PacketRegistration<T> reg = (PacketRegistration<T>) packetsByClass.get(packetClass);
        if (reg != null) {
            reg.addHandler(handler);
        } else {
            PulseLogger.error(LOG, "Cannot add handler: packet not registered");
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 패킷 송신 (GameNetworkBridge를 통해 게임 네트워크에 연결)
    // ─────────────────────────────────────────────────────────────

    /**
     * 서버로 패킷 전송 (클라이언트에서 호출)
     */
    public static void sendToServer(Packet packet) {
        byte[] data = INSTANCE.serialize(packet);
        boolean sent = GameNetworkBridge.getInstance().sendToServer(data);

        if (!sent) {
            PulseLogger.debug(LOG, "Queued for server: {} ({} bytes)", packet.getId(), data.length);
        }
    }

    /**
     * 클라이언트로 패킷 전송 (서버에서 호출)
     * 
     * @param connection 클라이언트 연결 객체 (UdpConnection)
     * @param packet     전송할 패킷
     */
    public static void sendToClient(Object connection, Packet packet) {
        byte[] data = INSTANCE.serialize(packet);
        boolean sent = GameNetworkBridge.getInstance().sendToClient(connection, data);

        if (!sent) {
            PulseLogger.debug(LOG, "Queued for client: {} ({} bytes)", packet.getId(), data.length);
        }
    }

    /**
     * 모든 클라이언트로 패킷 전송
     */
    public static void sendToAll(Packet packet) {
        byte[] data = INSTANCE.serialize(packet);
        boolean sent = GameNetworkBridge.getInstance().sendToAll(data);

        if (!sent) {
            PulseLogger.debug(LOG, "Queued for broadcast: {} ({} bytes)", packet.getId(), data.length);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 직렬화/역직렬화
    // ─────────────────────────────────────────────────────────────

    /**
     * 패킷 직렬화
     */
    public byte[] serialize(Packet packet) {
        PacketBuffer buf = new PacketBuffer();

        // 패킷 ID 쓰기
        buf.writeString(packet.getId().toString());

        // 패킷 데이터 쓰기
        packet.write(buf);

        return buf.toByteArray();
    }

    /**
     * 패킷 역직렬화
     */
    @SuppressWarnings("unchecked")
    public <T extends Packet> T deserialize(byte[] data) {
        PacketBuffer buf = new PacketBuffer(data);

        // 패킷 ID 읽기
        String idStr = buf.readString();
        Identifier id = Identifier.parse(idStr);

        // 패킷 타입 찾기
        PacketRegistration<T> reg = (PacketRegistration<T>) packetsByType.get(id);
        if (reg == null) {
            PulseLogger.warn(LOG, "Unknown packet: {}", id);
            return null;
        }

        // 패킷 인스턴스 생성 및 데이터 읽기
        T packet = reg.create();
        packet.read(buf);

        return packet;
    }

    /**
     * 수신된 패킷 처리
     */
    @SuppressWarnings("unchecked")
    public void handleReceived(byte[] data, Object sender) {
        PacketBuffer buf = new PacketBuffer(data);

        String idStr = buf.readString();
        Identifier id = Identifier.parse(idStr);

        PacketRegistration<?> reg = packetsByType.get(id);
        if (reg == null) {
            PulseLogger.warn(LOG, "Unknown packet: {}", id);
            return;
        }

        Packet packet = reg.create();
        packet.read(buf);

        // 핸들러 호출
        ((PacketRegistration<Packet>) reg).handlePacket(packet, sender);
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    @FunctionalInterface
    public interface PacketHandler<T extends Packet> {
        void handle(T packet, Object sender);
    }

    @SuppressWarnings("unused") // Public API for future game integration
    private static class PacketRegistration<T extends Packet> {
        final Identifier id;
        final Class<T> packetClass;
        final Supplier<T> factory;
        final NetworkSide side;
        final List<PacketHandler<T>> handlers = new ArrayList<>();

        PacketRegistration(Identifier id, Class<T> packetClass,
                Supplier<T> factory, NetworkSide side) {
            this.id = id;
            this.packetClass = packetClass;
            this.factory = factory;
            this.side = side;
        }

        T create() {
            return factory.get();
        }

        Class<T> getPacketClass() {
            return packetClass;
        }

        NetworkSide getSide() {
            return side;
        }

        void addHandler(PacketHandler<T> handler) {
            handlers.add(handler);
        }

        void handlePacket(T packet, Object sender) {
            for (PacketHandler<T> handler : handlers) {
                try {
                    handler.handle(packet, sender);
                } catch (Exception e) {
                    PulseLogger.error(LOG, "Handler error for {}: {}", id, e.getMessage());
                    e.printStackTrace();
                }
            }
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\network\NetworkPacketStats.java =====

package com.pulse.network;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 네트워크 패킷 통계
 */
public class NetworkPacketStats {

    private final AtomicInteger sentPacketCount = new AtomicInteger(0);
    private final AtomicInteger receivedPacketCount = new AtomicInteger(0);
    private final AtomicLong totalBytesSent = new AtomicLong(0);
    private final AtomicLong totalBytesReceived = new AtomicLong(0);

    public int getSentPacketCount() {
        return sentPacketCount.get();
    }

    public int getReceivedPacketCount() {
        return receivedPacketCount.get();
    }

    public long getTotalBytesSent() {
        return totalBytesSent.get();
    }

    public long getTotalBytesReceived() {
        return totalBytesReceived.get();
    }

    public void recordSent(int bytes) {
        sentPacketCount.incrementAndGet();
        totalBytesSent.addAndGet(bytes);
    }

    public void recordReceived(int bytes) {
        receivedPacketCount.incrementAndGet();
        totalBytesReceived.addAndGet(bytes);
    }

    public void reset() {
        sentPacketCount.set(0);
        receivedPacketCount.set(0);
        totalBytesSent.set(0);
        totalBytesReceived.set(0);
    }

    public String getReport() {
        return String.format(
                "[Pulse/Network] Stats: sent=%d packets (%d bytes), received=%d packets (%d bytes)",
                getSentPacketCount(), getTotalBytesSent(),
                getReceivedPacketCount(), getTotalBytesReceived());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\network\NetworkSide.java =====

package com.pulse.network;

/**
 * 네트워크 사이드.
 * 패킷이 어느 방향으로 전송되는지 정의.
 */
public enum NetworkSide {
    /**
     * 클라이언트 → 서버
     */
    SERVER,

    /**
     * 서버 → 클라이언트
     */
    CLIENT,

    /**
     * 양방향
     */
    BOTH
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\network\Packet.java =====

package com.pulse.network;

import com.pulse.registry.Identifier;

/**
 * 패킷 인터페이스.
 * 모든 네트워크 패킷은 이 인터페이스를 구현해야 함.
 * 
 * 사용 예:
 * 
 * <pre>
 * public class MyPacket implements Packet {
 *     private String message;
 *     
 *     public MyPacket() {} // 역직렬화용
 *     
 *     public MyPacket(String message) {
 *         this.message = message;
 *     }
 *     
 *     {@literal @}Override
 *     public void write(PacketBuffer buf) {
 *         buf.writeString(message);
 *     }
 *     
 *     {@literal @}Override
 *     public void read(PacketBuffer buf) {
 *         message = buf.readString();
 *     }
 *     
 *     {@literal @}Override
 *     public Identifier getId() {
 *         return Identifier.of("mymod", "my_packet");
 *     }
 * }
 * </pre>
 */
public interface Packet {

    /**
     * 패킷 ID
     */
    Identifier getId();

    /**
     * 패킷 데이터를 버퍼에 쓰기
     */
    void write(PacketBuffer buf);

    /**
     * 버퍼에서 패킷 데이터 읽기
     */
    void read(PacketBuffer buf);
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\network\PacketBuffer.java =====

package com.pulse.network;

import java.io.*;
import java.nio.charset.StandardCharsets;

/**
 * 패킷 버퍼.
 * 패킷 데이터의 직렬화/역직렬화를 담당.
 */
public class PacketBuffer {

    private final ByteArrayOutputStream outputStream;
    private final DataOutputStream out;
    private final DataInputStream in;
    private byte[] data;

    /**
     * 쓰기용 버퍼 생성
     */
    public PacketBuffer() {
        this.outputStream = new ByteArrayOutputStream();
        this.out = new DataOutputStream(outputStream);
        this.in = null;
        this.data = null;
    }

    /**
     * 읽기용 버퍼 생성
     */
    public PacketBuffer(byte[] data) {
        this.data = data;
        this.outputStream = null;
        this.out = null;
        this.in = new DataInputStream(new ByteArrayInputStream(data));
    }

    // ─────────────────────────────────────────────────────────────
    // 쓰기 메서드
    // ─────────────────────────────────────────────────────────────

    public void writeByte(int value) {
        try {
            out.writeByte(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeShort(int value) {
        try {
            out.writeShort(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeInt(int value) {
        try {
            out.writeInt(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeLong(long value) {
        try {
            out.writeLong(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeFloat(float value) {
        try {
            out.writeFloat(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeDouble(double value) {
        try {
            out.writeDouble(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeBoolean(boolean value) {
        try {
            out.writeBoolean(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeString(String value) {
        try {
            byte[] bytes = value.getBytes(StandardCharsets.UTF_8);
            out.writeInt(bytes.length);
            out.write(bytes);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeBytes(byte[] bytes) {
        try {
            out.writeInt(bytes.length);
            out.write(bytes);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 읽기 메서드
    // ─────────────────────────────────────────────────────────────

    public byte readByte() {
        try {
            return in.readByte();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public short readShort() {
        try {
            return in.readShort();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public int readInt() {
        try {
            return in.readInt();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public long readLong() {
        try {
            return in.readLong();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public float readFloat() {
        try {
            return in.readFloat();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public double readDouble() {
        try {
            return in.readDouble();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public boolean readBoolean() {
        try {
            return in.readBoolean();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public String readString() {
        try {
            int length = in.readInt();
            byte[] bytes = new byte[length];
            in.readFully(bytes);
            return new String(bytes, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public byte[] readBytes() {
        try {
            int length = in.readInt();
            byte[] bytes = new byte[length];
            in.readFully(bytes);
            return bytes;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 버퍼 데이터를 바이트 배열로 변환
     */
    public byte[] toByteArray() {
        if (outputStream != null) {
            return outputStream.toByteArray();
        }
        return data;
    }

    /**
     * 남은 바이트 수
     */
    public int remaining() {
        if (in != null) {
            try {
                return in.available();
            } catch (IOException e) {
                return 0;
            }
        }
        return 0;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\network\Synced.java =====

package com.pulse.network;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 자동 동기화 필드 마커.
 * 이 어노테이션이 붙은 필드는 자동으로 서버-클라이언트 간 동기화됨.
 * 
 * 사용 예:
 * 
 * <pre>
 * public class MyEntity {
 *     &#64;Synced
 *     private int health;
 * 
 *     @Synced(direction = SyncDirection.SERVER_TO_CLIENT)
 *     private String name;
 * }
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Synced {

    /**
     * 동기화 방향.
     */
    SyncDirection direction() default SyncDirection.BIDIRECTIONAL;

    /**
     * 동기화 우선순위 (낮을수록 먼저).
     */
    int priority() default 100;

    /**
     * 변경 시에만 동기화할지 여부.
     */
    boolean onlyOnChange() default true;

    public enum SyncDirection {
        SERVER_TO_CLIENT, // 서버 → 클라이언트
        CLIENT_TO_SERVER, // 클라이언트 → 서버
        BIDIRECTIONAL // 양방향
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\package-info.java =====

/**
 * Pulse Mod Loader for Project Zomboid.
 * 
 * <p>
 * Pulse는 Project Zomboid를 위한 고성능 모드 로더입니다.
 * </p>
 * 
 * <h2>Core Packages</h2>
 * <table>
 * <tr>
 * <th>Package</th>
 * <th>Description</th>
 * </tr>
 * <tr>
 * <td>{@link com.pulse.api}</td>
 * <td>Public API for mod developers</td>
 * </tr>
 * <tr>
 * <td>{@link com.pulse.event}</td>
 * <td>Event bus and event types</td>
 * </tr>
 * <tr>
 * <td>{@link com.pulse.mod}</td>
 * <td>Mod loading and lifecycle</td>
 * </tr>
 * <tr>
 * <td>{@link com.pulse.scheduler}</td>
 * <td>Task scheduling</td>
 * </tr>
 * <tr>
 * <td>{@link com.pulse.lifecycle}</td>
 * <td>Resource cleanup</td>
 * </tr>
 * <tr>
 * <td>{@link com.pulse.mixin}</td>
 * <td>Game code hooks (internal)</td>
 * </tr>
 * </table>
 * 
 * <h2>Sub-module Projects</h2>
 * <ul>
 * <li><b>pulse-api</b> - SPI interfaces for dependent projects</li>
 * <li><b>Echo</b> - Performance profiler using Pulse API</li>
 * <li><b>Fuse</b> - AI-based optimizer</li>
 * <li><b>Nerve</b> - Network optimizer</li>
 * </ul>
 * 
 * <h2>Quick Start</h2>
 * 
 * <pre>{@code
 * public class MyMod implements PulseMod {
 *     @Override
 *     public void onInitialize() {
 *         PulseLogger.info("Pulse", "MyMod loaded!");
 * 
 *         EventBus.subscribe(GameTickEvent.class, e -> {
 *             // Handle tick
 *         });
 *     }
 * }
 * }</pre>
 * 
 * @see <a href="https://github.com/randomstrangerpassenger/PZ">GitHub
 *      Repository</a>
 * @since 1.0
 */
package com.pulse;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\PulseAgent.java =====

package com.pulse;

import com.pulse.api.log.PulseLogger;
import com.pulse.bootstrap.*;
import com.pulse.transformer.PulseClassTransformer;

import java.lang.instrument.Instrumentation;

/**
 * Pulse Java Agent Entry Point.
 * 
 * JVM 시작 시 -javaagent:Pulse.jar 옵션으로 로드됨.
 * 
 * 초기화 순서:
 * 1. Instrumentation 저장
 * 2. 시스템 프로퍼티 설정
 * 3. Mixin 부트스트랩
 * 4. Mixin config 등록
 * 5. Class transformer 등록
 */
public class PulseAgent {

    private static final String LOG = PulseLogger.PULSE;
    private static Instrumentation instrumentation;
    private static PulseClassTransformer classTransformer;

    public static void premain(String agentArgs, Instrumentation inst) {
        instrumentation = inst;
        PulseEnvironment.setInstrumentation(inst);

        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "╔══════════════════════════════════════════════════════════════╗");
        PulseLogger.info(LOG, "║              Pulse MOD LOADER v1.0.0                       ║");
        PulseLogger.info(LOG, "║          Project Zomboid Modding Platform                    ║");
        PulseLogger.info(LOG, "╚══════════════════════════════════════════════════════════════╝");
        PulseLogger.info(LOG, "");

        try {
            initializePulse(inst);
        } catch (Throwable t) {
            PulseLogger.error(LOG, "════════════════════════════════════════");
            PulseLogger.error(LOG, "CRITICAL INITIALIZATION ERROR");
            PulseLogger.error(LOG, "════════════════════════════════════════");
            t.printStackTrace();
        }
    }

    private static void initializePulse(Instrumentation inst) {
        InitializationContext ctx = new InitializationContext(inst);

        // 1. System Properties
        new SystemPropertyInitializer().initialize(ctx);

        // 2. Bootstrap Loader (Mixin)
        new BootstrapLoader().initialize(ctx);

        // 3. Config Registrar
        new ConfigRegistrar().initialize(ctx);

        // 4 & 5. Transformer Registrar
        classTransformer = new TransformerRegistrar().initialize(ctx);

        // 6. Complete Initialization
        PulseEnvironment.markInitialized();

        // 6.5. Optimization Extensions
        new OptimizationInitializer().initialize(ctx);

        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "════════════════════════════════════════════════════");
        PulseLogger.info(LOG, "CORE INITIALIZATION COMPLETE");
        PulseLogger.info(LOG, "════════════════════════════════════════════════════");
        PulseLogger.info(LOG, "");

        // 7. Mod Loader (Discovery & Mixins)
        new ModInitializer().initialize(ctx);

        PulseLogger.info(LOG, "");
        PulseLogger.info(LOG, "════════════════════════════════════════════════════");
        PulseLogger.info(LOG, "Pulse FULLY INITIALIZED");
        PulseLogger.info(LOG, "Waiting for zombie.* classes to load...");
        PulseLogger.info(LOG, "════════════════════════════════════════════════════");
        PulseLogger.info(LOG, "");

        PulseEnvironment.printStatus();

        // Start Debug Monitor
        new DebugMonitorFactory().startMonitor(classTransformer);
    }

    public static Instrumentation getInstrumentation() {
        return instrumentation;
    }

    public static PulseClassTransformer getClassTransformer() {
        return classTransformer;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\PulseEnvironment.java =====

package com.pulse;

import com.pulse.api.log.PulseLogger;
import org.spongepowered.asm.mixin.transformer.IMixinTransformer;

/**
 * Pulse 전역 환경 상태 관리.
 * 
 * 다양한 컴포넌트 간에 공유되는 상태를 보관:
 * - Game ClassLoader
 * - Mixin Transformer
 * - Instrumentation 인스턴스
 * - 기타 환경 설정
 */
public class PulseEnvironment {

    private static ClassLoader gameClassLoader;
    private static IMixinTransformer mixinTransformer;
    private static java.lang.instrument.Instrumentation instrumentation;

    private static boolean initialized = false;
    private static boolean mixinReady = false;

    // --- Game ClassLoader ---

    public static void setGameClassLoader(ClassLoader cl) {
        if (gameClassLoader == null && cl != null) {
            gameClassLoader = cl;
            PulseLogger.info(PulseLogger.PULSE, "Game ClassLoader registered: {}", cl);
            PulseLogger.debug(PulseLogger.PULSE, "ClassLoader class: {}", cl.getClass().getName());
        }
    }

    public static ClassLoader getGameClassLoader() {
        return gameClassLoader;
    }

    // --- Mixin Transformer ---

    public static void setMixinTransformer(IMixinTransformer transformer) {
        if (mixinTransformer == null && transformer != null) {
            mixinTransformer = transformer;
            mixinReady = true;
            PulseLogger.info(PulseLogger.PULSE, "Mixin Transformer registered: {}",
                    transformer.getClass().getName());
        }
    }

    public static IMixinTransformer getMixinTransformer() {
        return mixinTransformer;
    }

    public static boolean isMixinReady() {
        return mixinReady;
    }

    // --- Instrumentation ---

    public static void setInstrumentation(java.lang.instrument.Instrumentation inst) {
        instrumentation = inst;
        PulseLogger.info(PulseLogger.PULSE, "Instrumentation registered");
    }

    public static java.lang.instrument.Instrumentation getInstrumentation() {
        return instrumentation;
    }

    // --- Lifecycle ---

    public static void markInitialized() {
        initialized = true;
        PulseLogger.info(PulseLogger.PULSE, "Environment marked as initialized");
    }

    public static boolean isInitialized() {
        return initialized;
    }

    // --- Development Mode ---

    private static volatile Boolean developmentModeCache = null;

    /**
     * 개발 모드 여부 확인.
     * 
     * 다음 조건 중 하나라도 만족하면 개발 모드:
     * <ul>
     * <li>시스템 프로퍼티 {@code pulse.dev=true}</li>
     * <li>환경 변수 {@code PULSE_DEV} 설정됨</li>
     * <li>실행 디렉토리에 {@code pulse_dev.lock} 파일 존재</li>
     * </ul>
     * 
     * 개발 모드에서는 Mixin 에러가 전파되어 디버깅이 용이함.
     * 프로덕션에서는 에러가 격리되어 게임 안정성 유지.
     * 
     * @return 개발 모드이면 true
     */
    public static boolean isDevelopmentMode() {
        if (developmentModeCache != null) {
            return developmentModeCache;
        }

        // System property check
        if (Boolean.getBoolean("pulse.dev")) {
            developmentModeCache = true;
            return true;
        }

        // Environment variable check
        String envVar = System.getenv("PULSE_DEV");
        if (envVar != null && !envVar.isEmpty()) {
            developmentModeCache = true;
            return true;
        }

        // Lock file check
        java.io.File lockFile = new java.io.File("pulse_dev.lock");
        if (lockFile.exists()) {
            developmentModeCache = true;
            return true;
        }

        developmentModeCache = false;
        return false;
    }

    /**
     * 개발 모드 캐시 초기화 (테스트용).
     */
    public static void resetDevelopmentModeCache() {
        developmentModeCache = null;
    }

    // --- Debug Info ---

    public static void printStatus() {
        PulseLogger.info(PulseLogger.PULSE, "==================================================");
        PulseLogger.info(PulseLogger.PULSE, "STATUS REPORT");
        PulseLogger.info(PulseLogger.PULSE, "  Initialized: {}", initialized);
        PulseLogger.info(PulseLogger.PULSE, "  Game ClassLoader: {}",
                (gameClassLoader != null ? gameClassLoader : "NOT SET"));
        PulseLogger.info(PulseLogger.PULSE, "  Mixin Ready: {}", mixinReady);
        PulseLogger.info(PulseLogger.PULSE, "  Mixin Transformer: {}",
                (mixinTransformer != null ? "SET" : "NOT SET"));
        PulseLogger.info(PulseLogger.PULSE, "  Instrumentation: {}",
                (instrumentation != null ? "SET" : "NOT SET"));
        PulseLogger.info(PulseLogger.PULSE, "==================================================");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\PulseInfo.java =====

package com.pulse;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.jar.Attributes;
import java.util.jar.Manifest;

/**
 * Pulse 버전 및 빌드 정보 유틸리티.
 * 
 * 빌드 시 생성된 파일(pulse-version.txt, MANIFEST.MF)에서 버전 정보를 읽습니다.
 * 
 * @since Pulse 1.2
 */
public final class PulseInfo {

    private static final String DEFAULT_VERSION = "0.8.0";
    private static final String VERSION_FILE = "pulse-version.txt";

    private static volatile String cachedVersion;

    private PulseInfo() {
    }

    /**
     * Pulse 버전 문자열 반환
     * 
     * @return 버전 문자열 (예: "0.8.0")
     */
    public static String getVersion() {
        if (cachedVersion == null) {
            cachedVersion = loadVersion();
        }
        return cachedVersion;
    }

    /** 버전 정보 로드 */
    private static String loadVersion() {
        // 1. pulse-version.txt 파일에서 읽기 시도 (Gradle generateVersionFile 태스크)
        String version = loadFromVersionFile();
        if (version != null) {
            return version;
        }

        // 2. JAR MANIFEST.MF에서 Implementation-Version 읽기 시도
        version = loadFromManifest();
        if (version != null) {
            return version;
        }

        // 3. 시스템 속성에서 읽기 시도 (테스트 또는 개발 환경)
        version = System.getProperty("pulse.version");
        if (version != null && !version.isEmpty()) {
            return version;
        }

        // 4. 기본값 반환
        return DEFAULT_VERSION;
    }

    /**
     * pulse-version.txt 파일에서 버전 읽기
     */
    private static String loadFromVersionFile() {
        try {
            // 클래스로더에서 리소스로 시도
            InputStream is = PulseInfo.class.getClassLoader().getResourceAsStream(VERSION_FILE);
            if (is != null) {
                try (BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {
                    String version = reader.readLine();
                    if (version != null && !version.trim().isEmpty()) {
                        return version.trim();
                    }
                }
            }

            // 현재 디렉토리에서 시도
            Path versionPath = Paths.get(VERSION_FILE);
            if (Files.exists(versionPath)) {
                String version = Files.readString(versionPath, StandardCharsets.UTF_8).trim();
                if (!version.isEmpty()) {
                    return version;
                }
            }

            // JAR 파일 옆에서 시도
            URL jarLocation = PulseInfo.class.getProtectionDomain().getCodeSource().getLocation();
            if (jarLocation != null) {
                Path jarDir = Paths.get(jarLocation.toURI()).getParent();
                if (jarDir != null) {
                    Path sideFile = jarDir.resolve(VERSION_FILE);
                    if (Files.exists(sideFile)) {
                        String version = Files.readString(sideFile, StandardCharsets.UTF_8).trim();
                        if (!version.isEmpty()) {
                            return version;
                        }
                    }
                }
            }
        } catch (Exception e) {
            // fallback
        }
        return null;
    }

    /**
     * JAR MANIFEST.MF에서 버전 읽기
     */
    private static String loadFromManifest() {
        try {
            InputStream is = PulseInfo.class.getClassLoader().getResourceAsStream("META-INF/MANIFEST.MF");
            if (is != null) {
                try (is) {
                    Manifest manifest = new Manifest(is);
                    Attributes attrs = manifest.getMainAttributes();
                    String version = attrs.getValue("Implementation-Version");
                    if (version != null && !version.isEmpty() && !version.contains("SNAPSHOT")) {
                        return version.replace("-SNAPSHOT", "");
                    }
                    // SNAPSHOT 버전도 허용
                    if (version != null && !version.isEmpty()) {
                        return version.replace("-SNAPSHOT", "");
                    }
                }
            }
        } catch (Exception e) {
            // fallback
        }
        return null;
    }

    /** 전체 버전 문자열 (SNAPSHOT 포함) */
    public static String getFullVersion() {
        String version = loadFromManifest();
        if (version != null) {
            return version;
        }
        return getVersion();
    }

    /** 빌드 정보 요약 */
    public static String getBuildInfo() {
        return String.format("Pulse v%s (Java %s)", getVersion(), System.getProperty("java.version"));
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\registry\DeferredRegister.java =====

package com.pulse.registry;

import com.pulse.api.log.PulseLogger;

import java.util.*;
import java.util.function.Supplier;

/**
 * 지연 등록 헬퍼.
 * NeoForge의 DeferredRegister와 유사한 개념.
 * 모드 초기화 시점에 등록을 수집하고, 나중에 실제 레지스트리에 커밋.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 모드 클래스에서
 * public static final DeferredRegister<MyItem> ITEMS = DeferredRegister.create("mymod", MyRegistries.ITEMS);
 * 
 * public static final RegistryEntry<MyItem> COOL_ITEM = ITEMS.register("cool_item", MyCoolItem::new);
 * 
 * // 초기화 시
 * ITEMS.registerAll();
 * </pre>
 * 
 * @param <T> 등록할 객체 타입
 */
public class DeferredRegister<T> {

    private final String modId;
    private final Registry<T> registry;
    private final List<PendingEntry<T>> pendingEntries = new ArrayList<>();
    private boolean committed = false;
    private static final String LOG = PulseLogger.PULSE;

    private DeferredRegister(String modId, Registry<T> registry) {
        this.modId = modId;
        this.registry = registry;
    }

    /**
     * DeferredRegister 생성
     */
    public static <T> DeferredRegister<T> create(String modId, Registry<T> registry) {
        return new DeferredRegister<>(modId, registry);
    }

    /**
     * 레지스트리 ID로 DeferredRegister 생성
     */
    public static <T> DeferredRegister<T> create(String modId, Identifier registryId) {
        Registry<T> registry = Registry.getRegistry(registryId);
        if (registry == null) {
            throw new IllegalArgumentException("Registry not found: " + registryId);
        }
        return new DeferredRegister<>(modId, registry);
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 객체 등록 (지연)
     */
    public RegistryEntry<T> register(String name, Supplier<T> supplier) {
        if (committed) {
            throw new IllegalStateException("DeferredRegister already committed");
        }

        Identifier id = Identifier.of(modId, name);
        RegistryEntry<T> entry = new RegistryEntry<>(id, registry);
        pendingEntries.add(new PendingEntry<>(id, supplier, entry));

        return entry;
    }

    /**
     * 이미 생성된 객체 등록
     */
    public RegistryEntry<T> register(String name, T value) {
        return register(name, () -> value);
    }

    // ─────────────────────────────────────────────────────────────
    // 커밋
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 대기 중인 등록을 레지스트리에 커밋
     */
    public void registerAll() {
        if (committed) {
            return;
        }

        for (PendingEntry<T> pending : pendingEntries) {
            T value = pending.supplier.get();
            registry.register(pending.id, value);
            pending.entry.setValue(value);
        }

        committed = true;
        committed = true;
        PulseLogger.info(LOG, "[Registry] Committed {} entries from {} to {}",
                pendingEntries.size(), modId, registry.getRegistryId());
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    public String getModId() {
        return modId;
    }

    public Registry<T> getRegistry() {
        return registry;
    }

    public int getPendingCount() {
        return pendingEntries.size();
    }

    public boolean isCommitted() {
        return committed;
    }

    /**
     * 등록된 모든 엔트리 가져오기
     */
    public List<RegistryEntry<T>> getEntries() {
        List<RegistryEntry<T>> entries = new ArrayList<>();
        for (PendingEntry<T> pending : pendingEntries) {
            entries.add(pending.entry);
        }
        return entries;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    private static class PendingEntry<T> {
        final Identifier id;
        final Supplier<T> supplier;
        final RegistryEntry<T> entry;

        PendingEntry(Identifier id, Supplier<T> supplier, RegistryEntry<T> entry) {
            this.id = id;
            this.supplier = supplier;
            this.entry = entry;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\registry\Identifier.java =====

package com.pulse.registry;

import java.util.Objects;

/**
 * 리소스 식별자.
 * 네임스페이스:경로 형식 (예: "mymod:my_item")
 * Minecraft의 ResourceLocation과 동일한 개념.
 */
public final class Identifier {

    public static final String DEFAULT_NAMESPACE = "Pulse";
    public static final char SEPARATOR = ':';

    private final String namespace;
    private final String path;

    private Identifier(String namespace, String path) {
        this.namespace = namespace;
        this.path = path;
    }

    /**
     * 식별자 생성
     */
    public static Identifier of(String namespace, String path) {
        validateNamespace(namespace);
        validatePath(path);
        return new Identifier(namespace, path);
    }

    /**
     * 문자열에서 파싱
     * "namespace:path" 또는 "path" (기본 네임스페이스 사용)
     */
    public static Identifier parse(String id) {
        if (id == null || id.isEmpty()) {
            throw new IllegalArgumentException("Identifier cannot be null or empty");
        }

        int colonIndex = id.indexOf(SEPARATOR);
        if (colonIndex < 0) {
            // 네임스페이스 없음 - 기본 사용
            return of(DEFAULT_NAMESPACE, id);
        }

        String namespace = id.substring(0, colonIndex);
        String path = id.substring(colonIndex + 1);
        return of(namespace, path);
    }

    /**
     * 모드 ID로 네임스페이스 지정하여 생성
     */
    public static Identifier mod(String modId, String path) {
        return of(modId, path);
    }

    // ─────────────────────────────────────────────────────────────
    // 유효성 검사
    // ─────────────────────────────────────────────────────────────

    private static void validateNamespace(String namespace) {
        if (namespace == null || namespace.isEmpty()) {
            throw new IllegalArgumentException("Namespace cannot be null or empty");
        }
        if (!isValidNamespace(namespace)) {
            throw new IllegalArgumentException("Invalid namespace: " + namespace);
        }
    }

    private static void validatePath(String path) {
        if (path == null || path.isEmpty()) {
            throw new IllegalArgumentException("Path cannot be null or empty");
        }
        if (!isValidPath(path)) {
            throw new IllegalArgumentException("Invalid path: " + path);
        }
    }

    /**
     * 네임스페이스 유효성 (a-z, 0-9, _, -)
     */
    public static boolean isValidNamespace(String namespace) {
        for (char c : namespace.toCharArray()) {
            if (!(c >= 'a' && c <= 'z') &&
                    !(c >= '0' && c <= '9') &&
                    c != '_' && c != '-') {
                return false;
            }
        }
        return true;
    }

    /**
     * 경로 유효성 (a-z, 0-9, _, -, ., /)
     */
    public static boolean isValidPath(String path) {
        for (char c : path.toCharArray()) {
            if (!(c >= 'a' && c <= 'z') &&
                    !(c >= '0' && c <= '9') &&
                    c != '_' && c != '-' && c != '.' && c != '/') {
                return false;
            }
        }
        return true;
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public String getNamespace() {
        return namespace;
    }

    public String getPath() {
        return path;
    }

    /**
     * 전체 문자열 (namespace:path)
     */
    @Override
    public String toString() {
        return namespace + SEPARATOR + path;
    }

    /**
     * 파일 경로 형식 (namespace/path)
     */
    public String toFilePath() {
        return namespace + "/" + path;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Identifier that = (Identifier) o;
        return namespace.equals(that.namespace) && path.equals(that.path);
    }

    @Override
    public int hashCode() {
        return Objects.hash(namespace, path);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\registry\Registry.java =====

package com.pulse.registry;

import com.pulse.api.log.PulseLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 범용 레지스트리.
 * 특정 타입의 객체를 식별자로 등록하고 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 레지스트리 생성
 * Registry<MyItem> ITEMS = Registry.create(Identifier.of("mymod", "items"));
 * 
 * // 등록
 * ITEMS.register(Identifier.of("mymod", "cool_item"), new MyCoolItem());
 * 
 * // 조회
 * MyItem item = ITEMS.get(Identifier.of("mymod", "cool_item"));
 * </pre>
 * 
 * @param <T> 레지스트리에 저장할 객체 타입
 */
public class Registry<T> {

    private final Identifier registryId;
    private final Map<Identifier, T> entries = new ConcurrentHashMap<>();
    private final Map<Identifier, Supplier<T>> deferredEntries = new ConcurrentHashMap<>();
    private boolean frozen = false;

    // 글로벌 레지스트리 목록
    private static final Map<Identifier, Registry<?>> REGISTRIES = new ConcurrentHashMap<>();
    private static final String LOG = PulseLogger.PULSE;

    private Registry(Identifier registryId) {
        this.registryId = registryId;
    }

    /**
     * 새 레지스트리 생성
     */
    public static <T> Registry<T> create(Identifier registryId) {
        if (REGISTRIES.containsKey(registryId)) {
            throw new IllegalStateException("Registry already exists: " + registryId);
        }

        Registry<T> registry = new Registry<>(registryId);
        REGISTRIES.put(registryId, registry);

        PulseLogger.info(LOG, "[Registry] Created registry: {}", registryId);
        return registry;
    }

    /**
     * 기존 레지스트리 가져오기
     */
    @SuppressWarnings("unchecked")
    public static <T> Registry<T> getRegistry(Identifier registryId) {
        return (Registry<T>) REGISTRIES.get(registryId);
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 객체 등록
     */
    public T register(Identifier id, T value) {
        if (frozen) {
            throw new IllegalStateException("Registry is frozen: " + registryId);
        }
        if (entries.containsKey(id)) {
            throw new IllegalArgumentException("Duplicate entry: " + id);
        }

        entries.put(id, value);
        PulseLogger.info(LOG, "[Registry] Registered {} -> {}", registryId, id);
        return value;
    }

    /**
     * 문자열 ID로 등록
     */
    public T register(String id, T value) {
        return register(Identifier.parse(id), value);
    }

    /**
     * 지연 등록 (Supplier 사용)
     * 실제 객체는 freeze 시점에 생성됨
     */
    public void registerDeferred(Identifier id, Supplier<T> supplier) {
        if (frozen) {
            throw new IllegalStateException("Registry is frozen: " + registryId);
        }
        deferredEntries.put(id, supplier);
    }

    // ─────────────────────────────────────────────────────────────
    // 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * ID로 객체 가져오기
     */
    public T get(Identifier id) {
        return entries.get(id);
    }

    /**
     * 문자열 ID로 가져오기
     */
    public T get(String id) {
        return get(Identifier.parse(id));
    }

    /**
     * ID로 Optional 가져오기
     */
    public Optional<T> getOptional(Identifier id) {
        return Optional.ofNullable(entries.get(id));
    }

    /**
     * ID 존재 여부 확인
     */
    public boolean contains(Identifier id) {
        return entries.containsKey(id);
    }

    /**
     * 객체의 ID 가져오기 (역방향 조회)
     */
    public Optional<Identifier> getId(T value) {
        for (Map.Entry<Identifier, T> entry : entries.entrySet()) {
            if (entry.getValue().equals(value)) {
                return Optional.of(entry.getKey());
            }
        }
        return Optional.empty();
    }

    // ─────────────────────────────────────────────────────────────
    // 반복
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 ID
     */
    public Set<Identifier> getIds() {
        return Collections.unmodifiableSet(entries.keySet());
    }

    /**
     * 모든 값
     */
    public Collection<T> getValues() {
        return Collections.unmodifiableCollection(entries.values());
    }

    /**
     * 모든 엔트리
     */
    public Set<Map.Entry<Identifier, T>> getEntries() {
        return Collections.unmodifiableSet(entries.entrySet());
    }

    /**
     * 등록된 항목 수
     */
    public int size() {
        return entries.size();
    }

    public boolean isEmpty() {
        return entries.isEmpty();
    }

    // ─────────────────────────────────────────────────────────────
    // 레지스트리 잠금
    // ─────────────────────────────────────────────────────────────

    /**
     * 레지스트리 잠금 (더 이상 등록 불가)
     * 지연 등록된 항목들이 이 시점에 생성됨
     */
    public void freeze() {
        if (frozen)
            return;

        // 지연 등록 처리
        for (Map.Entry<Identifier, Supplier<T>> entry : deferredEntries.entrySet()) {
            T value = entry.getValue().get();
            entries.put(entry.getKey(), value);
        }
        deferredEntries.clear();

        frozen = true;
        PulseLogger.info(LOG, "[Registry] Frozen {} with {} entries", registryId, entries.size());
    }

    public boolean isFrozen() {
        return frozen;
    }

    public Identifier getRegistryId() {
        return registryId;
    }

    /**
     * 모든 레지스트리 잠금
     */
    public static void freezeAll() {
        for (Registry<?> registry : REGISTRIES.values()) {
            registry.freeze();
        }
    }

    /**
     * 모든 레지스트리 가져오기
     */
    public static Collection<Registry<?>> getAllRegistries() {
        return Collections.unmodifiableCollection(REGISTRIES.values());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\registry\RegistryEntry.java =====

package com.pulse.registry;

/**
 * 레지스트리 엔트리 참조.
 * DeferredRegister에서 반환되어 나중에 실제 값에 접근할 수 있게 함.
 * 
 * @param <T> 등록된 객체 타입
 */
public class RegistryEntry<T> {

    private final Identifier id;
    private final Registry<T> registry;
    private T value;
    private boolean resolved = false;

    RegistryEntry(Identifier id, Registry<T> registry) {
        this.id = id;
        this.registry = registry;
    }

    /**
     * 등록된 값 가져오기
     */
    public T get() {
        if (!resolved) {
            // 아직 커밋되지 않은 경우 레지스트리에서 조회 시도
            T fromRegistry = registry.get(id);
            if (fromRegistry != null) {
                this.value = fromRegistry;
                this.resolved = true;
            }
        }

        if (value == null && !resolved) {
            throw new IllegalStateException("Registry entry not yet available: " + id);
        }

        return value;
    }

    /**
     * 값이 이미 해결되었는지 확인
     */
    public boolean isResolved() {
        return resolved || registry.contains(id);
    }

    /**
     * 식별자 가져오기
     */
    public Identifier getId() {
        return id;
    }

    /**
     * 레지스트리 가져오기
     */
    public Registry<T> getRegistry() {
        return registry;
    }

    // 내부 사용
    void setValue(T value) {
        this.value = value;
        this.resolved = true;
    }

    @Override
    public String toString() {
        return "RegistryEntry[" + id + "]";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\resource\I18n.java =====

package com.pulse.resource;

import com.pulse.registry.Identifier;

import java.util.*;

/**
 * 번역/다국어 지원.
 * 모드의 번역 문자열을 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 번역 로드
 * I18n.loadLanguage("mymod", "ko_kr");
 * 
 * // 번역 사용
 * String text = I18n.translate("mymod.item.cool_item.name");
 * String formatted = I18n.translate("mymod.message.welcome", playerName);
 * </pre>
 */
public class I18n {

    private static final I18n INSTANCE = new I18n();

    // 현재 언어
    private String currentLanguage = "en_us";

    // 로드된 번역 (modId -> key -> translation)
    private final Map<String, Map<String, String>> translations = new HashMap<>();

    // 폴백 번역 (영어)
    private final Map<String, Map<String, String>> fallback = new HashMap<>();

    private I18n() {
    }

    public static I18n getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 언어 설정
    // ─────────────────────────────────────────────────────────────

    /**
     * 현재 언어 설정
     */
    public static void setLanguage(String language) {
        INSTANCE.currentLanguage = language.toLowerCase();
        INSTANCE.reloadAllTranslations();
    }

    /**
     * 현재 언어 가져오기
     */
    public static String getLanguage() {
        return INSTANCE.currentLanguage;
    }

    // ─────────────────────────────────────────────────────────────
    // 번역 로드
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드의 번역 파일 로드
     */
    public static void loadLanguage(String modId, String language) {
        INSTANCE.loadTranslations(modId, language, false);
    }

    /**
     * 모드의 현재 언어 번역 로드
     */
    public static void loadLanguage(String modId) {
        INSTANCE.loadTranslations(modId, INSTANCE.currentLanguage, false);
        // 폴백으로 영어도 로드
        if (!INSTANCE.currentLanguage.equals("en_us")) {
            INSTANCE.loadTranslations(modId, "en_us", true);
        }
    }

    private void loadTranslations(String modId, String language, boolean isFallback) {
        Identifier langId = Identifier.of(modId, "lang/" + language + ".json");
        String json = ResourceLoader.loadString(langId);

        if (json == null) {
            // .properties 파일도 시도
            langId = Identifier.of(modId, "lang/" + language + ".properties");
            Properties props = ResourceLoader.loadProperties(langId);
            if (props != null) {
                Map<String, String> map = new HashMap<>();
                for (String key : props.stringPropertyNames()) {
                    map.put(key, props.getProperty(key));
                }
                if (isFallback) {
                    fallback.put(modId, map);
                } else {
                    translations.put(modId, map);
                }
                return;
            }
            return;
        }

        // JSON 파싱 (간단한 구현)
        Map<String, String> map = parseSimpleJson(json);
        if (isFallback) {
            fallback.put(modId, map);
        } else {
            translations.put(modId, map);
        }
    }

    private Map<String, String> parseSimpleJson(String json) {
        Map<String, String> result = new HashMap<>();
        // 간단한 JSON 파싱 ({"key": "value"} 형식)
        json = json.trim();
        if (json.startsWith("{") && json.endsWith("}")) {
            json = json.substring(1, json.length() - 1);
            String[] pairs = json.split(",");
            for (String pair : pairs) {
                int colonIdx = pair.indexOf(':');
                if (colonIdx > 0) {
                    String key = pair.substring(0, colonIdx).trim();
                    String value = pair.substring(colonIdx + 1).trim();
                    // 따옴표 제거
                    key = stripQuotes(key);
                    value = stripQuotes(value);
                    result.put(key, value);
                }
            }
        }
        return result;
    }

    private String stripQuotes(String s) {
        if ((s.startsWith("\"") && s.endsWith("\"")) ||
                (s.startsWith("'") && s.endsWith("'"))) {
            return s.substring(1, s.length() - 1);
        }
        return s;
    }

    private void reloadAllTranslations() {
        Set<String> modIds = new HashSet<>(translations.keySet());
        translations.clear();
        for (String modId : modIds) {
            loadLanguage(modId);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 번역 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * 키를 번역
     */
    public static String translate(String key) {
        return INSTANCE.getTranslation(key);
    }

    /**
     * 키를 번역하고 포맷팅
     */
    public static String translate(String key, Object... args) {
        String translation = INSTANCE.getTranslation(key);
        if (args.length > 0) {
            try {
                return String.format(translation, args);
            } catch (Exception e) {
                return translation;
            }
        }
        return translation;
    }

    /**
     * 번역이 존재하는지 확인
     */
    public static boolean hasTranslation(String key) {
        return INSTANCE.translationExists(key);
    }

    private String getTranslation(String key) {
        // modId 추출 시도
        String modId = extractModId(key);

        // 현재 언어에서 찾기
        Map<String, String> modTranslations = translations.get(modId);
        if (modTranslations != null && modTranslations.containsKey(key)) {
            return modTranslations.get(key);
        }

        // 폴백에서 찾기
        Map<String, String> modFallback = fallback.get(modId);
        if (modFallback != null && modFallback.containsKey(key)) {
            return modFallback.get(key);
        }

        // 번역 없음 - 키 반환
        return key;
    }

    private boolean translationExists(String key) {
        String modId = extractModId(key);
        Map<String, String> modTranslations = translations.get(modId);
        if (modTranslations != null && modTranslations.containsKey(key)) {
            return true;
        }
        Map<String, String> modFallback = fallback.get(modId);
        return modFallback != null && modFallback.containsKey(key);
    }

    private String extractModId(String key) {
        int dotIdx = key.indexOf('.');
        if (dotIdx > 0) {
            return key.substring(0, dotIdx);
        }
        return "Pulse";
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\resource\ResourceLoader.java =====

package com.pulse.resource;

import com.pulse.api.log.PulseLogger;
import com.pulse.registry.Identifier;

import java.io.*;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

/**
 * 리소스 로더.
 * 모드 JAR 및 리소스 팩에서 리소스를 로드.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 텍스처 로드
 * InputStream tex = ResourceLoader.getResource(
 *         Identifier.of("mymod", "textures/item/cool_item.png"));
 * 
 * // JSON 데이터 로드
 * String json = ResourceLoader.loadString(
 *         Identifier.of("mymod", "data/items.json"));
 * 
 * // 번역 파일 로드
 * Properties lang = ResourceLoader.loadProperties(
 *         Identifier.of("mymod", "lang/ko_kr.properties"));
 * </pre>
 */
public class ResourceLoader {

    private static final ResourceLoader INSTANCE = new ResourceLoader();
    private static final String LOG = PulseLogger.PULSE;

    // 등록된 리소스 소스
    private final List<ResourceSource> sources = new ArrayList<>();

    // 리소스 캐시
    private final Map<Identifier, byte[]> cache = new ConcurrentHashMap<>();
    private boolean cacheEnabled = true;

    private ResourceLoader() {
    }

    public static ResourceLoader getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 리소스 소스 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * JAR 파일을 리소스 소스로 추가
     */
    public static void addJarSource(Path jarPath) {
        INSTANCE.registerJarSource(jarPath);
    }

    /**
     * 디렉토리를 리소스 소스로 추가
     */
    public static void addDirectorySource(Path directory) {
        INSTANCE.registerDirectorySource(directory);
    }

    /**
     * 클래스로더를 리소스 소스로 추가
     */
    public static void addClassLoaderSource(ClassLoader classLoader, String namespace) {
        INSTANCE.registerClassLoaderSource(classLoader, namespace);
    }

    private void registerJarSource(Path jarPath) {
        sources.add(new JarResourceSource(jarPath));
        PulseLogger.info(LOG, "[Resource] Added JAR source: {}", jarPath.getFileName());
    }

    private void registerDirectorySource(Path directory) {
        sources.add(new DirectoryResourceSource(directory));
        PulseLogger.info(LOG, "[Resource] Added directory source: {}", directory);
    }

    private void registerClassLoaderSource(ClassLoader classLoader, String namespace) {
        sources.add(new ClassLoaderResourceSource(classLoader, namespace));
        PulseLogger.info(LOG, "[Resource] Added classloader source for: {}", namespace);
    }

    // ─────────────────────────────────────────────────────────────
    // 리소스 로드
    // ─────────────────────────────────────────────────────────────

    /**
     * 리소스를 InputStream으로 가져오기
     */
    public static InputStream getResource(Identifier id) {
        return INSTANCE.loadResource(id);
    }

    /**
     * 리소스를 문자열로 로드
     */
    public static String loadString(Identifier id) {
        byte[] data = INSTANCE.loadBytesInternal(id);
        if (data == null)
            return null;
        return new String(data, StandardCharsets.UTF_8);
    }

    /**
     * 리소스를 바이트 배열로 로드
     */
    public static byte[] loadBytes(Identifier id) {
        return INSTANCE.loadBytesInternal(id);
    }

    /**
     * Properties 파일 로드
     */
    public static Properties loadProperties(Identifier id) {
        try (InputStream is = getResource(id)) {
            if (is == null)
                return null;
            Properties props = new Properties();
            props.load(is);
            return props;
        } catch (IOException e) {
            PulseLogger.error(LOG, "[Resource] Failed to load properties: {}", id);
            return null;
        }
    }

    /**
     * 리소스 존재 여부 확인
     */
    public static boolean exists(Identifier id) {
        return INSTANCE.resourceExists(id);
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 구현
    // ─────────────────────────────────────────────────────────────

    private InputStream loadResource(Identifier id) {
        byte[] data = loadBytesInternal(id);
        if (data == null)
            return null;
        return new ByteArrayInputStream(data);
    }

    private byte[] loadBytesInternal(Identifier id) {
        // 캐시 확인
        if (cacheEnabled && cache.containsKey(id)) {
            return cache.get(id);
        }

        // 소스에서 로드
        for (ResourceSource source : sources) {
            byte[] data = source.load(id);
            if (data != null) {
                if (cacheEnabled) {
                    cache.put(id, data);
                }
                return data;
            }
        }

        return null;
    }

    private boolean resourceExists(Identifier id) {
        if (cacheEnabled && cache.containsKey(id)) {
            return true;
        }
        for (ResourceSource source : sources) {
            if (source.exists(id)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 캐시 비우기
     */
    public static void clearCache() {
        INSTANCE.cache.clear();
    }

    public static void setCacheEnabled(boolean enabled) {
        INSTANCE.cacheEnabled = enabled;
    }

    // ─────────────────────────────────────────────────────────────
    // 리소스 소스 인터페이스 및 구현
    // ─────────────────────────────────────────────────────────────

    interface ResourceSource {
        byte[] load(Identifier id);

        boolean exists(Identifier id);
    }

    static class JarResourceSource implements ResourceSource {
        private final Path jarPath;

        JarResourceSource(Path jarPath) {
            this.jarPath = jarPath;
        }

        @Override
        public byte[] load(Identifier id) {
            String path = "assets/" + id.getNamespace() + "/" + id.getPath();
            try (JarFile jar = new JarFile(jarPath.toFile())) {
                JarEntry entry = jar.getJarEntry(path);
                if (entry != null) {
                    try (InputStream is = jar.getInputStream(entry)) {
                        return is.readAllBytes();
                    }
                }
            } catch (IOException e) {
                // Ignore
            }
            return null;
        }

        @Override
        public boolean exists(Identifier id) {
            String path = "assets/" + id.getNamespace() + "/" + id.getPath();
            try (JarFile jar = new JarFile(jarPath.toFile())) {
                return jar.getJarEntry(path) != null;
            } catch (IOException e) {
                return false;
            }
        }
    }

    static class DirectoryResourceSource implements ResourceSource {
        private final Path baseDir;

        DirectoryResourceSource(Path baseDir) {
            this.baseDir = baseDir;
        }

        @Override
        public byte[] load(Identifier id) {
            Path file = baseDir.resolve("assets")
                    .resolve(id.getNamespace())
                    .resolve(id.getPath());
            if (Files.exists(file)) {
                try {
                    return Files.readAllBytes(file);
                } catch (IOException e) {
                    return null;
                }
            }
            return null;
        }

        @Override
        public boolean exists(Identifier id) {
            Path file = baseDir.resolve("assets")
                    .resolve(id.getNamespace())
                    .resolve(id.getPath());
            return Files.exists(file);
        }
    }

    static class ClassLoaderResourceSource implements ResourceSource {
        private final ClassLoader classLoader;
        private final String namespace;

        ClassLoaderResourceSource(ClassLoader classLoader, String namespace) {
            this.classLoader = classLoader;
            this.namespace = namespace;
        }

        @Override
        public byte[] load(Identifier id) {
            if (!id.getNamespace().equals(namespace)) {
                return null;
            }
            String path = "assets/" + id.getNamespace() + "/" + id.getPath();
            try (InputStream is = classLoader.getResourceAsStream(path)) {
                if (is != null) {
                    return is.readAllBytes();
                }
            } catch (IOException e) {
                // Ignore
            }
            return null;
        }

        @Override
        public boolean exists(Identifier id) {
            if (!id.getNamespace().equals(namespace)) {
                return false;
            }
            String path = "assets/" + id.getNamespace() + "/" + id.getPath();
            URL url = classLoader.getResource(path);
            return url != null;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\runtime\package-info.java =====

/**
 * Pulse 런타임 환경 및 버전 호환성 계층.
 * 
 * B41과 B42 사이의 API 차이를 흡수하여 모드가 버전에 관계없이 동작하게 합니다.
 * 
 * <h2>주요 클래스</h2>
 * <ul>
 * <li>{@link com.pulse.runtime.PulseRuntime} - 게임 버전 감지</li>
 * <li>{@link com.pulse.runtime.PulseReflection} - 안전한 Reflection 유틸리티</li>
 * </ul>
 * 
 * @since Pulse 1.2
 */
package com.pulse.runtime;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\runtime\PulseReflection.java =====

package com.pulse.runtime;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.pulse.api.util.ReflectionCache;

/**
 * 안전한 Reflection 유틸리티.
 * 
 * B42에서 클래스/메서드 시그니처가 변경될 수 있으므로
 * Reflection 호출을 안전하게 래핑합니다.
 * 로드맵의 "Reflection Safety Layer" 요구사항을 충족합니다.
 * 
 * <p>
 * v2.0: 내부적으로 {@link ReflectionCache}를 사용하여 캐시를 일원화합니다.
 * </p>
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * // 안전한 메서드 호출
 * Object result = PulseReflection.safeInvoke(player, "getHealth");
 * 
 * // 안전한 필드 접근
 * Object value = PulseReflection.getField(player, "lastHeardSound");
 * 
 * // 메서드 존재 여부 확인
 * if (PulseReflection.methodExists("IsoPlayer", "getNewMethod")) {
 *     // B42 전용 API 사용
 * }
 * }</pre>
 * 
 * @since Pulse 1.2
 * @since Pulse 2.0 - ReflectionCache 통합
 */
public final class PulseReflection {

    // 존재하지 않는 항목 캐시 (반복 실패 방지) - PulseReflection 고유 기능
    private static final Map<String, Boolean> notFoundCache = new ConcurrentHashMap<>();

    private PulseReflection() {
    }

    // ─────────────────────────────────────────────────────────────
    // 클래스 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * 클래스 안전하게 조회
     */
    public static Class<?> findClass(String className) {
        if (notFoundCache.containsKey("class:" + className)) {
            return null;
        }

        Class<?> result = ReflectionCache.getClassOrNull(className, getClassLoader());
        if (result == null) {
            notFoundCache.put("class:" + className, true);
        }
        return result;
    }

    /**
     * 클래스 존재 여부
     */
    public static boolean classExists(String className) {
        return findClass(className) != null;
    }

    // ─────────────────────────────────────────────────────────────
    // 메서드 호출
    // ─────────────────────────────────────────────────────────────

    /**
     * 안전한 메서드 호출 (인자 없음)
     */
    public static Object safeInvoke(Object obj, String methodName) {
        return safeInvoke(obj, methodName, new Object[0]);
    }

    /**
     * 안전한 메서드 호출
     */
    public static Object safeInvoke(Object obj, String methodName, Object... args) {
        if (obj == null || methodName == null) {
            return null;
        }

        String cacheKey = "method:" + obj.getClass().getName() + "." + methodName;
        if (notFoundCache.containsKey(cacheKey)) {
            return null;
        }

        try {
            // 인자 타입 추론
            Class<?>[] paramTypes = new Class<?>[args.length];
            for (int i = 0; i < args.length; i++) {
                paramTypes[i] = args[i] != null ? args[i].getClass() : Object.class;
            }

            Method method = ReflectionCache.getMethodOrNull(obj.getClass(), methodName, paramTypes);
            if (method == null) {
                // 파라미터 타입 무시하고 이름만으로 검색
                method = findMethodByName(obj.getClass(), methodName, args.length);
            }

            if (method != null) {
                return method.invoke(obj, args);
            } else {
                notFoundCache.put(cacheKey, true);
                return null;
            }
        } catch (Exception e) {
            // 조용히 실패
            return null;
        }
    }

    /**
     * 메서드 존재 여부
     */
    public static boolean methodExists(String className, String methodName) {
        Class<?> clazz = findClass(className);
        if (clazz == null)
            return false;

        for (Method m : clazz.getDeclaredMethods()) {
            if (m.getName().equals(methodName)) {
                return true;
            }
        }
        return false;
    }

    private static Method findMethodByName(Class<?> clazz, String name, int paramCount) {
        for (Method m : clazz.getMethods()) {
            if (m.getName().equals(name) && m.getParameterCount() == paramCount) {
                m.setAccessible(true);
                return m;
            }
        }
        return null;
    }

    // ─────────────────────────────────────────────────────────────
    // 필드 접근
    // ─────────────────────────────────────────────────────────────

    /**
     * 필드 값 안전하게 읽기
     */
    public static Object getField(Object obj, String fieldName) {
        if (obj == null || fieldName == null) {
            return null;
        }

        String cacheKey = "field:" + obj.getClass().getName() + "." + fieldName;
        if (notFoundCache.containsKey(cacheKey)) {
            return null;
        }

        try {
            Field field = findFieldInHierarchy(obj.getClass(), fieldName);
            if (field != null) {
                return field.get(obj);
            } else {
                notFoundCache.put(cacheKey, true);
                return null;
            }
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 클래스의 필드 조회 (static 포함)
     */
    public static Object findField(String className, String fieldName) {
        Class<?> clazz = findClass(className);
        if (clazz == null)
            return null;

        try {
            Field field = findFieldInHierarchy(clazz, fieldName);
            if (field != null) {
                return field.get(null); // static 필드
            }
        } catch (Exception e) {
            // pass
        }
        return null;
    }

    /**
     * 필드 존재 여부
     */
    public static boolean fieldExists(String className, String fieldName) {
        Class<?> clazz = findClass(className);
        return clazz != null && findFieldInHierarchy(clazz, fieldName) != null;
    }

    private static Field findFieldInHierarchy(Class<?> clazz, String name) {
        // ReflectionCache 먼저 시도
        try {
            return ReflectionCache.getField(clazz, name);
        } catch (NoSuchFieldException e) {
            // 부모 클래스 검색
            Class<?> parent = clazz.getSuperclass();
            if (parent != null) {
                return findFieldInHierarchy(parent, name);
            }
            return null;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 캐시 초기화
     */
    public static void clearCaches() {
        notFoundCache.clear();
        // ReflectionCache는 전역 캐시이므로 여기서 초기화하지 않음
        // ReflectionCache.clearAll()은 필요시 별도 호출
    }

    /**
     * 캐시 통계
     */
    public static String getCacheStats() {
        return String.format("PulseReflection: notFound=%d, ReflectionCache: methods=%d, fields=%d, classes=%d",
                notFoundCache.size(),
                ReflectionCache.getMethodCacheSize(),
                ReflectionCache.getFieldCacheSize(),
                ReflectionCache.getClassCacheSize());
    }

    private static ClassLoader getClassLoader() {
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        return loader != null ? loader : ClassLoader.getSystemClassLoader();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\runtime\PulseRuntime.java =====

package com.pulse.runtime;

import com.pulse.api.log.PulseLogger;

/**
 * Pulse 런타임 환경 정보.
 * 
 * 게임 버전(B41/B42)을 감지하고, 버전별 분기가 필요한 로직에서 사용합니다.
 * 로드맵의 "Version Abstraction" 요구사항을 충족합니다.
 * 
 * <h2>사용 예시</h2>
 * 
 * <pre>{@code
 * if (PulseRuntime.isB42()) {
 *     // B42 전용 로직
 * } else {
 *     // B41 로직
 * }
 * }</pre>
 * 
 * @since Pulse 1.2
 */
public final class PulseRuntime {

    private static final String LOG = PulseLogger.PULSE;

    /**
     * Project Zomboid 버전
     */
    public enum Version {
        B41("Build 41"),
        B42("Build 42"),
        UNKNOWN("Unknown");

        private final String displayName;

        Version(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }
    }

    private static volatile Version detectedVersion = null;
    private static volatile String versionString = null;
    private static volatile boolean initialized = false;

    private PulseRuntime() {
    }

    /**
     * 게임 버전 감지 (게임 초기화 시 호출)
     */
    public static void detectVersion() {
        if (initialized) {
            return;
        }
        initialized = true;

        try {
            // 방법 1: Core.getInstance().getVersion() 시도
            Class<?> coreClass = Class.forName("zombie.core.Core");
            Object coreInstance = coreClass.getMethod("getInstance").invoke(null);
            Object versionObj = coreClass.getMethod("getVersion").invoke(coreInstance);

            if (versionObj != null) {
                versionString = versionObj.toString();
                detectedVersion = parseVersion(versionString);
                PulseLogger.info(LOG, "Detected game version: {} -> {}", versionString, detectedVersion);
                return;
            }
        } catch (Exception e) {
            // 방법 1 실패, 다음 시도
        }

        try {
            // 방법 2: GameVersion 클래스 확인
            Class.forName("zombie.GameVersion");
            java.lang.reflect.Field versionField = Class.forName("zombie.GameVersion").getField("VERSION");
            versionString = (String) versionField.get(null);
            detectedVersion = parseVersion(versionString);
            PulseLogger.info(LOG, "Detected game version (GameVersion): {} -> {}", versionString, detectedVersion);
            return;
        } catch (Exception e) {
            // 방법 2 실패
        }

        try {
            // 방법 3: 클래스 존재 여부로 판단 (B42 전용 클래스)
            Class.forName("zombie.core.opengl.ShaderProgram"); // B42에만 존재하는 클래스 예시
            detectedVersion = Version.B42;
            versionString = "B42 (inferred)";
            PulseLogger.info(LOG, "Inferred game version: B42");
            return;
        } catch (ClassNotFoundException e) {
            // B42 전용 클래스 없음 - B41로 추정
        }

        // 기본값: B41로 추정
        detectedVersion = Version.B41;
        versionString = "B41 (default)";
        PulseLogger.info(LOG, "Defaulting to: B41");
    }

    private static Version parseVersion(String version) {
        if (version == null)
            return Version.UNKNOWN;
        String lower = version.toLowerCase();
        if (lower.contains("42") || lower.contains("b42")) {
            return Version.B42;
        } else if (lower.contains("41") || lower.contains("b41")) {
            return Version.B41;
        }
        return Version.UNKNOWN;
    }

    /**
     * 현재 감지된 버전
     */
    public static Version getVersion() {
        if (!initialized) {
            detectVersion();
        }
        return detectedVersion != null ? detectedVersion : Version.UNKNOWN;
    }

    /**
     * 버전 문자열
     */
    public static String getVersionString() {
        if (!initialized) {
            detectVersion();
        }
        return versionString != null ? versionString : "Unknown";
    }

    /**
     * B41 여부
     */
    public static boolean isB41() {
        return getVersion() == Version.B41;
    }

    /**
     * B42 여부
     */
    public static boolean isB42() {
        return getVersion() == Version.B42;
    }

    /**
     * 버전별 분기 실행
     */
    public static <T> T versionSwitch(T b41Value, T b42Value) {
        return isB42() ? b42Value : b41Value;
    }

    /**
     * 상태 요약
     */
    public static String getStatus() {
        return String.format("PulseRuntime: version=%s, string=%s, initialized=%s",
                detectedVersion, versionString, initialized);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\scheduler\package-info.java =====

/**
 * Pulse Scheduler System.
 * 
 * <p>
 * 게임 틱 기반 태스크 스케줄링.
 * </p>
 * 
 * <h2>주요 클래스</h2>
 * <ul>
 * <li>{@link com.pulse.scheduler.PulseScheduler} - 스케줄러 싱글톤</li>
 * <li>{@link com.pulse.scheduler.TaskHandle} - 태스크 제어 핸들</li>
 * <li>{@link com.pulse.scheduler.SchedulerConfig} - 스케줄러 설정</li>
 * </ul>
 * 
 * <h2>스케줄링 타입</h2>
 * <ul>
 * <li>{@code runLater()} - 지연 후 1회 실행</li>
 * <li>{@code runTimer()} - 주기적 반복 실행</li>
 * <li>{@code runAsync()} - 비동기 즉시 실행</li>
 * <li>{@code runSync()} - 메인 스레드에서 실행</li>
 * </ul>
 * 
 * <h2>사용 예</h2>
 * 
 * <pre>{@code
 * // 60틱(약 3초) 후 실행
 * TaskHandle handle = PulseScheduler.runLater(() -> {
 *     System.out.println("Delayed task!");
 * }, 60);
 * 
 * // 취소
 * handle.cancel();
 * }</pre>
 * 
 * @since 1.0
 */
package com.pulse.scheduler;



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\scheduler\PulseScheduler.java =====

package com.pulse.scheduler;

import com.pulse.api.log.PulseLogger;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Pulse 태스크 스케줄러.
 * 
 * 게임 틱 기반 태스크 스케줄링을 제공.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 60틱(약 3초) 후 1회 실행
 * TaskHandle handle = PulseScheduler.runLater(() -> {
 *     System.out.println("Hello!");
 * }, 60);
 * 
 * // 20틱마다 반복 실행
 * TaskHandle timer = PulseScheduler.runTimer(() -> {
 *     System.out.println("Tick!");
 * }, 20, 0);
 * 
 * // 취소
 * timer.cancel();
 * 
 * // 비동기 실행
 * PulseScheduler.runAsync(() -> {
 *     // 무거운 작업
 * });
 * </pre>
 */
public class PulseScheduler {

    private static final PulseScheduler INSTANCE = new PulseScheduler();

    // 현재 게임 틱
    private volatile long currentTick = 0;

    // 태스크 ID 생성기
    private final AtomicLong taskIdGenerator = new AtomicLong(0);

    // 스케줄된 태스크 목록
    private final List<ScheduledTask> tasks = new CopyOnWriteArrayList<>();

    // 메인 스레드에서 실행할 태스크 큐
    private final ConcurrentLinkedQueue<Runnable> syncQueue = new ConcurrentLinkedQueue<>();

    // 비동기 실행용 스레드 풀
    private ExecutorService asyncExecutor = Executors.newCachedThreadPool(new PulseThreadFactory("Pulse-Async"));

    // 디버그 모드
    private boolean debug = false;

    // 설정
    private SchedulerConfig config = new SchedulerConfig();

    private PulseScheduler() {
        // 기본 ThreadFactory 설정
        config.setThreadFactory(new PulseThreadFactory("Pulse-Async"));
    }

    /**
     * 설정을 업데이트합니다.
     * 실행 중인 태스크에는 즉시 영향을 미치지 않을 수 있습니다.
     */
    public void setConfig(SchedulerConfig config) {
        this.config = config;
    }

    public SchedulerConfig getConfig() {
        return config;
    }

    public static PulseScheduler getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 편의 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 지정된 틱 수 후에 1회 실행
     * 
     * @param task       실행할 태스크
     * @param delayTicks 지연 틱 수 (20틱 ≈ 1초)
     * @return 태스크 핸들
     */
    public static TaskHandle runLater(Runnable task, long delayTicks) {
        return INSTANCE.scheduleOnce(task, delayTicks, null);
    }

    /**
     * 지정된 틱 수 후에 1회 실행 (이름 지정)
     */
    public static TaskHandle runLater(Runnable task, long delayTicks, String name) {
        return INSTANCE.scheduleOnce(task, delayTicks, name);
    }

    /**
     * 지정된 간격으로 반복 실행
     * 
     * @param task        실행할 태스크
     * @param periodTicks 반복 간격 (틱)
     * @param delayTicks  첫 실행 전 지연 (틱)
     * @return 태스크 핸들
     */
    public static TaskHandle runTimer(Runnable task, long periodTicks, long delayTicks) {
        return INSTANCE.scheduleRepeating(task, periodTicks, delayTicks, null);
    }

    /**
     * 지정된 간격으로 반복 실행 (이름 지정)
     */
    public static TaskHandle runTimer(Runnable task, long periodTicks, long delayTicks, String name) {
        return INSTANCE.scheduleRepeating(task, periodTicks, delayTicks, name);
    }

    /**
     * 비동기로 즉시 실행 (별도 스레드)
     * 
     * @param task 실행할 태스크
     * @return 태스크 핸들
     */
    public static TaskHandle runAsync(Runnable task) {
        return INSTANCE.executeAsync(task, null);
    }

    /**
     * 비동기로 즉시 실행 (이름 지정)
     */
    public static TaskHandle runAsync(Runnable task, String name) {
        return INSTANCE.executeAsync(task, name);
    }

    /**
     * 메인 스레드(게임 스레드)에서 실행
     * 다음 틱에 실행됨
     * 
     * @param task 실행할 태스크
     */
    public static void runSync(Runnable task) {
        INSTANCE.syncQueue.offer(task);
    }

    /**
     * 현재 게임 틱 가져오기
     */
    public static long getCurrentTick() {
        return INSTANCE.currentTick;
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드 (내부)
    // ─────────────────────────────────────────────────────────────

    private TaskHandle scheduleOnce(Runnable task, long delayTicks, String name) {
        long id = taskIdGenerator.incrementAndGet();
        String taskName = name != null ? name : "task-" + id;
        TaskHandle handle = new TaskHandle(id, taskName);

        ScheduledTask scheduled = new ScheduledTask(
                handle, task, ScheduledTask.TaskType.ONCE,
                delayTicks, 0, currentTick);

        tasks.add(scheduled);

        if (debug) {
            PulseLogger.debug(PulseLogger.PULSE, "Scheduled once: {} (delay={} ticks)", taskName, delayTicks);
        }

        return handle;
    }

    private TaskHandle scheduleRepeating(Runnable task, long periodTicks, long delayTicks, String name) {
        long id = taskIdGenerator.incrementAndGet();
        String taskName = name != null ? name : "timer-" + id;
        TaskHandle handle = new TaskHandle(id, taskName);

        ScheduledTask scheduled = new ScheduledTask(
                handle, task, ScheduledTask.TaskType.REPEATING,
                delayTicks, periodTicks, currentTick);

        tasks.add(scheduled);

        if (debug) {
            PulseLogger.debug(PulseLogger.PULSE, "Scheduled repeating: {} (period={}, delay={} ticks)",
                    taskName, periodTicks, delayTicks);
        }

        return handle;
    }

    private TaskHandle executeAsync(Runnable task, String name) {
        long id = taskIdGenerator.incrementAndGet();
        String taskName = name != null ? name : "async-" + id;
        TaskHandle handle = new TaskHandle(id, taskName);

        asyncExecutor.submit(() -> {
            try {
                task.run();
                handle.incrementExecutionCount();
                handle.markCompleted();
            } catch (Exception e) {
                PulseLogger.error(PulseLogger.PULSE, "Async task error: {}", taskName);
                e.printStackTrace();
            }
        });

        if (debug) {
            PulseLogger.debug(PulseLogger.PULSE, "Submitted async: {}", taskName);
        }

        return handle;
    }

    // ─────────────────────────────────────────────────────────────
    // 틱 핸들러 (게임 루프에서 호출되어야 함)
    // ─────────────────────────────────────────────────────────────

    /**
     * 틱 처리.
     * 게임의 메인 루프에서 매 틱마다 호출되어야 함.
     * (Mixin으로 GameTime.tick()에 연결)
     */
    public void tick() {
        currentTick++;

        // 동기 큐 처리
        processSyncQueue();

        // 스케줄된 태스크 처리
        processScheduledTasks();
    }

    private void processSyncQueue() {
        Runnable task;
        int processed = 0;
        int maxPerTick = config.getTickBatchSize(); // 한 틱당 최대 처리량

        while ((task = syncQueue.poll()) != null && processed < maxPerTick) {
            try {
                task.run();
                processed++;
            } catch (Exception e) {
                PulseLogger.error(PulseLogger.PULSE, "Sync task error");
                e.printStackTrace();
            }
        }
    }

    private void processScheduledTasks() {
        List<ScheduledTask> toRemove = new ArrayList<>();

        for (ScheduledTask task : tasks) {
            if (task.handle.isCancelled()) {
                toRemove.add(task);
                continue;
            }

            if (task.isReadyToExecute(currentTick)) {
                task.execute(config.getExceptionPolicy());

                if (!task.shouldContinue()) {
                    toRemove.add(task);
                }
            }
        }

        tasks.removeAll(toRemove);
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 태스크 취소
     */
    public void cancelAll() {
        for (ScheduledTask task : tasks) {
            task.handle.cancel();
        }
        tasks.clear();
        syncQueue.clear();
    }

    /**
     * 활성 태스크 수
     */
    public int getActiveTaskCount() {
        return tasks.size();
    }

    /**
     * 팬딩 동기 태스크 수
     */
    public int getPendingSyncTaskCount() {
        return syncQueue.size();
    }

    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    /**
     * 스케줄러 종료 (게임 종료 시)
     */
    public void shutdown() {
        cancelAll();
        asyncExecutor.shutdown();
        try {
            if (!asyncExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                asyncExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            asyncExecutor.shutdownNow();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\scheduler\PulseThreadFactory.java =====

package com.pulse.scheduler;

import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Custom ThreadFactory for Pulse scheduler threads.
 * Provides named daemon threads.
 */
public class PulseThreadFactory implements ThreadFactory {
    private final String namePrefix;
    private final AtomicInteger threadNumber = new AtomicInteger(1);

    public PulseThreadFactory(String namePrefix) {
        this.namePrefix = namePrefix;
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, namePrefix + "-" + threadNumber.getAndIncrement());
        if (!t.isDaemon())
            t.setDaemon(true);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\scheduler\ScheduledTask.java =====

package com.pulse.scheduler;

import com.pulse.api.log.PulseLogger;

/**
 * 내부 태스크 래퍼.
 * 스케줄러 내부에서 사용.
 */
class ScheduledTask {

    private static final String LOG = PulseLogger.PULSE;

    enum TaskType {
        ONCE, // 1회 실행
        REPEATING, // 반복 실행
        ASYNC // 비동기 실행
    }

    final TaskHandle handle;
    final Runnable task;
    final TaskType type;
    final long delayTicks;
    final long periodTicks;

    long nextExecutionTick;

    ScheduledTask(TaskHandle handle, Runnable task, TaskType type,
            long delayTicks, long periodTicks, long currentTick) {
        this.handle = handle;
        this.task = task;
        this.type = type;
        this.delayTicks = delayTicks;
        this.periodTicks = periodTicks;
        this.nextExecutionTick = currentTick + delayTicks;
    }

    /**
     * 실행 시점인지 확인
     */
    boolean isReadyToExecute(long currentTick) {
        return currentTick >= nextExecutionTick && !handle.isCancelled();
    }

    /**
     * 태스크 실행
     */
    private int retryCount = 0;

    /**
     * 태스크 실행
     */
    void execute(SchedulerConfig.ExceptionPolicy policy) {
        if (handle.isCancelled())
            return;

        try {
            task.run();
            handle.incrementExecutionCount();
            retryCount = 0; // Reset retry count on success

            if (type == TaskType.ONCE) {
                handle.markCompleted();
            } else if (type == TaskType.REPEATING) {
                // 다음 실행 시점 계산
                nextExecutionTick += periodTicks;
            }
        } catch (Exception e) {
            handleException(e, policy);
        }
    }

    private void handleException(Exception e, SchedulerConfig.ExceptionPolicy policy) {
        PulseLogger.error(LOG, "Task execution error: {} ({})", handle.getName(), policy);
        e.printStackTrace();

        switch (policy) {
            case ABORT_TASK:
                handle.cancel();
                break;
            case RETRY_ONCE:
                if (retryCount == 0) {
                    PulseLogger.info(LOG, "Retrying task: {}", handle.getName());
                    retryCount++;
                    // Do not advance nextExecutionTick, so it runs again next tick (or immediately
                    // if loop allows)
                    // For now, next tick is safest.
                    // However, we need to ensure it doesn't get removed if it was ONCE.
                } else {
                    PulseLogger.warn(LOG, "Retry failed, aborting task: {}", handle.getName());
                    handle.cancel();
                }
                break;
            case LOG_AND_CONTINUE:
            default:
                if (type == TaskType.REPEATING) {
                    nextExecutionTick += periodTicks; // Skip to next period
                } else {
                    handle.markCompleted(); // Mark done if it was ONCE
                }
                break;
        }
    }

    /**
     * 반복 태스크인지 확인
     */
    boolean shouldContinue() {
        return type == TaskType.REPEATING && !handle.isCancelled();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\scheduler\Scheduler.java =====

package com.pulse.scheduler;

/**
 * Scheduler API 편의 클래스.
 * 
 * PulseScheduler의 정적 메서드를 re-export하여
 * 더 짧은 이름으로 사용 가능하게 함.
 * 
 * 사용 예:
 * 
 * <pre>
 * import static com.pulse.scheduler.Scheduler.*;
 * 
 * // 3초 후 실행
 * runLater(() -> System.out.println("Hello!"), 60);
 * 
 * // 1초마다 반복
 * TaskHandle timer = runTimer(() -> System.out.println("Tick"), 20, 0);
 * timer.cancel();
 * </pre>
 */
public final class Scheduler {

    private Scheduler() {
    }

    /**
     * 지정된 틱 수 후에 1회 실행
     * 
     * @param task       실행할 태스크
     * @param delayTicks 지연 틱 수 (20틱 ≈ 1초)
     * @return 태스크 핸들
     */
    public static TaskHandle runLater(Runnable task, long delayTicks) {
        return PulseScheduler.runLater(task, delayTicks);
    }

    /**
     * 지정된 틱 수 후에 1회 실행 (이름 지정)
     */
    public static TaskHandle runLater(Runnable task, long delayTicks, String name) {
        return PulseScheduler.runLater(task, delayTicks, name);
    }

    /**
     * 지정된 간격으로 반복 실행
     * 
     * @param task        실행할 태스크
     * @param periodTicks 반복 간격 (틱)
     * @param delayTicks  첫 실행 전 지연 (틱)
     * @return 태스크 핸들
     */
    public static TaskHandle runTimer(Runnable task, long periodTicks, long delayTicks) {
        return PulseScheduler.runTimer(task, periodTicks, delayTicks);
    }

    /**
     * 지정된 간격으로 반복 실행 (이름 지정)
     */
    public static TaskHandle runTimer(Runnable task, long periodTicks, long delayTicks, String name) {
        return PulseScheduler.runTimer(task, periodTicks, delayTicks, name);
    }

    /**
     * 비동기로 즉시 실행 (별도 스레드)
     */
    public static TaskHandle runAsync(Runnable task) {
        return PulseScheduler.runAsync(task);
    }

    /**
     * 비동기로 즉시 실행 (이름 지정)
     */
    public static TaskHandle runAsync(Runnable task, String name) {
        return PulseScheduler.runAsync(task, name);
    }

    /**
     * 메인 스레드(게임 스레드)에서 실행
     */
    public static void runSync(Runnable task) {
        PulseScheduler.runSync(task);
    }

    /**
     * 현재 게임 틱 가져오기
     */
    public static long currentTick() {
        return PulseScheduler.getCurrentTick();
    }

    /**
     * 틱을 초로 변환 (약 20틱 = 1초)
     */
    public static long ticksToSeconds(long ticks) {
        return ticks / 20;
    }

    /**
     * 초를 틱으로 변환
     */
    public static long secondsToTicks(double seconds) {
        return (long) (seconds * 20);
    }

    /**
     * 밀리초를 틱으로 변환
     */
    public static long millisToTicks(long millis) {
        return millis / 50;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\scheduler\SchedulerConfig.java =====

package com.pulse.scheduler;

import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

/**
 * Configuration for PulseScheduler.
 */
public class SchedulerConfig {

    private int tickBatchSize = 100;
    private ExceptionPolicy exceptionPolicy = ExceptionPolicy.LOG_AND_CONTINUE;
    private ThreadFactory threadFactory = Executors.defaultThreadFactory();

    /**
     * Policy for handling exceptions during task execution.
     */
    public enum ExceptionPolicy {
        /** Retry the task once immediately (not implemented yet for all types). */
        RETRY_ONCE,
        /** Log the error and continue with next tasks. */
        LOG_AND_CONTINUE,
        /** Abort the specific task (mark as cancelled). */
        ABORT_TASK
    }

    public int getTickBatchSize() {
        return tickBatchSize;
    }

    public SchedulerConfig setTickBatchSize(int tickBatchSize) {
        this.tickBatchSize = tickBatchSize;
        return this;
    }

    public ExceptionPolicy getExceptionPolicy() {
        return exceptionPolicy;
    }

    public SchedulerConfig setExceptionPolicy(ExceptionPolicy exceptionPolicy) {
        this.exceptionPolicy = exceptionPolicy;
        return this;
    }

    public ThreadFactory getThreadFactory() {
        return threadFactory;
    }

    public SchedulerConfig setThreadFactory(ThreadFactory threadFactory) {
        this.threadFactory = threadFactory;
        return this;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\scheduler\TaskHandle.java =====

package com.pulse.scheduler;

/**
 * 스케줄된 태스크 핸들.
 * 태스크 취소 및 상태 확인에 사용.
 */
public class TaskHandle {

    private final long taskId;
    private final String name;
    private volatile boolean cancelled = false;
    private volatile boolean completed = false;
    private volatile int executionCount = 0;

    public TaskHandle(long taskId, String name) {
        this.taskId = taskId;
        this.name = name;
    }

    /**
     * 태스크 취소
     */
    public void cancel() {
        this.cancelled = true;
    }

    /**
     * 취소 여부
     */
    public boolean isCancelled() {
        return cancelled;
    }

    /**
     * 완료 여부
     */
    public boolean isCompleted() {
        return completed;
    }

    /**
     * 실행 중 여부
     */
    public boolean isActive() {
        return !cancelled && !completed;
    }

    /**
     * 실행 횟수
     */
    public int getExecutionCount() {
        return executionCount;
    }

    // 내부 사용
    void markCompleted() {
        this.completed = true;
    }

    void incrementExecutionCount() {
        this.executionCount++;
    }

    public long getTaskId() {
        return taskId;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        String status = cancelled ? "CANCELLED" : (completed ? "COMPLETED" : "ACTIVE");
        return String.format("TaskHandle[id=%d, name=%s, status=%s, executions=%d]",
                taskId, name, status, executionCount);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\security\ModSignature.java =====

package com.pulse.security;

import com.pulse.api.log.PulseLogger;

/**
 * 모드 서명 및 검증.
 * 모드 JAR의 무결성 확인.
 */
public class ModSignature {

    private final String modId;
    private final String algorithm;
    private final byte[] signature;
    private final String publicKeyId;
    private boolean verified = false;
    private static final String LOG = PulseLogger.PULSE;

    public ModSignature(String modId, String algorithm, byte[] signature, String publicKeyId) {
        this.modId = modId;
        this.algorithm = algorithm;
        this.signature = signature;
        this.publicKeyId = publicKeyId;
    }

    // ─────────────────────────────────────────────────────────────
    // 서명 검증
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 JAR 서명 검증.
     */
    public boolean verify(byte[] jarData) {
        try {
            java.security.Signature sig = java.security.Signature.getInstance(algorithm);

            // 공개 키 로드 (신뢰 저장소에서)
            java.security.PublicKey publicKey = TrustStore.getPublicKey(publicKeyId);
            if (publicKey == null) {
                PulseLogger.error(LOG, "[Security] Unknown public key: {}", publicKeyId);
                return false;
            }

            sig.initVerify(publicKey);
            sig.update(jarData);
            verified = sig.verify(signature);

            if (verified) {
                PulseLogger.info(LOG, "[Security] Signature verified: {}", modId);
            } else {
                PulseLogger.error(LOG, "[Security] Signature verification failed: {}", modId);
            }

            return verified;
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Security] Signature error: {}", e.getMessage());
            return false;
        }
    }

    /**
     * 파일에서 서명 검증.
     */
    public boolean verifyFile(java.io.File jarFile) {
        try {
            byte[] data = java.nio.file.Files.readAllBytes(jarFile.toPath());
            return verify(data);
        } catch (java.io.IOException e) {
            return false;
        }
    }

    // Getters
    public String getModId() {
        return modId;
    }

    public String getAlgorithm() {
        return algorithm;
    }

    public byte[] getSignature() {
        return signature.clone();
    }

    public String getPublicKeyId() {
        return publicKeyId;
    }

    public boolean isVerified() {
        return verified;
    }

    // ─────────────────────────────────────────────────────────────
    // 서명 생성 (개발용)
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 JAR 서명 생성.
     */
    public static ModSignature sign(String modId, byte[] jarData,
            java.security.PrivateKey privateKey, String publicKeyId) {
        try {
            java.security.Signature sig = java.security.Signature.getInstance("SHA256withRSA");
            sig.initSign(privateKey);
            sig.update(jarData);
            byte[] signature = sig.sign();

            return new ModSignature(modId, "SHA256withRSA", signature, publicKeyId);
        } catch (Exception e) {
            PulseLogger.error(LOG, "[Security] Failed to sign: {}", e.getMessage());
            return null;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 신뢰 저장소
    // ─────────────────────────────────────────────────────────────

    public static class TrustStore {
        private static final java.util.Map<String, java.security.PublicKey> keys = new java.util.concurrent.ConcurrentHashMap<>();

        /**
         * 공개 키 등록.
         */
        public static void registerPublicKey(String keyId, java.security.PublicKey key) {
            keys.put(keyId, key);
        }

        /**
         * 공개 키 조회.
         */
        public static java.security.PublicKey getPublicKey(String keyId) {
            return keys.get(keyId);
        }

        /**
         * 파일에서 공개 키 로드.
         */
        public static void loadFromFile(String keyId, java.io.File keyFile) {
            try {
                byte[] keyBytes = java.nio.file.Files.readAllBytes(keyFile.toPath());
                java.security.spec.X509EncodedKeySpec spec = new java.security.spec.X509EncodedKeySpec(keyBytes);
                java.security.KeyFactory kf = java.security.KeyFactory.getInstance("RSA");
                java.security.PublicKey key = kf.generatePublic(spec);
                registerPublicKey(keyId, key);
            } catch (Exception e) {
                PulseLogger.error(LOG, "[Security] Failed to load key: {}", e.getMessage());
            }
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\security\PermissionManager.java =====

package com.pulse.security;

import com.pulse.api.log.PulseLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 모드 권한 관리자.
 * 모드별 권한을 검증하고 관리.
 */
public class PermissionManager {

    private static final PermissionManager INSTANCE = new PermissionManager();

    // modId -> 허용된 권한 세트
    private final Map<String, Set<Permission>> grantedPermissions = new ConcurrentHashMap<>();
    private static final String LOG = PulseLogger.PULSE;

    // 권한별 기본 정책
    private final Map<Permission, PermissionPolicy> defaultPolicies = new EnumMap<>(Permission.class);

    private PermissionManager() {
        // 기본 정책 설정
        for (Permission p : Permission.values()) {
            defaultPolicies.put(p, p.getDefaultPolicy());
        }
    }

    public static PermissionManager getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 권한 검사
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드가 특정 권한을 가지고 있는지 확인.
     */
    public static boolean hasPermission(String modId, Permission permission) {
        return INSTANCE.checkPermission(modId, permission);
    }

    private boolean checkPermission(String modId, Permission permission) {
        // 명시적으로 부여된 권한
        Set<Permission> perms = grantedPermissions.get(modId);
        if (perms != null && perms.contains(permission)) {
            return true;
        }

        // 기본 정책 확인
        PermissionPolicy policy = defaultPolicies.get(permission);
        return policy == PermissionPolicy.ALLOW_ALL;
    }

    /**
     * 권한 검사 및 예외 발생.
     */
    public static void require(String modId, Permission permission) throws SecurityException {
        if (!hasPermission(modId, permission)) {
            throw new SecurityException("Mod '" + modId + "' lacks permission: " + permission);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 권한 부여
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드에 권한 부여.
     */
    public static void grant(String modId, Permission permission) {
        INSTANCE.grantedPermissions
                .computeIfAbsent(modId, k -> ConcurrentHashMap.newKeySet())
                .add(permission);
        PulseLogger.info(LOG, "[Security] Granted {} to {}", permission, modId);
    }

    /**
     * 모드에서 권한 제거.
     */
    public static void revoke(String modId, Permission permission) {
        Set<Permission> perms = INSTANCE.grantedPermissions.get(modId);
        if (perms != null) {
            perms.remove(permission);
        }
    }

    /**
     * 모드의 모든 권한 제거.
     */
    public static void revokeAll(String modId) {
        INSTANCE.grantedPermissions.remove(modId);
    }

    /**
     * pulse.mod.json의 permissions 필드에서 권한 로드.
     */
    public static void loadFromMetadata(String modId, List<String> permissionNames) {
        for (String name : permissionNames) {
            try {
                Permission perm = Permission.valueOf(name.toUpperCase().replace(".", "_"));
                grant(modId, perm);
            } catch (IllegalArgumentException e) {
                PulseLogger.warn(LOG, "[Security] Unknown permission: {}", name);
            }
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 권한 열거형
    // ─────────────────────────────────────────────────────────────

    public enum Permission {
        // 파일 시스템
        FILE_READ(PermissionPolicy.ALLOW_ALL),
        FILE_WRITE(PermissionPolicy.ASK),
        FILE_DELETE(PermissionPolicy.DENY),

        // 네트워크
        NETWORK_CLIENT(PermissionPolicy.ALLOW_ALL),
        NETWORK_SERVER(PermissionPolicy.ASK),
        NETWORK_EXTERNAL(PermissionPolicy.DENY),

        // 시스템
        SYSTEM_EXEC(PermissionPolicy.DENY),
        SYSTEM_CLASSLOADER(PermissionPolicy.DENY),
        SYSTEM_REFLECTION(PermissionPolicy.ASK),

        // 게임
        GAME_WORLD_MODIFY(PermissionPolicy.ALLOW_ALL),
        GAME_PLAYER_DATA(PermissionPolicy.ALLOW_ALL),
        GAME_ADMIN_COMMANDS(PermissionPolicy.ASK),

        // 콘솔 (멀티플레이 보안)
        CONSOLE_ACCESS(PermissionPolicy.ALLOW_ALL), // 기본 콘솔 접근
        CONSOLE_LUA_EXEC(PermissionPolicy.DENY), // Lua 코드 실행 (위험)
        CONSOLE_MOD_MANAGE(PermissionPolicy.DENY), // 모드 reload/disable/enable

        // 모드 간
        MOD_IMC(PermissionPolicy.ALLOW_ALL),
        MOD_ACCESS_INTERNAL(PermissionPolicy.DENY);

        private final PermissionPolicy defaultPolicy;

        Permission(PermissionPolicy defaultPolicy) {
            this.defaultPolicy = defaultPolicy;
        }

        public PermissionPolicy getDefaultPolicy() {
            return defaultPolicy;
        }
    }

    public enum PermissionPolicy {
        ALLOW_ALL, // 항상 허용
        ASK, // 사용자 확인 필요
        DENY // 항상 거부 (명시적 부여 필요)
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\security\SideValidator.java =====

package com.pulse.security;

import com.pulse.api.log.PulseLogger;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModMetadata;

/**
 * 모드 사이드 검증.
 * 서버 전용/클라이언트 전용 모드 구분.
 */
public class SideValidator {

    /**
     * 현재 실행 환경.
     */
    public enum Side {
        CLIENT, // 클라이언트 (싱글 포함)
        SERVER, // 전용 서버
        BOTH // 양쪽 모두
    }

    private static Side currentSide = Side.CLIENT;
    private static final String LOG = PulseLogger.PULSE;

    /**
     * 현재 사이드 설정.
     */
    public static void setCurrentSide(Side side) {
        currentSide = side;
        PulseLogger.info(LOG, "[Side] Running on: {}", side);
    }

    /**
     * 현재 사이드 조회.
     */
    public static Side getCurrentSide() {
        return currentSide;
    }

    public static boolean isClient() {
        return currentSide == Side.CLIENT;
    }

    public static boolean isServer() {
        return currentSide == Side.SERVER;
    }

    /**
     * 모드가 현재 사이드에서 로드 가능한지 확인.
     */
    public static boolean canLoad(ModContainer mod) {
        ModMetadata meta = mod.getMetadata();
        ModSide modSide = getModSide(meta);

        switch (modSide) {
            case CLIENT_ONLY:
                return currentSide == Side.CLIENT;
            case SERVER_ONLY:
                return currentSide == Side.SERVER;
            case BOTH:
            default:
                return true;
        }
    }

    /**
     * 모드 메타데이터에서 사이드 정보 추출.
     */
    private static ModSide getModSide(ModMetadata meta) {
        // 권한 목록에서 사이드 힌트 확인
        for (String perm : meta.getPermissions()) {
            if ("client_only".equalsIgnoreCase(perm)) {
                return ModSide.CLIENT_ONLY;
            }
            if ("server_only".equalsIgnoreCase(perm)) {
                return ModSide.SERVER_ONLY;
            }
        }
        return ModSide.BOTH;
    }

    /**
     * 모드가 잘못된 사이드에서 실행 시 경고.
     */
    public static void warnIfWrongSide(String modId, ModSide requiredSide) {
        boolean valid = true;

        switch (requiredSide) {
            case CLIENT_ONLY:
                valid = currentSide == Side.CLIENT;
                break;
            case SERVER_ONLY:
                valid = currentSide == Side.SERVER;
                break;
            default:
                break;
        }

        if (!valid) {
            PulseLogger.warn(LOG, "[Side] WARNING: Mod '{}' requires {} but running on {}",
                    modId, requiredSide, currentSide);
        }
    }

    public enum ModSide {
        CLIENT_ONLY,
        SERVER_ONLY,
        BOTH
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\service\MixinLogger.java =====

package com.pulse.service;

import com.pulse.api.log.PulseLogger;
import org.spongepowered.asm.logging.ILogger;
import org.spongepowered.asm.logging.Level;

/**
 * Pulse용 Mixin ILogger 구현.
 * Sponge Mixin이 필요로 하는 ILogger 인터페이스 구현체.
 * 
 * Note: com.pulse.api.log.PulseLogger와 구분을 위해 MixinLogger로 명명.
 */
public class MixinLogger implements ILogger {
    private static final String LOG = PulseLogger.PULSE;
    private final String name;

    public MixinLogger(String name) {
        this.name = name;
    }

    @Override
    public String getId() {
        return this.name;
    }

    @Override
    public String getType() {
        return "Pulse";
    }

    public String getName() {
        return this.name;
    }

    private String format(String level, String message, Object... params) {
        String formatted = message;
        if (params != null && params.length > 0) {
            // 간단한 {} 치환
            for (Object param : params) {
                int idx = formatted.indexOf("{}");
                if (idx >= 0) {
                    formatted = formatted.substring(0, idx) + param + formatted.substring(idx + 2);
                }
            }
        }
        return String.format("[Mixin/%s] [%s] %s", level, name, formatted);
    }

    @Override
    public void debug(String message, Object... params) {
        PulseLogger.debug(LOG, format("DEBUG", message, params));
    }

    @Override
    public void debug(String message, Throwable t) {
        PulseLogger.debug(LOG, format("DEBUG", message), t);
    }

    @Override
    public void trace(String message, Object... params) {
        PulseLogger.trace(LOG, format("TRACE", message, params));
    }

    @Override
    public void trace(String message, Throwable t) {
        PulseLogger.trace(LOG, format("TRACE", message), t);
    }

    @Override
    public void info(String message, Object... params) {
        PulseLogger.info(LOG, format("INFO", message, params));
    }

    @Override
    public void info(String message, Throwable t) {
        PulseLogger.info(LOG, format("INFO", message), t);
    }

    @Override
    public void warn(String message, Object... params) {
        PulseLogger.warn(LOG, format("WARN", message, params));
    }

    @Override
    public void warn(String message, Throwable t) {
        PulseLogger.warn(LOG, format("WARN", message), t);
    }

    @Override
    public void error(String message, Object... params) {
        PulseLogger.error(LOG, format("ERROR", message, params));
    }

    @Override
    public void error(String message, Throwable t) {
        PulseLogger.error(LOG, format("ERROR", message), t);
    }

    @Override
    public void fatal(String message, Object... params) {
        PulseLogger.error(LOG, format("FATAL", message, params));
    }

    @Override
    public void fatal(String message, Throwable t) {
        PulseLogger.error(LOG, format("FATAL", message), t);
    }

    @Override
    public void log(Level level, String message, Object... params) {
        switch (level) {
            case DEBUG:
                debug(message, params);
                break;
            case TRACE:
                trace(message, params);
                break;
            case INFO:
                info(message, params);
                break;
            case WARN:
                warn(message, params);
                break;
            case ERROR:
                error(message, params);
                break;
            case FATAL:
                fatal(message, params);
                break;
            default:
                info(message, params);
        }
    }

    @Override
    public void log(Level level, String message, Throwable t) {
        switch (level) {
            case DEBUG:
                debug(message, t);
                break;
            case TRACE:
                trace(message, t);
                break;
            case INFO:
                info(message, t);
                break;
            case WARN:
                warn(message, t);
                break;
            case ERROR:
                error(message, t);
                break;
            case FATAL:
                fatal(message, t);
                break;
            default:
                info(message, t);
        }
    }

    @Override
    public <T extends Throwable> T throwing(T t) {
        error("Throwing", t);
        return t;
    }

    @Override
    public void catching(Throwable t) {
        catching(Level.ERROR, t);
    }

    @Override
    public void catching(Level level, Throwable t) {
        log(level, "Catching exception: " + t.getClass().getName(), t);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\service\ProviderRegistry.java =====

package com.pulse.service;

import com.pulse.api.log.PulseLogger;
import com.pulse.api.spi.*;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * IProviderRegistry 구현체.
 * 모든 SPI 프로바이더를 관리하는 중앙 레지스트리.
 */
public class ProviderRegistry implements IProviderRegistry {

    private static final String LOG = PulseLogger.PULSE;
    private static final ProviderRegistry INSTANCE = new ProviderRegistry();

    private final Map<String, IProvider> providersById = new ConcurrentHashMap<>();
    private final List<IProviderCallback> callbacks = new ArrayList<>();
    private final Map<String, ProviderLifecycle> lifecycles = new ConcurrentHashMap<>();

    private ProviderRegistry() {
    }

    public static ProviderRegistry getInstance() {
        return INSTANCE;
    }

    @Override
    public <T extends IProvider> void register(T provider) {
        if (provider == null) {
            throw new IllegalArgumentException("Provider cannot be null");
        }

        String id = provider.getId();
        if (providersById.containsKey(id)) {
            PulseLogger.warn(LOG, "Provider already registered: {}", id);
            return;
        }

        providersById.put(id, provider);
        lifecycles.put(id, ProviderLifecycle.REGISTERED);

        PulseLogger.info(LOG, "Registered provider: {} ({}) v{}",
                provider.getName(), id, provider.getVersion());

        // 콜백 알림
        for (IProviderCallback callback : callbacks) {
            try {
                callback.onProviderRegistered(provider);
            } catch (Exception e) {
                PulseLogger.error(LOG, "Callback error: {}", e.getMessage());
            }
        }

        // 초기화
        initializeProvider(provider);
    }

    private void initializeProvider(IProvider provider) {
        String id = provider.getId();
        try {
            updateLifecycle(provider, ProviderLifecycle.INITIALIZING);
            provider.onInitialize();
            updateLifecycle(provider, ProviderLifecycle.ACTIVE);
            PulseLogger.info(LOG, "Provider initialized: {}", id);
        } catch (Exception e) {
            updateLifecycle(provider, ProviderLifecycle.ERROR);
            PulseLogger.error(LOG, "Failed to initialize provider {}: {}", id, e.getMessage());
            notifyError(provider, e);
        }
    }

    @Override
    public void unregister(String providerId) {
        IProvider provider = providersById.remove(providerId);
        if (provider != null) {
            try {
                updateLifecycle(provider, ProviderLifecycle.SHUTTING_DOWN);
                provider.onShutdown();
                updateLifecycle(provider, ProviderLifecycle.TERMINATED);
            } catch (Exception e) {
                PulseLogger.error(LOG, "Error during shutdown: {}", e.getMessage());
            }

            lifecycles.remove(providerId);
            PulseLogger.info(LOG, "Unregistered provider: {}", providerId);

            for (IProviderCallback callback : callbacks) {
                try {
                    callback.onProviderUnregistered(provider);
                } catch (Exception e) {
                    PulseLogger.error(LOG, "Callback error: {}", e.getMessage());
                }
            }
        }
    }

    @Override
    public Optional<IProvider> getProvider(String providerId) {
        return Optional.ofNullable(providersById.get(providerId));
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T extends IProvider> Optional<T> getProvider(Class<T> type) {
        return providersById.values().stream()
                .filter(p -> type.isAssignableFrom(p.getClass()))
                .filter(IProvider::isEnabled)
                .max(Comparator.comparingInt(IProvider::getPriority))
                .map(p -> (T) p);
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T extends IProvider> Collection<T> getProviders(Class<T> type) {
        return providersById.values().stream()
                .filter(p -> type.isAssignableFrom(p.getClass()))
                .filter(IProvider::isEnabled)
                .sorted((a, b) -> Integer.compare(b.getPriority(), a.getPriority()))
                .map(p -> (T) p)
                .collect(Collectors.toList());
    }

    @Override
    public Collection<IProvider> getAllProviders() {
        return Collections.unmodifiableCollection(providersById.values());
    }

    @Override
    public boolean isRegistered(String providerId) {
        return providersById.containsKey(providerId);
    }

    @Override
    public <T extends IProvider> boolean hasProvider(Class<T> type) {
        return providersById.values().stream()
                .anyMatch(p -> type.isAssignableFrom(p.getClass()) && p.isEnabled());
    }

    // --- 추가 기능 ---

    /**
     * 콜백 등록
     */
    public void addCallback(IProviderCallback callback) {
        if (callback != null && !callbacks.contains(callback)) {
            callbacks.add(callback);
        }
    }

    /**
     * 콜백 해제
     */
    public void removeCallback(IProviderCallback callback) {
        callbacks.remove(callback);
    }

    /**
     * 프로바이더 생명주기 조회
     */
    public ProviderLifecycle getLifecycle(String providerId) {
        return lifecycles.getOrDefault(providerId, ProviderLifecycle.TERMINATED);
    }

    /**
     * 모든 프로바이더 종료
     */
    public void shutdownAll() {
        PulseLogger.info(LOG, "Shutting down all providers...");
        for (String id : new ArrayList<>(providersById.keySet())) {
            unregister(id);
        }
    }

    private void updateLifecycle(IProvider provider, ProviderLifecycle newState) {
        String id = provider.getId();
        ProviderLifecycle oldState = lifecycles.get(id);
        lifecycles.put(id, newState);

        for (IProviderCallback callback : callbacks) {
            try {
                callback.onLifecycleChanged(provider, oldState, newState);
            } catch (Exception e) {
                PulseLogger.error(LOG, "Callback error: {}", e.getMessage());
            }
        }
    }

    private void notifyError(IProvider provider, Throwable error) {
        for (IProviderCallback callback : callbacks) {
            try {
                callback.onProviderError(provider, error);
            } catch (Exception e) {
                PulseLogger.error(LOG, "Callback error: {}", e.getMessage());
            }
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\service\PulseClassTracker.java =====

package com.pulse.service;

import org.spongepowered.asm.service.IClassTracker;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * 클래스 로딩 상태를 추적하는 서비스.
 */
public class PulseClassTracker implements IClassTracker {

    private final Set<String> loadedClasses = Collections.synchronizedSet(new HashSet<>());
    private final Set<String> invalidClasses = Collections.synchronizedSet(new HashSet<>());

    // IClassTracker 메서드들 - @Override 없이 구현
    
    public void registerClass(String name) {
        loadedClasses.add(name);
    }

    public boolean isClassLoaded(String name) {
        return loadedClasses.contains(name);
    }

    public String getClassRestrictions(String className) {
        if (loadedClasses.contains(className)) {
            return "already loaded";
        }
        if (invalidClasses.contains(className)) {
            return "invalid class";
        }
        return "";
    }

    public void registerInvalidClass(String name) {
        invalidClasses.add(name);
    }

    // Pulse 내부용 메서드
    
    public Set<String> getLoadedClasses() {
        return Collections.unmodifiableSet(loadedClasses);
    }

    public int countLoadedWithPrefix(String prefix) {
        return (int) loadedClasses.stream()
            .filter(n -> n.startsWith(prefix))
            .count();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\service\PulseDefineClassTransformer.java =====

package com.pulse.service;

import com.pulse.api.log.PulseLogger;
import com.pulse.PulseEnvironment;

import java.lang.instrument.ClassFileTransformer;
import java.security.ProtectionDomain;

public class PulseDefineClassTransformer implements ClassFileTransformer {
    private static final String LOG = PulseLogger.PULSE;

    @Override
    public byte[] transform(
            Module module,
            ClassLoader loader,
            String className,
            Class<?> classBeingRedefined,
            ProtectionDomain protectionDomain,
            byte[] classfileBuffer) {

        // defineClass가 호출될 때 className은 null일 수 있다.
        if (className == null || loader == null)
            return null;

        // convert name style: "zombie/characters/IsoZombie"
        if (className.startsWith("zombie/")) {

            PulseLogger.info(LOG, "ClassLoader has loaded zombie class: {}", className);
            PulseLogger.info(LOG, "Registering Game ClassLoader: {}", loader);

            PulseEnvironment.setGameClassLoader(loader);

            // Once captured, we do NOT want to override or modify class bytes
            return null;
        }

        return null;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\service\PulseGameClassTracker.java =====

package com.pulse.service;

import com.pulse.api.log.PulseLogger;
import com.pulse.PulseEnvironment;

import java.lang.instrument.ClassFileTransformer;
import java.security.ProtectionDomain;

public class PulseGameClassTracker implements ClassFileTransformer {
    private static final String LOG = PulseLogger.PULSE;

    @Override
    public byte[] transform(
            Module module,
            ClassLoader loader,
            String className,
            Class<?> classBeingRedefined,
            ProtectionDomain protectionDomain,
            byte[] classfileBuffer) {
        // 예: className = "zombie/characters/IsoZombie"
        if (className != null && loader != null && className.startsWith("zombie/")) {
            PulseLogger.info(LOG, "[TRACKER] Detected zombie class: {}", className);
            PulseLogger.info(LOG, "[TRACKER] Loader: {}", loader);

            // 실제 게임 클래스 로더 등록
            PulseEnvironment.setGameClassLoader(loader);
        }

        // 클래스 바이트코드는 건드리지 않는다
        return null;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\service\PulseGlobalPropertyService.java =====

package com.pulse.service;

import org.spongepowered.asm.service.IGlobalPropertyService;
import org.spongepowered.asm.service.IPropertyKey;

import java.util.HashMap;
import java.util.Map;

/**
 * Mixin 전역 프로퍼티 서비스.
 * Mixin 시스템 전체에서 공유되는 설정값을 관리.
 */
public class PulseGlobalPropertyService implements IGlobalPropertyService {

    private final Map<String, Object> properties = new HashMap<>();

    public PulseGlobalPropertyService() {
        // 기본 프로퍼티 설정
        properties.put("mixin.debug", true);
        properties.put("mixin.env.disableRefMap", true);
    }

    @Override
    public IPropertyKey resolveKey(String name) {
        return new StringPropertyKey(name);
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> T getProperty(IPropertyKey key) {
        return (T) properties.get(key.toString());
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> T getProperty(IPropertyKey key, T defaultValue) {
        Object value = properties.get(key.toString());
        return value != null ? (T) value : defaultValue;
    }

    @Override
    public void setProperty(IPropertyKey key, Object value) {
        properties.put(key.toString(), value);
    }

    @Override
    public String getPropertyString(IPropertyKey key, String defaultValue) {
        Object value = properties.get(key.toString());
        return value != null ? value.toString() : defaultValue;
    }

    // 내부 키 구현
    private static class StringPropertyKey implements IPropertyKey {
        private final String key;

        StringPropertyKey(String key) {
            this.key = key;
        }

        @Override
        public String toString() {
            return key;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            return key.equals(((StringPropertyKey) o).key);
        }

        @Override
        public int hashCode() {
            return key.hashCode();
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\service\PulseMixinService.java =====

package com.pulse.service;

import com.pulse.api.log.PulseLogger;
import com.pulse.PulseEnvironment;
import org.spongepowered.asm.launch.platform.container.ContainerHandleVirtual;
import org.spongepowered.asm.launch.platform.container.IContainerHandle;
import org.spongepowered.asm.logging.ILogger;
import org.spongepowered.asm.mixin.MixinEnvironment.CompatibilityLevel;
import org.spongepowered.asm.mixin.MixinEnvironment.Phase;
import org.spongepowered.asm.mixin.transformer.IMixinTransformer;
import org.spongepowered.asm.mixin.transformer.IMixinTransformerFactory;
import org.spongepowered.asm.service.*;
import org.spongepowered.asm.util.ReEntranceLock;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Collection;
import java.util.Collections;

/**
 * Pulse의 핵심 Mixin 서비스 구현.
 * 
 * Sponge Mixin이 필요로 하는 모든 인터페이스를 구현:
 * - IMixinService: 메인 서비스 인터페이스
 * - IClassProvider: 클래스 로딩
 * - IClassBytecodeProvider: 바이트코드 접근
 */
public class PulseMixinService implements IMixinService, IClassProvider, IClassBytecodeProvider {

    private static final String LOG = PulseLogger.PULSE;

    private final ReEntranceLock lock = new ReEntranceLock(1);
    private final PulseTransformerProvider transformerProvider = new PulseTransformerProvider();
    private final PulseClassTracker classTracker = new PulseClassTracker();

    // Mixin이 생성한 transformer (offer()를 통해 전달됨)
    private IMixinTransformer mixinTransformer;
    private IMixinTransformerFactory transformerFactory;

    // Primary container (이 JAR 자체)
    private IContainerHandle primaryContainer;

    public PulseMixinService() {
        PulseLogger.debug(LOG, "PulseMixinService instantiated");
    }

    // --- ClassLoader Management ---

    private ClassLoader getEffectiveClassLoader() {
        // 1순위: 게임 클래스 로더
        ClassLoader gameLoader = PulseEnvironment.getGameClassLoader();
        if (gameLoader != null) {
            return gameLoader;
        }

        // 2순위: 현재 컨텍스트 클래스 로더
        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
        if (contextLoader != null) {
            return contextLoader;
        }

        // 3순위: 시스템 클래스 로더
        return ClassLoader.getSystemClassLoader();
    }

    // --- IMixinService ---

    @Override
    public String getName() {
        return "Pulse";
    }

    @Override
    public boolean isValid() {
        return true;
    }

    @Override
    public void prepare() {
        PulseLogger.debug(LOG, "prepare() called");
    }

    @Override
    public Phase getInitialPhase() {
        return Phase.PREINIT;
    }

    @Override
    public void offer(IMixinInternal internal) {
        PulseLogger.debug(LOG, "offer() called with: {}",
                (internal != null ? internal.getClass().getName() : "null"));

        if (internal instanceof IMixinTransformerFactory) {
            this.transformerFactory = (IMixinTransformerFactory) internal;
            PulseLogger.info(LOG, "Received IMixinTransformerFactory");

            // Transformer 생성
            try {
                this.mixinTransformer = transformerFactory.createTransformer();
                PulseLogger.info(LOG, "Created IMixinTransformer: {}",
                        (mixinTransformer != null ? mixinTransformer.getClass().getName() : "null"));

                // PulseEnvironment에 저장하여 외부에서 접근 가능하게 함
                PulseEnvironment.setMixinTransformer(mixinTransformer);

            } catch (Exception e) {
                PulseLogger.error(LOG, "Failed to create transformer: {}", e.getMessage());
                e.printStackTrace();
            }
        }
    }

    @Override
    public void init() {
        PulseLogger.debug(LOG, "init() called");
    }

    @Override
    public void beginPhase() {
        PulseLogger.debug(LOG, "beginPhase() called");
    }

    @Override
    public void checkEnv(Object bootSource) {
        PulseLogger.debug(LOG, "checkEnv() called");
    }

    @Override
    public ReEntranceLock getReEntranceLock() {
        return this.lock;
    }

    @Override
    public IClassProvider getClassProvider() {
        return this;
    }

    @Override
    public IClassBytecodeProvider getBytecodeProvider() {
        return this;
    }

    @Override
    public ITransformerProvider getTransformerProvider() {
        return this.transformerProvider;
    }

    @Override
    public IClassTracker getClassTracker() {
        return this.classTracker;
    }

    @Override
    public IMixinAuditTrail getAuditTrail() {
        // 감사 추적은 선택사항
        return null;
    }

    @Override
    public Collection<String> getPlatformAgents() {
        // Platform agent 클래스 이름들
        // 필요시 PulsePlatformAgent 구현 가능
        return Collections.singletonList("com.pulse.service.PulsePlatformAgent");
    }

    @Override
    public String getSideName() {
        return "CLIENT";
    }

    @Override
    public IContainerHandle getPrimaryContainer() {
        if (primaryContainer == null) {
            try {
                // 이 클래스가 포함된 JAR/폴더의 위치
                URL location = getClass().getProtectionDomain().getCodeSource().getLocation();
                primaryContainer = new ContainerHandleVirtual(getName());
                PulseLogger.debug(LOG, "Primary container location: {}", location);
            } catch (Exception e) {
                primaryContainer = new ContainerHandleVirtual(getName());
            }
        }
        return primaryContainer;
    }

    @Override
    public Collection<IContainerHandle> getMixinContainers() {
        // Mixin config를 포함하는 컨테이너들
        // 현재는 primary container만 반환
        return Collections.singletonList(getPrimaryContainer());
    }

    @Override
    public InputStream getResourceAsStream(String name) {
        PulseLogger.trace(LOG, "getResourceAsStream() called for: {}", name);

        ClassLoader cl = getEffectiveClassLoader();
        PulseLogger.trace(LOG, "  - Using ClassLoader: {}", cl.getClass().getName());

        // 여러 경로 시도
        InputStream is = cl.getResourceAsStream(name);
        PulseLogger.trace(LOG, "  - Try 1 (direct): {}", (is != null ? "FOUND" : "not found"));

        if (is == null) {
            // 슬래시로 시작하는 경로 시도
            is = cl.getResourceAsStream("/" + name);
            PulseLogger.trace(LOG, "  - Try 2 (with /): {}", (is != null ? "FOUND" : "not found"));
        }

        if (is == null) {
            // 이 클래스의 클래스로더에서 시도
            is = getClass().getClassLoader().getResourceAsStream(name);
            PulseLogger.trace(LOG, "  - Try 3 (service classloader): {}", (is != null ? "FOUND" : "not found"));
        }

        if (is == null) {
            // 시스템 클래스로더에서 시도
            is = ClassLoader.getSystemClassLoader().getResourceAsStream(name);
            PulseLogger.trace(LOG, "  - Try 4 (system classloader): {}", (is != null ? "FOUND" : "not found"));
        }

        if (is == null) {
            PulseLogger.warn(LOG, "  - FAILED to find resource: {}", name);
        } else {
            PulseLogger.trace(LOG, "  - SUCCESS: Found resource: {}", name);
        }

        return is;
    }

    @Override
    public CompatibilityLevel getMinCompatibilityLevel() {
        return CompatibilityLevel.JAVA_8;
    }

    @Override
    public CompatibilityLevel getMaxCompatibilityLevel() {
        return CompatibilityLevel.JAVA_17;
    }

    @Override
    public ILogger getLogger(String name) {
        return new MixinLogger(name);
    }

    // --- IClassProvider ---

    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {
        return findClass(name, true);
    }

    @Override
    public Class<?> findClass(String name, boolean initialize) throws ClassNotFoundException {
        classTracker.registerClass(name);
        return Class.forName(name, initialize, getEffectiveClassLoader());
    }

    @Override
    public Class<?> findAgentClass(String name, boolean initialize) throws ClassNotFoundException {
        // Agent 클래스는 시스템 클래스로더에서 로드
        return Class.forName(name, initialize, ClassLoader.getSystemClassLoader());
    }

    @Override
    public URL[] getClassPath() {
        // 클래스패스 URL 배열 반환
        // Java 9+에서는 모듈 시스템 때문에 복잡해질 수 있음
        return new URL[0];
    }

    // --- IClassBytecodeProvider ---

    @Override
    public ClassNode getClassNode(String name) throws ClassNotFoundException, IOException {
        return getClassNode(name, true);
    }

    @Override
    public ClassNode getClassNode(String name, boolean runTransformers)
            throws ClassNotFoundException, IOException {

        String resourceName = name.replace('.', '/') + ".class";
        InputStream is = getResourceAsStream(resourceName);

        if (is == null) {
            throw new ClassNotFoundException("Cannot find class bytecode: " + name +
                    " (resource: " + resourceName + ")");
        }

        try {
            ClassReader reader = new ClassReader(is);
            ClassNode node = new ClassNode();
            reader.accept(node, ClassReader.EXPAND_FRAMES);
            return node;
        } finally {
            is.close();
        }
    }

    // --- Pulse Methods ---

    /**
     * Mixin transformer 반환 (PulseClassTransformer에서 사용)
     */
    public IMixinTransformer getMixinTransformer() {
        return this.mixinTransformer;
    }

    /**
     * ClassTracker 반환 (디버깅/모니터링용)
     */
    public PulseClassTracker getClassTrackerInstance() {
        return this.classTracker;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\service\PulseMixinServiceBootstrap.java =====

package com.pulse.service;

import com.pulse.api.log.PulseLogger;
import org.spongepowered.asm.service.IMixinServiceBootstrap;

/**
 * Mixin 서비스 부트스트랩.
 * Sponge Mixin이 서비스를 초기화할 때 가장 먼저 호출됨.
 * 
 * ServiceLoader를 통해 자동 발견됨:
 * META-INF/services/org.spongepowered.asm.service.IMixinServiceBootstrap
 */
public class PulseMixinServiceBootstrap implements IMixinServiceBootstrap {
    private static final String LOG = PulseLogger.PULSE;

    @Override
    public String getName() {
        return "Pulse";
    }

    @Override
    public String getServiceClassName() {
        return "com.pulse.service.PulseMixinService";
    }

    @Override
    public void bootstrap() {
        PulseLogger.info(LOG, "[Bootstrap] Mixin service bootstrap initiated");

        // 환경 준비 작업
        // 예: 시스템 프로퍼티 설정, 초기 상태 구성 등

        PulseLogger.info(LOG, "[Bootstrap] Bootstrap complete");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\service\PulsePlatformAgent.java =====

package com.pulse.service;

import com.pulse.api.log.PulseLogger;
import org.spongepowered.asm.launch.platform.MixinPlatformAgentAbstract;
import org.spongepowered.asm.launch.platform.container.IContainerHandle;

/**
 * Mixin Platform Agent.
 */
public class PulsePlatformAgent extends MixinPlatformAgentAbstract {
    private static final String LOG = PulseLogger.PULSE;

    public AcceptResult accept(IContainerHandle root, String className) {
        if (className != null && className.startsWith("com.pulse.")) {
            return AcceptResult.ACCEPTED;
        }
        return AcceptResult.REJECTED;
    }

    public String getPhaseProvider() {
        return null;
    }

    public void prepare() {
        PulseLogger.info(LOG, "[PlatformAgent] prepare()");
    }

    public void initPrimaryContainer() {
        PulseLogger.info(LOG, "[PlatformAgent] initPrimaryContainer()");
    }

    public void inject() {
        PulseLogger.info(LOG, "[PlatformAgent] inject()");
    }

    public String getLaunchTarget() {
        return null;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\service\PulseTransformerProvider.java =====

package com.pulse.service;

import com.pulse.api.log.PulseLogger;
import org.spongepowered.asm.service.ITransformer;
import org.spongepowered.asm.service.ITransformerProvider;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * Mixin에게 transformer 정보를 제공하는 서비스.
 * 
 * Sponge Mixin은 이 provider를 통해:
 * 1. 기존 transformer들의 존재를 인식
 * 2. transformer 제외 규칙을 관리
 * 3. delegated transformer를 통한 체이닝 지원
 */
public class PulseTransformerProvider implements ITransformerProvider {

    private static final String LOG = PulseLogger.PULSE;
    private final List<ITransformer> transformers = new ArrayList<>();
    private final List<ITransformer> delegatedTransformers = new ArrayList<>();
    private final List<String> exclusions = new ArrayList<>();

    public PulseTransformerProvider() {
        // 기본 제외 패턴
        exclusions.add("java.");
        exclusions.add("javax.");
        exclusions.add("sun.");
        exclusions.add("com.pulse.mixin."); // Mixin 클래스 자체는 제외
    }

    @Override
    public Collection<ITransformer> getTransformers() {
        return Collections.unmodifiableList(transformers);
    }

    @Override
    public Collection<ITransformer> getDelegatedTransformers() {
        return Collections.unmodifiableList(delegatedTransformers);
    }

    @Override
    public void addTransformerExclusion(String name) {
        if (name != null && !name.isEmpty()) {
            exclusions.add(name);
            PulseLogger.info(LOG, "[TransformerProvider] Added exclusion: {}", name);
        }
    }

    /**
     * transformer 등록 (Pulse 내부용)
     */
    public void registerTransformer(ITransformer transformer) {
        if (transformer != null) {
            transformers.add(transformer);
            PulseLogger.info(LOG, "[TransformerProvider] Registered transformer: {}", transformer.getClass().getName());
        }
    }

    /**
     * 클래스가 제외 대상인지 확인
     */
    public boolean isExcluded(String className) {
        for (String exclusion : exclusions) {
            if (className.startsWith(exclusion)) {
                return true;
            }
        }
        return false;
    }

    public List<String> getExclusions() {
        return Collections.unmodifiableList(exclusions);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\test\Assertions.java =====

package com.pulse.test;

/**
 * 테스트 어설션.
 */
public class Assertions {

    public static void assertTrue(boolean condition) {
        if (!condition) {
            throw new AssertionError("Expected true but was false");
        }
    }

    public static void assertTrue(boolean condition, String message) {
        if (!condition) {
            throw new AssertionError(message);
        }
    }

    public static void assertFalse(boolean condition) {
        if (condition) {
            throw new AssertionError("Expected false but was true");
        }
    }

    public static void assertFalse(boolean condition, String message) {
        if (condition) {
            throw new AssertionError(message);
        }
    }

    public static void assertEquals(Object expected, Object actual) {
        if (!java.util.Objects.equals(expected, actual)) {
            throw new AssertionError("Expected: " + expected + " but was: " + actual);
        }
    }

    public static void assertEquals(Object expected, Object actual, String message) {
        if (!java.util.Objects.equals(expected, actual)) {
            throw new AssertionError(message + " - Expected: " + expected + " but was: " + actual);
        }
    }

    public static void assertNotEquals(Object unexpected, Object actual) {
        if (java.util.Objects.equals(unexpected, actual)) {
            throw new AssertionError("Expected not equal to: " + unexpected);
        }
    }

    public static void assertNull(Object obj) {
        if (obj != null) {
            throw new AssertionError("Expected null but was: " + obj);
        }
    }

    public static void assertNotNull(Object obj) {
        if (obj == null) {
            throw new AssertionError("Expected not null");
        }
    }

    public static void assertNotNull(Object obj, String message) {
        if (obj == null) {
            throw new AssertionError(message);
        }
    }

    public static <T extends Throwable> T assertThrows(Class<T> expectedType, Runnable executable) {
        try {
            executable.run();
            throw new AssertionError("Expected " + expectedType.getSimpleName() + " to be thrown");
        } catch (Throwable t) {
            if (expectedType.isInstance(t)) {
                return expectedType.cast(t);
            }
            throw new AssertionError("Expected " + expectedType.getSimpleName() +
                    " but was " + t.getClass().getSimpleName());
        }
    }

    public static void fail() {
        throw new AssertionError("Test failed");
    }

    public static void fail(String message) {
        throw new AssertionError(message);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\test\TestRunner.java =====

package com.pulse.test;

import com.pulse.api.log.PulseLogger;
import java.lang.reflect.*;
import java.util.*;

/**
 * 헤드리스 테스트 러너.
 * 게임 없이 모드 코드 테스트.
 */
public class TestRunner {

    private static final TestRunner INSTANCE = new TestRunner();
    private static final String LOG = PulseLogger.PULSE;

    private final List<TestResult> results = new ArrayList<>();
    private int passed = 0;
    private int failed = 0;

    private TestRunner() {
    }

    public static TestRunner getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 테스트 실행
    // ─────────────────────────────────────────────────────────────

    /**
     * 테스트 클래스 실행.
     */
    public static void run(Class<?> testClass) {
        INSTANCE.runClass(testClass);
    }

    private void runClass(Class<?> testClass) {
        PulseLogger.info(LOG, "\n═══════════════════════════════════════");
        PulseLogger.info(LOG, "  Running: {}", testClass.getSimpleName());
        PulseLogger.info(LOG, "═══════════════════════════════════════");

        Object instance = null;
        try {
            instance = testClass.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            PulseLogger.error(LOG, "Failed to instantiate test class: {}", e.getMessage());
            return;
        }

        // @BeforeAll
        invokeAnnotatedMethods(testClass, instance, BeforeAll.class, true);

        // 테스트 메서드 실행
        for (Method method : testClass.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Test.class)) {
                // @BeforeEach
                invokeAnnotatedMethods(testClass, instance, BeforeEach.class, false);

                runTest(instance, method);

                // @AfterEach
                invokeAnnotatedMethods(testClass, instance, AfterEach.class, false);
            }
        }

        // @AfterAll
        invokeAnnotatedMethods(testClass, instance, AfterAll.class, true);

        printSummary();
    }

    private void runTest(Object instance, Method method) {
        String testName = method.getDeclaringClass().getSimpleName() + "." + method.getName();
        long startTime = System.nanoTime();

        try {
            method.setAccessible(true);
            method.invoke(instance);

            long duration = (System.nanoTime() - startTime) / 1_000_000;
            passed++;
            results.add(new TestResult(testName, true, duration, null));
            PulseLogger.info(LOG, "  ✓ {} ({}ms)", method.getName(), duration);

        } catch (InvocationTargetException e) {
            long duration = (System.nanoTime() - startTime) / 1_000_000;
            Throwable cause = e.getCause();
            failed++;
            results.add(new TestResult(testName, false, duration, cause));
            results.add(new TestResult(testName, false, duration, cause));
            PulseLogger.info(LOG, "  ✗ {} - {}", method.getName(), cause.getMessage());
        } catch (Exception e) {
            failed++;
            results.add(new TestResult(testName, false, 0, e));
            results.add(new TestResult(testName, false, 0, e));
            PulseLogger.info(LOG, "  ✗ {} - {}", method.getName(), e.getMessage());
        }
    }

    private void invokeAnnotatedMethods(Class<?> clazz, Object instance,
            Class<? extends java.lang.annotation.Annotation> annotation, boolean isStatic) {
        for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(annotation)) {
                try {
                    method.setAccessible(true);
                    method.invoke(isStatic && Modifier.isStatic(method.getModifiers()) ? null : instance);
                } catch (Exception e) {
                    PulseLogger.error(LOG, "Setup/Teardown failed: {}", e.getMessage());
                }
            }
        }
    }

    private void printSummary() {
        PulseLogger.info(LOG, "───────────────────────────────────────");
        PulseLogger.info(LOG, "  Results: {} passed, {} failed", passed, failed);
        PulseLogger.info(LOG, "═══════════════════════════════════════\n");
    }

    /**
     * 모든 테스트 결과 초기화.
     */
    public static void reset() {
        INSTANCE.results.clear();
        INSTANCE.passed = 0;
        INSTANCE.failed = 0;
    }

    /**
     * 테스트 결과 조회.
     */
    public static List<TestResult> getResults() {
        return new ArrayList<>(INSTANCE.results);
    }

    // ─────────────────────────────────────────────────────────────
    // 테스트 결과
    // ─────────────────────────────────────────────────────────────

    public static class TestResult {
        public final String testName;
        public final boolean passed;
        public final long durationMs;
        public final Throwable error;

        TestResult(String testName, boolean passed, long durationMs, Throwable error) {
            this.testName = testName;
            this.passed = passed;
            this.durationMs = durationMs;
            this.error = error;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 어노테이션
    // ─────────────────────────────────────────────────────────────

    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
    @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD)
    public @interface Test {
    }

    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
    @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD)
    public @interface BeforeEach {
    }

    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
    @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD)
    public @interface AfterEach {
    }

    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
    @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD)
    public @interface BeforeAll {
    }

    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
    @java.lang.annotation.Target(java.lang.annotation.ElementType.METHOD)
    public @interface AfterAll {
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\transformer\PulseClassTransformer.java =====

package com.pulse.transformer;

import com.pulse.api.log.PulseLogger;
import com.pulse.PulseEnvironment;
import com.pulse.mixin.MixinDiagnostics;
import org.spongepowered.asm.mixin.MixinEnvironment;
import org.spongepowered.asm.mixin.transformer.IMixinTransformer;

import java.lang.instrument.ClassFileTransformer;
import java.security.ProtectionDomain;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Pulse의 핵심 클래스 트랜스포머.
 * Java Instrumentation API와 Sponge Mixin을 연결한다.
 *
 * 역할:
 * 1. zombie.* 클래스 로딩을 감지
 * 2. Mixin 변환을 적용
 * 3. 향후 추가될 다른 transformer들과 체이닝
 */
public class PulseClassTransformer implements ClassFileTransformer {

    private static final String LOG = PulseLogger.PULSE;

    private final Set<String> transformedClasses = ConcurrentHashMap.newKeySet();
    private final Set<String> excludedPrefixes = ConcurrentHashMap.newKeySet();

    private IMixinTransformer mixinTransformer;
    private boolean mixinReady = false;

    public PulseClassTransformer() {
        // Mixin 적용 제외 패키지
        excludedPrefixes.add("java/");
        excludedPrefixes.add("javax/");
        excludedPrefixes.add("sun/");
        excludedPrefixes.add("jdk/");
        excludedPrefixes.add("com.pulse/");
        excludedPrefixes.add("org/spongepowered/");
        excludedPrefixes.add("org/objectweb/asm/");
    }

    /**
     * Mixin Transformer를 연결한다.
     * MixinBootstrap.init() 이후에 호출되어야 함.
     */
    public void connectMixinTransformer(IMixinTransformer transformer) {
        this.mixinTransformer = transformer;
        this.mixinReady = (transformer != null);

        if (mixinReady) {
            PulseLogger.info(LOG, "Mixin transformer connected successfully");
        } else {
            PulseLogger.warn(LOG, "WARNING: Mixin transformer is null!");
        }
    }

    @Override
    public byte[] transform(
            ClassLoader loader,
            String className,
            Class<?> classBeingRedefined,
            ProtectionDomain protectionDomain,
            byte[] classfileBuffer) {
        if (className == null || classfileBuffer == null) {
            return null;
        }

        // 제외 패키지 체크
        for (String prefix : excludedPrefixes) {
            if (className.startsWith(prefix)) {
                return null;
            }
        }

        // Game ClassLoader 등록 (최초 zombie 클래스 발견 시)
        if (className.startsWith("zombie/") && loader != null) {
            if (PulseEnvironment.getGameClassLoader() == null) {
                PulseEnvironment.setGameClassLoader(loader);
            }
        }

        // Mixin 변환 적용
        byte[] transformed = applyMixinTransform(className, classfileBuffer);

        return transformed;
    }

    // Java 9+ module-aware 버전
    @Override
    public byte[] transform(
            Module module,
            ClassLoader loader,
            String className,
            Class<?> classBeingRedefined,
            ProtectionDomain protectionDomain,
            byte[] classfileBuffer) {
        return transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);
    }

    private byte[] applyMixinTransform(String className, byte[] classfileBuffer) {
        if (!mixinReady || mixinTransformer == null) {
            return null;
        }

        // Mixin 대상 패키지: zombie, se.krka.kahlua (Lua VM)
        boolean isTargetPackage = className.startsWith("zombie/") ||
                className.startsWith("se/krka/kahlua/");
        if (!isTargetPackage) {
            return null;
        }

        String dotName = className.replace('/', '.');

        try {
            // Mixin 환경 가져오기
            MixinEnvironment env = MixinEnvironment.getDefaultEnvironment();

            long startTime = System.nanoTime();

            // 변환 수행
            byte[] result = mixinTransformer.transformClass(env, dotName, classfileBuffer);

            if (result != null && result != classfileBuffer) {
                long elapsedMs = (System.nanoTime() - startTime) / 1_000_000;

                transformedClasses.add(dotName);

                // MixinDiagnostics 연동
                MixinDiagnostics.getInstance().recordMixinApplied(
                        dotName, "PulseTransformer", "pulse", 1000);

                // MixinInjectionValidator 성공 기록
                com.pulse.api.mixin.MixinInjectionValidator.recordSuccess(
                        "PulseTransformer", dotName, elapsedMs);

                PulseLogger.debug(LOG, "✓ Mixin applied to: {}", dotName);
                return result;
            }

        } catch (Throwable t) {
            // Fail-soft 처리 - 실패해도 게임 계속
            MixinDiagnostics.getInstance().recordMixinFailed(
                    "Unknown", "pulse", dotName, t.getMessage());

            // MixinInjectionValidator 실패 기록
            com.pulse.api.mixin.MixinInjectionValidator.recordFailure(
                    "PulseTransformer", dotName, t.getMessage());

            // FailsoftPolicy로 처리 (크래시 대신 경고)
            com.pulse.api.FailsoftPolicy.handleMixinFailure(
                    "PulseTransformer", dotName, t);

            PulseLogger.warn(LOG, "Error transforming: {} (fail-soft applied)", dotName);
        }

        return null;
    }

    public Set<String> getTransformedClasses() {
        return new java.util.HashSet<>(transformedClasses);
    }

    public boolean isMixinReady() {
        return mixinReady;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\ui\Button.java =====

package com.pulse.ui;

import java.util.function.Consumer;

/**
 * 버튼 위젯.
 */
public class Button extends Widget {

    private String text;
    private Consumer<Button> onClick;
    private boolean hovered = false;
    private boolean pressed = false;

    // 색상
    // 색상
    private int backgroundColor = UIConstants.Colors.BUTTON_BG;
    private int hoverColor = UIConstants.Colors.BUTTON_HOVER_BG;
    private int pressedColor = UIConstants.Colors.BUTTON_PRESSED_BG;
    private int textColor = UIConstants.Colors.TEXT_DEFAULT;
    private int borderColor = UIConstants.Colors.BUTTON_BORDER;

    public Button(int x, int y, int width, int height, String text) {
        super(x, y, width, height);
        this.text = text;
    }

    public Button(int x, int y, int width, int height, String text, Consumer<Button> onClick) {
        this(x, y, width, height, text);
        this.onClick = onClick;
    }

    @Override
    public void render(UIRenderContext ctx) {
        if (!visible)
            return;

        int absX = getAbsoluteX();
        int absY = getAbsoluteY();

        // 배경
        int bgColor = pressed ? pressedColor : (hovered ? hoverColor : backgroundColor);
        ctx.fillRect(absX, absY, width, height, bgColor);

        // 테두리
        ctx.drawRect(absX, absY, width, height, borderColor);

        // 텍스트 (가운데 정렬)
        int textWidth = ctx.getTextWidth(text);
        int textHeight = ctx.getTextHeight();
        int textX = absX + (width - textWidth) / 2;
        int textY = absY + (height - textHeight) / 2;
        ctx.drawText(text, textX, textY, enabled ? textColor : UIConstants.Colors.DISABLED_TEXT);
    }

    @Override
    public void onMouseMove(int mouseX, int mouseY) {
        hovered = isMouseOver(mouseX, mouseY);
    }

    @Override
    public boolean onMouseClick(int mouseX, int mouseY, int button) {
        if (!visible || !enabled)
            return false;

        if (button == 0 && isMouseOver(mouseX, mouseY)) {
            pressed = true;
            if (onClick != null) {
                onClick.accept(this);
            }
            return true;
        }
        return false;
    }

    // Getters/Setters
    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public void setOnClick(Consumer<Button> onClick) {
        this.onClick = onClick;
    }

    public void setBackgroundColor(int color) {
        this.backgroundColor = color;
    }

    public void setHoverColor(int color) {
        this.hoverColor = color;
    }

    public void setTextColor(int color) {
        this.textColor = color;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\ui\HUDOverlay.java =====

package com.pulse.ui;

import com.pulse.api.log.PulseLogger;

import java.util.*;

/**
 * HUD 오버레이 매니저.
 * 게임 화면 위에 표시되는 UI 레이어.
 */
public class HUDOverlay {

    private static final HUDOverlay INSTANCE = new HUDOverlay();
    private static final String LOG = PulseLogger.PULSE;

    private final Map<String, HUDLayer> layers = new LinkedHashMap<>();
    private boolean visible = true;

    private HUDOverlay() {
    }

    public static HUDOverlay getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 레이어 관리
    // ─────────────────────────────────────────────────────────────

    /**
     * HUD 레이어 등록.
     * 
     * @param id       레이어 식별자
     * @param layer    레이어
     * @param priority 우선순위 (낮을수록 먼저 렌더링)
     */
    public static void registerLayer(String id, HUDLayer layer, int priority) {
        layer.id = id;
        layer.priority = priority;
        INSTANCE.layers.put(id, layer);
        INSTANCE.sortLayers();
        PulseLogger.info(LOG, "[HUD] Registered layer: {}", id);
    }

    /**
     * HUD 레이어 등록 해제.
     */
    public static void unregisterLayer(String id) {
        INSTANCE.layers.remove(id);
    }

    /**
     * 레이어 가져오기.
     */
    public static HUDLayer getLayer(String id) {
        return INSTANCE.layers.get(id);
    }

    private void sortLayers() {
        List<Map.Entry<String, HUDLayer>> entries = new ArrayList<>(layers.entrySet());
        entries.sort(Comparator.comparingInt(e -> e.getValue().priority));

        layers.clear();
        for (var entry : entries) {
            layers.put(entry.getKey(), entry.getValue());
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 렌더링
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 HUD 레이어 렌더링.
     */
    public static void render(UIRenderContext ctx) {
        if (!INSTANCE.visible)
            return;

        for (HUDLayer layer : INSTANCE.layers.values()) {
            if (layer.isVisible()) {
                try {
                    layer.render(ctx);
                } catch (Exception e) {
                    PulseLogger.error(LOG, "[HUD] Error rendering layer: {}", layer.id, e);
                }
            }
        }
    }

    /**
     * 모든 HUD 레이어 업데이트.
     */
    public static void update(float deltaTime) {
        for (HUDLayer layer : INSTANCE.layers.values()) {
            if (layer.isVisible()) {
                layer.update(deltaTime);
            }
        }
    }

    // Getters/Setters
    public static boolean isVisible() {
        return INSTANCE.visible;
    }

    public static void setVisible(boolean visible) {
        INSTANCE.visible = visible;
    }

    public static Collection<HUDLayer> getLayers() {
        return Collections.unmodifiableCollection(INSTANCE.layers.values());
    }

    // ─────────────────────────────────────────────────────────────
    // HUD 레이어 추상 클래스
    // ─────────────────────────────────────────────────────────────

    public static abstract class HUDLayer {
        String id;
        int priority;
        private boolean visible = true;

        /**
         * 레이어 렌더링.
         */
        public abstract void render(UIRenderContext ctx);

        /**
         * 레이어 업데이트.
         */
        public void update(float deltaTime) {
            // 선택적 오버라이드
        }

        public String getId() {
            return id;
        }

        public int getPriority() {
            return priority;
        }

        public boolean isVisible() {
            return visible;
        }

        public void setVisible(boolean visible) {
            this.visible = visible;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\ui\Label.java =====

package com.pulse.ui;

/**
 * 텍스트 라벨 위젯.
 */
public class Label extends Widget {

    private String text;
    private int textColor = UIConstants.Colors.TEXT_DEFAULT;
    private Alignment alignment = Alignment.LEFT;

    public Label(int x, int y, String text) {
        super(x, y, 0, UIConstants.Layout.TEXT_HEIGHT); // 너비는 텍스트에 맞춰 자동 조정
        this.text = text;
    }

    public Label(int x, int y, int width, int height, String text) {
        super(x, y, width, height);
        this.text = text;
    }

    @Override
    public void render(UIRenderContext ctx) {
        if (!visible || text == null)
            return;

        int absX = getAbsoluteX();
        int absY = getAbsoluteY();

        int textWidth = ctx.getTextWidth(text);
        int textX;

        switch (alignment) {
            case CENTER:
                textX = absX + (width - textWidth) / 2;
                break;
            case RIGHT:
                textX = absX + width - textWidth;
                break;
            default:
                textX = absX;
        }

        ctx.drawText(text, textX, absY, textColor);
    }

    // Getters/Setters
    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public int getTextColor() {
        return textColor;
    }

    public void setTextColor(int color) {
        this.textColor = color;
    }

    public Alignment getAlignment() {
        return alignment;
    }

    public void setAlignment(Alignment alignment) {
        this.alignment = alignment;
    }

    public enum Alignment {
        LEFT, CENTER, RIGHT
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\ui\Panel.java =====

package com.pulse.ui;

import java.util.ArrayList;
import java.util.List;

/**
 * 컨테이너 패널 위젯.
 * 다른 위젯들을 포함.
 */
public class Panel extends Widget {

    private final List<Widget> children = new ArrayList<>();
    private int backgroundColor = UIConstants.Colors.PANEL_BG;
    private int borderColor = UIConstants.Colors.PANEL_BORDER;
    private boolean drawBackground = true;
    private boolean drawBorder = true;
    private int padding = UIConstants.Layout.DEFAULT_PADDING;

    public Panel(int x, int y, int width, int height) {
        super(x, y, width, height);
    }

    @Override
    public void render(UIRenderContext ctx) {
        if (!visible)
            return;

        int absX = getAbsoluteX();
        int absY = getAbsoluteY();

        // 배경
        if (drawBackground) {
            ctx.fillRect(absX, absY, width, height, backgroundColor);
        }

        // 테두리
        if (drawBorder) {
            ctx.drawRect(absX, absY, width, height, borderColor);
        }

        // 자식 위젯 렌더링
        for (Widget child : children) {
            if (child.isVisible()) {
                child.preRender(ctx);
                child.render(ctx);
                child.postRender(ctx);
            }
        }
    }

    @Override
    public boolean onMouseClick(int mouseX, int mouseY, int button) {
        if (!visible || !enabled)
            return false;

        // 역순으로 검사 (위에 있는 것이 먼저)
        for (int i = children.size() - 1; i >= 0; i--) {
            Widget child = children.get(i);
            if (child.isVisible() && child.isEnabled()) {
                if (child.onMouseClick(mouseX, mouseY, button)) {
                    return true;
                }
            }
        }
        return isMouseOver(mouseX, mouseY);
    }

    @Override
    public void onMouseMove(int mouseX, int mouseY) {
        for (Widget child : children) {
            if (child.isVisible()) {
                child.onMouseMove(mouseX, mouseY);
            }
        }
    }

    @Override
    public boolean onKeyPress(int keyCode, char character) {
        for (Widget child : children) {
            if (child.isVisible() && child.isEnabled()) {
                if (child.onKeyPress(keyCode, character)) {
                    return true;
                }
            }
        }
        return false;
    }

    // ─────────────────────────────────────────────────────────────
    // 자식 관리
    // ─────────────────────────────────────────────────────────────

    public void add(Widget widget) {
        widget.setParent(this);
        children.add(widget);
    }

    public void remove(Widget widget) {
        widget.setParent(null);
        children.remove(widget);
    }

    public void clear() {
        for (Widget child : children) {
            child.setParent(null);
        }
        children.clear();
    }

    public List<Widget> getChildren() {
        return new ArrayList<>(children);
    }

    public Widget findById(String id) {
        for (Widget child : children) {
            if (id.equals(child.getId())) {
                return child;
            }
            if (child instanceof Panel) {
                Widget found = ((Panel) child).findById(id);
                if (found != null)
                    return found;
            }
        }
        return null;
    }

    // Getters/Setters
    public int getBackgroundColor() {
        return backgroundColor;
    }

    public void setBackgroundColor(int color) {
        this.backgroundColor = color;
    }

    public int getBorderColor() {
        return borderColor;
    }

    public void setBorderColor(int color) {
        this.borderColor = color;
    }

    public boolean isDrawBackground() {
        return drawBackground;
    }

    public void setDrawBackground(boolean draw) {
        this.drawBackground = draw;
    }

    public boolean isDrawBorder() {
        return drawBorder;
    }

    public void setDrawBorder(boolean draw) {
        this.drawBorder = draw;
    }

    public int getPadding() {
        return padding;
    }

    public void setPadding(int padding) {
        this.padding = padding;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\ui\TextField.java =====

package com.pulse.ui;

import java.util.function.Consumer;

/**
 * 텍스트 입력 필드 위젯.
 */
public class TextField extends Widget {

    private StringBuilder text = new StringBuilder();
    private String placeholder = "";
    private int maxLength = UIConstants.Defaults.MAX_INPUT_LENGTH;
    private int cursorPosition = 0;
    private boolean focused = false;

    // 콜백
    private Consumer<String> onTextChanged;
    private Consumer<String> onSubmit;

    // 색상
    // 색상
    private int backgroundColor = UIConstants.Colors.INPUT_BG;
    private int textColor = UIConstants.Colors.TEXT_DEFAULT;
    private int placeholderColor = UIConstants.Colors.PLACEHOLDER;
    private int borderColor = UIConstants.Colors.INPUT_BORDER;
    private int focusBorderColor = UIConstants.Colors.INPUT_FOCUS_BORDER;

    public TextField(int x, int y, int width, int height) {
        super(x, y, width, height);
    }

    public TextField(int x, int y, int width, int height, String placeholder) {
        this(x, y, width, height);
        this.placeholder = placeholder;
    }

    @Override
    public void render(UIRenderContext ctx) {
        if (!visible)
            return;

        int absX = getAbsoluteX();
        int absY = getAbsoluteY();

        // 배경
        ctx.fillRect(absX, absY, width, height, backgroundColor);

        // 테두리
        ctx.drawRect(absX, absY, width, height, focused ? focusBorderColor : borderColor);

        // 텍스트 또는 플레이스홀더
        String displayText = text.length() > 0 ? text.toString() : placeholder;
        int color = text.length() > 0 ? textColor : placeholderColor;

        int padding = UIConstants.Layout.DEFAULT_PADDING;
        int textY = absY + (height - ctx.getTextHeight()) / 2;
        ctx.drawText(displayText, absX + padding, textY, color);

        // 커서 (포커스 시)
        if (focused && System.currentTimeMillis() % 1000 < 500) {
            String beforeCursor = text.substring(0, Math.min(cursorPosition, text.length()));
            int cursorX = absX + padding + ctx.getTextWidth(beforeCursor);
            ctx.fillRect(cursorX, absY + UIConstants.Layout.CURSOR_OFFSET, UIConstants.Layout.CURSOR_WIDTH,
                    height - (UIConstants.Layout.DEFAULT_PADDING * 2), textColor);
        }
    }

    @Override
    public boolean onMouseClick(int mouseX, int mouseY, int button) {
        boolean wasMouseOver = isMouseOver(mouseX, mouseY);
        focused = wasMouseOver && enabled;
        return wasMouseOver;
    }

    @Override
    public boolean onKeyPress(int keyCode, char character) {
        if (!focused || !enabled)
            return false;

        // 백스페이스
        if (keyCode == 14 && cursorPosition > 0) {
            text.deleteCharAt(cursorPosition - 1);
            cursorPosition--;
            notifyTextChanged();
            return true;
        }

        // Delete
        if (keyCode == 211 && cursorPosition < text.length()) {
            text.deleteCharAt(cursorPosition);
            notifyTextChanged();
            return true;
        }

        // Enter
        if (keyCode == 28) {
            if (onSubmit != null) {
                onSubmit.accept(text.toString());
            }
            return true;
        }

        // 좌/우 화살표
        if (keyCode == 203 && cursorPosition > 0) {
            cursorPosition--;
            return true;
        }
        if (keyCode == 205 && cursorPosition < text.length()) {
            cursorPosition++;
            return true;
        }

        // 일반 문자 입력
        if (character >= 32 && character < 127 && text.length() < maxLength) {
            text.insert(cursorPosition, character);
            cursorPosition++;
            notifyTextChanged();
            return true;
        }

        return false;
    }

    private void notifyTextChanged() {
        if (onTextChanged != null) {
            onTextChanged.accept(text.toString());
        }
    }

    // Getters/Setters
    public String getText() {
        return text.toString();
    }

    public void setText(String text) {
        this.text = new StringBuilder(text);
        this.cursorPosition = text.length();
    }

    public String getPlaceholder() {
        return placeholder;
    }

    public void setPlaceholder(String placeholder) {
        this.placeholder = placeholder;
    }

    public int getMaxLength() {
        return maxLength;
    }

    public void setMaxLength(int maxLength) {
        this.maxLength = maxLength;
    }

    public boolean isFocused() {
        return focused;
    }

    public void setFocused(boolean focused) {
        this.focused = focused;
    }

    public void setOnTextChanged(Consumer<String> callback) {
        this.onTextChanged = callback;
    }

    public void setOnSubmit(Consumer<String> callback) {
        this.onSubmit = callback;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\ui\UIConstants.java =====

package com.pulse.ui;

/**
 * UI 관련 상수 모음.
 * 매직 넘버를 제거하고 일관된 테마를 제공하기 위함.
 * 
 * @since 1.3
 */
public final class UIConstants {
    private UIConstants() {
    }

    public static final class Colors {
        // 공통
        public static final int WHITE = 0xFFFFFF;
        public static final int BLACK = 0x000000;
        public static final int DISABLED_TEXT = 0x808080;

        // 버튼
        public static final int BUTTON_BG = 0x404040;
        public static final int BUTTON_HOVER_BG = 0x505050;
        public static final int BUTTON_PRESSED_BG = 0x303030;
        public static final int BUTTON_BORDER = 0x606060;

        // 텍스트/라벨
        public static final int TEXT_DEFAULT = 0xFFFFFF;

        // 패널/컨테이너
        public static final int PANEL_BG = 0x303030;
        public static final int PANEL_BORDER = 0x505050;

        // 입력 필드
        public static final int INPUT_BG = 0x202020;
        public static final int INPUT_BORDER = 0x404040;
        public static final int INPUT_FOCUS_BORDER = 0x6060FF;
        public static final int PLACEHOLDER = 0x808080;

        // 스크린
        public static final int SCREEN_BG = 0x000000;
    }

    public static final class Layout {
        public static final int DEFAULT_PADDING = 4;
        public static final int TEXT_HEIGHT = 16;
        public static final int DEFAULT_CHAR_WIDTH = 8; // 폰트 로드 실패 시 폴백
        public static final int CURSOR_WIDTH = 1;
        public static final int CURSOR_OFFSET = 2; // Y축 오프셋
    }

    public static final class Defaults {
        public static final int MAX_INPUT_LENGTH = 256;
        public static final int DEFAULT_SCREEN_WIDTH = 800;
        public static final int DEFAULT_SCREEN_HEIGHT = 600;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\ui\UIRenderContext.java =====

package com.pulse.ui;

/**
 * UI 렌더링 컨텍스트.
 * 위젯 렌더링에 필요한 그래픽 API 래퍼.
 */
public class UIRenderContext {

    private Object graphics; // PZ의 UIGraphics 또는 Graphics2D
    private float deltaTime;
    private int screenWidth;
    private int screenHeight;

    public UIRenderContext(Object graphics, float deltaTime, int screenWidth, int screenHeight) {
        this.graphics = graphics;
        this.deltaTime = deltaTime;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
    }

    // ─────────────────────────────────────────────────────────────
    // 기본 그리기
    // ─────────────────────────────────────────────────────────────

    /**
     * 사각형 그리기.
     */
    public void drawRect(int x, int y, int width, int height, int color) {
        drawRect(x, y, width, height, color, 1.0f);
    }

    public void drawRect(int x, int y, int width, int height, int color, float alpha) {
        try {
            // PZ UIGraphics 사용 시도
            if (graphics != null) {
                java.lang.reflect.Method drawMethod = graphics.getClass().getMethod(
                        "DrawRect", int.class, int.class, int.class, int.class,
                        float.class, float.class, float.class, float.class);

                float r = ((color >> 16) & 0xFF) / 255.0f;
                float g = ((color >> 8) & 0xFF) / 255.0f;
                float b = (color & 0xFF) / 255.0f;

                drawMethod.invoke(graphics, x, y, width, height, r, g, b, alpha);
            }
        } catch (Exception e) {
            // 폴백: 콘솔 로그
        }
    }

    /**
     * 채워진 사각형 그리기.
     */
    public void fillRect(int x, int y, int width, int height, int color) {
        fillRect(x, y, width, height, color, 1.0f);
    }

    public void fillRect(int x, int y, int width, int height, int color, float alpha) {
        try {
            if (graphics != null) {
                java.lang.reflect.Method fillMethod = graphics.getClass().getMethod(
                        "DrawRectFilled", int.class, int.class, int.class, int.class,
                        float.class, float.class, float.class, float.class);

                float r = ((color >> 16) & 0xFF) / 255.0f;
                float g = ((color >> 8) & 0xFF) / 255.0f;
                float b = (color & 0xFF) / 255.0f;

                fillMethod.invoke(graphics, x, y, width, height, r, g, b, alpha);
            }
        } catch (Exception e) {
            // 폴백
        }
    }

    /**
     * 텍스트 그리기.
     */
    public void drawText(String text, int x, int y, int color) {
        try {
            if (graphics != null) {
                java.lang.reflect.Method textMethod = graphics.getClass().getMethod(
                        "DrawText", String.class, int.class, int.class,
                        float.class, float.class, float.class, float.class);

                float r = ((color >> 16) & 0xFF) / 255.0f;
                float g = ((color >> 8) & 0xFF) / 255.0f;
                float b = (color & 0xFF) / 255.0f;

                textMethod.invoke(graphics, text, x, y, r, g, b, 1.0f);
            }
        } catch (Exception e) {
            // 폴백
        }
    }

    /**
     * 텍스트 너비 계산.
     */
    public int getTextWidth(String text) {
        try {
            if (graphics != null) {
                java.lang.reflect.Method widthMethod = graphics.getClass().getMethod(
                        "getTextWidth", String.class);
                return (int) widthMethod.invoke(graphics, text);
            }
        } catch (Exception e) {
            // 폴백: 글자당 8픽셀
        }
        return text.length() * UIConstants.Layout.DEFAULT_CHAR_WIDTH;
    }

    /**
     * 텍스트 높이.
     */
    public int getTextHeight() {
        return UIConstants.Layout.TEXT_HEIGHT; // 기본 폰트 높이
    }

    // Getters
    public Object getGraphics() {
        return graphics;
    }

    public float getDeltaTime() {
        return deltaTime;
    }

    public int getScreenWidth() {
        return screenWidth;
    }

    public int getScreenHeight() {
        return screenHeight;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\ui\UIScreen.java =====

package com.pulse.ui;

import com.pulse.api.log.PulseLogger;

import java.util.Stack;

/**
 * UI 스크린 매니저.
 * 게임 UI 스크린 관리 및 전환.
 */
public class UIScreen extends Panel {

    private static final Stack<UIScreen> screenStack = new Stack<>();
    private static UIScreen currentScreen = null;
    private static final String LOG = PulseLogger.PULSE;

    private String title;
    private boolean pauseGame = false;

    public UIScreen(String title) {
        super(0, 0, UIConstants.Defaults.DEFAULT_SCREEN_WIDTH, UIConstants.Defaults.DEFAULT_SCREEN_HEIGHT); // 기본 크기
                                                                                                            // (런타임에 조정)
        this.title = title;
        setDrawBackground(true);
        setBackgroundColor(UIConstants.Colors.SCREEN_BG);
    }

    // ─────────────────────────────────────────────────────────────
    // 스크린 라이프사이클
    // ─────────────────────────────────────────────────────────────

    /**
     * 스크린이 열릴 때 호출.
     */
    public void onOpen() {
        PulseLogger.info(LOG, "[UI] Screen opened: {}", title);
    }

    /**
     * 스크린이 닫힐 때 호출.
     */
    public void onClose() {
        PulseLogger.info(LOG, "[UI] Screen closed: {}", title);
    }

    /**
     * 매 프레임 업데이트.
     */
    public void update(float deltaTime) {
        // 하위 클래스에서 오버라이드
    }

    // ─────────────────────────────────────────────────────────────
    // 스크린 관리 (정적 메서드)
    // ─────────────────────────────────────────────────────────────

    /**
     * 스크린 열기.
     */
    public static void open(UIScreen screen) {
        if (currentScreen != null) {
            screenStack.push(currentScreen);
        }
        currentScreen = screen;
        screen.onOpen();
    }

    /**
     * 현재 스크린 닫기.
     */
    public static void close() {
        if (currentScreen != null) {
            currentScreen.onClose();
            currentScreen = screenStack.isEmpty() ? null : screenStack.pop();
        }
    }

    /**
     * 모든 스크린 닫기.
     */
    public static void closeAll() {
        while (currentScreen != null) {
            close();
        }
    }

    /**
     * 현재 스크린 가져오기.
     */
    public static UIScreen getCurrent() {
        return currentScreen;
    }

    /**
     * 스크린이 열려 있는지 확인.
     */
    public static boolean isOpen() {
        return currentScreen != null;
    }

    /**
     * 현재 스크린 렌더링.
     */
    public static void renderCurrent(UIRenderContext ctx) {
        if (currentScreen != null && currentScreen.isVisible()) {
            currentScreen.preRender(ctx);
            currentScreen.render(ctx);
            currentScreen.postRender(ctx);
        }
    }

    /**
     * 현재 스크린 업데이트.
     */
    public static void updateCurrent(float deltaTime) {
        if (currentScreen != null) {
            currentScreen.update(deltaTime);
        }
    }

    // Getters/Setters
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public boolean isPauseGame() {
        return pauseGame;
    }

    public void setPauseGame(boolean pause) {
        this.pauseGame = pause;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\java\com\pulse\ui\Widget.java =====

package com.pulse.ui;

/**
 * UI 위젯 기본 클래스.
 * 모든 UI 요소의 상위 클래스.
 */
public abstract class Widget {

    protected int x, y;
    protected int width, height;
    protected boolean visible = true;
    protected boolean enabled = true;
    protected Widget parent;
    protected String id;

    public Widget(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    // ─────────────────────────────────────────────────────────────
    // 렌더링
    // ─────────────────────────────────────────────────────────────

    /**
     * 위젯 렌더링 (하위 클래스에서 구현).
     */
    public abstract void render(UIRenderContext ctx);

    /**
     * 렌더링 전 처리.
     */
    public void preRender(UIRenderContext ctx) {
        // 선택적 오버라이드
    }

    /**
     * 렌더링 후 처리.
     */
    public void postRender(UIRenderContext ctx) {
        // 선택적 오버라이드
    }

    // ─────────────────────────────────────────────────────────────
    // 입력 처리
    // ─────────────────────────────────────────────────────────────

    /**
     * 마우스 클릭 처리.
     * 
     * @return 이벤트 소비 여부
     */
    public boolean onMouseClick(int mouseX, int mouseY, int button) {
        return false;
    }

    /**
     * 마우스 이동 처리.
     */
    public void onMouseMove(int mouseX, int mouseY) {
        // 선택적 오버라이드
    }

    /**
     * 키 입력 처리.
     * 
     * @return 이벤트 소비 여부
     */
    public boolean onKeyPress(int keyCode, char character) {
        return false;
    }

    /**
     * 마우스가 위젯 위에 있는지 확인.
     */
    public boolean isMouseOver(int mouseX, int mouseY) {
        int absX = getAbsoluteX();
        int absY = getAbsoluteY();
        return mouseX >= absX && mouseX < absX + width &&
                mouseY >= absY && mouseY < absY + height;
    }

    // ─────────────────────────────────────────────────────────────
    // 위치/크기
    // ─────────────────────────────────────────────────────────────

    public int getAbsoluteX() {
        return parent != null ? parent.getAbsoluteX() + x : x;
    }

    public int getAbsoluteY() {
        return parent != null ? parent.getAbsoluteY() + y : y;
    }

    public void setPosition(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void setSize(int width, int height) {
        this.width = width;
        this.height = height;
    }

    public void setBounds(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    // Getters/Setters
    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public boolean isVisible() {
        return visible;
    }

    public void setVisible(boolean visible) {
        this.visible = visible;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    public Widget getParent() {
        return parent;
    }

    public void setParent(Widget parent) {
        this.parent = parent;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\main\resources\mixins.pulse.json =====

{
  "required": true,
  "minVersion": "0.8",
  "package": "com.pulse.mixin",
  "mixins": [
    "MainScreenStateMixin",
    "GameClientMixin",
    "GameWindowMixin",
    "IsoWorldMixin",
    "IsoPlayerMixin",
    "IsoZombieMixin",
    "PathfindingMixin",
    "IsoGridMixin",
    "lua.MixinLuaEventManager",
    "kahlua.MixinKahluaThread"
  ],
  "client": [],
  "server": [],
  "injectors": {
    "defaultRequire": 0
  },
  "verbose": true
}


===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\api\exception\ExceptionHierarchyTest.java =====

package com.pulse.api.exception;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;

import static org.junit.jupiter.api.Assertions.*;

/**
 * 예외 계층 단위 테스트.
 * 각 예외 클래스의 팩토리 메서드 및 메시지 포맷 검증.
 */
@Tag("unit")
class ExceptionHierarchyTest {

    @Test
    void configurationException_invalidValue() {
        var ex = ConfigurationException.invalidValue("threshold", -1, "Must be positive");
        assertNotNull(ex);
        assertTrue(ex.getMessage().contains("threshold"));
        assertTrue(ex.getMessage().contains("-1"));
        assertTrue(ex.getMessage().contains("positive"));
    }

    @Test
    void configurationException_missingRequired() {
        var ex = ConfigurationException.missingRequired("api_key");
        assertNotNull(ex);
        assertTrue(ex.getMessage().contains("api_key"));
        assertTrue(ex.getMessage().contains("missing"));
    }

    @Test
    void injectionException_serviceNotFound() {
        var ex = InjectionException.serviceNotFound(String.class);
        assertNotNull(ex);
        assertTrue(ex.getMessage().contains("String"));
        assertTrue(ex.getMessage().contains("not found"));
    }

    @Test
    void injectionException_circularDependency() {
        var ex = InjectionException.circularDependency(Object.class);
        assertNotNull(ex);
        assertTrue(ex.getMessage().contains("Circular"));
    }

    @Test
    void luaInteropException_executionError() {
        var cause = new RuntimeException("nil value");
        var ex = LuaInteropException.executionError("function test()", 42, cause);
        assertNotNull(ex);
        assertTrue(ex.getMessage().contains("42"));
        assertEquals(42, ex.getLineNumber());
        assertNotNull(ex.getCause());
    }

    @Test
    void luaInteropException_functionNotFound() {
        var ex = LuaInteropException.functionNotFound("onUpdate");
        assertNotNull(ex);
        assertTrue(ex.getMessage().contains("onUpdate"));
    }

    @Test
    void mixinApplyException_targetNotFound() {
        var ex = MixinApplyException.targetNotFound("MyMixin", "zombie.core.Target");
        assertNotNull(ex);
        assertTrue(ex.getMessage().contains("zombie.core.Target"));
        assertEquals("MyMixin", ex.getMixinClass());
        assertEquals("zombie.core.Target", ex.getTargetClass());
    }

    @Test
    void mixinApplyException_signatureMismatch() {
        var ex = MixinApplyException.signatureMismatch("TestMixin", "inject", "(I)V", "(J)V");
        assertNotNull(ex);
        assertTrue(ex.getMessage().contains("signature"));
        assertTrue(ex.getMessage().contains("(I)V"));
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\api\GameAccessTest.java =====

package com.pulse.api;

import com.pulse.api.access.*;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * GameAccess 및 분리된 Access 클래스 회귀 테스트.
 * 리팩토링 후 기존 동작이 유지되는지 검증.
 */

class GameAccessTest {

    @Test
    void worldAccess_isWorldLoaded_returnsFalseWhenNotLoaded() {
        // 게임 실행 전에는 월드가 로드되지 않음
        assertFalse(WorldAccess.isWorldLoaded());
    }

    @Test
    void playerAccess_getLocalPlayer_returnsNullWhenNotInGame() {
        // 게임 실행 전에는 플레이어가 없음
        assertNull(PlayerAccess.getLocalPlayer());
    }

    @Test
    void timeAccess_getGameHour_returnsZeroWhenNotLoaded() {
        // GameTime이 없으면 0 반환
        assertEquals(0, TimeAccess.getGameHour());
    }

    @Test
    void networkAccess_isMultiplayer_returnsFalseByDefault() {
        // 게임 실행 전에는 싱글플레이어
        assertFalse(NetworkAccess.isMultiplayer());
    }

    @Test
    void networkAccess_isSinglePlayer_returnsTrueByDefault() {
        assertTrue(NetworkAccess.isSinglePlayer());
    }

}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\arch\PulseBoundaryTest.java =====

package com.pulse.arch;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.core.importer.ImportOption;
import com.tngtech.archunit.lang.ArchRule;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

/**
 * Package boundary enforcement for Pulse core-loader separation.
 * 
 * <p>
 * These tests MUST pass for the build to succeed.
 * Violation = future separation will break.
 * </p>
 * 
 * <h2>Boundary Rules:</h2>
 * <ul>
 * <li>Core (api, core, internal, bindings, mixin) → Loader: FORBIDDEN</li>
 * <li>API → Internal: FORBIDDEN</li>
 * <li>Core/API → zombie.*: Only via bindings/mixin</li>
 * </ul>
 * 
 * @since Pulse 0.9
 */
public class PulseBoundaryTest {

        private static JavaClasses pulseClasses;

        @BeforeAll
        static void setup() {
                pulseClasses = new ClassFileImporter()
                                .withImportOption(ImportOption.Predefined.DO_NOT_INCLUDE_TESTS)
                                .importPackages("com.pulse");
        }

        // ═══════════════════════════════════════════════════════════════
        // Rule 1: Core MUST NOT depend on Loader
        // ═══════════════════════════════════════════════════════════════

        @Test
        @DisplayName("Core packages must not depend on loader packages")
        void coreShouldNotDependOnLoader() {
                ArchRule rule = noClasses()
                                .that().resideInAnyPackage(
                                                "com.pulse.api..",
                                                "com.pulse.core..",
                                                "com.pulse.internal..",
                                                "com.pulse.bindings..",
                                                "com.pulse.mixin..",
                                                "com.pulse.event..",
                                                "com.pulse.bootstrap..")
                                .should().dependOnClassesThat()
                                .resideInAnyPackage("com.pulse.loader..");

                rule.check(pulseClasses);
        }

        // ═══════════════════════════════════════════════════════════════
        // Rule 2: Internal should not leak to API
        // ═══════════════════════════════════════════════════════════════

        @Test
        @DisplayName("API package must not depend on internal package")
        void apiShouldNotDependOnInternal() {
                ArchRule rule = noClasses()
                                .that().resideInAnyPackage("com.pulse.api..")
                                .should().dependOnClassesThat()
                                .resideInAnyPackage("com.pulse.internal..");

                rule.check(pulseClasses);
        }

        @Test
        @DisplayName("Core package must not depend on internal package")
        void coreShouldNotDependOnInternal() {
                ArchRule rule = noClasses()
                                .that().resideInAnyPackage("com.pulse.core..")
                                .should().dependOnClassesThat()
                                .resideInAnyPackage("com.pulse.internal..");

                rule.check(pulseClasses);
        }

        // ═══════════════════════════════════════════════════════════════
        // Rule 3: Core must not contain optimization-focused classes
        // ═══════════════════════════════════════════════════════════════

        @Test
        @DisplayName("Core mixin package must not contain optimization classes")
        void mixinShouldNotContainOptimizationClasses() {
                // Core mixins should only contain hook/contract classes, not optimization logic
                // Optimization classes belong in Fuse, not Pulse-core
                // This rule verifies no optimization package exists in mixin
                ArchRule rule = noClasses()
                                .that().resideInAnyPackage("com.pulse.mixin.optimization..")
                                .should().beInterfaces(); // Placeholder - any class here is a violation

                rule.allowEmptyShould(true).check(pulseClasses);
        }

        @Test
        @DisplayName("Core must not have classes with Optimizer/Throttle in name")
        void corePackageShouldNotContainOptimizerClasses() {
                // Core package should not contain optimizer/throttle classes (those are Fuse's
                // domain)
                ArchRule rule = noClasses()
                                .that().resideInAnyPackage("com.pulse.core..")
                                .should().haveSimpleNameContaining("Optimizer");

                rule.check(pulseClasses);
        }

        // ═══════════════════════════════════════════════════════════════
        // Rule 4: zombie.* access only via bindings/mixin (allowlist)
        // ═══════════════════════════════════════════════════════════════

        @Test
        @DisplayName("API package should not directly reference zombie.* classes")
        void apiShouldNotReferenceZombieClasses() {
                // API should be engine-agnostic
                // Exception: version detection classes
                ArchRule rule = noClasses()
                                .that().resideInAnyPackage("com.pulse.api..")
                                .and().haveSimpleNameNotContaining("Version")
                                .and().haveSimpleNameNotContaining("GameVersion")
                                .should().dependOnClassesThat()
                                .resideInAnyPackage("zombie..");

                rule.check(pulseClasses);
        }

        @Test
        @DisplayName("Core package should not directly reference zombie.* classes")
        void coreShouldNotReferenceZombieClasses() {
                // Core classes should go through bindings for engine access
                ArchRule rule = noClasses()
                                .that().resideInAnyPackage("com.pulse.core..")
                                .should().dependOnClassesThat()
                                .resideInAnyPackage("zombie..");

                rule.check(pulseClasses);
        }

        @Test
        @DisplayName("Loader package should not directly reference zombie.* classes")
        void loaderShouldNotReferenceZombieClasses() {
                // Loader should use bindings facade, not direct engine access
                ArchRule rule = noClasses()
                                .that().resideInAnyPackage("com.pulse.loader..")
                                .should().dependOnClassesThat()
                                .resideInAnyPackage("zombie..");

                rule.check(pulseClasses);
        }

        // ═══════════════════════════════════════════════════════════════
        // Rule 5: Bindings layer is the ONLY engine access point
        // ═══════════════════════════════════════════════════════════════

        @Test
        @DisplayName("Only bindings and mixin packages may reference zombie.* directly")
        @SuppressWarnings("unused") // Rule intentionally not checked yet - see comment at end
        void onlyBindingsAndMixinMayReferenceZombie() {
                // Allowed packages: bindings, mixin, adapter (legacy)
                // All other packages should NOT reference zombie.* directly
                ArchRule rule = noClasses()
                                .that().resideInAnyPackage(
                                                "com.pulse.event..",
                                                "com.pulse.scheduler..",
                                                "com.pulse.service..",
                                                "com.pulse.config..",
                                                "com.pulse.debug..")
                                .should().dependOnClassesThat()
                                .resideInAnyPackage("zombie..");

                // Note: This rule may be relaxed for utility classes that need PZ types
                // Enable when ready to enforce strict bindings isolation
                // rule.check(pulseClasses);
        }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\bootstrap\ModInitializerTest.java =====

package com.pulse.bootstrap;

import com.pulse.mod.ModLoader;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.instrument.Instrumentation;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ModInitializerTest {

    @Mock
    private ModLoader modLoader;

    @Mock
    private Instrumentation instrumentation;

    private ModInitializer initializer;
    private InitializationContext context;

    @BeforeEach
    void setUp() {
        initializer = new ModInitializer(modLoader);
        context = new InitializationContext(instrumentation);
    }

    @Test
    void initialize_ShouldCallModLoaderMethods() {
        // When
        initializer.initialize(context);

        // Then
        verify(modLoader).discoverMods();
        verify(modLoader).resolveDependencies();
        verify(modLoader).registerMixins();
    }

    @Test
    void initialize_ShouldHandleExceptionGracefully() {
        // Given
        doThrow(new RuntimeException("Test Error")).when(modLoader).discoverMods();

        // When
        initializer.initialize(context);

        // Then
        // Should not throw exception, but log error (verified by absence of crash)
        verify(modLoader).discoverMods();
        verify(modLoader, never()).resolveDependencies();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\bootstrap\SystemPropertyInitializerTest.java =====

package com.pulse.bootstrap;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.instrument.Instrumentation;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.assertEquals;

@ExtendWith(MockitoExtension.class)
class SystemPropertyInitializerTest {

    @Mock
    private Instrumentation instrumentation;

    private InitializationContext context;
    private SystemPropertyInitializer initializer;
    private Properties originalProperties;

    @BeforeEach
    void setUp() {
        // 백업
        originalProperties = (Properties) System.getProperties().clone();

        context = new InitializationContext(instrumentation);
        initializer = new SystemPropertyInitializer();
    }

    @AfterEach
    void tearDown() {
        // 복원
        System.setProperties(originalProperties);
    }

    @Test
    void initialize_ShouldSetMixinProperties() {
        // Given
        System.clearProperty("mixin.debug"); // ensure it's not set initially

        // When
        initializer.initialize(context);

        // Then
        assertEquals("true", System.getProperty("mixin.debug"));
        assertEquals("true", System.getProperty("mixin.debug.verbose"));
        assertEquals("true", System.getProperty("mixin.debug.export"));
        assertEquals("false", System.getProperty("mixin.debug.export.decompile"));
        assertEquals("true", System.getProperty("mixin.dumpTargetOnFailure"));
        assertEquals("true", System.getProperty("mixin.checks"));
        assertEquals("true", System.getProperty("mixin.hotSwap"));
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\command\CommandContextTest.java =====

package com.pulse.command;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;

import static org.junit.jupiter.api.Assertions.*;

/**
 * CommandContext 단위 테스트.
 */
@Tag("unit")
class CommandContextTest {

    private CommandContext ctx;

    @BeforeEach
    void setUp() {
        String[] args = { "status", "verbose", "42" };
        ctx = new CommandContext(new MockSender(), "test", args);
    }

    @Test
    void getArg_returnsCorrectArg() {
        assertEquals("status", ctx.getArg(0));
        assertEquals("verbose", ctx.getArg(1));
        assertEquals("42", ctx.getArg(2));
    }

    @Test
    void getArg_returnsNullForInvalidIndex() {
        assertNull(ctx.getArg(-1));
        assertNull(ctx.getArg(10));
    }

    @Test
    void getArg_withDefault_returnsDefaultForMissing() {
        assertEquals("default", ctx.getArg(10, "default"));
    }

    @Test
    void hasArg_returnsTrueForValidIndex() {
        assertTrue(ctx.hasArg(0));
        assertTrue(ctx.hasArg(2));
        assertFalse(ctx.hasArg(3));
    }

    @Test
    void getInt_parsesInteger() {
        Integer value = ctx.getInt(2);
        assertEquals(42, value);
    }

    @Test
    void getInt_returnsNullForNonInteger() {
        Integer value = ctx.getInt(0); // "status" is not an integer
        assertNull(value);
    }

    @Test
    void getInt_withDefault_returnsDefaultForMissing() {
        int value = ctx.getInt(10, 99);
        assertEquals(99, value);
    }

    @Test
    void getBoolean_parsesTruthy() {
        CommandContext boolCtx = new CommandContext(new MockSender(), "cmd",
                new String[] { "true", "yes", "1", "false" });

        assertTrue(boolCtx.getBoolean(0));
        assertTrue(boolCtx.getBoolean(1));
        assertTrue(boolCtx.getBoolean(2));
        assertFalse(boolCtx.getBoolean(3));
    }

    @Test
    void getRemainingArgs_joinsArgs() {
        ctx.nextArg(); // consume "status"
        String remaining = ctx.getRemainingArgs();
        assertEquals("verbose 42", remaining);
    }

    @Test
    void getArgCount_returnsCorrectCount() {
        assertEquals(3, ctx.getArgCount());
    }

    // 테스트용 Mock CommandSender
    // 테스트용 Mock CommandSender
    private static class MockSender implements CommandSender {

        @Override
        public void sendMessage(String message) {
        }

        @Override
        public void sendError(String message) {
        }

        @Override
        public boolean hasPermission(String permission) {
            return true;
        }

        @Override
        public String getName() {
            return "TestSender";
        }

        @Override
        public boolean isPlayer() {
            return false;
        }

        @Override
        public boolean isConsole() {
            return true;
        }

        @Override
        public Object getPlayer() {
            return null;
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\contract\PulseContractTest.java =====

package com.pulse.contract;

import com.pulse.api.util.ReflectionCache;
import com.pulse.event.EventBus;
import com.pulse.event.Event;
import com.pulse.scheduler.PulseScheduler;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class PulseContractTest {

    @Test
    void testEventBusContract() {
        EventBus bus = EventBus.getInstance();
        assertNotNull(bus, "EventBus instance should not be null");

        // Test subscription
        TestEvent event = new TestEvent();
        final boolean[] handled = { false };

        EventBus.subscribe(TestEvent.class, e -> handled[0] = true);
        EventBus.post(event);

        assertTrue(handled[0], "Event should be handled by subscriber");

        EventBus.getInstance().clearAll();
    }

    @Test
    void testSchedulerContract() {
        PulseScheduler scheduler = PulseScheduler.getInstance();
        assertNotNull(scheduler, "Scheduler instance should not be null");

        // Schedule a task
        PulseScheduler.runLater(() -> {
        }, 10);
        assertTrue(scheduler.getActiveTaskCount() > 0, "Task should be scheduled");
        scheduler.cancelAll();
        assertEquals(0, scheduler.getActiveTaskCount(), "Tasks should be cleared");
    }

    @Test
    void testReflectionCacheContract() throws Exception {
        ReflectionCache.clearAll();
        // Access a method (String.length is safe/standard)
        ReflectionCache.getMethodOrThrow(String.class, "length");
        assertTrue(ReflectionCache.getMethodCacheSize() > 0, "Method cache should contain entry");

        // Verify same instance returned (caching)
        java.lang.reflect.Method m1 = ReflectionCache.getMethodOrThrow(String.class, "length");
        java.lang.reflect.Method m2 = ReflectionCache.getMethodOrThrow(String.class, "length");
        assertSame(m1, m2, "Cached method instance should be identical");
    }

    // Concrete event implementation for testing
    public static class TestEvent extends Event {
        public TestEvent() {
            super(false);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\debug\DevConsoleTest.java =====

package com.pulse.debug;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;

import static org.junit.jupiter.api.Assertions.*;

/**
 * DevConsole 단위 테스트.
 * 싱글톤 상태에 영향받지 않는 기본 테스트만 포함.
 */
@Tag("unit")
class DevConsoleTest {

    @Test
    void getInstance_returnsSameInstance() {
        DevConsole instance1 = DevConsole.getInstance();
        DevConsole instance2 = DevConsole.getInstance();
        assertSame(instance1, instance2);
    }

    @Test
    void getInstance_notNull() {
        assertNotNull(DevConsole.getInstance());
    }

    @Test
    void execute_withNull_doesNotThrow() {
        assertDoesNotThrow(() -> DevConsole.execute(null));
    }

    @Test
    void execute_withEmptyString_doesNotThrow() {
        assertDoesNotThrow(() -> DevConsole.execute(""));
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\event\EventBusTest.java =====

package com.pulse.event;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * EventBus 회귀 테스트.
 * Lazy Sort 최적화 후 기존 동작이 유지되는지 검증.
 */
class EventBusTest {

    private EventBus eventBus;
    private boolean listenerCalled;
    private int callOrder;

    @BeforeEach
    void setUp() {
        eventBus = EventBus.getInstance();
        eventBus.clearAll();
        listenerCalled = false;
        callOrder = 0;
    }

    @Test
    void subscribe_and_fire_callsListener() {
        EventBus.subscribe(TestEvent.class, e -> listenerCalled = true);
        EventBus.post(new TestEvent());
        assertTrue(listenerCalled);
    }

    @Test
    void priority_highCalledFirst() {
        int[] order = new int[2];

        EventBus.subscribe(TestEvent.class, e -> order[0] = ++callOrder, EventPriority.LOW);
        EventBus.subscribe(TestEvent.class, e -> order[1] = ++callOrder, EventPriority.HIGH);

        EventBus.post(new TestEvent());

        // HIGH가 먼저 호출되므로 order[1] = 1, order[0] = 2
        assertEquals(1, order[1], "HIGH priority should be called first");
        assertEquals(2, order[0], "LOW priority should be called second");
    }

    @Test
    void unsubscribe_removesListener() {
        EventListener<TestEvent> listener = e -> listenerCalled = true;
        EventBus.subscribe(TestEvent.class, listener);
        EventBus.unsubscribe(TestEvent.class, listener);
        EventBus.post(new TestEvent());
        assertFalse(listenerCalled);
    }

    @Test
    void clearAll_removesAllListeners() {
        EventBus.subscribe(TestEvent.class, e -> listenerCalled = true);
        eventBus.clearAll();
        EventBus.post(new TestEvent());
        assertFalse(listenerCalled);
    }

    @Test
    void getListenerCount_returnsCorrectCount() {
        assertEquals(0, eventBus.getListenerCount(TestEvent.class));
        EventBus.subscribe(TestEvent.class, e -> {
        });
        assertEquals(1, eventBus.getListenerCount(TestEvent.class));
        EventBus.subscribe(TestEvent.class, e -> {
        });
        assertEquals(2, eventBus.getListenerCount(TestEvent.class));
    }

    // 테스트용 이벤트 클래스
    static class TestEvent extends Event {
        TestEvent() {
            super(false);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\lifecycle\LifecycleManagerTest.java =====

package com.pulse.lifecycle;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;

import static org.junit.jupiter.api.Assertions.*;

/**
 * LifecycleManager 단위 테스트.
 * 셧다운 훅 등록 및 실행을 검증.
 */
@Tag("unit")
class LifecycleManagerTest {

    private LifecycleManager manager;
    private int callOrder;

    @BeforeEach
    void setUp() {
        manager = LifecycleManager.getInstance();
        callOrder = 0;
    }

    @Test
    void registerShutdownHook_isCalledOnShutdown() {
        // Arrange
        manager.registerShutdownHook(() -> {
        });

        // Act - 강제 셧다운 호출 (테스트용)
        // 실제 JVM 셧다운은 테스트하지 않음
        // manager.shutdown(); // 싱글톤 상태 변경이므로 주의

        // Assert - 훅이 등록되었는지만 확인
        assertTrue(true, "Shutdown hook registration should succeed");
    }

    @Test
    void isShuttingDown_initiallyFalse() {
        // 새 인스턴스에서 shuttingDown 상태 확인
        assertFalse(manager.isShuttingDown(), "Should not be shutting down initially");
    }

    @Test
    void multipleHooks_allCalled() {
        int[] order = new int[3];

        manager.registerShutdownHook(() -> order[0] = ++callOrder);
        manager.registerShutdownHook(() -> order[1] = ++callOrder);
        manager.registerShutdownHook(() -> order[2] = ++callOrder);

        // 훅이 순서대로 등록되었는지 확인
        // 실제 shutdown() 호출은 싱글톤 상태를 변경하므로 생략
        assertTrue(true, "Multiple hooks should be registered");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\lua\BatchLuaBridgeBenchmarkTest.java =====

package com.pulse.lua;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;

import static org.mockito.Mockito.*;

@Tag("benchmark")
class BatchLuaBridgeBenchmarkTest {

    @Test
    void benchmarkBatchVsDirect() {
        // Simple micro-benchmark to compare overhead of queueing vs direct calls
        // Note: This does NOT measure actual Lua execution time, only the Java-side
        // overhead.

        int iterations = 1_000_000;

        // 1. Direct Call Simulation
        long startDirect = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            // Simulate direct call overhead
            if (i % 100 == 0) {
                // Simulate JNI boundary check
            }
        }
        long endDirect = System.nanoTime();

        // 2. Batch Queueing Simulation
        BatchLuaBridge batcher = new BatchLuaBridge(1000);

        try (MockedStatic<LuaBridge> luaBridge = mockStatic(LuaBridge.class)) {
            luaBridge.when(LuaBridge::isAvailable).thenReturn(true);

            long startBatch = System.nanoTime();
            for (int i = 0; i < iterations; i++) {
                batcher.queueCall("test", "arg");
            }
            batcher.flush(); // Flush remaining
            long endBatch = System.nanoTime();

            System.out.printf("Direct (Simulated): %.2f ms%n", (endDirect - startDirect) / 1e6);
            System.out.printf("Batch Queueing:     %.2f ms%n", (endBatch - startBatch) / 1e6);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\lua\LuaBridgeTest.java =====

package com.pulse.lua;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;

import static org.junit.jupiter.api.Assertions.*;

/**
 * LuaBridge 단위 테스트.
 * PZ 런타임 없이 테스트 가능한 항목만 포함.
 */
@Tag("unit")
class LuaBridgeTest {

    @Test
    void getInstance_returnsSameInstance() {
        LuaBridge instance1 = LuaBridge.getInstance();
        LuaBridge instance2 = LuaBridge.getInstance();
        assertSame(instance1, instance2);
    }

    @Test
    void call_withNullFunction_returnsNull() {
        Object result = LuaBridge.call(null);
        assertNull(result);
    }

    @Test
    void call_withInvalidFunction_returnsNull() {
        Object result = LuaBridge.call("nonExistentLuaFunction12345");
        assertNull(result);
    }

    @Test
    void getGlobal_withNullName_returnsNull() {
        Object result = LuaBridge.getGlobal(null);
        assertNull(result);
    }

    @Test
    void setGlobal_withNullName_doesNotThrow() {
        assertDoesNotThrow(() -> LuaBridge.setGlobal(null, "value"));
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\mod\ModLoaderTest.java =====

package com.pulse.mod;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;

import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.*;

/**
 * ModLoader 단위 테스트.
 */
@Tag("unit")
class ModLoaderTest {

    @Test
    void getInstance_returnsSameInstance() {
        ModLoader instance1 = ModLoader.getInstance();
        ModLoader instance2 = ModLoader.getInstance();
        assertSame(instance1, instance2, "ModLoader should be singleton");
    }

    @Test
    void getModsDirectory_returnsValidPath() {
        ModLoader loader = ModLoader.getInstance();
        Path modsDir = loader.getModsDirectory();

        assertNotNull(modsDir, "Mods directory should not be null");
        assertTrue(modsDir.toString().endsWith("mods"), "Should end with 'mods'");
    }

    @Test
    void getMod_returnsNullForUnknown() {
        ModLoader loader = ModLoader.getInstance();
        ModContainer result = loader.getMod("nonexistent-mod-id");

        assertNull(result, "Should return null for unknown mod ID");
    }

    @Test
    void isModLoaded_returnsFalseForUnknown() {
        ModLoader loader = ModLoader.getInstance();
        boolean loaded = loader.isModLoaded("unknown-mod");

        assertFalse(loaded, "Unknown mod should not be loaded");
    }

    @Test
    void getModCount_returnsNonNegative() {
        ModLoader loader = ModLoader.getInstance();
        int count = loader.getModCount();

        assertTrue(count >= 0, "Mod count should be non-negative");
    }

    @Test
    void getAllMods_returnsCollection() {
        ModLoader loader = ModLoader.getInstance();
        var mods = loader.getAllMods();

        assertNotNull(mods, "getAllMods should return non-null collection");
    }

    @Test
    void getLoadOrder_returnsUnmodifiableList() {
        ModLoader loader = ModLoader.getInstance();
        var loadOrder = loader.getLoadOrder();

        assertNotNull(loadOrder, "getLoadOrder should return non-null list");
        assertThrows(UnsupportedOperationException.class, () -> {
            loadOrder.clear();
        }, "Load order should be unmodifiable");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\network\GameNetworkBridgeTest.java =====

package com.pulse.network;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;

import static org.junit.jupiter.api.Assertions.*;

/**
 * GameNetworkBridge 단위 테스트.
 */
@Tag("unit")
class GameNetworkBridgeTest {

    @Test
    void getInstance_returnsSameInstance() {
        GameNetworkBridge instance1 = GameNetworkBridge.getInstance();
        GameNetworkBridge instance2 = GameNetworkBridge.getInstance();
        assertSame(instance1, instance2);
    }

    @Test
    void getInstance_notNull() {
        assertNotNull(GameNetworkBridge.getInstance());
    }

    @Test
    void isServer_withoutPZRuntime_returnsFalse() {
        assertFalse(GameNetworkBridge.getInstance().isServer());
    }

    @Test
    void isClient_withoutPZRuntime_returnsFalse() {
        assertFalse(GameNetworkBridge.getInstance().isClient());
    }

    @Test
    void reconnect_doesNotThrow() {
        assertDoesNotThrow(() -> GameNetworkBridge.getInstance().reconnect());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\src\test\java\com\pulse\scheduler\PulseSchedulerTest.java =====

package com.pulse.scheduler;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;

import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.jupiter.api.Assertions.*;

@Tag("unit")
class PulseSchedulerTest {

    private PulseScheduler scheduler;

    @BeforeEach
    void setUp() {
        scheduler = PulseScheduler.getInstance();
        scheduler.cancelAll();
        // Note: currentTick is persistent across tests because it's in a singleton.
        // We cannot reset currentTick easily without reflection or adding a method.
        // But runLater uses (currentTick + delay). So relative delay should work
        // regardless of absolute tick.
    }

    @Test
    void runLater_executesAfterDelay() {
        AtomicInteger counter = new AtomicInteger(0);
        long startTick = PulseScheduler.getCurrentTick();

        // Run after 2 ticks
        PulseScheduler.runLater(() -> counter.incrementAndGet(), 2);

        // Tick 1 (Elapsed 1)
        scheduler.tick();
        // Should NOT run yet
        assertEquals(0, counter.get(),
                "Should not run after 1 tick. Start: " + startTick + ", Current: " + PulseScheduler.getCurrentTick());

        // Tick 2 (Elapsed 2)
        scheduler.tick();
        // Should run now (or next tick depending on implementation?)
        // Implementation: isReadyToExecute(currentTick) -> currentTick >= targetTick
        // targetTick = startTick + 2
        // currentTick after 2 calls = startTick + 2.
        // So it should run.
        assertEquals(1, counter.get(),
                "Should run after 2 ticks. Start: " + startTick + ", Current: " + PulseScheduler.getCurrentTick());
    }

    @Test
    void runTimer_executesMultipleTimes() {
        AtomicInteger counter = new AtomicInteger(0);

        // 0 ticks delay, period 1 tick
        PulseScheduler.runTimer(() -> counter.incrementAndGet(), 1, 0);

        scheduler.tick(); // Should run 1st time
        assertTrue(counter.get() >= 1, "Should run immediately (delay 0) or after 1 tick");

        int afterFirst = counter.get();
        scheduler.tick(); // Should run 2nd time
        assertTrue(counter.get() > afterFirst, "Should increment");

        scheduler.tick(); // Should run 3rd time
        assertTrue(counter.get() > afterFirst + 1, "Should increment again");
    }

    @Test
    void cancel_stopsExecution() {
        AtomicInteger counter = new AtomicInteger(0);

        TaskHandle handle = PulseScheduler.runTimer(() -> counter.incrementAndGet(), 1, 0);

        scheduler.tick();
        handle.cancel();

        int valueAtCancel = counter.get();

        scheduler.tick();
        scheduler.tick();

        assertEquals(valueAtCancel, counter.get(), "Counter should not increase after cancel");
    }

    @Test
    void cancelAll_stopsAllTasks() {
        AtomicInteger counter = new AtomicInteger(0);

        PulseScheduler.runTimer(() -> counter.incrementAndGet(), 1, 0);
        PulseScheduler.runTimer(() -> counter.incrementAndGet(), 1, 0);

        scheduler.tick();
        assertTrue(counter.get() > 0);

        scheduler.cancelAll();
        int valueAtCancel = counter.get();

        scheduler.tick();

        assertEquals(valueAtCancel, counter.get(), "All tasks should be cancelled");
    }

    @Test
    void getActiveTaskCount_returnsCorrectCount() {
        scheduler.cancelAll();
        assertEquals(0, scheduler.getActiveTaskCount());

        PulseScheduler.runTimer(() -> {
        }, 10, 0);
        PulseScheduler.runLater(() -> {
        }, 100);

        assertEquals(2, scheduler.getActiveTaskCount());

        scheduler.cancelAll();
        assertEquals(0, scheduler.getActiveTaskCount());
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-mods\test-mod-a\build.gradle =====

plugins {
    id 'java'
}

group = 'com.pulse.test'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // Pulse API - 컴파일 타임에만 필요
    compileOnly files('../../build/libs/Pulse.jar')
}

jar {
    archiveBaseName.set('test-mod-a')
    
    from('src/main/resources') {
        include 'pulse.mod.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Test Mod A',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-mods\test-mod-a\src\main\java\com\mutagen\test\a\TestModA.java =====

package com.pulse.test.a;

import com.pulse.api.Pulse;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.mod.PulseMod;

/**
 * Test Mod A - Phase 1 검증용 단순 로그/이벤트 테스트 모드
 * 
 * 테스트 항목:
 * - PulseMod 인터페이스 작동
 * - onInitialize() 호출
 * - EventBus 구독/이벤트 처리
 */
public class TestModA implements PulseMod {

    private static final String MOD_ID = "test_mod_a";
    private int tickCount = 0;

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "═══════════════════════════════════════");
        Pulse.log(MOD_ID, "Test Mod A - onInitialize() called!");
        Pulse.log(MOD_ID, "═══════════════════════════════════════");

        // 이벤트 리스너 등록
        registerEventListeners();

        Pulse.log(MOD_ID, "Test Mod A initialized successfully!");
    }

    private void registerEventListeners() {
        Pulse.log(MOD_ID, "Registering event listeners...");

        // 게임 틱 이벤트 구독
        EventBus.subscribe(GameTickEvent.class, this::onGameTick);

        Pulse.log(MOD_ID, "Event listeners registered!");
    }

    private void onGameTick(GameTickEvent event) {
        tickCount++;

        // 매 1000틱마다 로그 출력 (약 50초)
        if (tickCount % 1000 == 0) {
            Pulse.log(MOD_ID, "Tick count: " + tickCount + " (Event handling works!)");
        }
    }

    @Override
    public void onWorldLoad() {
        Pulse.log(MOD_ID, "World loaded! Test Mod A is active.");
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Test Mod A unloading...");
        Pulse.log(MOD_ID, "Total ticks processed: " + tickCount);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-mods\test-mod-a\src\main\resources\pulse.mod.json =====

{
    "id": "test_mod_a",
    "name": "Test Mod A",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Simple logging and event test mod for Phase 1 verification",
    "entrypoint": "com.pulse.test.a.TestModA",
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-mods\test-mod-b\build.gradle =====

plugins {
    id 'java'
}

group = 'com.pulse.test'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven/' }
}

dependencies {
    // Pulse API - 컴파일 타임에만 필요
    compileOnly files('../../build/libs/Pulse.jar')
    
    // Mixin (annotation processing용)
    compileOnly 'org.spongepowered:mixin:0.8.5'
}

jar {
    archiveBaseName.set('test-mod-b')
    
    from('src/main/resources') {
        include 'pulse.mod.json'
        include 'mixins.testmodb.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Test Mod B',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-mods\test-mod-b\src\main\java\com\mutagen\test\b\mixin\TestMixin.java =====

package com.pulse.test.b.mixin;

import com.pulse.test.b.TestModB;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * Test Mixin - Phase 1 검증용 간단한 Mixin
 * 
 * 이 Mixin은 Object 클래스의 toString()을 타겟으로 합니다.
 * 실제 게임에서는 zombie.* 클래스를 타겟으로 해야 합니다.
 * 
 * 이 예제는 Mixin 시스템 동작 확인용입니다.
 */
@Mixin(Object.class)
public class TestMixin {

    /**
     * 정적 초기화 블록에서 Mixin 적용 알림
     * Mixin 클래스가 로드되면 실행됨
     */
    static {
        try {
            TestModB.onMixinApplied("java.lang.Object");
        } catch (Throwable t) {
            // TestModB가 아직 로드되지 않았을 수 있음
            System.out.println("[TestMixin] Mixin class loaded (TestModB not ready yet)");
        }
    }

    // Note: 실제로 Object.toString()에 Inject하면 성능 영향이 있으므로
    // 이 예제에서는 static 블록으로 로딩만 확인합니다.
    // 실제 모드에서는 게임 클래스를 타겟으로 해야 합니다.
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-mods\test-mod-b\src\main\java\com\mutagen\test\b\TestModB.java =====

package com.pulse.test.b;

import com.pulse.api.Pulse;
import com.pulse.mod.PulseMod;

/**
 * Test Mod B - Phase 1 검증용 Mixin 테스트 모드
 * 
 * 테스트 항목:
 * - PulseMod 인터페이스 작동
 * - 외부 Mixin 설정 로딩
 * - Mixin 적용 확인
 */
public class TestModB implements PulseMod {

    private static final String MOD_ID = "test_mod_b";
    private static boolean mixinApplied = false;

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "═══════════════════════════════════════");
        Pulse.log(MOD_ID, "Test Mod B - onInitialize() called!");
        Pulse.log(MOD_ID, "═══════════════════════════════════════");

        // Mixin 적용 확인
        if (mixinApplied) {
            Pulse.log(MOD_ID, "✓ Mixin was applied successfully!");
        } else {
            Pulse.log(MOD_ID, "⚠ Mixin not yet applied (might be applied after class loads)");
        }

        Pulse.log(MOD_ID, "Test Mod B initialized successfully!");
    }

    /**
     * Mixin에서 호출하는 콜백 메서드
     */
    public static void onMixinApplied(String targetClass) {
        mixinApplied = true;
        Pulse.log("test_mod_b", "Mixin successfully applied to: " + targetClass);
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Test Mod B unloading...");
        Pulse.log(MOD_ID, "Mixin was applied: " + mixinApplied);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-mods\test-mod-b\src\main\resources\mixins.testmodb.json =====

{
    "required": true,
    "package": "com.pulse.test.b.mixin",
    "compatibilityLevel": "JAVA_17",
    "mixins": [
        "TestMixin"
    ],
    "injectors": {
        "defaultRequire": 1
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-mods\test-mod-b\src\main\resources\pulse.mod.json =====

{
    "id": "test_mod_b",
    "name": "Test Mod B",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Mixin test mod for Phase 1 verification",
    "entrypoint": "com.pulse.test.b.TestModB",
    "mixins": [
        "mixins.testmodb.json"
    ],
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-output\testmod\build.gradle =====

plugins {
    id 'java'
}

group = 'com.example.testmod'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // Pulse API - compile time only
    compileOnly files('path/to/Pulse.jar')
}

jar {
    from('src/main/resources') {
        include 'pulse.mod.json'
    }
    
    manifest {
        attributes(
            'Implementation-Title': 'Test Mod',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-output\testmod\src\main\java\com\example\testmod\TestmodMod.java =====

package com.example.testmod;

import com.pulse.api.Pulse;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameInitEvent;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.mod.PulseMod;

/**
 * Test Mod - Main mod class
 */
public class TestmodMod implements PulseMod {

    private static final String MOD_ID = "testmod";

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "Test Mod initializing...");
        
        // Register event listeners
        EventBus.subscribe(GameInitEvent.class, this::onGameInit, MOD_ID);
        EventBus.subscribe(GameTickEvent.class, this::onGameTick, MOD_ID);
        
        Pulse.log(MOD_ID, "Test Mod initialized!");
    }
    
    private void onGameInit(GameInitEvent event) {
        Pulse.log(MOD_ID, "Game initialization complete!");
    }
    
    private void onGameTick(GameTickEvent event) {
        // Called every game tick
        // Add your tick logic here
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Test Mod unloading...");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\Pulse\test-output\testmod\src\main\resources\pulse.mod.json =====

{
  "id": "testmod",
  "name": "Test Mod",
  "version": "1.0.0",
  "author": "Developer",
  "description": "A Pulse mod for Project Zomboid",
  "entrypoint": "com.example.testmod.testmodMod",
  "dependencies": [
    {
      "id": "Pulse",
      "version": ">=1.0.0"
    }
  ]
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\build.gradle =====

// pulse-api - Shared API interfaces for Pulse ecosystem
// This module contains only interfaces and DTOs, no implementations

plugins {
    id 'java-library'
}

group = 'com.pulse'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

// No runtime dependencies - pure interfaces only
dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'
}

test {
    useJUnitPlatform()
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

jar {
    manifest {
        attributes(
            'Implementation-Title': 'Pulse API',
            'Implementation-Version': project.version
        )
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\FailsoftPolicy.java =====

package com.pulse.api;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Pulse Failsoft Policy
 * 
 * Pulse/Echo/Fuse/Nerve 전체에서 공유하는 에러 처리 정책.
 * 비정상 상태 발생 시 통일된 방식으로 보고하고 대응합니다.
 * 
 * @since Pulse 0.9
 */
public final class FailsoftPolicy {

    private FailsoftPolicy() {
    }

    // ═══════════════════════════════════════════════════════════════
    // Failsoft Action 타입
    // ═══════════════════════════════════════════════════════════════

    /**
     * Failsoft 액션 타입
     */
    public enum Action {
        /**
         * Phase 시퀀스 에러 (startPhase 후 endPhase 누락)
         */
        PHASE_SEQUENCE_ERROR,

        /**
         * Tick 계약 위반 (비정상 deltaTime)
         */
        TICK_CONTRACT_VIOLATION,

        /**
         * Lua 예산 초과 (Fuse/Nerve용)
         */
        LUA_BUDGET_EXCEEDED,

        /**
         * 일반 경고 (치명적이지 않은 문제)
         */
        WARNING,

        /**
         * 치명적 에러 (기능 비활성화 필요)
         */
        CRITICAL
    }

    // ═══════════════════════════════════════════════════════════════
    // 에러 기록
    // ═══════════════════════════════════════════════════════════════

    /**
     * Failsoft 보고 레코드
     */
    public static class Report {
        public final Action action;
        public final String detail;
        public final long timestamp;
        public final String contextId;

        public Report(Action action, String detail, String contextId) {
            this.action = action;
            this.detail = detail;
            this.timestamp = System.currentTimeMillis();
            this.contextId = contextId;
        }

        @Override
        public String toString() {
            return String.format("[%s] %s: %s", action, contextId != null ? contextId : "global", detail);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // 상태 관리
    // ═══════════════════════════════════════════════════════════════

    private static final int MAX_REPORTS = 100;
    private static final ConcurrentLinkedQueue<Report> recentReports = new ConcurrentLinkedQueue<>();

    private static final AtomicLong totalReports = new AtomicLong(0);
    private static final AtomicLong phaseSequenceErrors = new AtomicLong(0);
    private static final AtomicLong tickContractViolations = new AtomicLong(0);
    private static final AtomicLong luaBudgetExceeded = new AtomicLong(0);
    private static final AtomicLong criticalErrors = new AtomicLong(0);

    // ═══════════════════════════════════════════════════════════════
    // 보고 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * Failsoft 이슈 보고 (기본)
     * 
     * @param action 액션 타입
     * @param detail 상세 설명
     */
    public static void report(Action action, String detail) {
        report(action, detail, null);
    }

    /**
     * Failsoft 이슈 보고 (컨텍스트 포함)
     * 
     * @param action    액션 타입
     * @param detail    상세 설명
     * @param contextId 컨텍스트 ID (예: modId, phaseId)
     */
    public static void report(Action action, String detail, String contextId) {
        if (action == null || detail == null)
            return;

        // 카운터 증가
        totalReports.incrementAndGet();
        switch (action) {
            case PHASE_SEQUENCE_ERROR:
                phaseSequenceErrors.incrementAndGet();
                break;
            case TICK_CONTRACT_VIOLATION:
                tickContractViolations.incrementAndGet();
                break;
            case LUA_BUDGET_EXCEEDED:
                luaBudgetExceeded.incrementAndGet();
                break;
            case CRITICAL:
                criticalErrors.incrementAndGet();
                break;
            default:
                break;
        }

        // 레포트 저장 (최근 N개만)
        Report report = new Report(action, detail, contextId);
        recentReports.offer(report);
        while (recentReports.size() > MAX_REPORTS) {
            recentReports.poll();
        }

        // 콘솔 출력
        String level = (action == Action.CRITICAL) ? "ERROR" : "WARN";
        System.err.printf("[Pulse/Failsoft/%s] %s%n", level, report);
    }

    // ═══════════════════════════════════════════════════════════════
    // 조회 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 전체 보고 수
     */
    public static long getTotalReports() {
        return totalReports.get();
    }

    /**
     * Phase 시퀀스 에러 수
     */
    public static long getPhaseSequenceErrors() {
        return phaseSequenceErrors.get();
    }

    /**
     * Tick 계약 위반 수
     */
    public static long getTickContractViolations() {
        return tickContractViolations.get();
    }

    /**
     * Lua 예산 초과 수
     */
    public static long getLuaBudgetExceeded() {
        return luaBudgetExceeded.get();
    }

    /**
     * 치명적 에러 수
     */
    public static long getCriticalErrors() {
        return criticalErrors.get();
    }

    /**
     * 최근 보고 목록 (복사본)
     */
    public static Report[] getRecentReports() {
        return recentReports.toArray(new Report[0]);
    }

    /**
     * 상태가 안전한지 확인
     * 
     * @return 치명적 에러가 없으면 true
     */
    public static boolean isSafe() {
        return criticalErrors.get() == 0;
    }

    /**
     * 카운터 리셋
     */
    public static void reset() {
        recentReports.clear();
        totalReports.set(0);
        phaseSequenceErrors.set(0);
        tickContractViolations.set(0);
        luaBudgetExceeded.set(0);
        criticalErrors.set(0);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\IPulse.java =====

package com.pulse.api;

import java.nio.file.Path;
import java.util.Collection;
import java.util.Optional;

/**
 * Pulse 메인 API 인터페이스.
 * Pulse 모드 로더의 핵심 기능에 접근하기 위한 계약.
 */
public interface IPulse {

    /**
     * Pulse 버전 반환
     */
    String getVersion();

    /**
     * API 버전 반환 (호환성 체크용)
     */
    int getApiVersion();

    /**
     * 특정 모드가 로드되었는지 확인
     */
    boolean isModLoaded(String modId);

    /**
     * 모드 정보 가져오기
     */
    Optional<PulseModInfo> getModInfo(String modId);

    /**
     * 로드된 모든 모드 ID 목록
     */
    Collection<String> getLoadedModIds();

    /**
     * Pulse 초기화 완료 여부
     */
    boolean isInitialized();

    /**
     * 게임 디렉토리 경로
     */
    Path getGameDirectory();

    /**
     * mods 디렉토리 경로
     */
    Path getModsDirectory();

    /**
     * 설정 디렉토리 경로
     */
    Path getConfigDirectory();

    /**
     * 현재 실행 사이드 (CLIENT, SERVER 등)
     */
    PulseSide getSide();

    /**
     * 클라이언트 환경인지 확인
     */
    boolean isClient();

    /**
     * 서버 환경인지 확인
     */
    boolean isServer();

    /**
     * DevMode 활성화 여부
     */
    boolean isDevMode();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\IPulseEvent.java =====

package com.pulse.api;

/**
 * Pulse 이벤트 기본 인터페이스.
 * 모든 Pulse 이벤트가 구현해야 하는 기본 계약.
 */
public interface IPulseEvent {

    /**
     * 이벤트 이름 반환
     */
    String getEventName();

    /**
     * 이벤트가 취소 가능한지 여부
     */
    boolean isCancellable();

    /**
     * 이벤트가 취소되었는지 여부
     */
    boolean isCancelled();

    /**
     * 이벤트 취소 (취소 가능한 이벤트만)
     */
    void cancel();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\IPulseEventBus.java =====

package com.pulse.api;

import java.util.function.Consumer;

/**
 * Pulse 이벤트 버스 인터페이스.
 * 이벤트 등록 및 발행을 위한 계약.
 */
public interface IPulseEventBus {

    /**
     * 이벤트 리스너 등록
     * 
     * @param eventType 이벤트 타입 클래스
     * @param listener  리스너 함수
     * @param <T>       이벤트 타입
     */
    <T extends IPulseEvent> void register(Class<T> eventType, Consumer<T> listener);

    /**
     * 이벤트 리스너 해제
     * 
     * @param eventType 이벤트 타입 클래스
     * @param listener  리스너 함수
     * @param <T>       이벤트 타입
     */
    <T extends IPulseEvent> void unregister(Class<T> eventType, Consumer<T> listener);

    /**
     * 이벤트 발행
     * 
     * @param event 발행할 이벤트
     * @param <T>   이벤트 타입
     * @return 이벤트 (체이닝용)
     */
    <T extends IPulseEvent> T post(T event);
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\IPulseMetrics.java =====

package com.pulse.api;

/**
 * Pulse 메트릭 API 인터페이스.
 * 성능 메트릭 데이터에 접근하기 위한 계약.
 * Echo 프로파일러 등에서 사용.
 */
public interface IPulseMetrics {

    /**
     * 현재 FPS
     */
    double getFps();

    /**
     * 프레임 시간 (밀리초)
     */
    double getFrameTimeMs();

    /**
     * 틱 시간 (밀리초)
     */
    double getTickTimeMs();

    /**
     * 평균 틱 시간 (밀리초)
     */
    double getAverageTickTimeMs();

    /**
     * 최대 틱 시간 (밀리초)
     */
    double getMaxTickTimeMs();

    /**
     * TPS (Ticks Per Second)
     */
    double getTps();

    /**
     * 현재 로드된 청크 수
     */
    int getLoadedChunkCount();

    /**
     * 현재 엔티티 수
     */
    int getEntityCount();

    /**
     * 메모리 사용량 (MB)
     */
    long getUsedMemoryMB();

    /**
     * 최대 메모리 (MB)
     */
    long getMaxMemoryMB();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\lua\PulseLuaHook.java =====

package com.pulse.api.lua;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.concurrent.atomic.LongAdder;

/**
 * Pulse Lua Hook API.
 * 
 * LuaEventManager Mixin이 호출하는 Lua 이벤트 훅.
 * Echo 등 외부 모드는 콜백을 등록하여 이벤트 통계를 수집.
 * 
 * Phase 2C 설계:
 * - ThreadLocal<Deque> 스택: 중첩 이벤트 대응 (OnTick → OnPlayerUpdate 등)
 * - profilingEnabled 플래그: true일 때만 nanoTime() 호출
 * - 예외 방어: 스택 언더플로우 시 안전 처리
 * 
 * @since Pulse 1.3
 */
public final class PulseLuaHook {

    // =========================================
    // Phase 1B: 경로 히트 카운터 (경량)
    // =========================================

    private static final LongAdder PATH_HITS = new LongAdder();
    private static volatile boolean enabled = true;

    // =========================================
    // Phase 2C: 콜백 & 프로파일링
    // =========================================

    /** 콜백 인터페이스 - Echo가 구현 */
    public interface LuaEventCallback {
        void onEventEnd(String eventName, long durationMicros);
    }

    /** 등록된 콜백 (null이면 미등록) */
    private static volatile LuaEventCallback callback = null;

    /** 상세 프로파일링 활성화 여부 (별도 플래그, 콜백 유지하면서 ON/OFF 가능) */
    private static volatile boolean profilingEnabled = false;

    /** 중첩 이벤트 대응 스택 (ThreadLocal) */
    private static final ThreadLocal<Deque<EventFrame>> EVENT_STACK = ThreadLocal.withInitial(ArrayDeque::new);

    /** 이벤트 프레임 (eventName + startNanos) */
    private static final class EventFrame {
        final String eventName;
        final long startNanos;

        EventFrame(String eventName, long startNanos) {
            this.eventName = eventName;
            this.startNanos = startNanos;
        }
    }

    private PulseLuaHook() {
        // 유틸리티 클래스
    }

    // =========================================
    // Mixin에서 호출하는 메서드
    // =========================================

    /**
     * 경로 히트 증가 (Phase 1B).
     * 매 triggerEvent마다 호출. ~10ns 미만.
     */
    public static void incrementPathHit() {
        if (enabled) {
            PATH_HITS.increment();
        }
    }

    /**
     * 이벤트 시작 (Phase 2C).
     * 프로파일링 활성화 시에만 스택에 push.
     * 
     * @param eventName Lua 이벤트 이름 (OnTick, OnPlayerUpdate 등)
     */
    public static void fireEventStart(String eventName) {
        // On-Demand: 비활성화 시 nanoTime() 호출 자체를 스킵
        if (!profilingEnabled) {
            return;
        }
        EVENT_STACK.get().push(new EventFrame(eventName, System.nanoTime()));
    }

    /**
     * 이벤트 종료 (Phase 2C).
     * 스택에서 pop하고 콜백 호출.
     * 
     * 예외 방어: 스택이 비어있으면 무시 (예외로 onEventStart 없이 도달 시)
     */
    public static void fireEventEnd() {
        if (!profilingEnabled) {
            return;
        }

        Deque<EventFrame> stack = EVENT_STACK.get();

        // 스택 언더플로우 방어
        EventFrame frame = stack.poll();
        if (frame == null) {
            return; // 예외로 빠져나온 경우
        }

        LuaEventCallback cb = callback;
        if (cb != null) {
            long durationNanos = System.nanoTime() - frame.startNanos;
            long durationMicros = durationNanos / 1000; // ns → μs
            cb.onEventEnd(frame.eventName, durationMicros);
        }
    }

    // =========================================
    // Echo 등 외부에서 호출하는 API
    // =========================================

    /** 경로 히트 카운트 조회 */
    public static long getPathHitCount() {
        return PATH_HITS.sum();
    }

    /** 카운터 리셋 */
    public static void resetPathHitCount() {
        PATH_HITS.reset();
    }

    /** 콜백 등록 */
    public static void setCallback(LuaEventCallback cb) {
        callback = cb;
    }

    /** 상세 프로파일링 활성화 */
    public static void setProfilingEnabled(boolean value) {
        profilingEnabled = value;
    }

    /** 상세 프로파일링 활성화 여부 */
    public static boolean isProfilingEnabled() {
        return profilingEnabled;
    }

    // =========================================
    // 안전 장치
    // =========================================

    public static void setEnabled(boolean value) {
        enabled = value;
    }

    public static boolean isEnabled() {
        return enabled;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\PerformanceAlertEvent.java =====

package com.pulse.api;

/**
 * Echo → Nerve 성능 경보 이벤트 인터페이스.
 * 
 * Echo에서 성능 문제를 감지하면 이 이벤트를 발행하고,
 * Nerve에서 수신하여 자동 최적화 또는 사용자 알림을 처리합니다.
 * 
 * @since 1.0.1
 */
public interface PerformanceAlertEvent extends IPulseEvent {

    /**
     * 경보 유형
     */
    AlertType getAlertType();

    /**
     * 심각도 (0.0 ~ 1.0)
     * 0.0 = 정보성, 1.0 = 치명적
     */
    double getSeverity();

    /**
     * 경보 메시지
     */
    String getMessage();

    /**
     * 발생 타임스탬프 (epoch ms)
     */
    long getTimestamp();

    /**
     * 스레드 컨텍스트 (Nerve/Fuse 필터링용)
     */
    ThreadContext getThreadContext();

    /**
     * 발생 소스 ID (예: "FreezeDetector", "TickHistogram")
     */
    String getSourceId();

    /**
     * 경보 유형 열거형
     */
    enum AlertType {
        /** 틱 스파이크 감지 */
        LAG_SPIKE,
        /** 프리즈 경고 */
        FREEZE_WARNING,
        /** 메모리 압박 */
        MEMORY_PRESSURE,
        /** TPS 저하 */
        TPS_DROP,
        /** GC 일시정지 */
        GC_PAUSE,
        /** 엔티티 과부하 */
        ENTITY_OVERLOAD
    }

    /**
     * 스레드 컨텍스트 열거형
     */
    enum ThreadContext {
        /** 메인 게임 스레드 */
        MAIN,
        /** 렌더링 스레드 */
        RENDER,
        /** 네트워크 스레드 */
        NETWORK,
        /** I/O 스레드 */
        IO,
        /** 워커 스레드 */
        WORKER,
        /** 알 수 없음 */
        UNKNOWN
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\profiler\IsoGridHook.java =====

package com.pulse.api.profiler;

/**
 * Hook for IsoGrid (World Map) profiling.
 * 
 * @since Pulse 0.2.0
 */
public final class IsoGridHook {

    private static volatile IIsoGridCallback callback;
    public static volatile boolean enabled = true;
    public static volatile boolean detailsEnabled = false;

    private IsoGridHook() {
    }

    public static void setCallback(IIsoGridCallback cb) {
        callback = cb;
    }

    public static void onRecalcPropertiesStart() {
        IIsoGridCallback cb = callback;
        if (cb != null)
            cb.onRecalcPropertiesStart();
    }

    public static void onRecalcPropertiesEnd() {
        IIsoGridCallback cb = callback;
        if (cb != null)
            cb.onRecalcPropertiesEnd();
    }

    public static void onFloorUpdateStart() {
        IIsoGridCallback cb = callback;
        if (cb != null)
            cb.onFloorUpdateStart();
    }

    public static void onFloorUpdateEnd() {
        IIsoGridCallback cb = callback;
        if (cb != null)
            cb.onFloorUpdateEnd();
    }

    public static void onLightingUpdateStart() {
        IIsoGridCallback cb = callback;
        if (cb != null)
            cb.onLightingUpdateStart();
    }

    public static void onLightingUpdateEnd() {
        IIsoGridCallback cb = callback;
        if (cb != null)
            cb.onLightingUpdateEnd();
    }

    public static void onWeatherImpactStart() {
        IIsoGridCallback cb = callback;
        if (cb != null)
            cb.onWeatherImpactStart();
    }

    public static void onWeatherImpactEnd() {
        IIsoGridCallback cb = callback;
        if (cb != null)
            cb.onWeatherImpactEnd();
    }

    public interface IIsoGridCallback {
        void onFloorUpdateStart();

        void onFloorUpdateEnd();

        void onRecalcPropertiesStart();

        void onRecalcPropertiesEnd();

        void onLightingUpdateStart();

        void onLightingUpdateEnd();

        void onWeatherImpactStart();

        void onWeatherImpactEnd();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\profiler\IZombieThrottlePolicy.java =====

package com.pulse.api.profiler;

/**
 * Throttle Policy Interface.
 * 
 * Tiered throttle 방식: update() 취소 없이 ThrottleLevel 반환.
 * 
 * @since Pulse 1.2
 * @since Pulse 1.5 - ThrottleLevel 기반으로 변경
 */
public interface IZombieThrottlePolicy {

    /**
     * 좀비의 throttle 레벨 결정.
     * 
     * update()는 절대 취소되지 않으며, 반환된 ThrottleLevel에 따라
     * AI Step들만 선택적으로 throttle됩니다.
     * 
     * @param distSq          플레이어까지 거리 제곱
     * @param isAttacking     공격 중 여부
     * @param hasTarget       타겟 있음 여부
     * @param recentlyEngaged 최근 60틱 내 교전 여부 (피격/사운드 감지)
     * @return ThrottleLevel (FULL/REDUCED/LOW/MINIMAL)
     */
    ThrottleLevel getThrottleLevel(float distSq, boolean isAttacking,
            boolean hasTarget, boolean recentlyEngaged);

    /**
     * 레거시 호환용 (deprecated).
     * 기존 코드 호환을 위해 유지, 내부적으로 getThrottleLevel() 호출.
     * 
     * @deprecated Use getThrottleLevel() instead
     */
    @Deprecated
    default boolean shouldSkipFast(float distSq, boolean isAttacking, boolean hasTarget,
            int iterIndex, int worldTick) {
        // 레거시: FULL이 아니면 skip으로 간주 (하위 호환)
        ThrottleLevel level = getThrottleLevel(distSq, isAttacking, hasTarget, false);
        return level != ThrottleLevel.FULL;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\profiler\PathfindingHook.java =====

package com.pulse.api.profiler;

/**
 * Hook for AI Pathfinding profiling.
 * 
 * @since Pulse 0.2.0
 */
public final class PathfindingHook {

    private static volatile IPathfindingCallback callback;
    public static volatile boolean enabled = false;

    private PathfindingHook() {
    }

    public static void setCallback(IPathfindingCallback cb) {
        callback = cb;
    }

    public static void onLosCalculationStart() {
        IPathfindingCallback cb = callback;
        if (cb != null)
            cb.onLosCalculationStart();
    }

    public static void onLosCalculationEnd() {
        IPathfindingCallback cb = callback;
        if (cb != null)
            cb.onLosCalculationEnd();
    }

    public static void onGridSearchStart() {
        IPathfindingCallback cb = callback;
        if (cb != null)
            cb.onGridSearchStart();
    }

    public static void onGridSearchEnd() {
        IPathfindingCallback cb = callback;
        if (cb != null)
            cb.onGridSearchEnd();
    }

    public static void onPathRequest() {
        IPathfindingCallback cb = callback;
        if (cb != null)
            cb.onPathRequest();
    }

    public interface IPathfindingCallback {
        void onLosCalculationStart();

        void onLosCalculationEnd();

        void onGridSearchStart();

        void onGridSearchEnd();

        void onPathRequest();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\profiler\SubProfilerHook.java =====

package com.pulse.api.profiler;

/**
 * SubProfiler Hook API
 * 
 * Echo의 SubProfiler를 Pulse Mixin에서 호출하기 위한 인터페이스.
 * Echo가 로드되지 않은 환경에서도 안전하게 동작합니다.
 * 
 * @since Pulse 1.1 / Echo 1.0
 */
public final class SubProfilerHook {

    private static volatile ISubProfilerCallback callback = null;

    private SubProfilerHook() {
    }

    /**
     * 콜백 등록 (Echo 초기화 시 호출됨)
     */
    public static void setCallback(ISubProfilerCallback cb) {
        callback = cb;
        System.out.println("[Pulse/SubProfilerHook] Callback registered: " + (cb != null));
    }

    /**
     * 콜백 해제
     */
    public static void clearCallback() {
        callback = null;
    }

    /**
     * SubTiming 측정 시작
     * 
     * @param label SubLabel 이름 (예: "ZOMBIE_UPDATE", "PATHFINDING")
     * @return 시작 시간 (나노초), 비활성화 시 -1
     */
    public static long start(String label) {
        ISubProfilerCallback cb = callback;
        if (cb != null) {
            return cb.start(label);
        }
        return -1;
    }

    /**
     * SubTiming 측정 종료
     * 
     * @param label     SubLabel 이름
     * @param startTime start()에서 반환받은 시작 시간
     */
    public static void end(String label, long startTime) {
        if (startTime < 0)
            return;
        ISubProfilerCallback cb = callback;
        if (cb != null) {
            cb.end(label, startTime);
        }
    }

    /**
     * SubProfiler 콜백 인터페이스
     */
    public interface ISubProfilerCallback {
        long start(String label);

        void end(String label, long startTime);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\profiler\ThrottleLevel.java =====

package com.pulse.api.profiler;

import com.pulse.api.profiler.ZombieStepHook.StepType;

/**
 * Throttle Level for Tiered Zombie Optimization.
 * 
 * 각 레벨은 Step별 interval을 정의합니다.
 * interval=1이면 매 틱 실행, 2면 2틱마다 실행.
 * 
 * @since Pulse 1.5
 */
public enum ThrottleLevel {
    /**
     * 풀 업데이트 - 모든 Step 매 틱 실행.
     * 근거리 또는 공격/타겟/최근 교전 시 적용.
     */
    FULL(1, 1, 1),

    /**
     * 경량 업데이트 - PERCEPTION만 2틱.
     * 중거리 (20-40타일) 적용.
     */
    REDUCED(2, 1, 1),

    /**
     * 최소 업데이트 - PERCEPTION 4틱, BEHAVIOR 2틱.
     * 원거리 (40-80타일) 적용.
     */
    LOW(4, 2, 1),

    /**
     * 휴면 업데이트 - 공격적 throttle.
     * 초원거리 (80타일+) 적용.
     */
    MINIMAL(8, 4, 2);

    /** PERCEPTION step 실행 간격 (틱) */
    public final int perceptionInterval;

    /** BEHAVIOR step 실행 간격 (틱) */
    public final int behaviorInterval;

    /** TARGET step 실행 간격 (틱) */
    public final int targetInterval;

    ThrottleLevel(int perception, int behavior, int target) {
        this.perceptionInterval = perception;
        this.behaviorInterval = behavior;
        this.targetInterval = target;
    }

    /**
     * 주어진 Step이 이번 틱에 실행되어야 하는지 판단.
     * 
     * (zombieId + worldTick) % interval == 0 이면 실행.
     * 
     * @param type      Step 유형
     * @param zombieId  좀비 고유 ID (분산용)
     * @param worldTick 현재 월드 틱
     * @return true면 실행, false면 스킵
     */
    public boolean shouldExecute(StepType type, int zombieId, int worldTick) {
        int interval = getIntervalFor(type);
        if (interval <= 1) {
            return true; // 매 틱 실행
        }
        return ((zombieId + worldTick) % interval) == 0;
    }

    /**
     * Step 유형별 interval 반환.
     */
    public int getIntervalFor(StepType type) {
        if (type == null)
            return 1;

        switch (type) {
            case PERCEPTION:
                return perceptionInterval;
            case BEHAVIOR:
                return behaviorInterval;
            case TARGET:
                return targetInterval;
            case MOTION:
            case COLLISION:
            default:
                return 1; // 항상 실행
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\profiler\TickPhaseHook.java =====

package com.pulse.api.profiler;

import com.pulse.api.FailsoftPolicy;

/**
 * TickPhase Hook API
 * 
 * Echo의 TickPhaseProfiler를 Pulse Mixin에서 호출하기 위한 인터페이스.
 * Echo가 로드되지 않은 환경에서도 안전하게 동작합니다.
 * 
 * v0.9: Phase 시퀀스 검증 및 자동 state reset 추가
 * 
 * @since Pulse 1.1 / Echo 1.0
 * @since Pulse 0.9 - Phase sequence validation
 */
public final class TickPhaseHook {

    private static volatile ITickPhaseCallback callback = null;

    // v0.9: Phase state tracking for sequence validation
    private static volatile String currentOpenPhase = null;
    private static volatile long currentPhaseStartTime = -1;

    // 경고 스로틀링 (처음 3회만 출력)
    private static volatile int phaseErrorCount = 0;
    private static final int MAX_PHASE_WARNINGS = 3;

    // ═══════════════════════════════════════════════════════════════
    // v0.9: Predefined Phase 상수 (Echo TickPhaseBridge 매핑용)
    // ═══════════════════════════════════════════════════════════════
    public static final String PHASE_WORLD_UPDATE = "PULSE_WORLD_UPDATE";
    public static final String PHASE_AI_UPDATE = "PULSE_AI_UPDATE";
    public static final String PHASE_PHYSICS_UPDATE = "PULSE_PHYSICS_UPDATE";
    public static final String PHASE_ZOMBIE_UPDATE = "PULSE_ZOMBIE_UPDATE";
    public static final String PHASE_PLAYER_UPDATE = "PULSE_PLAYER_UPDATE";
    public static final String PHASE_RENDER_PREP = "PULSE_RENDER_PREP";
    public static final String PHASE_ISOGRID_UPDATE = "PULSE_ISOGRID_UPDATE";

    private TickPhaseHook() {
    }

    /**
     * 콜백 등록 (Echo 초기화 시 호출됨)
     */
    public static void setCallback(ITickPhaseCallback cb) {
        callback = cb;
        System.out.println("[Pulse/TickPhaseHook] Callback registered: " + (cb != null));
    }

    /**
     * 콜백 해제
     */
    public static void clearCallback() {
        callback = null;
    }

    /**
     * Phase 측정 시작
     * 
     * @param phase TickPhase 이름 (예: "AI_PHASE", "PHYSICS_PHASE")
     * @return 시작 시간 (나노초), 비활성화 시 -1
     */
    public static long startPhase(String phase) {
        // v0.9: 이전 phase가 닫히지 않았으면 경고 후 자동 리셋
        if (currentOpenPhase != null) {
            reportPhaseSequenceError("startPhase('" + phase + "') called but '"
                    + currentOpenPhase + "' was not closed");
            // 자동 리셋
            currentOpenPhase = null;
            currentPhaseStartTime = -1;
        }

        // 현재 phase 추적
        currentOpenPhase = phase;
        currentPhaseStartTime = System.nanoTime();

        ITickPhaseCallback cb = callback;
        if (cb != null) {
            return cb.startPhase(phase);
        }
        return currentPhaseStartTime;
    }

    /**
     * Phase 측정 종료
     * 
     * @param phase     TickPhase 이름
     * @param startTime startPhase()에서 반환받은 시작 시간
     */
    public static void endPhase(String phase, long startTime) {
        if (startTime < 0)
            return;

        // v0.9: Phase 순서 검증
        if (currentOpenPhase == null) {
            reportPhaseSequenceError("endPhase('" + phase + "') called but no phase is open");
        } else if (!currentOpenPhase.equals(phase)) {
            reportPhaseSequenceError("endPhase('" + phase + "') called but '"
                    + currentOpenPhase + "' is open");
        }

        // 상태 리셋
        currentOpenPhase = null;
        currentPhaseStartTime = -1;

        ITickPhaseCallback cb = callback;
        if (cb != null) {
            cb.endPhase(phase, startTime);
        }
    }

    /**
     * 틱 완료 알림
     * 
     * v0.9: 틱 끝에 열린 phase가 있으면 자동 리셋
     */
    public static void onTickComplete() {
        // v0.9: Phase state validation - 열린 phase 자동 리셋
        if (currentOpenPhase != null) {
            reportPhaseSequenceError("Tick ended but phase '" + currentOpenPhase + "' was not closed");
            currentOpenPhase = null;
            currentPhaseStartTime = -1;
        }

        ITickPhaseCallback cb = callback;
        if (cb != null) {
            cb.onTickComplete();
        }
    }

    /**
     * v0.9: Phase 시퀀스 에러 보고
     */
    private static void reportPhaseSequenceError(String detail) {
        phaseErrorCount++;

        // FailsoftPolicy로 보고
        FailsoftPolicy.report(FailsoftPolicy.Action.PHASE_SEQUENCE_ERROR, detail, "TickPhaseHook");

        // 처음 몇 번만 콘솔 경고 출력
        if (phaseErrorCount <= MAX_PHASE_WARNINGS) {
            System.err.println("[Pulse/TickPhaseHook] Phase sequence error: " + detail);
            if (phaseErrorCount == MAX_PHASE_WARNINGS) {
                System.err.println("[Pulse/TickPhaseHook] (Further phase warnings suppressed)");
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // v0.9: 상태 조회 API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 현재 열린 phase 이름 반환
     */
    public static String getCurrentOpenPhase() {
        return currentOpenPhase;
    }

    /**
     * Phase 에러 카운트 반환
     */
    public static int getPhaseErrorCount() {
        return phaseErrorCount;
    }

    /**
     * 상태 리셋 (테스트용)
     */
    public static void reset() {
        currentOpenPhase = null;
        currentPhaseStartTime = -1;
        phaseErrorCount = 0;
    }

    /**
     * TickPhase 콜백 인터페이스
     */
    public interface ITickPhaseCallback {
        long startPhase(String phase);

        void endPhase(String phase, long startTime);

        void onTickComplete();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\profiler\ZombieHook.java =====

package com.pulse.api.profiler;

/**
 * Zombie Hooks for Echo/Fuse.
 * 
 * Phase 2 Optimized: 리플렉션 제거, 경량화
 * Phase 3: Tiered throttle + ThreadLocal 컨텍스트
 * 
 * @since Pulse 1.2
 * @since Pulse 1.5 - ThrottleLevel 기반 Tiered throttle
 */
public class ZombieHook {

    /** Enable detailed profiling (계측 오버헤드 있음) */
    public static boolean profilingEnabled = false;

    /** Throttle policy (Fuse) */
    private static IZombieThrottlePolicy throttlePolicy;

    /** Profiling callback */
    private static IZombieCallback callback;

    // =================================================================
    // ThreadLocal ThrottleLevel Context (Stale 방지 포함)
    // =================================================================

    /** ThreadLocal 컨텍스트 (level + 설정 틱) */
    private static final ThreadLocal<ThrottleLevelContext> currentContext = new ThreadLocal<>();

    /** 컨텍스트 레코드 - level과 설정 틱을 함께 저장 */
    private static class ThrottleLevelContext {
        final ThrottleLevel level;
        final long setTick;

        ThrottleLevelContext(ThrottleLevel level, long setTick) {
            this.level = level;
            this.setTick = setTick;
        }
    }

    /**
     * 현재 좀비의 ThrottleLevel 설정 (Mixin update HEAD에서 호출).
     */
    public static void setCurrentThrottleLevel(ThrottleLevel level, long worldTick) {
        currentContext.set(new ThrottleLevelContext(level, worldTick));
    }

    /**
     * 현재 ThrottleLevel 조회 (Step hook에서 호출).
     * Stale 방지: 1틱 이상 지난 컨텍스트는 FULL로 폴백.
     */
    public static ThrottleLevel getCurrentThrottleLevel(long worldTick) {
        ThrottleLevelContext ctx = currentContext.get();
        if (ctx == null) {
            return ThrottleLevel.FULL;
        }

        if (worldTick - ctx.setTick > 1) {
            currentContext.remove();
            return ThrottleLevel.FULL;
        }
        return ctx.level;
    }

    /**
     * ThrottleLevel 컨텍스트 정리 (Mixin update RETURN에서 호출).
     */
    public static void clearCurrentThrottleLevel() {
        currentContext.remove();
    }

    // =================================================================
    // Registration
    // =================================================================

    public static void setCallback(IZombieCallback cb) {
        callback = cb;
    }

    public static void clearCallback() {
        callback = null;
    }

    public static void setThrottlePolicy(IZombieThrottlePolicy policy) {
        throttlePolicy = policy;
        if (policy != null) {
            System.out.println("[Pulse] ZombieThrottlePolicy registered (Tiered mode)");
        }
    }

    public static void clearThrottlePolicy() {
        throttlePolicy = null;
    }

    // =================================================================
    // ThrottleLevel API (신규)
    // =================================================================

    /**
     * ThrottleLevel 조회 (Mixin에서 호출).
     */
    public static ThrottleLevel getThrottleLevel(float distSq, boolean isAttacking,
            boolean hasTarget, boolean recentlyEngaged) {
        if (throttlePolicy == null) {
            return ThrottleLevel.FULL;
        }

        try {
            return throttlePolicy.getThrottleLevel(distSq, isAttacking, hasTarget, recentlyEngaged);
        } catch (Throwable t) {
            return ThrottleLevel.FULL;
        }
    }

    // =================================================================
    // Legacy API (Deprecated)
    // =================================================================

    /**
     * @deprecated Use getThrottleLevel() instead
     */
    @Deprecated
    public static boolean shouldSkipFast(float distSq, boolean isAttacking, boolean hasTarget,
            int iterIndex, int worldTick) {
        ThrottleLevel level = getThrottleLevel(distSq, isAttacking, hasTarget, false);
        return level != ThrottleLevel.FULL;
    }

    // --- Profiling (조건부) ---

    public static void onZombieUpdate(Object zombie) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onZombieUpdateWithContext(zombie);
            } catch (Throwable t) {
            }
        }
    }

    public static void onMotionUpdateStart(Object zombie) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onMotionUpdateStartWithContext(zombie);
            } catch (Throwable t) {
            }
        }
    }

    public static void onMotionUpdateEnd(Object zombie) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onMotionUpdateEndWithContext(zombie);
            } catch (Throwable t) {
            }
        }
    }

    // --- Phase 2: New Zombie Event Hooks ---

    /**
     * 좀비가 플레이어를 발견했을 때
     */
    public static void onZombieSpotted(Object zombie, Object target, boolean forced) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onZombieSpottedWithContext(zombie, target, forced);
            } catch (Throwable t) {
            }
        }
    }

    /**
     * 좀비가 피격당했을 때
     */
    public static void onZombieHit(Object zombie, Object attacker, float damage) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onZombieHitWithContext(zombie, attacker, damage);
            } catch (Throwable t) {
            }
        }
    }

    /**
     * 좀비가 사망했을 때
     */
    public static void onZombieKill(Object zombie, Object killer) {
        if (callback != null && profilingEnabled) {
            try {
                callback.onZombieKillWithContext(zombie, killer);
            } catch (Throwable t) {
            }
        }
    }

    // Legacy - disabled
    public static void onZombieUpdate() {
    }

    public static void onMotionUpdateStart() {
    }

    public static void onMotionUpdateEnd() {
    }

    public static void onSoundPerceptionStart() {
    }

    public static void onSoundPerceptionEnd() {
    }

    public static void onTargetTrackingStart() {
    }

    public static void onTargetTrackingEnd() {
    }

    public static void onSoundPerceptionStart(Object z) {
    }

    public static void onSoundPerceptionEnd(Object z) {
    }

    public static void onTargetTrackingStart(Object z) {
    }

    public static void onTargetTrackingEnd(Object z) {
    }

    // --- Callback Interface ---

    public interface IZombieCallback {
        default void onZombieUpdate() {
        }

        default void onMotionUpdateStart() {
        }

        default void onMotionUpdateEnd() {
        }

        default void onSoundPerceptionStart() {
        }

        default void onSoundPerceptionEnd() {
        }

        default void onTargetTrackingStart() {
        }

        default void onTargetTrackingEnd() {
        }

        default void onZombieUpdateWithContext(Object zombie) {
            onZombieUpdate();
        }

        default void onMotionUpdateStartWithContext(Object zombie) {
            onMotionUpdateStart();
        }

        default void onMotionUpdateEndWithContext(Object zombie) {
            onMotionUpdateEnd();
        }

        default void onSoundPerceptionStartWithContext(Object zombie) {
            onSoundPerceptionStart();
        }

        default void onSoundPerceptionEndWithContext(Object zombie) {
            onSoundPerceptionEnd();
        }

        default void onTargetTrackingStartWithContext(Object zombie) {
            onTargetTrackingStart();
        }

        default void onTargetTrackingEndWithContext(Object zombie) {
            onTargetTrackingEnd();
        }

        // --- Phase 2: New Event Hooks ---

        default void onZombieSpotted(Object target, boolean forced) {
        }

        default void onZombieSpottedWithContext(Object zombie, Object target, boolean forced) {
            onZombieSpotted(target, forced);
        }

        default void onZombieHit(Object attacker, float damage) {
        }

        default void onZombieHitWithContext(Object zombie, Object attacker, float damage) {
            onZombieHit(attacker, damage);
        }

        default void onZombieKill(Object killer) {
        }

        default void onZombieKillWithContext(Object zombie, Object killer) {
            onZombieKill(killer);
        }
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\profiler\ZombieStepHook.java =====

package com.pulse.api.profiler;

/**
 * Zombie Step Hook - Step-level throttling API.
 * 
 * Pulse provides hooks for individual zombie AI steps.
 * Fuse/other modules can implement throttle policies.
 * 
 * @since Pulse 1.3
 */
public class ZombieStepHook {

    /** Step types for throttling */
    public enum StepType {
        MOTION, // 이동 (skip 불가)
        PERCEPTION, // 인지 (throttle 가능)
        BEHAVIOR, // 행동 결정 (throttle 가능)
        TARGET, // 타겟 추적 (throttle 가능)
        COLLISION // 충돌 (skip 불가)
    }

    /** Throttle policy (Fuse에서 구현) */
    private static IZombieStepPolicy stepPolicy;

    // --- Registration ---

    public static void setStepPolicy(IZombieStepPolicy policy) {
        stepPolicy = policy;
        if (policy != null) {
            System.out.println("[Pulse] ZombieStepPolicy registered: " + policy.getClass().getSimpleName());
        }
    }

    public static void clearStepPolicy() {
        stepPolicy = null;
    }

    // --- Step Throttle Check ---

    /**
     * Check if a specific step should be skipped.
     */
    public static boolean shouldSkipStep(StepType stepType, float distSq, IStepContext context) {
        if (stepPolicy == null)
            return false;

        // MOTION and COLLISION are never skipped
        if (stepType == StepType.MOTION || stepType == StepType.COLLISION) {
            return false;
        }

        try {
            return stepPolicy.shouldSkipStep(stepType, distSq, context);
        } catch (Throwable t) {
            return false;
        }
    }

    public static boolean shouldSkipStep(StepType stepType, float distSq) {
        return shouldSkipStep(stepType, distSq, null);
    }

    // --- Interfaces ---

    public interface IZombieStepPolicy {
        boolean shouldSkipStep(StepType stepType, float distSq, IStepContext context);
    }

    public interface IStepContext {
        int getIterIndex();

        int getWorldTick();

        boolean isAttacking();

        boolean hasTarget();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\PulseLifecyclePhase.java =====

package com.pulse.api;

/**
 * Pulse 라이프사이클 단계.
 * 
 * Phase 3.1: 부트스트랩 프로파일링 포인트.
 * 모드 로딩이 느린지 vs 런타임이 느린지 구분할 수 있습니다.
 * 
 * @since 1.0.1
 */
public enum PulseLifecyclePhase {

    /**
     * 모드 발견 단계
     * mods 폴더 스캔 및 모드 목록 구성
     */
    MOD_DISCOVERY("Mod Discovery", "모드 파일 탐색"),

    /**
     * 모드 로딩 단계
     * 모드 JAR 파일 로드 및 초기화
     */
    MOD_LOADING("Mod Loading", "모드 클래스 로딩"),

    /**
     * Mixin 적용 단계
     * 바이트코드 변환 수행
     */
    MIXIN_APPLICATION("Mixin Application", "Mixin 변환 적용"),

    /**
     * 엔트리포인트 실행 단계
     * 모드 초기화 메서드 호출
     */
    ENTRYPOINT_EXECUTION("Entrypoint Execution", "모드 초기화"),

    /**
     * 런타임 활성 단계
     * 게임 실행 중
     */
    RUNTIME_ACTIVE("Runtime Active", "게임 실행 중"),

    /**
     * 종료 단계
     * 게임 종료 및 정리
     */
    SHUTDOWN("Shutdown", "게임 종료");

    private final String displayName;
    private final String description;
    private long startTimeMs = 0;
    private long endTimeMs = 0;
    private boolean completed = false;

    PulseLifecyclePhase(String displayName, String description) {
        this.displayName = displayName;
        this.description = description;
    }

    public String getDisplayName() {
        return displayName;
    }

    public String getDescription() {
        return description;
    }

    public long getStartTimeMs() {
        return startTimeMs;
    }

    public long getEndTimeMs() {
        return endTimeMs;
    }

    public long getDurationMs() {
        if (startTimeMs == 0)
            return 0;
        if (endTimeMs == 0)
            return System.currentTimeMillis() - startTimeMs;
        return endTimeMs - startTimeMs;
    }

    public boolean isCompleted() {
        return completed;
    }

    /**
     * 단계 시작 기록
     */
    public void markStart() {
        this.startTimeMs = System.currentTimeMillis();
        this.completed = false;
    }

    /**
     * 단계 완료 기록
     */
    public void markEnd() {
        this.endTimeMs = System.currentTimeMillis();
        this.completed = true;
    }

    /**
     * 모든 단계 초기화
     */
    public static void resetAll() {
        for (PulseLifecyclePhase phase : values()) {
            phase.startTimeMs = 0;
            phase.endTimeMs = 0;
            phase.completed = false;
        }
    }

    /**
     * 전체 라이프사이클 타이밍 맵
     */
    public static java.util.Map<String, Object> toMap() {
        java.util.Map<String, Object> map = new java.util.LinkedHashMap<>();

        for (PulseLifecyclePhase phase : values()) {
            java.util.Map<String, Object> phaseData = new java.util.LinkedHashMap<>();
            phaseData.put("duration_ms", phase.getDurationMs());
            phaseData.put("completed", phase.isCompleted());
            if (phase.startTimeMs > 0) {
                phaseData.put("start_time", phase.startTimeMs);
            }
            map.put(phase.name().toLowerCase(), phaseData);
        }

        // 총 부트스트랩 시간 (MOD_DISCOVERY ~ ENTRYPOINT_EXECUTION)
        long bootstrapTotal = 0;
        for (PulseLifecyclePhase phase : values()) {
            if (phase != RUNTIME_ACTIVE && phase != SHUTDOWN) {
                bootstrapTotal += phase.getDurationMs();
            }
        }
        map.put("bootstrap_total_ms", bootstrapTotal);

        return map;
    }

    /**
     * 현재 활성 단계
     */
    public static PulseLifecyclePhase getCurrentPhase() {
        for (int i = values().length - 1; i >= 0; i--) {
            PulseLifecyclePhase phase = values()[i];
            if (phase.startTimeMs > 0 && !phase.completed) {
                return phase;
            }
        }
        // 모든 단계 완료 시 RUNTIME_ACTIVE 반환
        return RUNTIME_ACTIVE;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\PulseModInfo.java =====

package com.pulse.api;

/**
 * 모드 정보 DTO.
 * 로드된 모드의 메타데이터를 담는 불변 객체.
 */
public final class PulseModInfo {

    private final String modId;
    private final String name;
    private final String version;
    private final String description;
    private final String[] authors;

    public PulseModInfo(String modId, String name, String version, String description, String[] authors) {
        this.modId = modId;
        this.name = name;
        this.version = version;
        this.description = description;
        this.authors = authors != null ? authors.clone() : new String[0];
    }

    public String getModId() {
        return modId;
    }

    public String getName() {
        return name;
    }

    public String getVersion() {
        return version;
    }

    public String getDescription() {
        return description;
    }

    public String[] getAuthors() {
        return authors.clone();
    }

    @Override
    public String toString() {
        return String.format("%s (%s) v%s", name, modId, version);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\PulseSide.java =====

package com.pulse.api;

/**
 * Pulse 실행 환경 사이드.
 * 클라이언트/서버 구분에 사용.
 */
public enum PulseSide {

    /**
     * 순수 클라이언트 (싱글플레이어 포함)
     */
    CLIENT,

    /**
     * 통합 서버 (싱글플레이어 호스트)
     */
    INTEGRATED_SERVER,

    /**
     * 데디케이티드 서버
     */
    DEDICATED_SERVER,

    /**
     * 알 수 없음 (초기화 전)
     */
    UNKNOWN;

    /**
     * 클라이언트 역할을 수행하는지 확인
     */
    public boolean isClient() {
        return this == CLIENT || this == INTEGRATED_SERVER;
    }

    /**
     * 서버 역할을 수행하는지 확인
     */
    public boolean isServer() {
        return this == DEDICATED_SERVER || this == INTEGRATED_SERVER;
    }

    /**
     * 데디케이티드 서버인지 확인
     */
    public boolean isDedicatedServer() {
        return this == DEDICATED_SERVER;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\IEntityMetrics.java =====

package com.pulse.api.spi;

/**
 * 엔티티 메트릭 인터페이스.
 * 
 * Phase 2.3: 엔티티 타입별 카운터를 제공합니다.
 * Echo에서 구현하여 Pulse에 등록하면 상관관계 분석에 활용됩니다.
 * 
 * @since 1.0.1
 */
public interface IEntityMetrics {

    /**
     * 현재 좀비 수
     */
    int getZombieCount();

    /**
     * 현재 생존자 NPC 수
     */
    int getNpcCount();

    /**
     * 현재 동물 수
     */
    int getAnimalCount();

    /**
     * 현재 차량 수
     */
    int getVehicleCount();

    /**
     * 월드에 놓인 아이템 수
     */
    int getWorldItemCount();

    /**
     * 로드된 셀(청크) 수
     */
    int getLoadedCellCount();

    /**
     * 총 엔티티 수 (좀비 + NPC + 동물)
     */
    default int getTotalEntityCount() {
        return getZombieCount() + getNpcCount() + getAnimalCount();
    }

    /**
     * 엔티티 밀도 (셀당 평균 엔티티 수)
     */
    default double getEntityDensity() {
        int cells = getLoadedCellCount();
        if (cells == 0)
            return 0;
        return (double) getTotalEntityCount() / cells;
    }

    /**
     * 빠른 엔티티 요약 맵
     */
    default java.util.Map<String, Integer> getEntitySummary() {
        java.util.Map<String, Integer> map = new java.util.LinkedHashMap<>();
        map.put("zombies", getZombieCount());
        map.put("npcs", getNpcCount());
        map.put("animals", getAnimalCount());
        map.put("vehicles", getVehicleCount());
        map.put("world_items", getWorldItemCount());
        map.put("cells", getLoadedCellCount());
        return map;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\INetworkProvider.java =====

package com.pulse.api.spi;

import java.util.Map;

/**
 * 네트워크 프로바이더 인터페이스.
 * Nerve와 같은 네트워크 모드가 구현.
 * 
 * 이 인터페이스는 Lua 모드와 Pulse 모드 모두 구현 가능.
 * Lua 모드는 브릿지를 통해 호출됨.
 */
public interface INetworkProvider extends IProvider {

    /**
     * 서버 연결 상태
     */
    boolean isConnected();

    /**
     * 현재 핑 (밀리초)
     */
    int getPingMs();

    /**
     * 평균 핑 (밀리초)
     */
    int getAveragePingMs();

    /**
     * 패킷 손실률 (%)
     */
    double getPacketLossPercent();

    /**
     * 송신 대역폭 (bytes/sec)
     */
    long getOutboundBandwidth();

    /**
     * 수신 대역폭 (bytes/sec)
     */
    long getInboundBandwidth();

    /**
     * 총 송신 바이트
     */
    long getTotalBytesSent();

    /**
     * 총 수신 바이트
     */
    long getTotalBytesReceived();

    /**
     * 패킷 타입별 통계
     * 
     * @return 패킷 타입 → 전송 횟수
     */
    Map<String, Long> getPacketStats();

    /**
     * 네트워크 통계 리셋
     */
    void resetStats();

    /**
     * 네트워크 품질 등급 (0=나쁨, 1=보통, 2=좋음)
     */
    default int getNetworkQuality() {
        int ping = getPingMs();
        double loss = getPacketLossPercent();

        if (ping < 50 && loss < 1.0)
            return 2; // 좋음
        if (ping < 150 && loss < 5.0)
            return 1; // 보통
        return 0; // 나쁨
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\IOptimizerProvider.java =====

package com.pulse.api.spi;

import java.util.Collection;
import java.util.Map;

/**
 * 최적화 프로바이더 인터페이스.
 * Fuse와 같은 최적화 모드가 구현.
 * 
 * 다른 모드도 동일한 인터페이스를 구현하여 최적화 기능 제공 가능.
 */
public interface IOptimizerProvider extends IProvider {

    /**
     * 최적화 가능한 영역 목록 조회
     */
    Collection<String> getOptimizableAreas();

    /**
     * 특정 영역 최적화 적용
     * 
     * @param area 최적화 영역 이름
     * @return 적용 성공 여부
     */
    boolean applyOptimization(String area);

    /**
     * 특정 영역 최적화 해제
     * 
     * @param area 최적화 영역 이름
     * @return 해제 성공 여부
     */
    boolean removeOptimization(String area);

    /**
     * 현재 적용된 최적화 목록
     */
    Collection<String> getActiveOptimizations();

    /**
     * 모든 최적화 적용
     */
    void applyAllOptimizations();

    /**
     * 모든 최적화 해제
     */
    void removeAllOptimizations();

    /**
     * 최적화 통계 조회
     * 
     * @return 영역별 개선율 (%)
     */
    Map<String, Double> getOptimizationStats();

    /**
     * 최적화로 인한 전체 성능 개선율 (%)
     */
    double getTotalImprovementPercent();

    /**
     * 병목 지점 힌트 받기 (프로파일러 연동)
     * 
     * @param bottlenecks 병목 영역 목록
     */
    default void receiveBottleneckHints(Collection<String> bottlenecks) {
        // 기본 구현: 무시
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\IProfilerProvider.java =====

package com.pulse.api.spi;

/**
 * 프로파일링 프로바이더 인터페이스.
 * Echo와 같은 프로파일링 모드가 구현.
 * 
 * 다른 모드도 동일한 인터페이스를 구현하여 프로파일링 기능 제공 가능.
 */
public interface IProfilerProvider extends IProvider {

    /**
     * 틱 시작 시 호출
     */
    void onTickStart();

    /**
     * 틱 종료 시 호출
     * 
     * @param tickTimeNanos 틱 소요 시간 (나노초)
     */
    void onTickEnd(long tickTimeNanos);

    /**
     * 프레임 시작 시 호출
     */
    void onFrameStart();

    /**
     * 프레임 종료 시 호출
     * 
     * @param frameTimeNanos 프레임 소요 시간 (나노초)
     */
    void onFrameEnd(long frameTimeNanos);

    /**
     * 현재 FPS 조회
     */
    double getCurrentFps();

    /**
     * 현재 평균 틱 시간 (밀리초)
     */
    double getAverageTickTimeMs();

    /**
     * 현재 평균 프레임 시간 (밀리초)
     */
    double getAverageFrameTimeMs();

    /**
     * 프로파일링 활성화
     */
    void startProfiling();

    /**
     * 프로파일링 비활성화
     */
    void stopProfiling();

    /**
     * 프로파일링 중인지 확인
     */
    boolean isProfiling();

    /**
     * 프로파일링 데이터 리셋
     */
    void resetData();
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\IProvider.java =====

package com.pulse.api.spi;

/**
 * 모든 SPI 프로바이더의 기본 인터페이스.
 * Pulse 위에서 동작하는 모든 확장 모드가 구현해야 하는 기본 계약.
 * 
 * 사용 예:
 * public class MyProfiler implements IProvider, IProfilerProvider {
 * // ...
 * }
 */
public interface IProvider {

    /**
     * 프로바이더 고유 ID (예: "echo", "fuse", "nerve")
     */
    String getId();

    /**
     * 프로바이더 이름 (표시용)
     */
    String getName();

    /**
     * 프로바이더 버전
     */
    String getVersion();

    /**
     * 프로바이더 설명
     */
    default String getDescription() {
        return "";
    }

    /**
     * 우선순위 (높을수록 먼저 실행)
     */
    default int getPriority() {
        return Priority.NORMAL;
    }

    /**
     * 프로바이더 초기화
     * Pulse가 모드 로드 시 호출
     */
    default void onInitialize() {
    }

    /**
     * 프로바이더 종료
     * Pulse가 게임 종료 시 호출
     */
    default void onShutdown() {
    }

    /**
     * 프로바이더 활성화 여부
     */
    default boolean isEnabled() {
        return true;
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\IProviderCallback.java =====

package com.pulse.api.spi;

/**
 * 프로바이더 이벤트 콜백 인터페이스.
 * 프로바이더 등록/해제 등의 이벤트를 수신할 수 있음.
 */
public interface IProviderCallback {

    /**
     * 프로바이더가 등록되었을 때 호출
     * 
     * @param provider 등록된 프로바이더
     */
    default void onProviderRegistered(IProvider provider) {
    }

    /**
     * 프로바이더가 해제되었을 때 호출
     * 
     * @param provider 해제된 프로바이더
     */
    default void onProviderUnregistered(IProvider provider) {
    }

    /**
     * 프로바이더 생명주기가 변경되었을 때 호출
     * 
     * @param provider 프로바이더
     * @param oldState 이전 상태
     * @param newState 새 상태
     */
    default void onLifecycleChanged(IProvider provider,
            ProviderLifecycle oldState,
            ProviderLifecycle newState) {
    }

    /**
     * 프로바이더에서 오류가 발생했을 때 호출
     * 
     * @param provider 프로바이더
     * @param error    발생한 오류
     */
    default void onProviderError(IProvider provider, Throwable error) {
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\IProviderRegistry.java =====

package com.pulse.api.spi;

import java.util.Collection;
import java.util.Optional;

/**
 * 프로바이더 레지스트리 인터페이스.
 * Pulse가 이 인터페이스를 구현하여 프로바이더를 관리함.
 * 
 * 사용 예:
 * // 프로파일러 프로바이더 조회
 * Optional<IProfilerProvider> profiler =
 * registry.getProvider(IProfilerProvider.class);
 * 
 * // 모든 프로바이더 조회
 * Collection<IProvider> all = registry.getAllProviders();
 */
public interface IProviderRegistry {

    /**
     * 프로바이더 등록
     * 
     * @param provider 등록할 프로바이더
     * @param <T>      프로바이더 타입
     */
    <T extends IProvider> void register(T provider);

    /**
     * 프로바이더 등록 해제
     * 
     * @param providerId 프로바이더 ID
     */
    void unregister(String providerId);

    /**
     * ID로 프로바이더 조회
     * 
     * @param providerId 프로바이더 ID
     * @return 프로바이더 (없으면 Optional.empty())
     */
    Optional<IProvider> getProvider(String providerId);

    /**
     * 타입으로 프로바이더 조회
     * 
     * @param type 프로바이더 인터페이스 타입
     * @param <T>  프로바이더 타입
     * @return 해당 타입을 구현한 첫 번째 프로바이더
     */
    <T extends IProvider> Optional<T> getProvider(Class<T> type);

    /**
     * 타입으로 모든 프로바이더 조회
     * 
     * @param type 프로바이더 인터페이스 타입
     * @param <T>  프로바이더 타입
     * @return 해당 타입을 구현한 모든 프로바이더 (우선순위 정렬)
     */
    <T extends IProvider> Collection<T> getProviders(Class<T> type);

    /**
     * 등록된 모든 프로바이더 조회
     * 
     * @return 모든 프로바이더 목록
     */
    Collection<IProvider> getAllProviders();

    /**
     * 특정 프로바이더가 등록되어 있는지 확인
     * 
     * @param providerId 프로바이더 ID
     * @return 등록 여부
     */
    boolean isRegistered(String providerId);

    /**
     * 특정 타입의 프로바이더가 등록되어 있는지 확인
     * 
     * @param type 프로바이더 인터페이스 타입
     * @return 등록 여부
     */
    <T extends IProvider> boolean hasProvider(Class<T> type);
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\ITickHealthProvider.java =====

package com.pulse.api.spi;

/**
 * Tick Health Provider SPI.
 * 
 * Tick 건강 상태(SlowTick, Spike 카운트 등)를 제공하는 인터페이스.
 * Echo 같은 프로파일러 모드가 구현하고, Nerve 같은 최적화 모드가 조회함.
 * 
 * 핵심 철학:
 * - 인터페이스(계약)는 pulse-api에 존재
 * - Echo는 이 인터페이스를 구현해서 Pulse에 등록 (선택)
 * - Nerve는 Pulse 레지스트리를 통해서만 조회 (Echo를 직접 참조 안함)
 * - Provider가 없으면 fail-open (안전 기본값 반환)
 * 
 * @since Pulse 1.1
 */
public interface ITickHealthProvider extends IProvider {

    /**
     * 현재 SlowTick 상태인지 확인.
     * SlowTick: 최근 틱이 임계값(예: 33.33ms)을 초과한 상태.
     * 
     * @return SlowTick 상태면 true
     */
    boolean isSlowTick();

    /**
     * 최근 N초 내 발생한 스파이크 횟수.
     * 스파이크: 틱 시간이 spikeTreshold(예: 100ms)를 초과한 횟수.
     * 
     * @return 스파이크 횟수 (0 이상)
     */
    int getRecentSpikeCount();

    /**
     * 최근 1초 내 최대 틱 시간 (ms).
     * 
     * @return 최대 틱 시간 (0 이상)
     */
    default double getLast1sMaxMs() {
        return 0.0;
    }

    /**
     * 최근 5초 평균 틱 시간 (ms).
     * 
     * @return 평균 틱 시간 (0 이상)
     */
    default double getLast5sAvgMs() {
        return 0.0;
    }

    /**
     * Tick Health가 "위험" 상태인지 확인.
     * 위험: 연속 스파이크, P95 초과 등.
     * 
     * @return 위험 상태면 true
     */
    default boolean isDangerous() {
        return getRecentSpikeCount() >= 3 || getLast1sMaxMs() > 100;
    }

    // ===================================
    // Fail-open 기본 구현 (Provider 없을 때)
    // ===================================

    /**
     * 기본 Tick Health Provider (fail-open).
     * Provider가 등록되지 않았을 때 사용되는 안전 기본값.
     */
    ITickHealthProvider DEFAULT = new ITickHealthProvider() {
        @Override
        public String getId() {
            return "default-tick-health";
        }

        @Override
        public String getName() {
            return "Default Tick Health Provider";
        }

        @Override
        public String getVersion() {
            return "1.0";
        }

        @Override
        public String getDescription() {
            return "Fail-open default provider - always returns safe values";
        }

        @Override
        public boolean isSlowTick() {
            return false; // 안전: SlowTick 아님
        }

        @Override
        public int getRecentSpikeCount() {
            return 0; // 안전: 스파이크 없음
        }

        @Override
        public boolean isEnabled() {
            return true;
        }
    };
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\package-info.java =====

/**
 * Pulse SPI (Service Provider Interface) 패키지.
 * 
 * 모든 Pulse 모드(Echo, Fuse, Nerve 등)가 구현할 수 있는 범용 인터페이스 제공.
 * 특정 모드에 특혜 없이, 동일한 API로 Pulse와 연동 가능.
 * 
 * <h2>핵심 인터페이스</h2>
 * <ul>
 * <li>{@link IProvider} - 모든 프로바이더의 기본 인터페이스</li>
 * <li>{@link IProviderRegistry} - 프로바이더 등록/조회</li>
 * </ul>
 * 
 * <h2>도메인 인터페이스</h2>
 * <ul>
 * <li>{@link IProfilerProvider} - 프로파일링 (Echo 등)</li>
 * <li>{@link IOptimizerProvider} - 최적화 (Fuse 등)</li>
 * <li>{@link INetworkProvider} - 네트워크 (Nerve 등)</li>
 * </ul>
 * 
 * <h2>사용 예</h2>
 * 
 * <pre>
 * public class MyProfiler implements IProfilerProvider {
 *     public String getId() {
 *         return "my-profiler";
 *     }
 * 
 *     public String getName() {
 *         return "My Profiler";
 *     }
 * 
 *     public String getVersion() {
 *         return "1.0.0";
 *     }
 *     // ... 기타 메서드 구현
 * }
 * 
 * // Pulse에 등록
 * Pulse.getProviderRegistry().register(new MyProfiler());
 * </pre>
 */
package com.pulse.api.spi;



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\Priority.java =====

package com.pulse.api.spi;

/**
 * 프로바이더 우선순위 상수.
 * 높을수록 먼저 초기화되고 이벤트를 먼저 받음.
 */
public final class Priority {

    private Priority() {
    }

    /** 가장 높은 우선순위 - 시스템 레벨 */
    public static final int HIGHEST = 1000;

    /** 높은 우선순위 - 핵심 기능 */
    public static final int HIGH = 750;

    /** 기본 우선순위 */
    public static final int NORMAL = 500;

    /** 낮은 우선순위 */
    public static final int LOW = 250;

    /** 가장 낮은 우선순위 - 후처리 */
    public static final int LOWEST = 0;
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\spi\ProviderLifecycle.java =====

package com.pulse.api.spi;

/**
 * 프로바이더 생명주기 상태.
 */
public enum ProviderLifecycle {

    /** 등록됨, 아직 초기화 안 됨 */
    REGISTERED,

    /** 초기화 중 */
    INITIALIZING,

    /** 활성화됨, 정상 동작 중 */
    ACTIVE,

    /** 일시 정지됨 */
    SUSPENDED,

    /** 종료 중 */
    SHUTTING_DOWN,

    /** 종료됨 */
    TERMINATED,

    /** 오류 발생 */
    ERROR
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\TickContract.java =====

package com.pulse.api;

/**
 * Pulse-Echo 공유 Tick 계약 상수
 * 
 * Pulse와 Echo가 동일한 기준으로 Tick 이벤트를 해석하기 위한 공식 계약.
 * 모든 시간 단위는 milliseconds로 통일됨.
 * 
 * @since Pulse 0.9 / Echo 0.9
 */
public final class TickContract {

    private TickContract() {
    }

    // ═══════════════════════════════════════════════════════════════
    // 계약 버전 (Fuse/Nerve 호환성 확인용)
    // ═══════════════════════════════════════════════════════════════

    /**
     * 계약 버전. 변경 시 Echo Report에 기록됨.
     */
    public static final int VERSION = 1;

    // ═══════════════════════════════════════════════════════════════
    // Tick 타이밍 계약
    // ═══════════════════════════════════════════════════════════════

    /**
     * 목표 Tick Rate (FPS)
     * TARGET_FPS와 동일한 의미, 명확성을 위해 추가.
     */
    public static final int TARGET_TICK_RATE = 60;

    /**
     * 목표 FPS (Project Zomboid 기본값)
     */
    public static final int TARGET_FPS = TARGET_TICK_RATE;

    /**
     * 예상 틱 간격 (nanoseconds)
     * 16,666,666ns
     */
    public static final long TARGET_TICK_DELTA_NANOS = 1_000_000_000L / TARGET_TICK_RATE;

    /**
     * 예상 틱 간격 (ms)
     * = 1000 / 60 ≈ 16.67ms
     */
    public static final float EXPECTED_DELTA_MS = 1000.0f / TARGET_FPS;

    /**
     * 스파이크 임계값 (ms)
     * 이 값 초과 시 "large delta" 경고 발생
     */
    public static final float MAX_REASONABLE_DELTA_MS = 100.0f;

    /**
     * 절대 최대 델타 (ms)
     * 5초 이상은 비정상 상태로 간주
     */
    public static final float MAX_ABSOLUTE_DELTA_MS = 5000.0f;

    /**
     * 중복 이벤트 감지 임계값 (nanoseconds)
     * 1ms 이내 연속 틱은 중복으로 간주
     */
    public static final long DUPLICATE_THRESHOLD_NS = 1_000_000L;

    // ═══════════════════════════════════════════════════════════════
    // Fallback 정책
    // ═══════════════════════════════════════════════════════════════

    /**
     * 기본 Fallback tick 간격 (ms)
     * = EXPECTED_DELTA_MS * 12 ≈ 200ms
     */
    public static final long DEFAULT_FALLBACK_INTERVAL_MS = 200L;

    /**
     * Fallback 활성화 대기 시간 (ms)
     * 이 시간 동안 tick hook이 없으면 fallback 활성화 고려
     */
    public static final long FALLBACK_ACTIVATION_DELAY_MS = 3000L;

    // ═══════════════════════════════════════════════════════════════
    // 유틸리티 메서드
    // ═══════════════════════════════════════════════════════════════

    /**
     * 주어진 delta time이 유효한지 검사
     * 
     * @param deltaMs delta time in milliseconds
     * @return true if valid, false otherwise
     */
    public static boolean isValidDelta(float deltaMs) {
        return deltaMs > 0 && deltaMs <= MAX_ABSOLUTE_DELTA_MS;
    }

    /**
     * 주어진 delta time이 스파이크인지 검사
     * 
     * @param deltaMs delta time in milliseconds
     * @return true if spike, false otherwise
     */
    public static boolean isSpike(float deltaMs) {
        return deltaMs > MAX_REASONABLE_DELTA_MS && deltaMs <= MAX_ABSOLUTE_DELTA_MS;
    }

    /**
     * 계약 정보 문자열 반환
     */
    public static String getContractInfo() {
        return String.format("TickContract v%d (FPS=%d, expected=%.2fms, max=%,.0fms)",
                VERSION, TARGET_FPS, EXPECTED_DELTA_MS, MAX_ABSOLUTE_DELTA_MS);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\version\GameVersion.java =====

package com.pulse.api.version;

/**
 * Project Zomboid 게임 버전 감지 및 관리.
 * 
 * Build 41과 Build 42+ 간의 API 차이를 런타임에 감지하여
 * 적절한 어댑터를 선택할 수 있도록 합니다.
 * 
 * 감지 방식:
 * 1. 클래스 존재 여부 확인 (Build 42 전용 클래스)
 * 2. 메서드 시그니처 차이 확인
 * 3. 시스템 프로퍼티 폴백
 * 
 * @since Pulse 1.4
 */
public final class GameVersion {

    /** Build 41 (IWBUMS 안정 버전) */
    public static final int BUILD_41 = 41;

    /** Build 42 (차세대 엔진) */
    public static final int BUILD_42 = 42;

    /** 알 수 없는 버전 */
    public static final int UNKNOWN = -1;

    // 캐시된 버전 (한 번만 감지)
    private static volatile int cachedVersion = UNKNOWN;
    private static volatile boolean detected = false;

    private GameVersion() {
        // 유틸리티 클래스
    }

    // ═══════════════════════════════════════════════════════════════
    // Public API
    // ═══════════════════════════════════════════════════════════════

    /**
     * 현재 게임 빌드 버전 반환.
     * 
     * @return BUILD_41, BUILD_42, 또는 UNKNOWN
     */
    public static int get() {
        if (!detected) {
            synchronized (GameVersion.class) {
                if (!detected) {
                    cachedVersion = detectVersion();
                    detected = true;
                    log("Detected game version: Build " + cachedVersion);
                }
            }
        }
        return cachedVersion;
    }

    /**
     * Build 41인지 확인.
     */
    public static boolean isBuild41() {
        return get() == BUILD_41;
    }

    /**
     * Build 42 이상인지 확인.
     */
    public static boolean isBuild42OrLater() {
        int v = get();
        return v >= BUILD_42;
    }

    /**
     * 버전 문자열 반환.
     */
    public static String getVersionString() {
        int v = get();
        if (v == UNKNOWN)
            return "Unknown";
        return "Build " + v;
    }

    /**
     * 수동 버전 설정 (테스트/오버라이드용).
     * 
     * @param version BUILD_41 또는 BUILD_42
     */
    public static void override(int version) {
        cachedVersion = version;
        detected = true;
        log("Version manually set to: Build " + version);
    }

    /**
     * 캐시 초기화 (테스트용).
     */
    public static void reset() {
        cachedVersion = UNKNOWN;
        detected = false;
    }

    // ═══════════════════════════════════════════════════════════════
    // Detection Logic
    // ═══════════════════════════════════════════════════════════════

    private static int detectVersion() {
        // 1. 시스템 프로퍼티 오버라이드 확인
        String override = System.getProperty("pulse.game.version");
        if (override != null) {
            try {
                return Integer.parseInt(override);
            } catch (NumberFormatException ignored) {
            }
        }

        // 2. Build 42 전용 클래스/메서드 확인
        if (hasBuild42Features()) {
            return BUILD_42;
        }

        // 3. Build 41 클래스 구조 확인
        if (hasBuild41Features()) {
            return BUILD_41;
        }

        // 4. 폴백: Build 41로 가정 (안전한 기본값)
        log("Version detection inconclusive, defaulting to Build 41");
        return BUILD_41;
    }

    /**
     * Build 42 전용 기능 확인.
     * 
     * Build 42에서 추가되는 클래스/메서드를 여기서 확인합니다.
     * 아직 Build 42가 출시되지 않았으므로 placeholder입니다.
     */
    private static boolean hasBuild42Features() {
        try {
            // Build 42 전용 클래스가 있으면 true
            Class.forName("zombie.core.engine.Engine");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }

    /**
     * Build 41 특징 확인.
     */
    private static boolean hasBuild41Features() {
        try {
            // IsoZombie 클래스 존재 확인
            Class<?> zombieClass = Class.forName("zombie.characters.IsoZombie");

            // Build 41의 메서드 시그니처 확인
            zombieClass.getMethod("getOnlineID");
            zombieClass.getMethod("getTarget");

            return true;
        } catch (ClassNotFoundException | NoSuchMethodException e) {
            return false;
        }
    }

    private static void log(String message) {
        System.out.println("[Pulse/GameVersion] " + message);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\version\IVersionAdapter.java =====

package com.pulse.api.version;

/**
 * 버전별 어댑터 공통 인터페이스.
 * 
 * 모든 버전별 어댑터가 구현해야 하는 기본 계약을 정의합니다.
 * 
 * @since Pulse 1.4
 */
public interface IVersionAdapter {

    /**
     * 이 어댑터가 지원하는 빌드 버전.
     * 
     * @return GameVersion.BUILD_41 또는 GameVersion.BUILD_42
     */
    int getSupportedBuild();

    /**
     * 현재 게임 환경과 호환되는지 확인.
     * 
     * @return 호환 가능하면 true
     */
    boolean isCompatible();

    /**
     * 어댑터 이름 (로깅용).
     */
    default String getName() {
        return getClass().getSimpleName();
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\main\java\com\pulse\api\VisibleForTesting.java =====

package com.pulse.api;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Indicates that a method, field, or constructor has relaxed visibility
 * solely for testing purposes. Production code should not use elements
 * marked with this annotation.
 * 
 * @since 1.1.0
 */
@Retention(RetentionPolicy.SOURCE)
@Target({ ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR })
public @interface VisibleForTesting {
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\pulse-api\src\test\java\com\pulse\api\ContractTest.java =====

package com.pulse.api;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Pulse API Contract Tests.
 * 
 * Echo가 Pulse에 기대하는 계약을 테스트합니다.
 * 이 테스트가 깨지면 Echo 호환성이 영향받을 수 있습니다.
 * 
 * Note: pulse-api 인터페이스만 테스트합니다.
 * Pulse 구현체 테스트는 Pulse 모듈에서 수행합니다.
 * 
 * @since 1.0.1
 */
public class ContractTest {

    /**
     * IPulseMetrics 인터페이스에 Echo가 필요로 하는 메서드가 존재하는지 확인
     */
    @Test
    void ipulseMetricsHasRequiredMethods() {
        Set<String> methodNames = Arrays.stream(IPulseMetrics.class.getMethods())
                .map(Method::getName)
                .collect(Collectors.toSet());

        // Echo가 기대하는 필수 메서드 - 기존
        assertTrue(methodNames.contains("getFps"), "getFps() required by Echo");
        assertTrue(methodNames.contains("getTickTimeMs"), "getTickTimeMs() required by Echo");
        assertTrue(methodNames.contains("getFrameTimeMs"), "getFrameTimeMs() required by Echo");
        assertTrue(methodNames.contains("getAverageTickTimeMs"), "getAverageTickTimeMs() required by Echo");
        assertTrue(methodNames.contains("getMaxTickTimeMs"), "getMaxTickTimeMs() required by Echo");
        assertTrue(methodNames.contains("getTps"), "getTps() required by Echo");

        // Phase 0 추가: 누락 메서드 4개
        assertTrue(methodNames.contains("getLoadedChunkCount"),
                "getLoadedChunkCount() required by Echo for correlation analysis");
        assertTrue(methodNames.contains("getEntityCount"),
                "getEntityCount() required by Echo for correlation analysis");
        assertTrue(methodNames.contains("getUsedMemoryMB"), "getUsedMemoryMB() required by Echo for memory profiling");
        assertTrue(methodNames.contains("getMaxMemoryMB"), "getMaxMemoryMB() required by Echo for memory profiling");
    }

    /**
     * IPulseEvent 인터페이스의 기본 계약이 유지되는지 확인 (안정성)
     */
    @Test
    void ipulseEventHasExpectedMethods() {
        Set<String> methodNames = Arrays.stream(IPulseEvent.class.getDeclaredMethods())
                .map(Method::getName)
                .collect(Collectors.toSet());

        // IPulseEvent 필수 메서드
        assertTrue(methodNames.contains("getEventName"), "getEventName() required");
        assertTrue(methodNames.contains("isCancellable"), "isCancellable() required");
        assertTrue(methodNames.contains("isCancelled"), "isCancelled() required");
        assertTrue(methodNames.contains("cancel"), "cancel() required");
    }

    /**
     * IPulse 인터페이스에 필수 메서드가 존재하는지 확인
     */
    @Test
    void ipulseHasRequiredMethods() {
        Set<String> methodNames = Arrays.stream(IPulse.class.getMethods())
                .map(Method::getName)
                .collect(Collectors.toSet());

        assertTrue(methodNames.contains("getVersion"), "getVersion() required");
        assertTrue(methodNames.contains("isModLoaded"), "isModLoaded() required");
        assertTrue(methodNames.contains("isInitialized"), "isInitialized() required");
    }

    /**
     * FailsoftPolicy가 예상된 액션을 가지고 있는지 확인
     */
    @Test
    void failsoftPolicyHasRequiredActions() {
        // FailsoftPolicy.Action enum 존재 확인
        FailsoftPolicy.Action[] actions = FailsoftPolicy.Action.values();
        assertTrue(actions.length >= 3, "FailsoftPolicy should have at least 3 actions");

        Set<String> actionNames = Arrays.stream(actions)
                .map(Enum::name)
                .collect(Collectors.toSet());

        assertTrue(actionNames.contains("WARNING"), "WARNING action required");
        assertTrue(actionNames.contains("CRITICAL"), "CRITICAL action required");
        assertTrue(actionNames.contains("TICK_CONTRACT_VIOLATION"), "TICK_CONTRACT_VIOLATION action required");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\settings.gradle =====

// PZ Root Project - Pulse Mod Ecosystem
// This is the root settings file that includes all subprojects

rootProject.name = 'pz-mods'

// Core API (shared interfaces)
include 'pulse-api'

// Main projects
include 'Pulse'
include 'Echo'
include 'Fuse'
include 'Nerve'

// Pulse first-party mods (Removed - superseded by top-level projects)




===== FILE: C:\Users\MW\Downloads\coding\PZ\src\main\resources\mixins.pulse.json =====

{
  "required": true,
  "minVersion": "0.8",
  "package": "com.pulse.mixin",
  "mixins": [
    "MainScreenStateMixin",
    "GameClientMixin",
    "GameWindowMixin",
    "IsoWorldMixin",
    "IsoPlayerMixin",
    "IsoZombieMixin",
    "PathfindingMixin",
    "IsoGridMixin"
  ],
  "client": [],
  "server": [],
  "injectors": {
    "defaultRequire": 0
  },
  "verbose": true
}


===== FILE: C:\Users\MW\Downloads\coding\PZ\test-mods\test-mod-a\build.gradle =====

plugins {
    id 'java'
}

group = 'com.pulse.test'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // Pulse API - 컴파일 타임에만 필요
    compileOnly files('../../build/libs/Pulse.jar')
}

jar {
    archiveBaseName.set('test-mod-a')
    
    from('src/main/resources') {
        include 'pulse.mod.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Test Mod A',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\test-mods\test-mod-a\src\main\java\com\mutagen\test\a\TestModA.java =====

package com.pulse.test.a;

import com.pulse.api.Pulse;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.mod.PulseMod;

/**
 * Test Mod A - Phase 1 검증용 단순 로그/이벤트 테스트 모드
 * 
 * 테스트 항목:
 * - PulseMod 인터페이스 작동
 * - onInitialize() 호출
 * - EventBus 구독/이벤트 처리
 */
public class TestModA implements PulseMod {

    private static final String MOD_ID = "test_mod_a";
    private int tickCount = 0;

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "═══════════════════════════════════════");
        Pulse.log(MOD_ID, "Test Mod A - onInitialize() called!");
        Pulse.log(MOD_ID, "═══════════════════════════════════════");

        // 이벤트 리스너 등록
        registerEventListeners();

        Pulse.log(MOD_ID, "Test Mod A initialized successfully!");
    }

    private void registerEventListeners() {
        Pulse.log(MOD_ID, "Registering event listeners...");

        // 게임 틱 이벤트 구독
        EventBus.subscribe(GameTickEvent.class, this::onGameTick);

        Pulse.log(MOD_ID, "Event listeners registered!");
    }

    private void onGameTick(GameTickEvent event) {
        tickCount++;

        // 매 1000틱마다 로그 출력 (약 50초)
        if (tickCount % 1000 == 0) {
            Pulse.log(MOD_ID, "Tick count: " + tickCount + " (Event handling works!)");
        }
    }

    @Override
    public void onWorldLoad() {
        Pulse.log(MOD_ID, "World loaded! Test Mod A is active.");
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Test Mod A unloading...");
        Pulse.log(MOD_ID, "Total ticks processed: " + tickCount);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\test-mods\test-mod-a\src\main\resources\pulse.mod.json =====

{
    "id": "test_mod_a",
    "name": "Test Mod A",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Simple logging and event test mod for Phase 1 verification",
    "entrypoint": "com.pulse.test.a.TestModA",
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\test-mods\test-mod-b\build.gradle =====

plugins {
    id 'java'
}

group = 'com.pulse.test'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven/' }
}

dependencies {
    // Pulse API - 컴파일 타임에만 필요
    compileOnly files('../../build/libs/Pulse.jar')
    
    // Mixin (annotation processing용)
    compileOnly 'org.spongepowered:mixin:0.8.5'
}

jar {
    archiveBaseName.set('test-mod-b')
    
    from('src/main/resources') {
        include 'pulse.mod.json'
        include 'mixins.testmodb.json'
    }

    manifest {
        attributes(
            'Implementation-Title': 'Test Mod B',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\test-mods\test-mod-b\src\main\java\com\mutagen\test\b\mixin\TestMixin.java =====

package com.pulse.test.b.mixin;

import com.pulse.test.b.TestModB;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * Test Mixin - Phase 1 검증용 간단한 Mixin
 * 
 * 이 Mixin은 Object 클래스의 toString()을 타겟으로 합니다.
 * 실제 게임에서는 zombie.* 클래스를 타겟으로 해야 합니다.
 * 
 * 이 예제는 Mixin 시스템 동작 확인용입니다.
 */
@Mixin(Object.class)
public class TestMixin {

    /**
     * 정적 초기화 블록에서 Mixin 적용 알림
     * Mixin 클래스가 로드되면 실행됨
     */
    static {
        try {
            TestModB.onMixinApplied("java.lang.Object");
        } catch (Throwable t) {
            // TestModB가 아직 로드되지 않았을 수 있음
            System.out.println("[TestMixin] Mixin class loaded (TestModB not ready yet)");
        }
    }

    // Note: 실제로 Object.toString()에 Inject하면 성능 영향이 있으므로
    // 이 예제에서는 static 블록으로 로딩만 확인합니다.
    // 실제 모드에서는 게임 클래스를 타겟으로 해야 합니다.
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\test-mods\test-mod-b\src\main\java\com\mutagen\test\b\TestModB.java =====

package com.pulse.test.b;

import com.pulse.api.Pulse;
import com.pulse.mod.PulseMod;

/**
 * Test Mod B - Phase 1 검증용 Mixin 테스트 모드
 * 
 * 테스트 항목:
 * - PulseMod 인터페이스 작동
 * - 외부 Mixin 설정 로딩
 * - Mixin 적용 확인
 */
public class TestModB implements PulseMod {

    private static final String MOD_ID = "test_mod_b";
    private static boolean mixinApplied = false;

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "═══════════════════════════════════════");
        Pulse.log(MOD_ID, "Test Mod B - onInitialize() called!");
        Pulse.log(MOD_ID, "═══════════════════════════════════════");

        // Mixin 적용 확인
        if (mixinApplied) {
            Pulse.log(MOD_ID, "✓ Mixin was applied successfully!");
        } else {
            Pulse.log(MOD_ID, "⚠ Mixin not yet applied (might be applied after class loads)");
        }

        Pulse.log(MOD_ID, "Test Mod B initialized successfully!");
    }

    /**
     * Mixin에서 호출하는 콜백 메서드
     */
    public static void onMixinApplied(String targetClass) {
        mixinApplied = true;
        Pulse.log("test_mod_b", "Mixin successfully applied to: " + targetClass);
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Test Mod B unloading...");
        Pulse.log(MOD_ID, "Mixin was applied: " + mixinApplied);
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\test-mods\test-mod-b\src\main\resources\mixins.testmodb.json =====

{
    "required": true,
    "package": "com.pulse.test.b.mixin",
    "compatibilityLevel": "JAVA_17",
    "mixins": [
        "TestMixin"
    ],
    "injectors": {
        "defaultRequire": 1
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\test-mods\test-mod-b\src\main\resources\pulse.mod.json =====

{
    "id": "test_mod_b",
    "name": "Test Mod B",
    "version": "1.0.0",
    "author": "Pulse Team",
    "description": "Mixin test mod for Phase 1 verification",
    "entrypoint": "com.pulse.test.b.TestModB",
    "mixins": [
        "mixins.testmodb.json"
    ],
    "dependencies": [
        {
            "id": "Pulse",
            "version": ">=1.0.0"
        }
    ]
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\test-output\testmod\build.gradle =====

plugins {
    id 'java'
}

group = 'com.example.testmod'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // Pulse API - compile time only
    compileOnly files('path/to/Pulse.jar')
}

jar {
    from('src/main/resources') {
        include 'pulse.mod.json'
    }
    
    manifest {
        attributes(
            'Implementation-Title': 'Test Mod',
            'Implementation-Version': version
        )
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\test-output\testmod\src\main\java\com\example\testmod\TestmodMod.java =====

package com.example.testmod;

import com.pulse.api.Pulse;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.GameInitEvent;
import com.pulse.event.lifecycle.GameTickEvent;
import com.pulse.mod.PulseMod;

/**
 * Test Mod - Main mod class
 */
public class TestmodMod implements PulseMod {

    private static final String MOD_ID = "testmod";

    @Override
    public void onInitialize() {
        Pulse.log(MOD_ID, "Test Mod initializing...");
        
        // Register event listeners
        EventBus.subscribe(GameInitEvent.class, this::onGameInit, MOD_ID);
        EventBus.subscribe(GameTickEvent.class, this::onGameTick, MOD_ID);
        
        Pulse.log(MOD_ID, "Test Mod initialized!");
    }
    
    private void onGameInit(GameInitEvent event) {
        Pulse.log(MOD_ID, "Game initialization complete!");
    }
    
    private void onGameTick(GameTickEvent event) {
        // Called every game tick
        // Add your tick logic here
    }

    @Override
    public void onUnload() {
        Pulse.log(MOD_ID, "Test Mod unloading...");
    }
}



===== FILE: C:\Users\MW\Downloads\coding\PZ\test-output\testmod\src\main\resources\pulse.mod.json =====

{
  "id": "testmod",
  "name": "Test Mod",
  "version": "1.0.0",
  "author": "Developer",
  "description": "A Pulse mod for Project Zomboid",
  "entrypoint": "com.example.testmod.testmodMod",
  "dependencies": [
    {
      "id": "Pulse",
      "version": ">=1.0.0"
    }
  ]
}

