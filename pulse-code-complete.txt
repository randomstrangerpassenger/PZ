
[src/main/java/com/pulse/PulseAgent.java]
package com.pulse;

import com.pulse.transformer.PulseClassTransformer;
import org.spongepowered.asm.launch.MixinBootstrap;
import org.spongepowered.asm.mixin.MixinEnvironment;
import org.spongepowered.asm.mixin.Mixins;
import org.spongepowered.asm.mixin.transformer.IMixinTransformer;

import java.lang.instrument.Instrumentation;

/**
 * Pulse Java Agent Entry Point.
 * 
 * JVM 시작 시 -javaagent:Pulse.jar 옵션으로 로드됨.
 * 
 * 초기화 순서:
 * 1. Instrumentation 저장
 * 2. 시스템 프로퍼티 설정
 * 3. Mixin 부트스트랩
 * 4. Mixin config 등록
 * 5. Class transformer 등록
 */
public class PulseAgent {

    private static Instrumentation instrumentation;
    private static PulseClassTransformer classTransformer;

    public static void premain(String agentArgs, Instrumentation inst) {
        instrumentation = inst;
        PulseEnvironment.setInstrumentation(inst);

        System.out.println();
        System.out.println("╔══════════════════════════════════════════════════════════════╗");
        System.out.println("║              Pulse MOD LOADER v1.0.0                       ║");
        System.out.println("║          Project Zomboid Modding Platform                    ║");
        System.out.println("╚══════════════════════════════════════════════════════════════╝");
        System.out.println();

        try {
            initializePulse(inst);
        } catch (Throwable t) {
            System.err.println("[Pulse] ════════════════════════════════════════");
            System.err.println("[Pulse] CRITICAL INITIALIZATION ERROR");
            System.err.println("[Pulse] ════════════════════════════════════════");
            t.printStackTrace();
        }
    }

    private static void initializePulse(Instrumentation inst) {
        // ─────────────────────────────────────────────────────────────
        // STEP 1: 시스템 프로퍼티 설정 (Mixin 부트스트랩 전에!)
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 1: Configuring system properties...");

        // Mixin 디버그 활성화
        System.setProperty("mixin.debug", "true");
        System.setProperty("mixin.debug.verbose", "true");
        System.setProperty("mixin.debug.export", "true");
        System.setProperty("mixin.debug.export.decompile", "false");
        System.setProperty("mixin.dumpTargetOnFailure", "true");
        System.setProperty("mixin.checks", "true");
        System.setProperty("mixin.hotSwap", "true");

        // Mixin 서비스 지정 (선택사항 - ServiceLoader가 자동 발견함)
        // System.setProperty("mixin.service",
        // "com.pulse.service.PulseMixinService");

        System.out.println("[Pulse] Step 1: Complete");

        // ─────────────────────────────────────────────────────────────
        // STEP 2: Mixin 부트스트랩
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 2: Bootstrapping Mixin subsystem...");

        MixinBootstrap.init();

        // 부트스트랩 직후 phase 확인
        MixinEnvironment env = MixinEnvironment.getDefaultEnvironment();
        System.out.println("[Pulse]   - Default Environment: " + env);
        System.out.println("[Pulse]   - Side: " + env.getSide());
        System.out.println("[Pulse]   - Phase (after init): " + env.getPhase());

        // Phase가 DEFAULT면 config 등록이 안 될 수 있음
        // gotoPhase로 PREINIT 상태로 되돌리기 시도
        try {
            var currentPhase = env.getPhase();
            System.out.println("[Pulse]   - Current phase: " + currentPhase);
            System.out.println("[Pulse]   - Attempting to check/set phase for config registration...");

            // MixinEnvironment.Phase.PREINIT 또는 INIT에서만 config 등록 가능
            // Reflection으로 phase 상태 확인
            var phaseField = MixinEnvironment.class.getDeclaredField("currentPhase");
            phaseField.setAccessible(true);
            System.out.println("[Pulse]   - Internal currentPhase: " + phaseField.get(null));
        } catch (Exception e) {
            System.out.println("[Pulse]   - Could not inspect phase field: " + e.getMessage());
        }

        System.out.println("[Pulse] Step 2: Complete");

        // ─────────────────────────────────────────────────────────────
        // STEP 2.5: Mixin 내부 상태 확인
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 2.5: Checking Mixin internal state...");
        try {
            // MixinEnvironment 상태
            var mixinEnv = MixinEnvironment.getDefaultEnvironment();
            System.out.println("[Pulse]   - Environment: " + mixinEnv);
            System.out.println("[Pulse]   - Phase: " + mixinEnv.getPhase());
            System.out.println("[Pulse]   - Side: " + mixinEnv.getSide());

            // Mixin Service 확인
            var service = org.spongepowered.asm.service.MixinService.getService();
            System.out.println("[Pulse]   - Active Service: " + service.getName());
            System.out.println("[Pulse]   - Service Class: " + service.getClass().getName());

            // 리소스 로딩 테스트
            var testStream = service.getResourceAsStream("mixins.pulse.json");
            System.out
                    .println("[Pulse]   - Service.getResourceAsStream(): " + (testStream != null ? "OK" : "FAILED"));
            if (testStream != null) {
                // 내용 읽어보기
                byte[] bytes = testStream.readAllBytes();
                System.out.println("[Pulse]   - Config file size: " + bytes.length + " bytes");
                System.out.println(
                        "[Pulse]   - Config content preview: " + new String(bytes, 0, Math.min(200, bytes.length)));
                testStream.close();
            }
        } catch (Throwable t) {
            System.err.println("[Pulse]   - Error checking state: " + t.getMessage());
            t.printStackTrace();
        }

        // ─────────────────────────────────────────────────────────────
        // STEP 3: Mixin Config 등록
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 3: Registering Mixin configurations...");

        // Config 파일 존재 확인
        try {
            var configStream = PulseAgent.class.getClassLoader().getResourceAsStream("mixins.pulse.json");
            if (configStream != null) {
                System.out.println("[Pulse]   - Found: mixins.pulse.json");
                configStream.close();
            } else {
                System.err.println("[Pulse]   - WARNING: mixins.pulse.json not found in classpath!");
            }
        } catch (Exception e) {
            System.err.println("[Pulse]   - Error checking config file: " + e.getMessage());
        }

        try {
            System.out.println("[Pulse]   - Calling Mixins.addConfiguration()...");

            // 먼저 현재 등록된 config 수 확인
            int beforeCount = Mixins.getConfigs().size();
            System.out.println("[Pulse]   - Configs before: " + beforeCount);

            Mixins.addConfiguration("mixins.pulse.json");

            int afterCount = Mixins.getConfigs().size();
            System.out.println("[Pulse]   - Configs after: " + afterCount);

            if (afterCount == beforeCount) {
                System.err.println("[Pulse]   - WARNING: Config was not added! Trying alternative method...");

                // 대안: MixinConfig.create()를 직접 호출 시도
                try {
                    Class<?> mixinConfigClass = Class.forName("org.spongepowered.asm.mixin.transformer.MixinConfig");
                    var createMethod = mixinConfigClass.getDeclaredMethod("create", String.class,
                            MixinEnvironment.class);
                    createMethod.setAccessible(true);

                    var config = createMethod.invoke(null, "mixins.pulse.json",
                            MixinEnvironment.getDefaultEnvironment());
                    System.out.println("[Pulse]   - Direct MixinConfig.create() result: " + config);

                    if (config != null) {
                        // MixinProcessor나 관련 클래스에 직접 등록 시도
                        System.out.println("[Pulse]   - Config created successfully: " + config);
                    }
                } catch (Exception ex) {
                    System.err.println("[Pulse]   - Alternative method failed: " + ex.getMessage());
                    ex.printStackTrace();
                }
            }

            System.out.println("[Pulse]   - addConfiguration() completed");
        } catch (Throwable t) {
            System.err.println("[Pulse]   - ERROR in addConfiguration(): " + t.getClass().getName());
            System.err.println("[Pulse]   - Message: " + t.getMessage());
            t.printStackTrace();
        }

        // 등록된 config 수 확인
        try {
            System.out.println("[Pulse]   - Calling Mixins.getConfigs()...");
            var configs = Mixins.getConfigs();
            System.out.println("[Pulse]   - Registered configs: " + (configs != null ? configs.size() : "null"));

            if (configs != null) {
                for (var config : configs) {
                    System.out.println("[Pulse]   - Config: " + config);
                }
            }
        } catch (Throwable t) {
            System.err.println("[Pulse]   - ERROR in getConfigs(): " + t.getClass().getName());
            System.err.println("[Pulse]   - Message: " + t.getMessage());
            t.printStackTrace();
        }

        System.out.println("[Pulse] Step 3: Complete");

        // ─────────────────────────────────────────────────────────────
        // STEP 4: Mixin Transformer 획득 대기
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 4: Waiting for Mixin transformer...");

        // PulseMixinService.offer()가 호출되면 transformer가 설정됨
        // 짧은 대기 후 확인
        IMixinTransformer mixinTransformer = null;

        for (int i = 0; i < 10; i++) {
            mixinTransformer = PulseEnvironment.getMixinTransformer();
            if (mixinTransformer != null) {
                break;
            }
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                break;
            }
        }

        if (mixinTransformer != null) {
            System.out.println("[Pulse]   - Mixin Transformer acquired: " +
                    mixinTransformer.getClass().getName());
        } else {
            System.err.println("[Pulse]   - WARNING: Mixin Transformer not available!");
            System.err.println("[Pulse]   - Mixins may not be applied correctly.");
        }

        System.out.println("[Pulse] Step 4: Complete");

        // ─────────────────────────────────────────────────────────────
        // STEP 5: Class Transformer 등록
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 5: Registering class transformer...");

        classTransformer = new PulseClassTransformer();

        // Mixin transformer 연결
        if (mixinTransformer != null) {
            classTransformer.connectMixinTransformer(mixinTransformer);
        }

        // Instrumentation에 등록 (canRetransform=true)
        inst.addTransformer(classTransformer, true);

        System.out.println("[Pulse]   - Transformer registered with Instrumentation");
        System.out.println("[Pulse] Step 5: Complete");

        // ─────────────────────────────────────────────────────────────
        // STEP 6: 초기화 완료
        // ─────────────────────────────────────────────────────────────
        PulseEnvironment.markInitialized();

        System.out.println();
        System.out.println("[Pulse] ════════════════════════════════════════════════════");
        System.out.println("[Pulse] CORE INITIALIZATION COMPLETE");
        System.out.println("[Pulse] ════════════════════════════════════════════════════");
        System.out.println();

        // ─────────────────────────────────────────────────────────────
        // STEP 7: 모드 로더 초기화
        // ─────────────────────────────────────────────────────────────
        System.out.println("[Pulse] Step 7: Initializing mod loader...");

        try {
            com.pulse.mod.ModLoader modLoader = com.pulse.mod.ModLoader.getInstance();

            // 모드 발견
            modLoader.discoverMods();

            // 의존성 해결
            modLoader.resolveDependencies();

            // 모드 Mixin 등록
            modLoader.registerMixins();

            System.out.println("[Pulse] Step 7: Complete");
        } catch (Throwable t) {
            System.err.println("[Pulse] Step 7: Mod loader error (non-fatal)");
            t.printStackTrace();
        }

        System.out.println();
        System.out.println("[Pulse] ════════════════════════════════════════════════════");
        System.out.println("[Pulse] Pulse FULLY INITIALIZED");
        System.out.println("[Pulse] Waiting for zombie.* classes to load...");
        System.out.println("[Pulse] ════════════════════════════════════════════════════");
        System.out.println();

        // 환경 상태 출력
        PulseEnvironment.printStatus();

        // 디버그: 지연 체크
        startDebugMonitor();
    }

    /**
     * 디버그용 모니터링 스레드
     * 첫 zombie 클래스 로딩과 mixin 적용을 확인
     */
    private static void startDebugMonitor() {
        new Thread(() -> {
            System.out.println("[Pulse/Debug] Monitor thread started");

            // 게임 클래스 로더가 등록될 때까지 대기
            int waitCount = 0;
            while (PulseEnvironment.getGameClassLoader() == null && waitCount < 300) {
                try {
                    Thread.sleep(100);
                    waitCount++;
                } catch (InterruptedException e) {
                    break;
                }
            }

            if (PulseEnvironment.getGameClassLoader() != null) {
                System.out.println("[Pulse/Debug] Game ClassLoader detected after " +
                        (waitCount * 100) + "ms");
                System.out.println("[Pulse/Debug] ClassLoader: " +
                        PulseEnvironment.getGameClassLoader());

                // 모드 초기화 (게임 클래스 로더 감지 후)
                try {
                    System.out.println("[Pulse/Debug] Initializing mods...");
                    com.pulse.mod.ModLoader.getInstance().initializeMods();
                } catch (Throwable t) {
                    System.err.println("[Pulse/Debug] Mod initialization error:");
                    t.printStackTrace();
                }
            } else {
                System.err.println("[Pulse/Debug] WARNING: Game ClassLoader not detected after 30s");
            }

            // Mixin 적용 상태 확인
            if (classTransformer != null) {
                try {
                    Thread.sleep(5000); // 5초 더 대기
                    var transformed = classTransformer.getTransformedClasses();
                    System.out.println("[Pulse/Debug] Transformed classes: " + transformed.size());
                    for (String cls : transformed) {
                        System.out.println("[Pulse/Debug]   - " + cls);
                    }
                } catch (InterruptedException e) {
                    // ignore
                }
            }
        }, "Pulse-Debug-Monitor").start();
    }

    public static Instrumentation getInstrumentation() {
        return instrumentation;
    }

    public static PulseClassTransformer getClassTransformer() {
        return classTransformer;
    }
}

[src/main/java/com/pulse/PulseEnvironment.java]
package com.pulse;

import org.spongepowered.asm.mixin.transformer.IMixinTransformer;

/**
 * Pulse 전역 환경 상태 관리.
 * 
 * 다양한 컴포넌트 간에 공유되는 상태를 보관:
 * - Game ClassLoader
 * - Mixin Transformer
 * - Instrumentation 인스턴스
 * - 기타 환경 설정
 */
public class PulseEnvironment {

    private static ClassLoader gameClassLoader;
    private static IMixinTransformer mixinTransformer;
    private static java.lang.instrument.Instrumentation instrumentation;
    
    private static boolean initialized = false;
    private static boolean mixinReady = false;

    // ================= Game ClassLoader =================

    public static void setGameClassLoader(ClassLoader cl) {
        if (gameClassLoader == null && cl != null) {
            gameClassLoader = cl;
            System.out.println("[Pulse/Env] Game ClassLoader registered: " + cl);
            System.out.println("[Pulse/Env] ClassLoader class: " + cl.getClass().getName());
        }
    }

    public static ClassLoader getGameClassLoader() {
        return gameClassLoader;
    }

    // ================= Mixin Transformer =================

    public static void setMixinTransformer(IMixinTransformer transformer) {
        if (mixinTransformer == null && transformer != null) {
            mixinTransformer = transformer;
            mixinReady = true;
            System.out.println("[Pulse/Env] Mixin Transformer registered: " + 
                transformer.getClass().getName());
        }
    }

    public static IMixinTransformer getMixinTransformer() {
        return mixinTransformer;
    }

    public static boolean isMixinReady() {
        return mixinReady;
    }

    // ================= Instrumentation =================

    public static void setInstrumentation(java.lang.instrument.Instrumentation inst) {
        instrumentation = inst;
        System.out.println("[Pulse/Env] Instrumentation registered");
    }

    public static java.lang.instrument.Instrumentation getInstrumentation() {
        return instrumentation;
    }

    // ================= Lifecycle =================

    public static void markInitialized() {
        initialized = true;
        System.out.println("[Pulse/Env] Environment marked as initialized");
    }

    public static boolean isInitialized() {
        return initialized;
    }

    // ================= Debug Info =================

    public static void printStatus() {
        System.out.println("==================================================");
        System.out.println("[Pulse/Env] STATUS REPORT");
        System.out.println("  Initialized: " + initialized);
        System.out.println("  Game ClassLoader: " + (gameClassLoader != null ? gameClassLoader : "NOT SET"));
        System.out.println("  Mixin Ready: " + mixinReady);
        System.out.println("  Mixin Transformer: " + (mixinTransformer != null ? "SET" : "NOT SET"));
        System.out.println("  Instrumentation: " + (instrumentation != null ? "SET" : "NOT SET"));
        System.out.println("==================================================");
    }
}

[src/main/java/com/pulse/transformer/PulseClassTransformer.java]
package com.pulse.transformer;

import com.pulse.PulseEnvironment;
import org.spongepowered.asm.mixin.MixinEnvironment;
import org.spongepowered.asm.mixin.transformer.IMixinTransformer;

import java.lang.instrument.ClassFileTransformer;
import java.security.ProtectionDomain;
import java.util.HashSet;
import java.util.Set;

/**
 * Pulse의 핵심 클래스 트랜스포머.
 * Java Instrumentation API와 Sponge Mixin을 연결한다.
 *
 * 역할:
 * 1. zombie.* 클래스 로딩을 감지
 * 2. Mixin 변환을 적용
 * 3. 향후 추가될 다른 transformer들과 체이닝
 */
public class PulseClassTransformer implements ClassFileTransformer {

    private final Set<String> transformedClasses = new HashSet<>();
    private final Set<String> excludedPrefixes = new HashSet<>();

    private IMixinTransformer mixinTransformer;
    private boolean mixinReady = false;

    public PulseClassTransformer() {
        // Mixin 적용 제외 패키지
        excludedPrefixes.add("java/");
        excludedPrefixes.add("javax/");
        excludedPrefixes.add("sun/");
        excludedPrefixes.add("jdk/");
        excludedPrefixes.add("com.pulse/");
        excludedPrefixes.add("org/spongepowered/");
        excludedPrefixes.add("org/objectweb/asm/");
    }

    /**
     * Mixin Transformer를 연결한다.
     * MixinBootstrap.init() 이후에 호출되어야 함.
     */
    public void connectMixinTransformer(IMixinTransformer transformer) {
        this.mixinTransformer = transformer;
        this.mixinReady = (transformer != null);

        if (mixinReady) {
            System.out.println("[Pulse/Transformer] Mixin transformer connected successfully");
        } else {
            System.err.println("[Pulse/Transformer] WARNING: Mixin transformer is null!");
        }
    }

    @Override
    public byte[] transform(
            ClassLoader loader,
            String className,
            Class<?> classBeingRedefined,
            ProtectionDomain protectionDomain,
            byte[] classfileBuffer) {
        if (className == null || classfileBuffer == null) {
            return null;
        }

        // 제외 패키지 체크
        for (String prefix : excludedPrefixes) {
            if (className.startsWith(prefix)) {
                return null;
            }
        }

        // Game ClassLoader 등록 (최초 zombie 클래스 발견 시)
        if (className.startsWith("zombie/") && loader != null) {
            if (PulseEnvironment.getGameClassLoader() == null) {
                PulseEnvironment.setGameClassLoader(loader);
            }
        }

        // Mixin 변환 적용
        byte[] transformed = applyMixinTransform(className, classfileBuffer);

        return transformed;
    }

    // Java 9+ module-aware 버전
    @Override
    public byte[] transform(
            Module module,
            ClassLoader loader,
            String className,
            Class<?> classBeingRedefined,
            ProtectionDomain protectionDomain,
            byte[] classfileBuffer) {
        return transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);
    }

    private byte[] applyMixinTransform(String className, byte[] classfileBuffer) {
        if (!mixinReady || mixinTransformer == null) {
            return null;
        }

        // zombie 패키지만 Mixin 대상
        if (!className.startsWith("zombie/")) {
            return null;
        }

        String dotName = className.replace('/', '.');

        try {
            // Mixin 환경 가져오기
            MixinEnvironment env = MixinEnvironment.getDefaultEnvironment();

            // 변환 수행
            byte[] result = mixinTransformer.transformClass(env, dotName, classfileBuffer);

            if (result != null && result != classfileBuffer) {
                transformedClasses.add(dotName);
                System.out.println("[Pulse/Transformer] ✓ Mixin applied to: " + dotName);
                return result;
            }

        } catch (Throwable t) {
            System.err.println("[Pulse/Transformer] Error transforming: " + dotName);
            t.printStackTrace();
        }

        return null;
    }

    public Set<String> getTransformedClasses() {
        return new HashSet<>(transformedClasses);
    }

    public boolean isMixinReady() {
        return mixinReady;
    }
}

[src/main/java/com/pulse/service/PulseMixinService.java]
package com.pulse.service;

import com.pulse.PulseEnvironment;
import org.spongepowered.asm.launch.platform.container.ContainerHandleVirtual;
import org.spongepowered.asm.launch.platform.container.IContainerHandle;
import org.spongepowered.asm.logging.ILogger;
import org.spongepowered.asm.mixin.MixinEnvironment.CompatibilityLevel;
import org.spongepowered.asm.mixin.MixinEnvironment.Phase;
import org.spongepowered.asm.mixin.transformer.IMixinTransformer;
import org.spongepowered.asm.mixin.transformer.IMixinTransformerFactory;
import org.spongepowered.asm.service.*;
import org.spongepowered.asm.util.ReEntranceLock;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Collection;
import java.util.Collections;

/**
 * Pulse의 핵심 Mixin 서비스 구현.
 * 
 * Sponge Mixin이 필요로 하는 모든 인터페이스를 구현:
 * - IMixinService: 메인 서비스 인터페이스
 * - IClassProvider: 클래스 로딩
 * - IClassBytecodeProvider: 바이트코드 접근
 */
public class PulseMixinService implements IMixinService, IClassProvider, IClassBytecodeProvider {

    private final ReEntranceLock lock = new ReEntranceLock(1);
    private final PulseTransformerProvider transformerProvider = new PulseTransformerProvider();
    private final PulseClassTracker classTracker = new PulseClassTracker();

    // Mixin이 생성한 transformer (offer()를 통해 전달됨)
    private IMixinTransformer mixinTransformer;
    private IMixinTransformerFactory transformerFactory;

    // Primary container (이 JAR 자체)
    private IContainerHandle primaryContainer;

    public PulseMixinService() {
        System.out.println("[Pulse/Service] PulseMixinService instantiated");
    }

    // ================= ClassLoader 관리 =================

    private ClassLoader getEffectiveClassLoader() {
        // 1순위: 게임 클래스 로더
        ClassLoader gameLoader = PulseEnvironment.getGameClassLoader();
        if (gameLoader != null) {
            return gameLoader;
        }

        // 2순위: 현재 컨텍스트 클래스 로더
        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
        if (contextLoader != null) {
            return contextLoader;
        }

        // 3순위: 시스템 클래스 로더
        return ClassLoader.getSystemClassLoader();
    }

    // ================= IMixinService 구현 =================

    @Override
    public String getName() {
        return "Pulse";
    }

    @Override
    public boolean isValid() {
        return true;
    }

    @Override
    public void prepare() {
        System.out.println("[Pulse/Service] prepare() called");
    }

    @Override
    public Phase getInitialPhase() {
        return Phase.PREINIT;
    }

    @Override
    public void offer(IMixinInternal internal) {
        System.out.println("[Pulse/Service] offer() called with: " +
                (internal != null ? internal.getClass().getName() : "null"));

        if (internal instanceof IMixinTransformerFactory) {
            this.transformerFactory = (IMixinTransformerFactory) internal;
            System.out.println("[Pulse/Service] Received IMixinTransformerFactory");

            // Transformer 생성
            try {
                this.mixinTransformer = transformerFactory.createTransformer();
                System.out.println("[Pulse/Service] Created IMixinTransformer: " +
                        (mixinTransformer != null ? mixinTransformer.getClass().getName() : "null"));

                // PulseEnvironment에 저장하여 외부에서 접근 가능하게 함
                PulseEnvironment.setMixinTransformer(mixinTransformer);

            } catch (Exception e) {
                System.err.println("[Pulse/Service] Failed to create transformer");
                e.printStackTrace();
            }
        }
    }

    @Override
    public void init() {
        System.out.println("[Pulse/Service] init() called");
    }

    @Override
    public void beginPhase() {
        System.out.println("[Pulse/Service] beginPhase() called");
    }

    @Override
    public void checkEnv(Object bootSource) {
        System.out.println("[Pulse/Service] checkEnv() called");
    }

    @Override
    public ReEntranceLock getReEntranceLock() {
        return this.lock;
    }

    @Override
    public IClassProvider getClassProvider() {
        return this;
    }

    @Override
    public IClassBytecodeProvider getBytecodeProvider() {
        return this;
    }

    @Override
    public ITransformerProvider getTransformerProvider() {
        return this.transformerProvider;
    }

    @Override
    public IClassTracker getClassTracker() {
        return this.classTracker;
    }

    @Override
    public IMixinAuditTrail getAuditTrail() {
        // 감사 추적은 선택사항
        return null;
    }

    @Override
    public Collection<String> getPlatformAgents() {
        // Platform agent 클래스 이름들
        // 필요시 PulsePlatformAgent 구현 가능
        return Collections.singletonList("com.pulse.service.PulsePlatformAgent");
    }

    @Override
    public String getSideName() {
        return "CLIENT";
    }

    @Override
    public IContainerHandle getPrimaryContainer() {
        if (primaryContainer == null) {
            try {
                // 이 클래스가 포함된 JAR/폴더의 위치
                URL location = getClass().getProtectionDomain().getCodeSource().getLocation();
                primaryContainer = new ContainerHandleVirtual(getName());
                System.out.println("[Pulse/Service] Primary container location: " + location);
            } catch (Exception e) {
                primaryContainer = new ContainerHandleVirtual(getName());
            }
        }
        return primaryContainer;
    }

    @Override
    public Collection<IContainerHandle> getMixinContainers() {
        // Mixin config를 포함하는 컨테이너들
        // 현재는 primary container만 반환
        return Collections.singletonList(getPrimaryContainer());
    }

    @Override
    public InputStream getResourceAsStream(String name) {
        System.out.println("[Pulse/Service] getResourceAsStream() called for: " + name);

        ClassLoader cl = getEffectiveClassLoader();
        System.out.println("[Pulse/Service]   - Using ClassLoader: " + cl.getClass().getName());

        // 여러 경로 시도
        InputStream is = cl.getResourceAsStream(name);
        System.out.println("[Pulse/Service]   - Try 1 (direct): " + (is != null ? "FOUND" : "not found"));

        if (is == null) {
            // 슬래시로 시작하는 경로 시도
            is = cl.getResourceAsStream("/" + name);
            System.out.println("[Pulse/Service]   - Try 2 (with /): " + (is != null ? "FOUND" : "not found"));
        }

        if (is == null) {
            // 이 클래스의 클래스로더에서 시도
            is = getClass().getClassLoader().getResourceAsStream(name);
            System.out.println(
                    "[Pulse/Service]   - Try 3 (service classloader): " + (is != null ? "FOUND" : "not found"));
        }

        if (is == null) {
            // 시스템 클래스로더에서 시도
            is = ClassLoader.getSystemClassLoader().getResourceAsStream(name);
            System.out.println(
                    "[Pulse/Service]   - Try 4 (system classloader): " + (is != null ? "FOUND" : "not found"));
        }

        if (is == null) {
            System.err.println("[Pulse/Service]   - FAILED to find resource: " + name);
        } else {
            System.out.println("[Pulse/Service]   - SUCCESS: Found resource: " + name);
        }

        return is;
    }

    @Override
    public CompatibilityLevel getMinCompatibilityLevel() {
        return CompatibilityLevel.JAVA_8;
    }

    @Override
    public CompatibilityLevel getMaxCompatibilityLevel() {
        return CompatibilityLevel.JAVA_17;
    }

    @Override
    public ILogger getLogger(String name) {
        return new PulseLogger(name);
    }

    // ================= IClassProvider 구현 =================

    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {
        return findClass(name, true);
    }

    @Override
    public Class<?> findClass(String name, boolean initialize) throws ClassNotFoundException {
        classTracker.registerClass(name);
        return Class.forName(name, initialize, getEffectiveClassLoader());
    }

    @Override
    public Class<?> findAgentClass(String name, boolean initialize) throws ClassNotFoundException {
        // Agent 클래스는 시스템 클래스로더에서 로드
        return Class.forName(name, initialize, ClassLoader.getSystemClassLoader());
    }

    @Override
    public URL[] getClassPath() {
        // 클래스패스 URL 배열 반환
        // Java 9+에서는 모듈 시스템 때문에 복잡해질 수 있음
        return new URL[0];
    }

    // ================= IClassBytecodeProvider 구현 =================

    @Override
    public ClassNode getClassNode(String name) throws ClassNotFoundException, IOException {
        return getClassNode(name, true);
    }

    @Override
    public ClassNode getClassNode(String name, boolean runTransformers)
            throws ClassNotFoundException, IOException {

        String resourceName = name.replace('.', '/') + ".class";
        InputStream is = getResourceAsStream(resourceName);

        if (is == null) {
            throw new ClassNotFoundException("Cannot find class bytecode: " + name +
                    " (resource: " + resourceName + ")");
        }

        try {
            ClassReader reader = new ClassReader(is);
            ClassNode node = new ClassNode();
            reader.accept(node, ClassReader.EXPAND_FRAMES);
            return node;
        } finally {
            is.close();
        }
    }

    // ================= Pulse 전용 메서드 =================

    /**
     * Mixin transformer 반환 (PulseClassTransformer에서 사용)
     */
    public IMixinTransformer getMixinTransformer() {
        return this.mixinTransformer;
    }

    /**
     * ClassTracker 반환 (디버깅/모니터링용)
     */
    public PulseClassTracker getClassTrackerInstance() {
        return this.classTracker;
    }
}

[src/main/java/com/pulse/mod/ModLoader.java]
package com.pulse.mod;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import org.spongepowered.asm.mixin.Mixins;

import java.io.*;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.*;
import java.util.*;
import java.util.jar.*;
import java.util.stream.Collectors;

/**
 * Pulse 모드 로더.
 * mods/ 폴더에서 모드 JAR를 발견하고 로드.
 */
public class ModLoader {

    private static ModLoader instance;

    private final Path modsDirectory;
    private final Map<String, ModContainer> mods = new LinkedHashMap<>();
    private final List<ModContainer> loadOrder = new ArrayList<>();
    private final Gson gson = new GsonBuilder().setPrettyPrinting().create();

    private boolean discoveryComplete = false;
    private boolean initialized = false;

    // ─────────────────────────────────────────────────────────────
    // 싱글톤
    // ─────────────────────────────────────────────────────────────

    public static ModLoader getInstance() {
        if (instance == null) {
            instance = new ModLoader();
        }
        return instance;
    }

    private ModLoader() {
        // 게임 디렉토리에서 mods 폴더 찾기
        String gameDir = System.getProperty("user.dir");
        this.modsDirectory = Paths.get(gameDir, "mods");

        System.out.println("[Pulse/ModLoader] Mods directory: " + modsDirectory.toAbsolutePath());
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 발견
    // ─────────────────────────────────────────────────────────────

    /**
     * mods/ 폴더에서 모든 모드 JAR 스캔
     */
    public void discoverMods() {
        if (discoveryComplete) {
            System.out.println("[Pulse/ModLoader] Discovery already complete");
            return;
        }

        System.out.println("[Pulse/ModLoader] ═══════════════════════════════════════");
        System.out.println("[Pulse/ModLoader] Discovering mods...");

        // mods 폴더 생성 (없으면)
        try {
            if (!Files.exists(modsDirectory)) {
                Files.createDirectories(modsDirectory);
                System.out.println("[Pulse/ModLoader] Created mods directory");
            }
        } catch (IOException e) {
            System.err.println("[Pulse/ModLoader] Failed to create mods directory: " + e.getMessage());
            return;
        }

        // JAR 파일 스캔
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(modsDirectory, "*.jar")) {
            for (Path jarPath : stream) {
                try {
                    discoverMod(jarPath);
                } catch (Exception e) {
                    System.err.println("[Pulse/ModLoader] Failed to load mod: " + jarPath.getFileName());
                    e.printStackTrace();
                }
            }
        } catch (IOException e) {
            System.err.println("[Pulse/ModLoader] Failed to scan mods directory: " + e.getMessage());
        }

        discoveryComplete = true;
        System.out.println("[Pulse/ModLoader] Discovered " + mods.size() + " mod(s)");
        System.out.println("[Pulse/ModLoader] ═══════════════════════════════════════");
    }

    /**
     * 단일 JAR 파일에서 모드 메타데이터 로드
     */
    private void discoverMod(Path jarPath) throws Exception {
        System.out.println("[Pulse/ModLoader] Scanning: " + jarPath.getFileName());

        try (JarFile jar = new JarFile(jarPath.toFile())) {
            // pulse.mod.json 찾기
            JarEntry metadataEntry = jar.getJarEntry("pulse.mod.json");

            if (metadataEntry == null) {
                System.out.println("[Pulse/ModLoader]   - No pulse.mod.json found, skipping");
                return;
            }

            // 메타데이터 파싱
            ModMetadata metadata;
            try (InputStream is = jar.getInputStream(metadataEntry);
                    InputStreamReader reader = new InputStreamReader(is)) {
                metadata = gson.fromJson(reader, ModMetadata.class);
            }

            // 유효성 검사
            if (metadata.getId() == null || metadata.getId().isEmpty()) {
                System.err.println("[Pulse/ModLoader]   - Invalid mod: missing 'id' field");
                return;
            }

            // 중복 체크
            if (mods.containsKey(metadata.getId())) {
                System.err.println("[Pulse/ModLoader]   - Duplicate mod ID: " + metadata.getId());
                return;
            }

            metadata.setSourceFile(jarPath.toAbsolutePath().toString());

            // 클래스로더 생성
            URL jarUrl = jarPath.toUri().toURL();
            URLClassLoader classLoader = new URLClassLoader(
                    new URL[] { jarUrl },
                    getClass().getClassLoader() // 부모 클래스로더
            );

            // 모드 컨테이너 생성
            ModContainer container = new ModContainer(metadata, classLoader);
            container.setState(ModContainer.ModState.METADATA_LOADED);

            mods.put(metadata.getId(), container);

            System.out.println("[Pulse/ModLoader]   ✓ " + metadata);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 의존성 해결 및 로드 순서 결정
    // ─────────────────────────────────────────────────────────────

    /**
     * 의존성 검사 및 로드 순서 결정 (토폴로지 정렬)
     */
    public void resolveDependencies() {
        System.out.println("[Pulse/ModLoader] Resolving dependencies...");

        List<String> errors = new ArrayList<>();

        // 각 모드의 의존성 검사
        for (ModContainer container : mods.values()) {
            ModMetadata metadata = container.getMetadata();

            for (ModMetadata.Dependency dep : metadata.getDependencies()) {
                // Pulse 자체는 항상 존재
                if ("Pulse".equals(dep.getId())) {
                    continue;
                }

                ModContainer depMod = mods.get(dep.getId());

                if (depMod == null) {
                    if (dep.isOptional()) {
                        System.out.println("[Pulse/ModLoader]   - " + metadata.getId() +
                                ": optional dependency '" + dep.getId() + "' not found");
                    } else {
                        errors.add(metadata.getId() + " requires " + dep.getId() + " " + dep.getVersion());
                    }
                } else {
                    // 버전 비교 로직
                    String actualVersion = depMod.getMetadata().getVersion();
                    String requiredVersion = dep.getVersion();

                    if (requiredVersion != null && !requiredVersion.isEmpty() && !"*".equals(requiredVersion)) {
                        if (VersionComparator.matches(actualVersion, requiredVersion)) {
                            System.out.println("[Pulse/ModLoader]   - " + metadata.getId() +
                                    " → " + dep.getId() + " v" + actualVersion + " ✓");
                        } else {
                            errors.add(metadata.getId() + " requires " + dep.getId() + " " +
                                    requiredVersion + " but found " + actualVersion);
                        }
                    } else {
                        System.out.println("[Pulse/ModLoader]   - " + metadata.getId() +
                                " → " + dep.getId() + " v" + actualVersion + " ✓");
                    }
                }
            }
        }

        // 충돌 검사
        for (ModContainer container : mods.values()) {
            ModMetadata metadata = container.getMetadata();
            for (String conflictId : metadata.getConflicts()) {
                if (mods.containsKey(conflictId)) {
                    errors.add(metadata.getId() + " conflicts with " + conflictId);
                    System.err.println("[Pulse/ModLoader] ✗ Conflict detected: " +
                            metadata.getId() + " and " + conflictId + " cannot be loaded together");
                }
            }
        }

        if (!errors.isEmpty()) {
            System.err.println("[Pulse/ModLoader] Dependency/Conflict errors:");
            for (String error : errors) {
                System.err.println("[Pulse/ModLoader]   ✗ " + error);
            }
        }

        // 토폴로지 정렬로 로드 순서 결정
        loadOrder.clear();
        Set<String> visited = new HashSet<>();
        Set<String> visiting = new HashSet<>();

        for (String modId : mods.keySet()) {
            if (!visited.contains(modId)) {
                topologicalSort(modId, visited, visiting, loadOrder);
            }
        }

        // 의존성 해결 완료 표시
        for (ModContainer container : loadOrder) {
            container.setState(ModContainer.ModState.DEPENDENCIES_RESOLVED);
        }

        System.out.println("[Pulse/ModLoader] Load order: " +
                loadOrder.stream().map(ModContainer::getId).collect(Collectors.joining(" → ")));
    }

    private void topologicalSort(String modId, Set<String> visited, Set<String> visiting,
            List<ModContainer> result) {
        if (visited.contains(modId))
            return;
        if (visiting.contains(modId)) {
            System.err.println("[Pulse/ModLoader] Circular dependency detected: " + modId);
            return;
        }

        visiting.add(modId);

        ModContainer container = mods.get(modId);
        if (container != null) {
            // 의존성 먼저 처리
            for (ModMetadata.Dependency dep : container.getMetadata().getDependencies()) {
                if (mods.containsKey(dep.getId())) {
                    topologicalSort(dep.getId(), visited, visiting, result);
                }
            }

            result.add(container);
        }

        visiting.remove(modId);
        visited.add(modId);
    }

    // ─────────────────────────────────────────────────────────────
    // Mixin 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 모드의 Mixin config 등록
     */
    public void registerMixins() {
        System.out.println("[Pulse/ModLoader] Registering mod mixins...");

        for (ModContainer container : loadOrder) {
            ModMetadata metadata = container.getMetadata();
            List<String> mixinConfigs = metadata.getMixins();

            if (mixinConfigs == null || mixinConfigs.isEmpty()) {
                continue;
            }

            for (String mixinConfig : mixinConfigs) {
                try {
                    System.out.println("[Pulse/Mixin] Registered mixin config " +
                            mixinConfig + " from " + metadata.getId());
                    Mixins.addConfiguration(mixinConfig);
                } catch (Exception e) {
                    System.err.println("[Pulse/Mixin] ✗ Failed to register " +
                            mixinConfig + " from " + metadata.getId() + ": " + e.getMessage());
                }
            }

            container.setState(ModContainer.ModState.MIXINS_APPLIED);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 모드 초기화 (엔트리포인트 호출)
     */
    public void initializeMods() {
        if (initialized) {
            System.out.println("[Pulse/ModLoader] Mods already initialized");
            return;
        }

        System.out.println("[Pulse/ModLoader] ═══════════════════════════════════════");
        System.out.println("[Pulse/ModLoader] Initializing mods...");

        int success = 0;
        int failed = 0;

        for (ModContainer container : loadOrder) {
            try {
                container.initialize();
                success++;
            } catch (Exception e) {
                failed++;
                System.err.println("[Pulse/ModLoader] ✗ " + container.getId() + " failed:");
                e.printStackTrace();
            }
        }

        initialized = true;

        System.out.println("[Pulse/ModLoader] ═══════════════════════════════════════");
        System.out.println("[Pulse/ModLoader] Initialization complete: " +
                success + " loaded, " + failed + " failed");
        System.out.println("[Pulse/ModLoader] ═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    public ModContainer getMod(String id) {
        return mods.get(id);
    }

    public Collection<ModContainer> getAllMods() {
        return Collections.unmodifiableCollection(mods.values());
    }

    public List<ModContainer> getLoadOrder() {
        return Collections.unmodifiableList(loadOrder);
    }

    public int getModCount() {
        return mods.size();
    }

    public Set<String> getLoadedModIds() {
        return Collections.unmodifiableSet(mods.keySet());
    }

    public boolean isModLoaded(String id) {
        ModContainer container = mods.get(id);
        return container != null && container.isLoaded();
    }

    public Path getModsDirectory() {
        return modsDirectory;
    }
}

[src/main/java/com/pulse/mod/ModContainer.java]
package com.pulse.mod;

import java.net.URLClassLoader;

/**
 * 로드된 모드를 나타내는 컨테이너.
 * 메타데이터, 클래스로더, 모드 인스턴스를 관리.
 */
public class ModContainer {

    private final ModMetadata metadata;
    private final URLClassLoader classLoader;
    private Object modInstance; // entrypoint 클래스의 인스턴스
    private ModState state = ModState.DISCOVERED;

    public ModContainer(ModMetadata metadata, URLClassLoader classLoader) {
        this.metadata = metadata;
        this.classLoader = classLoader;
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 상태
    // ─────────────────────────────────────────────────────────────

    public enum ModState {
        DISCOVERED, // JAR 발견됨
        METADATA_LOADED, // 메타데이터 파싱 완료
        DEPENDENCIES_RESOLVED, // 의존성 확인 완료
        MIXINS_APPLIED, // Mixin 적용됨
        INITIALIZED, // 초기화 완료
        LOADED, // 정상 로드됨 (활성 상태)
        DISABLED, // 비활성화됨 (핫 리로드)
        ERRORED // 에러 발생
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 초기화
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 엔트리포인트 클래스를 로드하고 인스턴스화
     */
    public void initialize() throws Exception {
        String entrypoint = metadata.getEntrypoint();
        if (entrypoint == null || entrypoint.isEmpty()) {
            System.out.println("[Pulse/Mod] " + metadata.getId() + " has no entrypoint, skipping initialization");
            state = ModState.INITIALIZED;
            return;
        }

        try {
            System.out.println("[Pulse/Mod] Initializing mod: " + metadata.getId());

            // 엔트리포인트 클래스 로드
            Class<?> entryClass = classLoader.loadClass(entrypoint);

            // PulseMod 인터페이스 구현 여부 확인
            if (PulseMod.class.isAssignableFrom(entryClass)) {
                modInstance = entryClass.getDeclaredConstructor().newInstance();
                ((PulseMod) modInstance).onInitialize();
                System.out.println("[Pulse/Mod] ✓ " + metadata.getId() + " initialized successfully");
            } else {
                System.err.println("[Pulse/Mod] WARNING: " + entrypoint +
                        " does not implement PulseMod interface");
                modInstance = entryClass.getDeclaredConstructor().newInstance();
            }

            state = ModState.INITIALIZED;
            metadata.setLoaded(true);

        } catch (Exception e) {
            state = ModState.ERRORED;
            System.err.println("[Pulse/Mod] Failed to initialize mod: " + metadata.getId());
            throw e;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public ModMetadata getMetadata() {
        return metadata;
    }

    public String getId() {
        return metadata.getId();
    }

    public String getVersion() {
        return metadata.getVersion();
    }

    public URLClassLoader getClassLoader() {
        return classLoader;
    }

    public Object getModInstance() {
        return modInstance;
    }

    @SuppressWarnings("unchecked")
    public <T> T getModInstance(Class<T> type) {
        if (type.isInstance(modInstance)) {
            return (T) modInstance;
        }
        return null;
    }

    public ModState getState() {
        return state;
    }

    public void setState(ModState state) {
        this.state = state;
    }

    public boolean isLoaded() {
        return state == ModState.INITIALIZED;
    }

    public boolean hasError() {
        return state == ModState.ERRORED;
    }

    @Override
    public String toString() {
        return String.format("ModContainer[%s v%s, state=%s]",
                metadata.getId(), metadata.getVersion(), state);
    }
}

[src/main/java/com/pulse/mod/ModMetadata.java]
package com.pulse.mod;

import java.util.ArrayList;
import java.util.List;

/**
 * 모드 메타데이터.
 * 각 모드의 pulse.mod.json 파일에서 파싱됨.
 * 
 * 예시 pulse.mod.json:
 * {
 * "id": "mymod",
 * "name": "My Awesome Mod",
 * "version": "1.0.0",
 * "author": "ModAuthor",
 * "description": "A cool mod for Project Zomboid",
 * "entrypoint": "com.example.mymod.MyMod",
 * "mixins": ["mixins.mymod.json"],
 * "dependencies": [
 * { "id": "Pulse", "version": ">=1.0.0" },
 * { "id": "othermod", "version": ">=2.0.0", "optional": true }
 * ]
 * }
 */
public class ModMetadata {

    private String id;
    private String name;
    private String version;
    private String author;
    private String description;
    private String entrypoint;
    private List<String> mixins = new ArrayList<>();
    private List<Dependency> dependencies = new ArrayList<>();
    private List<String> conflicts = new ArrayList<>();

    // Phase 2 추가 필드
    private String license;
    private String loaderVersion; // 필요한 Pulse 버전 (예: ">=1.0.0")
    private String gameVersion; // 필요한 PZ 버전 (예: "41.78+")
    private List<String> authors = new ArrayList<>();
    private EntryPoints entryPoints; // 환경별 엔트리포인트
    private List<String> accessWideners = new ArrayList<>();
    private List<String> permissions = new ArrayList<>();
    private String loadOrder; // 로드 순서 힌트 (예: "after:othermod")
    private String homepage;
    private String issues; // 이슈 트래커 URL
    private String source; // 소스 코드 URL

    // 런타임에 설정되는 필드
    private transient String sourceFile; // JAR 파일 경로
    private transient boolean loaded = false;

    // ─────────────────────────────────────────────────────────────
    // Getters & Setters
    // ─────────────────────────────────────────────────────────────

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getEntrypoint() {
        return entrypoint;
    }

    public void setEntrypoint(String entrypoint) {
        this.entrypoint = entrypoint;
    }

    public List<String> getMixins() {
        return mixins;
    }

    public void setMixins(List<String> mixins) {
        this.mixins = mixins != null ? mixins : new ArrayList<>();
    }

    public List<Dependency> getDependencies() {
        return dependencies;
    }

    public void setDependencies(List<Dependency> dependencies) {
        this.dependencies = dependencies != null ? dependencies : new ArrayList<>();
    }

    public List<String> getConflicts() {
        return conflicts;
    }

    public void setConflicts(List<String> conflicts) {
        this.conflicts = conflicts != null ? conflicts : new ArrayList<>();
    }

    public List<String> getPermissions() {
        return permissions;
    }

    public void setPermissions(List<String> permissions) {
        this.permissions = permissions != null ? permissions : new ArrayList<>();
    }

    public String getLicense() {
        return license;
    }

    public void setLicense(String license) {
        this.license = license;
    }

    public String getLoaderVersion() {
        return loaderVersion;
    }

    public void setLoaderVersion(String loaderVersion) {
        this.loaderVersion = loaderVersion;
    }

    public String getGameVersion() {
        return gameVersion;
    }

    public void setGameVersion(String gameVersion) {
        this.gameVersion = gameVersion;
    }

    public List<String> getAuthors() {
        return authors;
    }

    public void setAuthors(List<String> authors) {
        this.authors = authors != null ? authors : new ArrayList<>();
    }

    public EntryPoints getEntryPoints() {
        return entryPoints;
    }

    public void setEntryPoints(EntryPoints entryPoints) {
        this.entryPoints = entryPoints;
    }

    public List<String> getAccessWideners() {
        return accessWideners;
    }

    public void setAccessWideners(List<String> accessWideners) {
        this.accessWideners = accessWideners != null ? accessWideners : new ArrayList<>();
    }

    public String getLoadOrder() {
        return loadOrder;
    }

    public void setLoadOrder(String loadOrder) {
        this.loadOrder = loadOrder;
    }

    public String getHomepage() {
        return homepage;
    }

    public void setHomepage(String homepage) {
        this.homepage = homepage;
    }

    public String getIssues() {
        return issues;
    }

    public void setIssues(String issues) {
        this.issues = issues;
    }

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public String getSourceFile() {
        return sourceFile;
    }

    public void setSourceFile(String sourceFile) {
        this.sourceFile = sourceFile;
    }

    public boolean isLoaded() {
        return loaded;
    }

    public void setLoaded(boolean loaded) {
        this.loaded = loaded;
    }

    // ─────────────────────────────────────────────────────────────
    // 의존성 클래스
    // ─────────────────────────────────────────────────────────────

    public static class Dependency {
        private String id;
        private String version;
        private boolean optional = false;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getVersion() {
            return version;
        }

        public void setVersion(String version) {
            this.version = version;
        }

        public boolean isOptional() {
            return optional;
        }

        public void setOptional(boolean optional) {
            this.optional = optional;
        }

        @Override
        public String toString() {
            return id + " " + version + (optional ? " (optional)" : "");
        }
    }

    @Override
    public String toString() {
        return String.format("%s (%s) v%s by %s", name, id, version, author);
    }
}

[src/main/java/com/pulse/event/EventBus.java]
package com.pulse.event;

import com.pulse.api.DevMode;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Pulse 이벤트 버스.
 * 이벤트 등록, 발행, 구독을 관리.
 * 
 * 사용 예:
 * // 구독
 * EventBus.subscribe(GameTickEvent.class, event -> {
 * System.out.println("Game tick: " + event.getTick());
 * });
 * 
 * // 발행
 * EventBus.post(new GameTickEvent(tickCount));
 */
public class EventBus {

    private static final EventBus INSTANCE = new EventBus();

    // 이벤트 타입 → 리스너 목록
    private final Map<Class<? extends Event>, List<RegisteredListener<?>>> listeners = new ConcurrentHashMap<>();

    // 디버그 모드
    private boolean debug = false;

    // ─────────────────────────────────────────────────────────────
    // 싱글톤 접근
    // ─────────────────────────────────────────────────────────────

    public static EventBus getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 정적 메서드 (편의용)
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 리스너 등록 (기본 우선순위)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener) {
        INSTANCE.register(eventType, listener, EventPriority.NORMAL, null);
    }

    /**
     * 이벤트 리스너 등록 (우선순위 지정)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener,
            EventPriority priority) {
        INSTANCE.register(eventType, listener, priority, null);
    }

    /**
     * 이벤트 리스너 등록 (modId 지정 - 예외 격리용)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener,
            String modId) {
        INSTANCE.register(eventType, listener, EventPriority.NORMAL, modId);
    }

    /**
     * 이벤트 리스너 등록 (우선순위 + modId 지정)
     */
    public static <T extends Event> void subscribe(Class<T> eventType, EventListener<T> listener,
            EventPriority priority, String modId) {
        INSTANCE.register(eventType, listener, priority, modId);
    }

    /**
     * 이벤트 리스너 해제
     */
    public static <T extends Event> void unsubscribe(Class<T> eventType, EventListener<T> listener) {
        INSTANCE.unregister(eventType, listener);
    }

    /**
     * 이벤트 발행
     */
    public static <T extends Event> T post(T event) {
        return INSTANCE.fire(event);
    }

    // ─────────────────────────────────────────────────────────────
    // 인스턴스 메서드
    // ─────────────────────────────────────────────────────────────

    /**
     * 리스너 등록 (modId 없이)
     */
    public <T extends Event> void register(Class<T> eventType, EventListener<T> listener,
            EventPriority priority) {
        register(eventType, listener, priority, null);
    }

    /**
     * 리스너 등록 (modId 포함 - 예외 격리용)
     */
    public <T extends Event> void register(Class<T> eventType, EventListener<T> listener,
            EventPriority priority, String modId) {
        List<RegisteredListener<?>> list = listeners.computeIfAbsent(
                eventType,
                k -> new CopyOnWriteArrayList<>());

        RegisteredListener<T> registered = new RegisteredListener<>(listener, priority, modId);
        list.add(registered);

        // 우선순위로 정렬 (높은 것이 먼저)
        list.sort((a, b) -> Integer.compare(b.priority.getValue(), a.priority.getValue()));

        if (debug) {
            String modInfo = modId != null ? " from mod " + modId : "";
            System.out.println("[Pulse/Event] Registered listener for " +
                    eventType.getSimpleName() + " with priority " + priority + modInfo);
        }
    }

    /**
     * 리스너 해제
     */
    public <T extends Event> void unregister(Class<T> eventType, EventListener<T> listener) {
        List<RegisteredListener<?>> list = listeners.get(eventType);
        if (list != null) {
            list.removeIf(reg -> reg.listener == listener);
        }
    }

    /**
     * 이벤트 발행 (모든 리스너에 전달)
     */
    @SuppressWarnings("unchecked")
    public <T extends Event> T fire(T event) {
        List<RegisteredListener<?>> list = listeners.get(event.getClass());

        if (list == null || list.isEmpty()) {
            return event;
        }

        if (debug) {
            System.out.println("[Pulse/EventBus] Firing " + event.getEventName() +
                    " to " + list.size() + " listener(s)");
        }

        for (RegisteredListener<?> registered : list) {
            // 취소된 이벤트는 더 이상 전달하지 않음 (선택적)
            if (event.isCancelled()) {
                break;
            }

            try {
                ((EventListener<T>) registered.listener).onEvent(event);
            } catch (Exception e) {
                // 예외 격리: 어느 모드에서 문제가 발생했는지 명확히 로그
                String modId = registered.modId != null ? registered.modId : "unknown";
                System.err.println("[Pulse/Event] Exception in listener {" + modId +
                        "} for event {" + event.getEventName() + "}");

                // DevMode일 때 추가 정보
                if (DevMode.isEnabled()) {
                    System.err.println("[Pulse/Event]   Listener class: " +
                            registered.listener.getClass().getName());
                    System.err.println("[Pulse/Event]   Priority: " + registered.priority);
                }

                e.printStackTrace();

                // 예외가 발생해도 다른 리스너는 계속 실행됨 (격리)
            }
        }

        return event;
    }

    /**
     * 특정 이벤트 타입의 모든 리스너 해제
     */
    public void clearListeners(Class<? extends Event> eventType) {
        listeners.remove(eventType);
    }

    /**
     * 모든 리스너 해제
     */
    public void clearAll() {
        listeners.clear();
    }

    /**
     * 등록된 리스너 수
     */
    public int getListenerCount(Class<? extends Event> eventType) {
        List<RegisteredListener<?>> list = listeners.get(eventType);
        return list != null ? list.size() : 0;
    }

    /**
     * 특정 modId로 등록된 모든 리스너 해제.
     * 모드 비활성화/리로드 시 사용.
     * 
     * @param modId 해제할 모드 ID
     * @return 해제된 리스너 수
     */
    public static int unsubscribeAll(String modId) {
        return INSTANCE.unregisterAll(modId);
    }

    private int unregisterAll(String modId) {
        if (modId == null)
            return 0;

        int removed = 0;
        for (List<RegisteredListener<?>> list : listeners.values()) {
            int before = list.size();
            list.removeIf(reg -> modId.equals(reg.modId));
            removed += (before - list.size());
        }

        if (removed > 0) {
            System.out.println("[Pulse/Event] Unregistered " + removed +
                    " listeners for mod: " + modId);
        }
        return removed;
    }

    public void setDebug(boolean debug) {
        this.debug = debug;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    private static class RegisteredListener<T extends Event> {
        final EventListener<T> listener;
        final EventPriority priority;
        final String modId; // 예외 격리용 모드 식별자

        RegisteredListener(EventListener<T> listener, EventPriority priority, String modId) {
            this.listener = listener;
            this.priority = priority;
            this.modId = modId;
        }
    }
}

[src/main/java/com/pulse/event/Event.java]
package com.pulse.event;

/**
 * 모든 Pulse 이벤트의 기본 클래스.
 */
public abstract class Event {
    
    private boolean cancelled = false;
    private final boolean cancellable;
    
    protected Event() {
        this(false);
    }
    
    protected Event(boolean cancellable) {
        this.cancellable = cancellable;
    }
    
    /**
     * 이벤트 취소 (취소 가능한 이벤트만)
     */
    public void cancel() {
        if (!cancellable) {
            throw new UnsupportedOperationException("This event cannot be cancelled");
        }
        this.cancelled = true;
    }
    
    public boolean isCancelled() {
        return cancelled;
    }
    
    public boolean isCancellable() {
        return cancellable;
    }
    
    /**
     * 이벤트 이름 (디버깅용)
     */
    public String getEventName() {
        return getClass().getSimpleName();
    }
}

[src/main/java/com/pulse/event/EventPriority.java]
package com.pulse.event;

/**
 * 이벤트 리스너 우선순위.
 * 높은 우선순위가 먼저 실행됨.
 */
public enum EventPriority {
    
    /**
     * 가장 먼저 실행 (모니터링, 로깅용)
     */
    HIGHEST(100),
    
    /**
     * 높은 우선순위
     */
    HIGH(75),
    
    /**
     * 기본 우선순위
     */
    NORMAL(50),
    
    /**
     * 낮은 우선순위
     */
    LOW(25),
    
    /**
     * 가장 나중에 실행 (최종 처리용)
     */
    LOWEST(0);
    
    private final int value;
    
    EventPriority(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
}

[src/main/java/com/pulse/registry/Registry.java]
package com.pulse.registry;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * 범용 레지스트리.
 * 특정 타입의 객체를 식별자로 등록하고 관리.
 * 
 * 사용 예:
 * 
 * <pre>
 * // 레지스트리 생성
 * Registry<MyItem> ITEMS = Registry.create(Identifier.of("mymod", "items"));
 * 
 * // 등록
 * ITEMS.register(Identifier.of("mymod", "cool_item"), new MyCoolItem());
 * 
 * // 조회
 * MyItem item = ITEMS.get(Identifier.of("mymod", "cool_item"));
 * </pre>
 * 
 * @param <T> 레지스트리에 저장할 객체 타입
 */
public class Registry<T> {

    private final Identifier registryId;
    private final Map<Identifier, T> entries = new ConcurrentHashMap<>();
    private final Map<Identifier, Supplier<T>> deferredEntries = new ConcurrentHashMap<>();
    private boolean frozen = false;

    // 글로벌 레지스트리 목록
    private static final Map<Identifier, Registry<?>> REGISTRIES = new ConcurrentHashMap<>();

    private Registry(Identifier registryId) {
        this.registryId = registryId;
    }

    /**
     * 새 레지스트리 생성
     */
    public static <T> Registry<T> create(Identifier registryId) {
        if (REGISTRIES.containsKey(registryId)) {
            throw new IllegalStateException("Registry already exists: " + registryId);
        }

        Registry<T> registry = new Registry<>(registryId);
        REGISTRIES.put(registryId, registry);

        System.out.println("[Pulse/Registry] Created registry: " + registryId);
        return registry;
    }

    /**
     * 기존 레지스트리 가져오기
     */
    @SuppressWarnings("unchecked")
    public static <T> Registry<T> getRegistry(Identifier registryId) {
        return (Registry<T>) REGISTRIES.get(registryId);
    }

    // ─────────────────────────────────────────────────────────────
    // 등록
    // ─────────────────────────────────────────────────────────────

    /**
     * 객체 등록
     */
    public T register(Identifier id, T value) {
        if (frozen) {
            throw new IllegalStateException("Registry is frozen: " + registryId);
        }
        if (entries.containsKey(id)) {
            throw new IllegalArgumentException("Duplicate entry: " + id);
        }

        entries.put(id, value);
        System.out.println("[Pulse/Registry] Registered " + registryId + " -> " + id);
        return value;
    }

    /**
     * 문자열 ID로 등록
     */
    public T register(String id, T value) {
        return register(Identifier.parse(id), value);
    }

    /**
     * 지연 등록 (Supplier 사용)
     * 실제 객체는 freeze 시점에 생성됨
     */
    public void registerDeferred(Identifier id, Supplier<T> supplier) {
        if (frozen) {
            throw new IllegalStateException("Registry is frozen: " + registryId);
        }
        deferredEntries.put(id, supplier);
    }

    // ─────────────────────────────────────────────────────────────
    // 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * ID로 객체 가져오기
     */
    public T get(Identifier id) {
        return entries.get(id);
    }

    /**
     * 문자열 ID로 가져오기
     */
    public T get(String id) {
        return get(Identifier.parse(id));
    }

    /**
     * ID로 Optional 가져오기
     */
    public Optional<T> getOptional(Identifier id) {
        return Optional.ofNullable(entries.get(id));
    }

    /**
     * ID 존재 여부 확인
     */
    public boolean contains(Identifier id) {
        return entries.containsKey(id);
    }

    /**
     * 객체의 ID 가져오기 (역방향 조회)
     */
    public Optional<Identifier> getId(T value) {
        for (Map.Entry<Identifier, T> entry : entries.entrySet()) {
            if (entry.getValue().equals(value)) {
                return Optional.of(entry.getKey());
            }
        }
        return Optional.empty();
    }

    // ─────────────────────────────────────────────────────────────
    // 반복
    // ─────────────────────────────────────────────────────────────

    /**
     * 모든 ID
     */
    public Set<Identifier> getIds() {
        return Collections.unmodifiableSet(entries.keySet());
    }

    /**
     * 모든 값
     */
    public Collection<T> getValues() {
        return Collections.unmodifiableCollection(entries.values());
    }

    /**
     * 모든 엔트리
     */
    public Set<Map.Entry<Identifier, T>> getEntries() {
        return Collections.unmodifiableSet(entries.entrySet());
    }

    /**
     * 등록된 항목 수
     */
    public int size() {
        return entries.size();
    }

    public boolean isEmpty() {
        return entries.isEmpty();
    }

    // ─────────────────────────────────────────────────────────────
    // 레지스트리 잠금
    // ─────────────────────────────────────────────────────────────

    /**
     * 레지스트리 잠금 (더 이상 등록 불가)
     * 지연 등록된 항목들이 이 시점에 생성됨
     */
    public void freeze() {
        if (frozen)
            return;

        // 지연 등록 처리
        for (Map.Entry<Identifier, Supplier<T>> entry : deferredEntries.entrySet()) {
            T value = entry.getValue().get();
            entries.put(entry.getKey(), value);
        }
        deferredEntries.clear();

        frozen = true;
        System.out.println("[Pulse/Registry] Frozen " + registryId + " with " + entries.size() + " entries");
    }

    public boolean isFrozen() {
        return frozen;
    }

    public Identifier getRegistryId() {
        return registryId;
    }

    /**
     * 모든 레지스트리 잠금
     */
    public static void freezeAll() {
        for (Registry<?> registry : REGISTRIES.values()) {
            registry.freeze();
        }
    }

    /**
     * 모든 레지스트리 가져오기
     */
    public static Collection<Registry<?>> getAllRegistries() {
        return Collections.unmodifiableCollection(REGISTRIES.values());
    }
}

[src/main/java/com/pulse/registry/Identifier.java]
package com.pulse.registry;

import java.util.Objects;

/**
 * 리소스 식별자.
 * 네임스페이스:경로 형식 (예: "mymod:my_item")
 * Minecraft의 ResourceLocation과 동일한 개념.
 */
public final class Identifier {

    public static final String DEFAULT_NAMESPACE = "Pulse";
    public static final char SEPARATOR = ':';

    private final String namespace;
    private final String path;

    private Identifier(String namespace, String path) {
        this.namespace = namespace;
        this.path = path;
    }

    /**
     * 식별자 생성
     */
    public static Identifier of(String namespace, String path) {
        validateNamespace(namespace);
        validatePath(path);
        return new Identifier(namespace, path);
    }

    /**
     * 문자열에서 파싱
     * "namespace:path" 또는 "path" (기본 네임스페이스 사용)
     */
    public static Identifier parse(String id) {
        if (id == null || id.isEmpty()) {
            throw new IllegalArgumentException("Identifier cannot be null or empty");
        }

        int colonIndex = id.indexOf(SEPARATOR);
        if (colonIndex < 0) {
            // 네임스페이스 없음 - 기본 사용
            return of(DEFAULT_NAMESPACE, id);
        }

        String namespace = id.substring(0, colonIndex);
        String path = id.substring(colonIndex + 1);
        return of(namespace, path);
    }

    /**
     * 모드 ID로 네임스페이스 지정하여 생성
     */
    public static Identifier mod(String modId, String path) {
        return of(modId, path);
    }

    // ─────────────────────────────────────────────────────────────
    // 유효성 검사
    // ─────────────────────────────────────────────────────────────

    private static void validateNamespace(String namespace) {
        if (namespace == null || namespace.isEmpty()) {
            throw new IllegalArgumentException("Namespace cannot be null or empty");
        }
        if (!isValidNamespace(namespace)) {
            throw new IllegalArgumentException("Invalid namespace: " + namespace);
        }
    }

    private static void validatePath(String path) {
        if (path == null || path.isEmpty()) {
            throw new IllegalArgumentException("Path cannot be null or empty");
        }
        if (!isValidPath(path)) {
            throw new IllegalArgumentException("Invalid path: " + path);
        }
    }

    /**
     * 네임스페이스 유효성 (a-z, 0-9, _, -)
     */
    public static boolean isValidNamespace(String namespace) {
        for (char c : namespace.toCharArray()) {
            if (!(c >= 'a' && c <= 'z') &&
                    !(c >= '0' && c <= '9') &&
                    c != '_' && c != '-') {
                return false;
            }
        }
        return true;
    }

    /**
     * 경로 유효성 (a-z, 0-9, _, -, ., /)
     */
    public static boolean isValidPath(String path) {
        for (char c : path.toCharArray()) {
            if (!(c >= 'a' && c <= 'z') &&
                    !(c >= '0' && c <= '9') &&
                    c != '_' && c != '-' && c != '.' && c != '/') {
                return false;
            }
        }
        return true;
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public String getNamespace() {
        return namespace;
    }

    public String getPath() {
        return path;
    }

    /**
     * 전체 문자열 (namespace:path)
     */
    @Override
    public String toString() {
        return namespace + SEPARATOR + path;
    }

    /**
     * 파일 경로 형식 (namespace/path)
     */
    public String toFilePath() {
        return namespace + "/" + path;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Identifier that = (Identifier) o;
        return namespace.equals(that.namespace) && path.equals(that.path);
    }

    @Override
    public int hashCode() {
        return Objects.hash(namespace, path);
    }
}

[src/main/java/com/pulse/api/Pulse.java]
package com.pulse.api;

import com.pulse.PulseEnvironment;
import com.pulse.event.EventBus;
import com.pulse.mod.ModContainer;
import com.pulse.mod.ModLoader;

import java.nio.file.Path;
import java.util.Collection;
import java.util.Optional;

/**
 * Pulse API 메인 진입점.
 * 모드 개발자가 사용하는 안정적인 API.
 * 
 * 사용 예:
 * if (Pulse.isModLoaded("othermod")) {
 * // othermod와 연동
 * }
 */
public final class Pulse {

    private Pulse() {
    } // 인스턴스화 방지

    // ─────────────────────────────────────────────────────────────
    // 버전 정보
    // ─────────────────────────────────────────────────────────────

    public static final String VERSION = "1.0.0";
    public static final String NAME = "Pulse";
    public static final int API_VERSION = 1;

    /**
     * Pulse 버전 반환
     */
    public static String getVersion() {
        return VERSION;
    }

    /**
     * API 버전 반환 (호환성 체크용)
     */
    public static int getApiVersion() {
        return API_VERSION;
    }

    // ─────────────────────────────────────────────────────────────
    // 모드 관련
    // ─────────────────────────────────────────────────────────────

    /**
     * 특정 모드가 로드되었는지 확인
     */
    public static boolean isModLoaded(String modId) {
        return ModLoader.getInstance().isModLoaded(modId);
    }

    /**
     * 모드 컨테이너 가져오기
     */
    public static Optional<ModContainer> getMod(String modId) {
        return Optional.ofNullable(ModLoader.getInstance().getMod(modId));
    }

    /**
     * 로드된 모든 모드 목록
     */
    public static Collection<ModContainer> getAllMods() {
        return ModLoader.getInstance().getAllMods();
    }

    /**
     * 로드된 모드 수
     */
    public static int getModCount() {
        return ModLoader.getInstance().getModCount();
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 시스템
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 버스 접근
     */
    public static EventBus getEventBus() {
        return EventBus.getInstance();
    }

    // ─────────────────────────────────────────────────────────────
    // 환경 정보
    // ─────────────────────────────────────────────────────────────

    /**
     * Pulse이 완전히 초기화되었는지 확인
     */
    public static boolean isInitialized() {
        return PulseEnvironment.isInitialized();
    }

    /**
     * 게임 디렉토리 경로
     */
    public static Path getGameDirectory() {
        return Path.of(System.getProperty("user.dir"));
    }

    /**
     * mods 디렉토리 경로
     */
    public static Path getModsDirectory() {
        return ModLoader.getInstance().getModsDirectory();
    }

    /**
     * 설정 디렉토리 경로
     */
    public static Path getConfigDirectory() {
        return getGameDirectory().resolve("config");
    }

    // ─────────────────────────────────────────────────────────────
    // DevMode
    // ─────────────────────────────────────────────────────────────

    /**
     * DevMode 활성화 여부 확인
     */
    public static boolean isDevMode() {
        return DevMode.isEnabled();
    }

    /**
     * DevMode 활성화
     */
    public static void enableDevMode() {
        DevMode.enable();
    }

    // ─────────────────────────────────────────────────────────────
    // 로깅
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드별 로거 가져오기
     */
    public static ModLogger getLogger(String modId) {
        return ModLogger.getLogger(modId);
    }

    /**
     * Pulse 로그 출력
     */
    public static void log(String message) {
        System.out.println("[Pulse] " + message);
    }

    /**
     * 모드 로그 출력 (modId prefix 포함)
     */
    public static void log(String modId, String message) {
        System.out.println("[Mod/" + modId + "] " + message);
    }

    /**
     * Pulse 경고 출력
     */
    public static void warn(String message) {
        System.out.println("[Pulse/WARN] " + message);
    }

    /**
     * 모드 경고 출력
     */
    public static void warn(String modId, String message) {
        System.out.println("[Mod/" + modId + "/WARN] " + message);
    }

    /**
     * Pulse 에러 출력
     */
    public static void error(String message) {
        System.err.println("[Pulse/ERROR] " + message);
    }

    /**
     * 모드 에러 출력
     */
    public static void error(String modId, String message) {
        System.err.println("[Mod/" + modId + "/ERROR] " + message);
    }

    /**
     * Pulse 에러 출력 (예외 포함)
     */
    public static void error(String message, Throwable t) {
        System.err.println("[Pulse/ERROR] " + message);
        t.printStackTrace();
    }

    /**
     * 모드 에러 출력 (예외 포함)
     */
    public static void error(String modId, String message, Throwable t) {
        System.err.println("[Mod/" + modId + "/ERROR] " + message);
        t.printStackTrace();
    }
}

[src/main/java/com/pulse/lua/LuaTypeConverter.java]
package com.pulse.lua;

import java.util.List;
import java.util.Map;

/**
 * Java ↔ Lua 타입 변환기.
 * 양방향으로 타입을 안전하게 변환.
 */
public class LuaTypeConverter {

    private LuaTypeConverter() {
    }

    // ─────────────────────────────────────────────────────────────
    // Java → Lua
    // ─────────────────────────────────────────────────────────────

    /**
     * Java 객체를 Lua 호환 객체로 변환.
     */
    public static Object javaToLua(Object javaValue) {
        if (javaValue == null) {
            return null;
        }

        // 기본 타입은 그대로 전달 (Kahlua가 처리)
        if (javaValue instanceof String ||
                javaValue instanceof Number ||
                javaValue instanceof Boolean) {
            return javaValue;
        }

        // 배열 → Lua 테이블 (인덱스 1부터)
        if (javaValue.getClass().isArray()) {
            return arrayToLuaTable(javaValue);
        }

        // List → Lua 테이블
        if (javaValue instanceof List<?>) {
            return listToLuaTable((List<?>) javaValue);
        }

        // Map → Lua 테이블
        if (javaValue instanceof Map<?, ?>) {
            return mapToLuaTable((Map<?, ?>) javaValue);
        }

        // 기타 객체는 그대로 (userdata로 전달됨)
        return javaValue;
    }

    private static Object arrayToLuaTable(Object array) {
        try {
            // KahluaTable 생성 시도
            Class<?> tableClass = Class.forName("se.krka.kahlua.vm.KahluaTable");
            Object table = tableClass.getDeclaredConstructor().newInstance();

            int length = java.lang.reflect.Array.getLength(array);
            for (int i = 0; i < length; i++) {
                Object item = java.lang.reflect.Array.get(array, i);
                // Lua는 1-based 인덱스
                tableClass.getMethod("rawset", Object.class, Object.class)
                        .invoke(table, (double) (i + 1), javaToLua(item));
            }
            return table;
        } catch (Exception e) {
            // 테이블 생성 실패 시 원본 반환
            return array;
        }
    }

    private static Object listToLuaTable(List<?> list) {
        try {
            Class<?> tableClass = Class.forName("se.krka.kahlua.vm.KahluaTable");
            Object table = tableClass.getDeclaredConstructor().newInstance();

            int i = 1;
            for (Object item : list) {
                tableClass.getMethod("rawset", Object.class, Object.class)
                        .invoke(table, (double) i++, javaToLua(item));
            }
            return table;
        } catch (Exception e) {
            return list;
        }
    }

    private static Object mapToLuaTable(Map<?, ?> map) {
        try {
            Class<?> tableClass = Class.forName("se.krka.kahlua.vm.KahluaTable");
            Object table = tableClass.getDeclaredConstructor().newInstance();

            for (var entry : map.entrySet()) {
                Object key = javaToLua(entry.getKey());
                Object value = javaToLua(entry.getValue());
                tableClass.getMethod("rawset", Object.class, Object.class)
                        .invoke(table, key, value);
            }
            return table;
        } catch (Exception e) {
            return map;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // Lua → Java
    // ─────────────────────────────────────────────────────────────

    /**
     * Lua 값을 Java 타입으로 변환.
     */
    @SuppressWarnings("unchecked")
    public static <T> T luaToJava(Object luaValue, Class<T> targetType) {
        if (luaValue == null) {
            return null;
        }

        // 이미 원하는 타입이면 그대로 반환
        if (targetType.isInstance(luaValue)) {
            return (T) luaValue;
        }

        // Lua number → 다양한 숫자 타입
        if (luaValue instanceof Double) {
            Double d = (Double) luaValue;
            if (targetType == Integer.class || targetType == int.class) {
                return (T) Integer.valueOf(d.intValue());
            }
            if (targetType == Long.class || targetType == long.class) {
                return (T) Long.valueOf(d.longValue());
            }
            if (targetType == Float.class || targetType == float.class) {
                return (T) Float.valueOf(d.floatValue());
            }
            if (targetType == Double.class || targetType == double.class) {
                return (T) d;
            }
        }

        // String 변환
        if (targetType == String.class) {
            return (T) String.valueOf(luaValue);
        }

        // Boolean 변환
        if (targetType == Boolean.class || targetType == boolean.class) {
            if (luaValue instanceof Boolean) {
                return (T) luaValue;
            }
            return (T) Boolean.TRUE; // Lua에서 nil과 false만 falsy
        }

        // KahluaTable → List
        if (targetType == List.class) {
            return (T) luaTableToList(luaValue);
        }

        // KahluaTable → Map
        if (targetType == Map.class) {
            return (T) luaTableToMap(luaValue);
        }

        // 변환 불가 - 원본 반환 시도
        try {
            return (T) luaValue;
        } catch (ClassCastException e) {
            return null;
        }
    }

    private static List<Object> luaTableToList(Object luaTable) {
        List<Object> result = new java.util.ArrayList<>();
        try {
            Class<?> tableClass = luaTable.getClass();
            java.lang.reflect.Method lenMethod = tableClass.getMethod("len");
            int len = ((Number) lenMethod.invoke(luaTable)).intValue();

            java.lang.reflect.Method rawgetMethod = tableClass.getMethod(
                    "rawget", Object.class);

            for (int i = 1; i <= len; i++) {
                Object value = rawgetMethod.invoke(luaTable, (double) i);
                result.add(value);
            }
        } catch (Exception e) {
            // 변환 실패
        }
        return result;
    }

    private static Map<Object, Object> luaTableToMap(Object luaTable) {
        Map<Object, Object> result = new java.util.LinkedHashMap<>();
        try {
            Class<?> tableClass = luaTable.getClass();

            // 테이블의 next() 메서드로 순회
            java.lang.reflect.Method nextMethod = tableClass.getMethod(
                    "next", Object.class);
            java.lang.reflect.Method rawgetMethod = tableClass.getMethod(
                    "rawget", Object.class);

            Object key = nextMethod.invoke(luaTable, (Object) null);
            while (key != null) {
                Object value = rawgetMethod.invoke(luaTable, key);
                result.put(key, value);
                key = nextMethod.invoke(luaTable, key);
            }
        } catch (Exception e) {
            // 변환 실패
        }
        return result;
    }
}

[src/main/java/com/pulse/debug/EventMonitor.java]
package com.pulse.debug;

import com.pulse.event.Event;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 이벤트 모니터.
 * 실시간으로 발생하는 이벤트 추적 및 통계.
 * 
 * 사용 예:
 * 
 * <pre>
 * EventMonitor.enable();
 * // ... 게임 플레이 ...
 * EventMonitor.printStats();
 * </pre>
 */
public class EventMonitor {

    private static final EventMonitor INSTANCE = new EventMonitor();

    private boolean enabled = false;
    private final Map<Class<? extends Event>, EventStats> stats = new ConcurrentHashMap<>();
    private final List<EventRecord> recentEvents = Collections.synchronizedList(new LinkedList<>());
    private static final int MAX_RECENT = 100;

    private EventMonitor() {
    }

    public static EventMonitor getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 제어
    // ─────────────────────────────────────────────────────────────

    public static void enable() {
        INSTANCE.enabled = true;
        System.out.println("[Pulse/EventMonitor] Monitoring enabled");
    }

    public static void disable() {
        INSTANCE.enabled = false;
        System.out.println("[Pulse/EventMonitor] Monitoring disabled");
    }

    public static boolean isEnabled() {
        return INSTANCE.enabled;
    }

    public static void reset() {
        INSTANCE.stats.clear();
        INSTANCE.recentEvents.clear();
    }

    // ─────────────────────────────────────────────────────────────
    // 이벤트 기록 (EventBus에서 호출)
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 발생 기록.
     */
    public static void record(Event event, long processingTimeNs) {
        if (!INSTANCE.enabled)
            return;

        Class<? extends Event> type = event.getClass();

        // 통계 업데이트
        INSTANCE.stats.computeIfAbsent(type, k -> new EventStats(type))
                .record(processingTimeNs);

        // 최근 이벤트 저장
        synchronized (INSTANCE.recentEvents) {
            INSTANCE.recentEvents.add(new EventRecord(type, processingTimeNs));
            while (INSTANCE.recentEvents.size() > MAX_RECENT) {
                INSTANCE.recentEvents.remove(0);
            }
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 통계 조회
    // ─────────────────────────────────────────────────────────────

    /**
     * 이벤트 통계 출력.
     */
    public static void printStats() {
        System.out.println("═══════════════════════════════════════");
        System.out.println("        EVENT MONITOR STATISTICS        ");
        System.out.println("═══════════════════════════════════════");

        List<EventStats> sorted = new ArrayList<>(INSTANCE.stats.values());
        sorted.sort((a, b) -> Long.compare(b.count.get(), a.count.get()));

        for (EventStats stat : sorted) {
            System.out.printf("  %-30s : %6d events, avg %.2fms\n",
                    stat.eventType.getSimpleName(),
                    stat.count.get(),
                    stat.getAverageMs());
        }

        System.out.println("═══════════════════════════════════════");
    }

    /**
     * 통계 맵 반환.
     */
    public static Map<Class<? extends Event>, EventStats> getStats() {
        return Collections.unmodifiableMap(INSTANCE.stats);
    }

    /**
     * 최근 이벤트 목록.
     */
    public static List<EventRecord> getRecentEvents() {
        return new ArrayList<>(INSTANCE.recentEvents);
    }

    // ─────────────────────────────────────────────────────────────
    // 데이터 클래스
    // ─────────────────────────────────────────────────────────────

    public static class EventStats {
        public final Class<? extends Event> eventType;
        public final AtomicLong count = new AtomicLong(0);
        public final AtomicLong totalTimeNs = new AtomicLong(0);

        EventStats(Class<? extends Event> eventType) {
            this.eventType = eventType;
        }

        void record(long processingTimeNs) {
            count.incrementAndGet();
            totalTimeNs.addAndGet(processingTimeNs);
        }

        public double getAverageMs() {
            long c = count.get();
            if (c == 0)
                return 0;
            return (totalTimeNs.get() / (double) c) / 1_000_000.0;
        }
    }

    public static class EventRecord {
        public final Class<? extends Event> eventType;
        public final long timestamp;
        public final long processingTimeNs;

        EventRecord(Class<? extends Event> eventType, long processingTimeNs) {
            this.eventType = eventType;
            this.timestamp = System.currentTimeMillis();
            this.processingTimeNs = processingTimeNs;
        }
    }
}

[src/main/java/com/pulse/mixin/MixinDiagnostics.java]
package com.pulse.mixin;

import com.pulse.api.DevMode;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Mixin 진단 도구.
 * 적용된 Mixin 추적 및 잠재적 충돌 감지.
 * 
 * DevMode가 활성화되면 상세한 리포트 출력.
 */
public class MixinDiagnostics {

    private static final MixinDiagnostics INSTANCE = new MixinDiagnostics();

    // 타겟 클래스 → 적용된 Mixin 정보 목록
    private final Map<String, List<MixinInfo>> appliedMixins = new ConcurrentHashMap<>();

    // 로드 실패한 Mixin 목록
    private final List<FailedMixin> failedMixins = new ArrayList<>();

    public static MixinDiagnostics getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // Mixin 추적
    // ─────────────────────────────────────────────────────────────

    /**
     * Mixin 적용 기록
     */
    public void recordMixinApplied(String targetClass, String mixinClass,
            String modId, int priority) {
        MixinInfo info = new MixinInfo(mixinClass, modId, priority);
        appliedMixins.computeIfAbsent(targetClass, k -> new ArrayList<>()).add(info);

        if (DevMode.isEnabled()) {
            System.out.println("[Pulse/Mixin] Applied " + mixinClass +
                    " to " + targetClass + " (mod: " + modId + ", priority: " + priority + ")");
        }
    }

    /**
     * Mixin 실패 기록
     */
    public void recordMixinFailed(String mixinClass, String modId,
            String targetClass, String reason) {
        FailedMixin failed = new FailedMixin(mixinClass, modId, targetClass, reason);
        failedMixins.add(failed);

        System.err.println("[Pulse/Mixin] Failed " + mixinClass + " from " + modId +
                " to " + targetClass + ": " + reason);
    }

    // ─────────────────────────────────────────────────────────────
    // 충돌 감지
    // ─────────────────────────────────────────────────────────────

    /**
     * 잠재적 충돌 검사 및 경고
     */
    public void checkConflicts() {
        if (!DevMode.isEnabled())
            return;

        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");
        System.out.println("[Pulse/Mixin] Checking for potential Mixin conflicts...");

        int conflictCount = 0;

        for (Map.Entry<String, List<MixinInfo>> entry : appliedMixins.entrySet()) {
            String targetClass = entry.getKey();
            List<MixinInfo> mixins = entry.getValue();

            if (mixins.size() > 1) {
                // 동일 타겟에 여러 Mixin - 잠재적 충돌
                Set<String> mods = new HashSet<>();
                for (MixinInfo info : mixins) {
                    mods.add(info.modId);
                }

                if (mods.size() > 1) {
                    // 다른 모드의 Mixin이 같은 클래스를 수정
                    System.out.println("[Pulse/Mixin] Potential conflict on " + targetClass + ":");
                    for (MixinInfo info : mixins) {
                        System.out.println("[Pulse/Mixin]   - " + info.modId +
                                ": " + info.mixinClass + " (priority: " + info.priority + ")");
                    }
                    conflictCount++;
                }
            }
        }

        if (conflictCount == 0) {
            System.out.println("[Pulse/Mixin] No conflicts detected.");
        } else {
            System.out.println("[Pulse/Mixin] " + conflictCount + " potential conflict(s) found.");
        }

        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // 리포트
    // ─────────────────────────────────────────────────────────────

    /**
     * 전체 Mixin 적용 상태 리포트
     */
    public void printReport() {
        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");
        System.out.println("[Pulse/Mixin] MIXIN APPLICATION REPORT");
        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");

        System.out.println("[Pulse/Mixin] Applied Mixins by Target:");
        for (Map.Entry<String, List<MixinInfo>> entry : appliedMixins.entrySet()) {
            System.out.println("[Pulse/Mixin]   " + entry.getKey() + ":");
            for (MixinInfo info : entry.getValue()) {
                System.out.println("[Pulse/Mixin]     - " + info.mixinClass +
                        " (" + info.modId + ", p=" + info.priority + ")");
            }
        }

        if (!failedMixins.isEmpty()) {
            System.out.println("[Pulse/Mixin] Failed Mixins:");
            for (FailedMixin failed : failedMixins) {
                System.out.println("[Pulse/Mixin]   ✗ " + failed.mixinClass +
                        " from " + failed.modId + " → " + failed.targetClass);
                System.out.println("[Pulse/Mixin]     Reason: " + failed.reason);
            }
        }

        System.out.println("[Pulse/Mixin] ═══════════════════════════════════════");
    }

    // ─────────────────────────────────────────────────────────────
    // Getters
    // ─────────────────────────────────────────────────────────────

    public int getAppliedCount() {
        return appliedMixins.values().stream().mapToInt(List::size).sum();
    }

    public int getFailedCount() {
        return failedMixins.size();
    }

    public List<MixinInfo> getMixinsForTarget(String targetClass) {
        return appliedMixins.getOrDefault(targetClass, Collections.emptyList());
    }

    /**
     * 크래시 리포트용 변환 상세 정보 반환.
     * 
     * @return 타겟 클래스 → Mixin 클래스 목록 맵
     */
    public static Map<String, List<String>> getTransformationDetails() {
        Map<String, List<String>> result = new LinkedHashMap<>();

        for (Map.Entry<String, List<MixinInfo>> entry : INSTANCE.appliedMixins.entrySet()) {
            List<String> mixinNames = new ArrayList<>();
            for (MixinInfo info : entry.getValue()) {
                mixinNames.add(info.mixinClass + " (" + info.modId + ")");
            }
            result.put(entry.getKey(), mixinNames);
        }

        return result;
    }

    /**
     * 적용된 Mixin 목록 문자열로 반환.
     */
    public static List<String> getAppliedMixins() {
        List<String> result = new ArrayList<>();
        for (Map.Entry<String, List<MixinInfo>> entry : INSTANCE.appliedMixins.entrySet()) {
            for (MixinInfo info : entry.getValue()) {
                result.add(info.mixinClass + " → " + entry.getKey() + " (" + info.modId + ")");
            }
        }
        return result;
    }

    // ─────────────────────────────────────────────────────────────
    // 내부 클래스
    // ─────────────────────────────────────────────────────────────

    public static class MixinInfo {
        public final String mixinClass;
        public final String modId;
        public final int priority;

        public MixinInfo(String mixinClass, String modId, int priority) {
            this.mixinClass = mixinClass;
            this.modId = modId;
            this.priority = priority;
        }
    }

    public static class FailedMixin {
        public final String mixinClass;
        public final String modId;
        public final String targetClass;
        public final String reason;

        public FailedMixin(String mixinClass, String modId,
                String targetClass, String reason) {
            this.mixinClass = mixinClass;
            this.modId = modId;
            this.targetClass = targetClass;
            this.reason = reason;
        }
    }
}

[src/main/java/com/pulse/config/ConfigSpec.java]
package com.pulse.config;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 설정 스펙.
 * 설정 클래스의 메타데이터를 담고 있음.
 */
public class ConfigSpec {

    private final Class<?> configClass;
    private final String modId;
    private final String fileName;
    private final String category;
    private final List<ConfigEntry> entries = new ArrayList<>();

    public ConfigSpec(Class<?> configClass) {
        this.configClass = configClass;

        Config config = configClass.getAnnotation(Config.class);
        if (config == null) {
            throw new IllegalArgumentException("Class must have @Config annotation");
        }

        this.modId = config.modId();
        this.fileName = config.fileName().isEmpty() ? modId + ".json" : config.fileName();
        this.category = config.category();

        // 필드 스캔
        scanFields();
    }

    private void scanFields() {
        for (Field field : configClass.getDeclaredFields()) {
            ConfigValue annotation = field.getAnnotation(ConfigValue.class);
            if (annotation != null) {
                field.setAccessible(true);

                String key = annotation.key().isEmpty() ? field.getName() : annotation.key();
                Object defaultValue = getFieldValue(field);

                ConfigEntry entry = new ConfigEntry(
                        key,
                        field,
                        annotation.comment(),
                        defaultValue,
                        annotation.min(),
                        annotation.max(),
                        annotation.requiresRestart(),
                        annotation.options(),
                        annotation.step(),
                        annotation.category());

                entries.add(entry);
            }
        }
    }

    private Object getFieldValue(Field field) {
        try {
            return field.get(null);
        } catch (IllegalAccessException e) {
            return null;
        }
    }

    // Getters

    public Class<?> getConfigClass() {
        return configClass;
    }

    public String getModId() {
        return modId;
    }

    public String getFileName() {
        return fileName;
    }

    public String getCategory() {
        return category;
    }

    public List<ConfigEntry> getEntries() {
        return entries;
    }

    /**
     * @Validate 메서드 실행.
     * @return 검증 성공 여부
     */
    public boolean runValidation() {
        for (Method method : configClass.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Validate.class)) {
                method.setAccessible(true);
                try {
                    Object result = method.invoke(null);
                    if (result instanceof Boolean b && !b) {
                        Validate validate = method.getAnnotation(Validate.class);
                        System.err.println("[Pulse/Config] Validation failed: " + validate.message());
                        return false;
                    }
                } catch (Exception e) {
                    System.err.println("[Pulse/Config] Validation error: " + e.getMessage());
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 모든 값을 기본값으로 리셋.
     */
    public void resetAll() {
        for (ConfigEntry entry : entries) {
            entry.reset();
        }
        System.out.println("[Pulse/Config] Reset all values to defaults for: " + modId);
    }

    public static class ConfigEntry {
        private final String key;
        private final Field field;
        private final String comment;
        private final Object defaultValue;
        private final double min;
        private final double max;
        private final boolean requiresRestart;
        private final String[] options;
        private final double step;
        private final String category;

        public ConfigEntry(String key, Field field, String comment, Object defaultValue,
                double min, double max, boolean requiresRestart,
                String[] options, double step, String category) {
            this.key = key;
            this.field = field;
            this.comment = comment;
            this.defaultValue = defaultValue;
            this.min = min;
            this.max = max;
            this.requiresRestart = requiresRestart;
            this.options = options;
            this.step = step;
            this.category = category;
        }

        public String getKey() {
            return key;
        }

        public Field getField() {
            return field;
        }

        public String getComment() {
            return comment;
        }

        public Object getDefaultValue() {
            return defaultValue;
        }

        public double getMin() {
            return min;
        }

        public double getMax() {
            return max;
        }

        public boolean requiresRestart() {
            return requiresRestart;
        }

        public Class<?> getType() {
            return field.getType();
        }

        public Object getValue() {
            try {
                return field.get(null);
            } catch (IllegalAccessException e) {
                return defaultValue;
            }
        }

        public void setValue(Object value) {
            try {
                // options 검증 (String 타입)
                if (options != null && options.length > 0 && value instanceof String strVal) {
                    List<String> optionList = Arrays.asList(options);
                    if (!optionList.contains(strVal)) {
                        System.err.println("[Pulse/Config] Invalid option '" + strVal +
                                "' for " + key + ", resetting to default");
                        value = defaultValue;
                    }
                }

                // 범위 검사 및 step 적용 (숫자 타입)
                if (value instanceof Number num) {
                    double val = num.doubleValue();

                    // step 적용 (반올림)
                    if (step > 0) {
                        val = Math.round(val / step) * step;
                    }

                    // min/max 범위 적용
                    if (min != Double.MIN_VALUE && val < min) {
                        val = min;
                    }
                    if (max != Double.MAX_VALUE && val > max) {
                        val = max;
                    }

                    value = convertToFieldType(val, field.getType());
                }

                field.set(null, value);
            } catch (IllegalAccessException e) {
                System.err.println("[Pulse/Config] Failed to set value for " + key);
            }
        }

        private Object convertToFieldType(double value, Class<?> type) {
            if (type == int.class || type == Integer.class)
                return (int) value;
            if (type == long.class || type == Long.class)
                return (long) value;
            if (type == float.class || type == Float.class)
                return (float) value;
            if (type == double.class || type == Double.class)
                return value;
            return value;
        }

        public void reset() {
            setValue(defaultValue);
        }

        public String[] getOptions() {
            return options;
        }

        public double getStep() {
            return step;
        }

        public String getCategory() {
            return category;
        }

        public boolean hasOptions() {
            return options != null && options.length > 0;
        }
    }
}

[src/main/java/com/pulse/network/Packet.java]
package com.pulse.network;

import com.pulse.registry.Identifier;

/**
 * 패킷 인터페이스.
 * 모든 네트워크 패킷은 이 인터페이스를 구현해야 함.
 * 
 * 사용 예:
 * 
 * <pre>
 * public class MyPacket implements Packet {
 *     private String message;
 *     
 *     public MyPacket() {} // 역직렬화용
 *     
 *     public MyPacket(String message) {
 *         this.message = message;
 *     }
 *     
 *     {@literal @}Override
 *     public void write(PacketBuffer buf) {
 *         buf.writeString(message);
 *     }
 *     
 *     {@literal @}Override
 *     public void read(PacketBuffer buf) {
 *         message = buf.readString();
 *     }
 *     
 *     {@literal @}Override
 *     public Identifier getId() {
 *         return Identifier.of("mymod", "my_packet");
 *     }
 * }
 * </pre>
 */
public interface Packet {

    /**
     * 패킷 ID
     */
    Identifier getId();

    /**
     * 패킷 데이터를 버퍼에 쓰기
     */
    void write(PacketBuffer buf);

    /**
     * 버퍼에서 패킷 데이터 읽기
     */
    void read(PacketBuffer buf);
}

[src/main/java/com/pulse/network/PacketBuffer.java]
package com.pulse.network;

import java.io.*;
import java.nio.charset.StandardCharsets;

/**
 * 패킷 버퍼.
 * 패킷 데이터의 직렬화/역직렬화를 담당.
 */
public class PacketBuffer {

    private final ByteArrayOutputStream outputStream;
    private final DataOutputStream out;
    private final DataInputStream in;
    private byte[] data;

    /**
     * 쓰기용 버퍼 생성
     */
    public PacketBuffer() {
        this.outputStream = new ByteArrayOutputStream();
        this.out = new DataOutputStream(outputStream);
        this.in = null;
        this.data = null;
    }

    /**
     * 읽기용 버퍼 생성
     */
    public PacketBuffer(byte[] data) {
        this.data = data;
        this.outputStream = null;
        this.out = null;
        this.in = new DataInputStream(new ByteArrayInputStream(data));
    }

    // ─────────────────────────────────────────────────────────────
    // 쓰기 메서드
    // ─────────────────────────────────────────────────────────────

    public void writeByte(int value) {
        try {
            out.writeByte(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeShort(int value) {
        try {
            out.writeShort(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeInt(int value) {
        try {
            out.writeInt(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeLong(long value) {
        try {
            out.writeLong(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeFloat(float value) {
        try {
            out.writeFloat(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeDouble(double value) {
        try {
            out.writeDouble(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeBoolean(boolean value) {
        try {
            out.writeBoolean(value);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeString(String value) {
        try {
            byte[] bytes = value.getBytes(StandardCharsets.UTF_8);
            out.writeInt(bytes.length);
            out.write(bytes);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeBytes(byte[] bytes) {
        try {
            out.writeInt(bytes.length);
            out.write(bytes);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 읽기 메서드
    // ─────────────────────────────────────────────────────────────

    public byte readByte() {
        try {
            return in.readByte();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public short readShort() {
        try {
            return in.readShort();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public int readInt() {
        try {
            return in.readInt();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public long readLong() {
        try {
            return in.readLong();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public float readFloat() {
        try {
            return in.readFloat();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public double readDouble() {
        try {
            return in.readDouble();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public boolean readBoolean() {
        try {
            return in.readBoolean();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public String readString() {
        try {
            int length = in.readInt();
            byte[] bytes = new byte[length];
            in.readFully(bytes);
            return new String(bytes, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public byte[] readBytes() {
        try {
            int length = in.readInt();
            byte[] bytes = new byte[length];
            in.readFully(bytes);
            return bytes;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 버퍼 데이터를 바이트 배열로 변환
     */
    public byte[] toByteArray() {
        if (outputStream != null) {
            return outputStream.toByteArray();
        }
        return data;
    }

    /**
     * 남은 바이트 수
     */
    public int remaining() {
        if (in != null) {
            try {
                return in.available();
            } catch (IOException e) {
                return 0;
            }
        }
        return 0;
    }
}

[src/main/java/com/pulse/mod/ModReloadManager.java]
package com.pulse.mod;

import com.pulse.config.ConfigManager;
import com.pulse.event.EventBus;
import com.pulse.event.lifecycle.ModReloadEvent;

import java.io.File;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 모드 핫 리로드 매니저.
 * 런타임에 모드를 비활성화/재활성화할 수 있는 기능 제공.
 * 
 * 제한사항:
 * - Mixin이 적용된 모드는 완전한 언로드가 불가능
 * - 리로드는 설정 및 이벤트 리스너만 갱신
 * - 바이트코드 변경은 게임 재시작 필요
 * 
 * 사용 예:
 * 
 * <pre>
 * // 모드 비활성화
 * ModReloadManager.disable("mymod");
 * 
 * // 모드 재활성화
 * ModReloadManager.enable("mymod");
 * 
 * // 설정만 리로드
 * ModReloadManager.reloadConfig("mymod");
 * 
 * // 전체 소프트 리로드 (Mixin 제외)
 * ModReloadManager.softReload("mymod");
 * </pre>
 */
public class ModReloadManager {

    private static final ModReloadManager INSTANCE = new ModReloadManager();

    // 비활성화된 모드 목록
    private final Set<String> disabledMods = ConcurrentHashMap.newKeySet();

    private ModReloadManager() {
    }

    public static ModReloadManager getInstance() {
        return INSTANCE;
    }

    // ─────────────────────────────────────────────────────────────
    // 활성화/비활성화
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 비활성화.
     * 이벤트 리스너 해제, 스케줄러 태스크 취소.
     * 
     * @param modId 비활성화할 모드 ID
     * @return 성공 여부
     */
    public static boolean disable(String modId) {
        return INSTANCE.disableMod(modId);
    }

    /**
     * 모드 활성화.
     * 비활성화된 모드를 다시 활성화.
     * 
     * @param modId 활성화할 모드 ID
     * @return 성공 여부
     */
    public static boolean enable(String modId) {
        return INSTANCE.enableMod(modId);
    }

    /**
     * 모드가 활성 상태인지 확인.
     */
    public static boolean isEnabled(String modId) {
        return !INSTANCE.disabledMods.contains(modId);
    }

    /**
     * 비활성화된 모드 목록.
     */
    public static Set<String> getDisabledMods() {
        return Collections.unmodifiableSet(INSTANCE.disabledMods);
    }

    private boolean disableMod(String modId) {
        ModLoader loader = ModLoader.getInstance();
        ModContainer container = loader.getMod(modId);

        if (container == null) {
            System.err.println("[Pulse/Reload] Mod not found: " + modId);
            return false;
        }

        if (disabledMods.contains(modId)) {
            System.out.println("[Pulse/Reload] Mod already disabled: " + modId);
            return true;
        }

        try {
            System.out.println("[Pulse/Reload] Disabling mod: " + modId);

            // 1. 모드의 onUnload 호출
            PulseMod instance = container.getModInstance(PulseMod.class);
            if (instance != null) {
                try {
                    instance.onUnload();
                } catch (Exception e) {
                    System.err.println("[Pulse/Reload] Error in onUnload: " + e.getMessage());
                }
            }

            // 2. 설정 저장
            ConfigManager.saveAll();

            // 3. 비활성화 상태로 표시
            disabledMods.add(modId);
            container.setState(ModContainer.ModState.DISABLED);

            // 4. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.DISABLED));

            System.out.println("[Pulse/Reload] Mod disabled: " + modId);
            return true;

        } catch (Exception e) {
            System.err.println("[Pulse/Reload] Failed to disable mod: " + modId);
            e.printStackTrace();
            return false;
        }
    }

    private boolean enableMod(String modId) {
        ModLoader loader = ModLoader.getInstance();
        ModContainer container = loader.getMod(modId);

        if (container == null) {
            System.err.println("[Pulse/Reload] Mod not found: " + modId);
            return false;
        }

        if (!disabledMods.contains(modId)) {
            System.out.println("[Pulse/Reload] Mod already enabled: " + modId);
            return true;
        }

        try {
            System.out.println("[Pulse/Reload] Enabling mod: " + modId);

            // 1. 활성화 상태로 표시
            disabledMods.remove(modId);
            container.setState(ModContainer.ModState.LOADED);

            // 2. 설정 리로드
            reloadConfigInternal(modId);

            // 3. 모드의 onInitialize 다시 호출
            PulseMod instance = container.getModInstance(PulseMod.class);
            if (instance != null) {
                try {
                    instance.onInitialize();
                } catch (Exception e) {
                    System.err.println("[Pulse/Reload] Error in onInitialize: " + e.getMessage());
                }
            }

            // 4. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.ENABLED));

            System.out.println("[Pulse/Reload] Mod enabled: " + modId);
            return true;

        } catch (Exception e) {
            System.err.println("[Pulse/Reload] Failed to enable mod: " + modId);
            e.printStackTrace();
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 리로드
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 설정만 리로드.
     * 파일에서 설정을 다시 읽어옴.
     */
    public static boolean reloadConfig(String modId) {
        return INSTANCE.reloadConfigInternal(modId);
    }

    /**
     * 모드 소프트 리로드.
     * 설정 리로드 + 이벤트 리스너 재등록.
     * Mixin 변경은 반영되지 않음.
     */
    public static boolean softReload(String modId) {
        return INSTANCE.softReloadMod(modId);
    }

    /**
     * 모든 모드 설정 리로드.
     */
    public static void reloadAllConfigs() {
        ConfigManager.reloadAll();
        System.out.println("[Pulse/Reload] All configs reloaded");
    }

    private boolean reloadConfigInternal(String modId) {
        try {
            // modId에 해당하는 설정 클래스를 알 수 없으므로 전체 리로드
            ConfigManager.reloadAll();
            System.out.println("[Pulse/Reload] Config reloaded for: " + modId);
            return true;
        } catch (Exception e) {
            System.err.println("[Pulse/Reload] Failed to reload config: " + modId);
            e.printStackTrace();
            return false;
        }
    }

    private boolean softReloadMod(String modId) {
        ModLoader loader = ModLoader.getInstance();
        ModContainer container = loader.getMod(modId);

        if (container == null) {
            System.err.println("[Pulse/Reload] Mod not found: " + modId);
            return false;
        }

        try {
            System.out.println("[Pulse/Reload] Soft reloading mod: " + modId);

            PulseMod instance = container.getModInstance(PulseMod.class);

            // 1. onUnload 호출 (정리)
            if (instance != null) {
                try {
                    instance.onUnload();
                } catch (Exception e) {
                    System.err.println("[Pulse/Reload] Error in onUnload: " + e.getMessage());
                }
            }

            // 2. 설정 리로드
            reloadConfigInternal(modId);

            // 3. onInitialize 호출 (재초기화)
            if (instance != null) {
                try {
                    instance.onInitialize();
                } catch (Exception e) {
                    System.err.println("[Pulse/Reload] Error in onInitialize: " + e.getMessage());
                }
            }

            // 4. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.RELOADED));

            System.out.println("[Pulse/Reload] Mod soft reloaded: " + modId);
            return true;

        } catch (Exception e) {
            System.err.println("[Pulse/Reload] Failed to soft reload mod: " + modId);
            e.printStackTrace();
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 핫 스왑 (실험적)
    // ─────────────────────────────────────────────────────────────

    /**
     * 모드 JAR 파일 핫 스왑 (실험적).
     * 새 JAR 파일을 로드하여 모드 클래스를 교체 시도.
     * 
     * ⚠️ 제한 사항:
     * - JVM은 이미 로드된 클래스를 교체할 수 없음
     * - 새 클래스만 새 로더에서 로드됨
     * - 완전한 핫 스왑은 게임 재시작 필요
     */
    public static boolean hotSwap(String modId, File newJarFile) {
        return INSTANCE.hotSwapMod(modId, newJarFile);
    }

    private boolean hotSwapMod(String modId, File newJarFile) {
        if (!newJarFile.exists() || !newJarFile.getName().endsWith(".jar")) {
            System.err.println("[Pulse/Reload] Invalid JAR file: " + newJarFile);
            return false;
        }

        try {
            System.out.println("[Pulse/Reload] Hot swapping mod: " + modId);
            System.out.println("[Pulse/Reload] New JAR: " + newJarFile.getAbsolutePath());

            // 1. 현재 모드 비활성화
            disable(modId);

            // 2. 새 클래스 로더로 JAR 로드
            URL jarUrl = newJarFile.toURI().toURL();
            @SuppressWarnings("resource")
            URLClassLoader newLoader = new URLClassLoader(
                    new URL[] { jarUrl },
                    getClass().getClassLoader());

            // 3. 새 entrypoint 로드 시도
            ModLoader loader = ModLoader.getInstance();
            ModContainer container = loader.getMod(modId);

            if (container != null) {
                String entrypoint = container.getMetadata().getEntrypoint();
                if (entrypoint != null && !entrypoint.isEmpty()) {
                    try {
                        Class<?> newModClass = newLoader.loadClass(entrypoint);
                        Object newInstance = newModClass.getDeclaredConstructor().newInstance();

                        if (newInstance instanceof PulseMod) {
                            // 새 인스턴스로 교체 (리플렉션)
                            java.lang.reflect.Field instanceField = ModContainer.class.getDeclaredField("modInstance");
                            instanceField.setAccessible(true);
                            instanceField.set(container, newInstance);

                            System.out.println("[Pulse/Reload] Loaded new mod instance");
                        }
                    } catch (ClassNotFoundException e) {
                        System.out.println("[Pulse/Reload] Entrypoint not found in new JAR, using existing");
                    }
                }
            }

            // 4. 다시 활성화
            enable(modId);

            // 5. 이벤트 발행
            EventBus.post(new ModReloadEvent(modId, ModReloadEvent.Action.HOT_SWAPPED));

            System.out.println("[Pulse/Reload] Hot swap complete (partial - JVM limitations apply)");
            return true;

        } catch (Exception e) {
            System.err.println("[Pulse/Reload] Hot swap failed: " + modId);
            e.printStackTrace();
            return false;
        }
    }

    // ─────────────────────────────────────────────────────────────
    // 유틸리티
    // ─────────────────────────────────────────────────────────────

    /**
     * 비활성화 여부를 확인하고 실행을 스킵할지 결정.
     * 이벤트 핸들러 등에서 사용.
     */
    public static boolean shouldSkip(String modId) {
        return INSTANCE.disabledMods.contains(modId);
    }

    /**
     * 모든 모드 상태 출력.
     */
    public static void printStatus() {
        System.out.println("═══════════════════════════════════════");
        System.out.println("       MOD RELOAD MANAGER STATUS       ");
        System.out.println("═══════════════════════════════════════");

        ModLoader loader = ModLoader.getInstance();
        for (String modId : loader.getLoadedModIds()) {
            ModContainer mod = loader.getMod(modId);
            String status = INSTANCE.disabledMods.contains(mod.getId()) ? "DISABLED" : "ENABLED";
            System.out.println("  " + mod.getId() + " v" + mod.getMetadata().getVersion() +
                    " [" + status + "]");
        }

        System.out.println("═══════════════════════════════════════");
    }
}

[src/main/java/com/pulse/mod/PulseMod.java]
package com.pulse.mod;

/**
 * 모드 엔트리포인트 인터페이스.
 * 모든 Pulse 모드는 이 인터페이스를 구현해야 함.
 * 
 * 예시:
 * public class MyMod implements PulseMod {
 *     @Override
 *     public void onInitialize() {
 *         System.out.println("My mod loaded!");
 *         // 이벤트 리스너 등록, 설정 로드 등
 *     }
 * }
 */
public interface PulseMod {
    
    /**
     * 모드 초기화 시 호출됨.
     * 이벤트 리스너 등록, 설정 로드 등을 수행.
     */
    void onInitialize();
    
    /**
     * 모드가 언로드될 때 호출됨 (선택적 구현).
     * 리소스 정리 등을 수행.
     */
    default void onUnload() {
        // 기본 구현: 아무것도 안 함
    }
    
    /**
     * 게임 월드가 로드된 후 호출됨 (선택적 구현).
     */
    default void onWorldLoad() {
        // 기본 구현: 아무것도 안 함
    }
    
    /**
     * 게임 월드가 언로드될 때 호출됨 (선택적 구현).
     */
    default void onWorldUnload() {
        // 기본 구현: 아무것도 안 함
    }
}

[src/main/resources/mixins.pulse.json]
{
  "required": true,
  "minVersion": "0.8",
  "package": "com.pulse.mixin",
  "mixins": [
    "MainScreenStateMixin",
    "GameClientMixin",
    "GameWindowMixin",
    "IsoWorldMixin",
    "IsoPlayerMixin"
  ],
  "client": [],
  "server": [],
  "injectors": {
    "defaultRequire": 0
  },
  "verbose": true
}

[build.gradle]
plugins {
    id 'java'
    id 'eclipse'
    id 'idea'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'com.pulse'
version = '1.0.0-SNAPSHOT'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

repositories {
    mavenCentral()
    maven { url 'https://repo.spongepowered.org/maven/' }
}

dependencies {
    // Mixin Core
    implementation 'org.spongepowered:mixin:0.8.5'

    // JSON (Mixin config 파싱에 필요)
    implementation 'com.google.code.gson:gson:2.10.1'

    // ASM (바이트코드 조작)
    implementation 'org.ow2.asm:asm:9.5'
    implementation 'org.ow2.asm:asm-commons:9.5'
    implementation 'org.ow2.asm:asm-tree:9.5'
    implementation 'org.ow2.asm:asm-util:9.5'
    implementation 'org.ow2.asm:asm-analysis:9.5'

    // Guava (Mixin 내부에서 사용)
    implementation 'com.google.guava:guava:32.1.2-jre'

    // Game Code (컴파일 전용)
    compileOnly files('C:/SteamLibrary/steamapps/common/ProjectZomboid')
    compileOnly fileTree(dir: 'C:/SteamLibrary/steamapps/common/ProjectZomboid', include: ['*.jar'])
}

shadowJar {
    archiveBaseName.set('Pulse')
    archiveClassifier.set('')
    archiveVersion.set('')

    // 서비스 파일 병합 (중요!)
    mergeServiceFiles()

    // 중복 제외
    exclude 'META-INF/MANIFEST.MF'
    exclude 'META-INF/*.SF'
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'

    manifest {
        attributes(
            'Premain-Class': 'com.pulse.PulseAgent',
            'Agent-Class': 'com.pulse.PulseAgent',
            'Can-Retransform-Classes': 'true',
            'Can-Redefine-Classes': 'true',
            'Can-Set-Native-Method-Prefix': 'true',
            'Implementation-Title': 'Pulse',
            'Implementation-Version': project.version,
            'Multi-Release': 'true'
        )
    }
}

tasks.named('build') {
    dependsOn shadowJar
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.compilerArgs += ['-parameters']  // 메서드 파라미터 이름 유지
}

// 디버그: 종속성 트리 출력
task printDeps {
    doLast {
        configurations.runtimeClasspath.each { println it }
    }
}

